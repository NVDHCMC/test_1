
ADCT_BGS_FPT.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000059ec  0800010c  0800010c  0001010c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000004  08005af8  08005af8  00015af8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08005afc  08005afc  00015afc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08005b00  08005b00  00015b00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000084  20000000  08005b04  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000274  20000084  08005b88  00020084  2**2
                  ALLOC
  7 ._user_heap_stack 00000100  200002f8  08005b88  000202f8  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  00020084  2**0
                  CONTENTS, READONLY
  9 .debug_info   0000d323  00000000  00000000  000200ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002faa  00000000  00000000  0002d3d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001080  00000000  00000000  00030380  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000e98  00000000  00000000  00031400  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00008c14  00000000  00000000  00032298  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000051d1  00000000  00000000  0003aeac  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007e  00000000  00000000  0004007d  2**0
                  CONTENTS, READONLY
 16 .debug_frame  000042e0  00000000  00000000  000400fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .stabstr      0000003f  00000000  00000000  000443dc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800010c <__do_global_dtors_aux>:
 800010c:	b510      	push	{r4, lr}
 800010e:	4c05      	ldr	r4, [pc, #20]	; (8000124 <__do_global_dtors_aux+0x18>)
 8000110:	7823      	ldrb	r3, [r4, #0]
 8000112:	b933      	cbnz	r3, 8000122 <__do_global_dtors_aux+0x16>
 8000114:	4b04      	ldr	r3, [pc, #16]	; (8000128 <__do_global_dtors_aux+0x1c>)
 8000116:	b113      	cbz	r3, 800011e <__do_global_dtors_aux+0x12>
 8000118:	4804      	ldr	r0, [pc, #16]	; (800012c <__do_global_dtors_aux+0x20>)
 800011a:	f3af 8000 	nop.w
 800011e:	2301      	movs	r3, #1
 8000120:	7023      	strb	r3, [r4, #0]
 8000122:	bd10      	pop	{r4, pc}
 8000124:	20000084 	.word	0x20000084
 8000128:	00000000 	.word	0x00000000
 800012c:	08005ae0 	.word	0x08005ae0

08000130 <frame_dummy>:
 8000130:	b508      	push	{r3, lr}
 8000132:	4b03      	ldr	r3, [pc, #12]	; (8000140 <frame_dummy+0x10>)
 8000134:	b11b      	cbz	r3, 800013e <frame_dummy+0xe>
 8000136:	4903      	ldr	r1, [pc, #12]	; (8000144 <frame_dummy+0x14>)
 8000138:	4803      	ldr	r0, [pc, #12]	; (8000148 <frame_dummy+0x18>)
 800013a:	f3af 8000 	nop.w
 800013e:	bd08      	pop	{r3, pc}
 8000140:	00000000 	.word	0x00000000
 8000144:	20000088 	.word	0x20000088
 8000148:	08005ae0 	.word	0x08005ae0

0800014c <ADCT_BGS_ASW_100ms_TaskHandler>:
#include "HardwareCfg.h"
#include "ADCT_DHT22.h"
extern FPT_SystemStatus    GstSystemStatus;
ADCT_BGS_ASW_TaskDatatypes g_ASW_Task_flag;
void ADCT_BGS_ASW_100ms_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
 800014c:	b580      	push	{r7, lr}
 800014e:	b082      	sub	sp, #8
 8000150:	af00      	add	r7, sp, #0
 8000152:	6078      	str	r0, [r7, #4]
 8000154:	6039      	str	r1, [r7, #0]
//	GPIO_WriteBit(LED1_GPIO_PORT, LED1_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED1_GPIO_PORT, LED1_PIN)));
//	GPIO_WriteBit(LED2_GPIO_PORT, LED2_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED2_GPIO_PORT, LED2_PIN)));
	ADCT_DHT22_FPT_GetValue(&GstSystemStatus.dhtData);
 8000156:	4803      	ldr	r0, [pc, #12]	; (8000164 <ADCT_BGS_ASW_100ms_TaskHandler+0x18>)
 8000158:	f001 fab0 	bl	80016bc <ADCT_DHT22_FPT_GetValue>
}
 800015c:	bf00      	nop
 800015e:	3708      	adds	r7, #8
 8000160:	46bd      	mov	sp, r7
 8000162:	bd80      	pop	{r7, pc}
 8000164:	20000266 	.word	0x20000266

08000168 <ADCT_BGS_ASW_100ms_Init>:
void ADCT_BGS_ASW_100ms_Init(void)
{
 8000168:	b580      	push	{r7, lr}
 800016a:	b082      	sub	sp, #8
 800016c:	af02      	add	r7, sp, #8
	TM_DELAY_TimerCreate(100, 1, 1, ADCT_BGS_ASW_100ms_TaskHandler, NULL);
 800016e:	2300      	movs	r3, #0
 8000170:	9300      	str	r3, [sp, #0]
 8000172:	4b04      	ldr	r3, [pc, #16]	; (8000184 <ADCT_BGS_ASW_100ms_Init+0x1c>)
 8000174:	2201      	movs	r2, #1
 8000176:	2101      	movs	r1, #1
 8000178:	2064      	movs	r0, #100	; 0x64
 800017a:	f003 fb85 	bl	8003888 <TM_DELAY_TimerCreate>
}
 800017e:	bf00      	nop
 8000180:	46bd      	mov	sp, r7
 8000182:	bd80      	pop	{r7, pc}
 8000184:	0800014d 	.word	0x0800014d

08000188 <ADCT_BGS_ASW_10ms_TaskHandler>:

void ADCT_BGS_ASW_10ms_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
 8000188:	b480      	push	{r7}
 800018a:	b083      	sub	sp, #12
 800018c:	af00      	add	r7, sp, #0
 800018e:	6078      	str	r0, [r7, #4]
 8000190:	6039      	str	r1, [r7, #0]
	g_ASW_Task_flag.ASW_10ms_flag = ADCT_TRUE;
 8000192:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <ADCT_BGS_ASW_10ms_TaskHandler+0x1c>)
 8000194:	2201      	movs	r2, #1
 8000196:	709a      	strb	r2, [r3, #2]
}
 8000198:	bf00      	nop
 800019a:	370c      	adds	r7, #12
 800019c:	46bd      	mov	sp, r7
 800019e:	bc80      	pop	{r7}
 80001a0:	4770      	bx	lr
 80001a2:	bf00      	nop
 80001a4:	200001dc 	.word	0x200001dc

080001a8 <ADCT_BGS_ASW_1s_TaskHandler>:
{
	g_ASW_Task_flag.ASW_1ms_flag = ADCT_TRUE;
}

void ADCT_BGS_ASW_1s_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
 80001a8:	b480      	push	{r7}
 80001aa:	b083      	sub	sp, #12
 80001ac:	af00      	add	r7, sp, #0
 80001ae:	6078      	str	r0, [r7, #4]
 80001b0:	6039      	str	r1, [r7, #0]
	g_ASW_Task_flag.ASW_1s_flag = ADCT_TRUE;
 80001b2:	4b04      	ldr	r3, [pc, #16]	; (80001c4 <ADCT_BGS_ASW_1s_TaskHandler+0x1c>)
 80001b4:	2201      	movs	r2, #1
 80001b6:	701a      	strb	r2, [r3, #0]
//	GPIO_WriteBit(LED3_GPIO_PORT, LED3_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED3_GPIO_PORT, LED3_PIN)));
//	GPIO_WriteBit(LED4_GPIO_PORT, LED4_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED4_GPIO_PORT, LED4_PIN)));
}
 80001b8:	bf00      	nop
 80001ba:	370c      	adds	r7, #12
 80001bc:	46bd      	mov	sp, r7
 80001be:	bc80      	pop	{r7}
 80001c0:	4770      	bx	lr
 80001c2:	bf00      	nop
 80001c4:	200001dc 	.word	0x200001dc

080001c8 <ADCT_BGS_ASW_10ms_Init>:
void ADCT_BGS_ASW_10ms_Init(void)
{
 80001c8:	b580      	push	{r7, lr}
 80001ca:	b082      	sub	sp, #8
 80001cc:	af02      	add	r7, sp, #8
	g_ASW_Task_flag.ASW_10ms_flag = ADCT_FALSE;
 80001ce:	4b07      	ldr	r3, [pc, #28]	; (80001ec <ADCT_BGS_ASW_10ms_Init+0x24>)
 80001d0:	2200      	movs	r2, #0
 80001d2:	709a      	strb	r2, [r3, #2]
	TM_DELAY_TimerCreate(10, 1, 1, ADCT_BGS_ASW_10ms_TaskHandler, NULL);
 80001d4:	2300      	movs	r3, #0
 80001d6:	9300      	str	r3, [sp, #0]
 80001d8:	4b05      	ldr	r3, [pc, #20]	; (80001f0 <ADCT_BGS_ASW_10ms_Init+0x28>)
 80001da:	2201      	movs	r2, #1
 80001dc:	2101      	movs	r1, #1
 80001de:	200a      	movs	r0, #10
 80001e0:	f003 fb52 	bl	8003888 <TM_DELAY_TimerCreate>
}
 80001e4:	bf00      	nop
 80001e6:	46bd      	mov	sp, r7
 80001e8:	bd80      	pop	{r7, pc}
 80001ea:	bf00      	nop
 80001ec:	200001dc 	.word	0x200001dc
 80001f0:	08000189 	.word	0x08000189

080001f4 <ADCT_BGS_ASW_1s_Init>:
//	g_ASW_Task_flag.ASW_1ms_flag =ADCT_FALSE;
//	TM_DELAY_TimerCreate(1, 1, 1, ADCT_BGS_ASW_1ms_TaskHandler, NULL);
//}

void ADCT_BGS_ASW_1s_Init(void)
{
 80001f4:	b580      	push	{r7, lr}
 80001f6:	b082      	sub	sp, #8
 80001f8:	af02      	add	r7, sp, #8
	g_ASW_Task_flag.ASW_1s_flag =ADCT_FALSE;
 80001fa:	4b07      	ldr	r3, [pc, #28]	; (8000218 <ADCT_BGS_ASW_1s_Init+0x24>)
 80001fc:	2200      	movs	r2, #0
 80001fe:	701a      	strb	r2, [r3, #0]
	TM_DELAY_TimerCreate(1000, 1, 1, ADCT_BGS_ASW_1s_TaskHandler, NULL);
 8000200:	2300      	movs	r3, #0
 8000202:	9300      	str	r3, [sp, #0]
 8000204:	4b05      	ldr	r3, [pc, #20]	; (800021c <ADCT_BGS_ASW_1s_Init+0x28>)
 8000206:	2201      	movs	r2, #1
 8000208:	2101      	movs	r1, #1
 800020a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800020e:	f003 fb3b 	bl	8003888 <TM_DELAY_TimerCreate>
}
 8000212:	bf00      	nop
 8000214:	46bd      	mov	sp, r7
 8000216:	bd80      	pop	{r7, pc}
 8000218:	200001dc 	.word	0x200001dc
 800021c:	080001a9 	.word	0x080001a9

08000220 <ADCT_BGS_StateManger>:
void ADCT_BGS_CheckBuzzerTimerRun(void);
void ADCT_BGS_CheckTminFan(void);
void ADCT_BGS_CheckDelayOfftime(void);
void ADCT_BGS_AlarmBuzzer(void);
void ADCT_BGS_StateManger(void)
{
 8000220:	b580      	push	{r7, lr}
 8000222:	af00      	add	r7, sp, #0
	if(g_ASW_Task_flag.ASW_1s_flag == ADCT_TRUE)
 8000224:	4b12      	ldr	r3, [pc, #72]	; (8000270 <ADCT_BGS_StateManger+0x50>)
 8000226:	781b      	ldrb	r3, [r3, #0]
 8000228:	2b01      	cmp	r3, #1
 800022a:	d11f      	bne.n	800026c <ADCT_BGS_StateManger+0x4c>
	{
		/* Call sequence start reading DHT 22 */
		/* DHT 22 main */
		ADCT_BGS_DHT22Start(DHT22_Device_1);
 800022c:	2000      	movs	r0, #0
 800022e:	f001 fbb5 	bl	800199c <ADCT_BGS_DHT22Start>
		/* DHT22 sub */
		ADCT_BGS_DHT22Start(DHT22_Device_2);
 8000232:	2001      	movs	r0, #1
 8000234:	f001 fbb2 	bl	800199c <ADCT_BGS_DHT22Start>

		/* Get all input data */
		ADCT_IO_FPT_GetValue(&GstSystemStatus.ioData);
 8000238:	480e      	ldr	r0, [pc, #56]	; (8000274 <ADCT_BGS_StateManger+0x54>)
 800023a:	f000 f98b 	bl	8000554 <ADCT_IO_FPT_GetValue>
		/* check state modbus */
		ADCT_SYSTEM_FPT_CheckState_MODBUS();
 800023e:	f000 f9cd 	bl	80005dc <ADCT_SYSTEM_FPT_CheckState_MODBUS>
		/* Check state IO */
		ADCT_SYSTEM_FPT_CheckState_IO();
 8000242:	f000 fb15 	bl	8000870 <ADCT_SYSTEM_FPT_CheckState_IO>
		/* Check switching time */
		ADCT_BGS_SwitchAIR_TimeCal();
 8000246:	f000 f817 	bl	8000278 <ADCT_BGS_SwitchAIR_TimeCal>
		/* Check time min swith for AIR 1_2*/
		ADCT_BGS_CheckMinSwitchAIR1_2();
 800024a:	f000 f857 	bl	80002fc <ADCT_BGS_CheckMinSwitchAIR1_2>
		/* Check time min switch for AIR 3_4 */
		ADCT_BGS_CheckMinSwitchAIR3_4();
 800024e:	f000 f883 	bl	8000358 <ADCT_BGS_CheckMinSwitchAIR3_4>
		/* Check state DHT22 */
		ADCT_SYSTEM_FPT_CheckState_DHT();
 8000252:	f000 fc13 	bl	8000a7c <ADCT_SYSTEM_FPT_CheckState_DHT>
		/* Check t min fan */
		ADCT_BGS_CheckTminFan();
 8000256:	f000 f91d 	bl	8000494 <ADCT_BGS_CheckTminFan>
		/* Check buzzer timer */
		ADCT_BGS_CheckBuzzerTimerRun();
 800025a:	f000 f8ab 	bl	80003b4 <ADCT_BGS_CheckBuzzerTimerRun>
		/* Check delay off time */
		ADCT_BGS_CheckDelayOfftime();
 800025e:	f000 f8e9 	bl	8000434 <ADCT_BGS_CheckDelayOfftime>
		ADCT_BGS_AlarmBuzzer();
 8000262:	f000 f945 	bl	80004f0 <ADCT_BGS_AlarmBuzzer>
		g_ASW_Task_flag.ASW_1s_flag = ADCT_FALSE;
 8000266:	4b02      	ldr	r3, [pc, #8]	; (8000270 <ADCT_BGS_StateManger+0x50>)
 8000268:	2200      	movs	r2, #0
 800026a:	701a      	strb	r2, [r3, #0]
	}
}
 800026c:	bf00      	nop
 800026e:	bd80      	pop	{r7, pc}
 8000270:	200001dc 	.word	0x200001dc
 8000274:	2000026e 	.word	0x2000026e

08000278 <ADCT_BGS_SwitchAIR_TimeCal>:
void ADCT_BGS_SwitchAIR_TimeCal(void)
{
 8000278:	b580      	push	{r7, lr}
 800027a:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_TimerManager.SWitchingTimer.second  == 0)
 800027c:	4b1d      	ldr	r3, [pc, #116]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 800027e:	789b      	ldrb	r3, [r3, #2]
 8000280:	2b00      	cmp	r3, #0
 8000282:	d12e      	bne.n	80002e2 <ADCT_BGS_SwitchAIR_TimeCal+0x6a>
	{
		g_ADCT_BGS_TimerManager.SWitchingTimer.second = 59;
 8000284:	4b1b      	ldr	r3, [pc, #108]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 8000286:	223b      	movs	r2, #59	; 0x3b
 8000288:	709a      	strb	r2, [r3, #2]
		if(g_ADCT_BGS_TimerManager.SWitchingTimer.minute == 0)
 800028a:	4b1a      	ldr	r3, [pc, #104]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 800028c:	785b      	ldrb	r3, [r3, #1]
 800028e:	2b00      	cmp	r3, #0
 8000290:	d120      	bne.n	80002d4 <ADCT_BGS_SwitchAIR_TimeCal+0x5c>
		{
			g_ADCT_BGS_TimerManager.SWitchingTimer.minute = 59;
 8000292:	4b18      	ldr	r3, [pc, #96]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 8000294:	223b      	movs	r2, #59	; 0x3b
 8000296:	705a      	strb	r2, [r3, #1]
			if(g_ADCT_BGS_TimerManager.SWitchingTimer.hour == 0)
 8000298:	4b16      	ldr	r3, [pc, #88]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 800029a:	781b      	ldrb	r3, [r3, #0]
 800029c:	2b00      	cmp	r3, #0
 800029e:	d126      	bne.n	80002ee <ADCT_BGS_SwitchAIR_TimeCal+0x76>
			{
				if(g_ADCT_BGS_StateOutput.WITCH_AIR == ADCT_TRUE)
 80002a0:	4b15      	ldr	r3, [pc, #84]	; (80002f8 <ADCT_BGS_SwitchAIR_TimeCal+0x80>)
 80002a2:	7a9b      	ldrb	r3, [r3, #10]
 80002a4:	2b01      	cmp	r3, #1
 80002a6:	d103      	bne.n	80002b0 <ADCT_BGS_SwitchAIR_TimeCal+0x38>
				{
					g_ADCT_BGS_StateOutput.WITCH_AIR = ADCT_FALSE;
 80002a8:	4b13      	ldr	r3, [pc, #76]	; (80002f8 <ADCT_BGS_SwitchAIR_TimeCal+0x80>)
 80002aa:	2200      	movs	r2, #0
 80002ac:	729a      	strb	r2, [r3, #10]
 80002ae:	e002      	b.n	80002b6 <ADCT_BGS_SwitchAIR_TimeCal+0x3e>
				}
				else
				{
					g_ADCT_BGS_StateOutput.WITCH_AIR = ADCT_TRUE;
 80002b0:	4b11      	ldr	r3, [pc, #68]	; (80002f8 <ADCT_BGS_SwitchAIR_TimeCal+0x80>)
 80002b2:	2201      	movs	r2, #1
 80002b4:	729a      	strb	r2, [r3, #10]
				}
				g_ADCT_BGS_TimerManager.SWitchingTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_HOUR);
 80002b6:	200b      	movs	r0, #11
 80002b8:	f002 fbea 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80002bc:	4603      	mov	r3, r0
 80002be:	461a      	mov	r2, r3
 80002c0:	4b0c      	ldr	r3, [pc, #48]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 80002c2:	701a      	strb	r2, [r3, #0]
				g_ADCT_BGS_TimerManager.SWitchingTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_MINUTE);
 80002c4:	200c      	movs	r0, #12
 80002c6:	f002 fbe3 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80002ca:	4603      	mov	r3, r0
 80002cc:	461a      	mov	r2, r3
 80002ce:	4b09      	ldr	r3, [pc, #36]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 80002d0:	705a      	strb	r2, [r3, #1]
	}
	else
	{
		g_ADCT_BGS_TimerManager.SWitchingTimer.second --;
	}
}
 80002d2:	e00c      	b.n	80002ee <ADCT_BGS_SwitchAIR_TimeCal+0x76>
				g_ADCT_BGS_TimerManager.SWitchingTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_HOUR);
				g_ADCT_BGS_TimerManager.SWitchingTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_MINUTE);
			}
		}else
		{
			g_ADCT_BGS_TimerManager.SWitchingTimer.minute --;
 80002d4:	4b07      	ldr	r3, [pc, #28]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 80002d6:	785b      	ldrb	r3, [r3, #1]
 80002d8:	3b01      	subs	r3, #1
 80002da:	b2da      	uxtb	r2, r3
 80002dc:	4b05      	ldr	r3, [pc, #20]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 80002de:	705a      	strb	r2, [r3, #1]
	}
	else
	{
		g_ADCT_BGS_TimerManager.SWitchingTimer.second --;
	}
}
 80002e0:	e005      	b.n	80002ee <ADCT_BGS_SwitchAIR_TimeCal+0x76>
			g_ADCT_BGS_TimerManager.SWitchingTimer.minute --;
		}
	}
	else
	{
		g_ADCT_BGS_TimerManager.SWitchingTimer.second --;
 80002e2:	4b04      	ldr	r3, [pc, #16]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 80002e4:	789b      	ldrb	r3, [r3, #2]
 80002e6:	3b01      	subs	r3, #1
 80002e8:	b2da      	uxtb	r2, r3
 80002ea:	4b02      	ldr	r3, [pc, #8]	; (80002f4 <ADCT_BGS_SwitchAIR_TimeCal+0x7c>)
 80002ec:	709a      	strb	r2, [r3, #2]
	}
}
 80002ee:	bf00      	nop
 80002f0:	bd80      	pop	{r7, pc}
 80002f2:	bf00      	nop
 80002f4:	200001e0 	.word	0x200001e0
 80002f8:	200001f4 	.word	0x200001f4

080002fc <ADCT_BGS_CheckMinSwitchAIR1_2>:

// Timer to check if air_1 has run at least t_min (s)
void ADCT_BGS_CheckMinSwitchAIR1_2(void)
{
 80002fc:	b480      	push	{r7}
 80002fe:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == ADCT_TRUE)
 8000300:	4b13      	ldr	r3, [pc, #76]	; (8000350 <ADCT_BGS_CheckMinSwitchAIR1_2+0x54>)
 8000302:	795b      	ldrb	r3, [r3, #5]
 8000304:	2b01      	cmp	r3, #1
 8000306:	d11e      	bne.n	8000346 <ADCT_BGS_CheckMinSwitchAIR1_2+0x4a>
	{
		if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second == 0)
 8000308:	4b12      	ldr	r3, [pc, #72]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 800030a:	795b      	ldrb	r3, [r3, #5]
 800030c:	2b00      	cmp	r3, #0
 800030e:	d114      	bne.n	800033a <ADCT_BGS_CheckMinSwitchAIR1_2+0x3e>
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second = 59;
 8000310:	4b10      	ldr	r3, [pc, #64]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 8000312:	223b      	movs	r2, #59	; 0x3b
 8000314:	715a      	strb	r2, [r3, #5]
			if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute == 0)
 8000316:	4b0f      	ldr	r3, [pc, #60]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 8000318:	791b      	ldrb	r3, [r3, #4]
 800031a:	2b00      	cmp	r3, #0
 800031c:	d106      	bne.n	800032c <ADCT_BGS_CheckMinSwitchAIR1_2+0x30>
			{
				g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = FALSE;
 800031e:	4b0c      	ldr	r3, [pc, #48]	; (8000350 <ADCT_BGS_CheckMinSwitchAIR1_2+0x54>)
 8000320:	2200      	movs	r2, #0
 8000322:	715a      	strb	r2, [r3, #5]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second = 0;
 8000324:	4b0b      	ldr	r3, [pc, #44]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 8000326:	2200      	movs	r2, #0
 8000328:	715a      	strb	r2, [r3, #5]
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second --;
		}
	}
}
 800032a:	e00c      	b.n	8000346 <ADCT_BGS_CheckMinSwitchAIR1_2+0x4a>
				g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = FALSE;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second = 0;
			}
			else
			{
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute --;
 800032c:	4b09      	ldr	r3, [pc, #36]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 800032e:	791b      	ldrb	r3, [r3, #4]
 8000330:	3b01      	subs	r3, #1
 8000332:	b2da      	uxtb	r2, r3
 8000334:	4b07      	ldr	r3, [pc, #28]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 8000336:	711a      	strb	r2, [r3, #4]
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second --;
		}
	}
}
 8000338:	e005      	b.n	8000346 <ADCT_BGS_CheckMinSwitchAIR1_2+0x4a>
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute --;
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second --;
 800033a:	4b06      	ldr	r3, [pc, #24]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 800033c:	795b      	ldrb	r3, [r3, #5]
 800033e:	3b01      	subs	r3, #1
 8000340:	b2da      	uxtb	r2, r3
 8000342:	4b04      	ldr	r3, [pc, #16]	; (8000354 <ADCT_BGS_CheckMinSwitchAIR1_2+0x58>)
 8000344:	715a      	strb	r2, [r3, #5]
		}
	}
}
 8000346:	bf00      	nop
 8000348:	46bd      	mov	sp, r7
 800034a:	bc80      	pop	{r7}
 800034c:	4770      	bx	lr
 800034e:	bf00      	nop
 8000350:	200001f4 	.word	0x200001f4
 8000354:	200001e0 	.word	0x200001e0

08000358 <ADCT_BGS_CheckMinSwitchAIR3_4>:
void ADCT_BGS_CheckMinSwitchAIR3_4(void)
{
 8000358:	b480      	push	{r7}
 800035a:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == ADCT_TRUE)
 800035c:	4b13      	ldr	r3, [pc, #76]	; (80003ac <ADCT_BGS_CheckMinSwitchAIR3_4+0x54>)
 800035e:	799b      	ldrb	r3, [r3, #6]
 8000360:	2b01      	cmp	r3, #1
 8000362:	d11e      	bne.n	80003a2 <ADCT_BGS_CheckMinSwitchAIR3_4+0x4a>
	{
		if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second == 0)
 8000364:	4b12      	ldr	r3, [pc, #72]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 8000366:	7a1b      	ldrb	r3, [r3, #8]
 8000368:	2b00      	cmp	r3, #0
 800036a:	d114      	bne.n	8000396 <ADCT_BGS_CheckMinSwitchAIR3_4+0x3e>
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second = 59;
 800036c:	4b10      	ldr	r3, [pc, #64]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 800036e:	223b      	movs	r2, #59	; 0x3b
 8000370:	721a      	strb	r2, [r3, #8]
			if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute == 0)
 8000372:	4b0f      	ldr	r3, [pc, #60]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 8000374:	79db      	ldrb	r3, [r3, #7]
 8000376:	2b00      	cmp	r3, #0
 8000378:	d106      	bne.n	8000388 <ADCT_BGS_CheckMinSwitchAIR3_4+0x30>
			{
				g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = FALSE;
 800037a:	4b0c      	ldr	r3, [pc, #48]	; (80003ac <ADCT_BGS_CheckMinSwitchAIR3_4+0x54>)
 800037c:	2200      	movs	r2, #0
 800037e:	719a      	strb	r2, [r3, #6]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second = 0;
 8000380:	4b0b      	ldr	r3, [pc, #44]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 8000382:	2200      	movs	r2, #0
 8000384:	721a      	strb	r2, [r3, #8]
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second --;
		}
	}
}
 8000386:	e00c      	b.n	80003a2 <ADCT_BGS_CheckMinSwitchAIR3_4+0x4a>
				g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = FALSE;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second = 0;
			}
			else
			{
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute --;
 8000388:	4b09      	ldr	r3, [pc, #36]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 800038a:	79db      	ldrb	r3, [r3, #7]
 800038c:	3b01      	subs	r3, #1
 800038e:	b2da      	uxtb	r2, r3
 8000390:	4b07      	ldr	r3, [pc, #28]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 8000392:	71da      	strb	r2, [r3, #7]
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second --;
		}
	}
}
 8000394:	e005      	b.n	80003a2 <ADCT_BGS_CheckMinSwitchAIR3_4+0x4a>
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute --;
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second --;
 8000396:	4b06      	ldr	r3, [pc, #24]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 8000398:	7a1b      	ldrb	r3, [r3, #8]
 800039a:	3b01      	subs	r3, #1
 800039c:	b2da      	uxtb	r2, r3
 800039e:	4b04      	ldr	r3, [pc, #16]	; (80003b0 <ADCT_BGS_CheckMinSwitchAIR3_4+0x58>)
 80003a0:	721a      	strb	r2, [r3, #8]
		}
	}
}
 80003a2:	bf00      	nop
 80003a4:	46bd      	mov	sp, r7
 80003a6:	bc80      	pop	{r7}
 80003a8:	4770      	bx	lr
 80003aa:	bf00      	nop
 80003ac:	200001f4 	.word	0x200001f4
 80003b0:	200001e0 	.word	0x200001e0

080003b4 <ADCT_BGS_CheckBuzzerTimerRun>:
void ADCT_BGS_CheckBuzzerTimerRun(void)
{
 80003b4:	b580      	push	{r7, lr}
 80003b6:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE == ADCT_TRUE)
 80003b8:	4b1c      	ldr	r3, [pc, #112]	; (800042c <ADCT_BGS_CheckBuzzerTimerRun+0x78>)
 80003ba:	791b      	ldrb	r3, [r3, #4]
 80003bc:	2b01      	cmp	r3, #1
 80003be:	d133      	bne.n	8000428 <ADCT_BGS_CheckBuzzerTimerRun+0x74>
	{
		if(g_ADCT_BGS_TimerManager.BuzzerTimer.second == 0)
 80003c0:	4b1b      	ldr	r3, [pc, #108]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 80003c2:	7b9b      	ldrb	r3, [r3, #14]
 80003c4:	2b00      	cmp	r3, #0
 80003c6:	d129      	bne.n	800041c <ADCT_BGS_CheckBuzzerTimerRun+0x68>
		{
			g_ADCT_BGS_TimerManager.BuzzerTimer.second = 59;
 80003c8:	4b19      	ldr	r3, [pc, #100]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 80003ca:	223b      	movs	r2, #59	; 0x3b
 80003cc:	739a      	strb	r2, [r3, #14]
			if(g_ADCT_BGS_TimerManager.BuzzerTimer.minute ==0)
 80003ce:	4b18      	ldr	r3, [pc, #96]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 80003d0:	7b5b      	ldrb	r3, [r3, #13]
 80003d2:	2b00      	cmp	r3, #0
 80003d4:	d11b      	bne.n	800040e <ADCT_BGS_CheckBuzzerTimerRun+0x5a>
			{
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute = 59;
 80003d6:	4b16      	ldr	r3, [pc, #88]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 80003d8:	223b      	movs	r2, #59	; 0x3b
 80003da:	735a      	strb	r2, [r3, #13]
				if(g_ADCT_BGS_TimerManager.BuzzerTimer.hour == 0)
 80003dc:	4b14      	ldr	r3, [pc, #80]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 80003de:	7b1b      	ldrb	r3, [r3, #12]
 80003e0:	2b00      	cmp	r3, #0
 80003e2:	d121      	bne.n	8000428 <ADCT_BGS_CheckBuzzerTimerRun+0x74>
				{
					g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE = ADCT_FALSE;
 80003e4:	4b11      	ldr	r3, [pc, #68]	; (800042c <ADCT_BGS_CheckBuzzerTimerRun+0x78>)
 80003e6:	2200      	movs	r2, #0
 80003e8:	711a      	strb	r2, [r3, #4]
					g_ADCT_BGS_TimerManager.BuzzerTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_LOW);
 80003ea:	200f      	movs	r0, #15
 80003ec:	f002 fb50 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80003f0:	4603      	mov	r3, r0
 80003f2:	461a      	mov	r2, r3
 80003f4:	4b0e      	ldr	r3, [pc, #56]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 80003f6:	731a      	strb	r2, [r3, #12]
					g_ADCT_BGS_TimerManager.BuzzerTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH);
 80003f8:	2010      	movs	r0, #16
 80003fa:	f002 fb49 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80003fe:	4603      	mov	r3, r0
 8000400:	461a      	mov	r2, r3
 8000402:	4b0b      	ldr	r3, [pc, #44]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 8000404:	735a      	strb	r2, [r3, #13]
					g_ADCT_BGS_TimerManager.BuzzerTimer.second =0;
 8000406:	4b0a      	ldr	r3, [pc, #40]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 8000408:	2200      	movs	r2, #0
 800040a:	739a      	strb	r2, [r3, #14]
		}else
		{
			g_ADCT_BGS_TimerManager.BuzzerTimer.second--;
		}
	}
}
 800040c:	e00c      	b.n	8000428 <ADCT_BGS_CheckBuzzerTimerRun+0x74>
					g_ADCT_BGS_TimerManager.BuzzerTimer.second =0;
				}
			}
			else
			{
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute --;
 800040e:	4b08      	ldr	r3, [pc, #32]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 8000410:	7b5b      	ldrb	r3, [r3, #13]
 8000412:	3b01      	subs	r3, #1
 8000414:	b2da      	uxtb	r2, r3
 8000416:	4b06      	ldr	r3, [pc, #24]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 8000418:	735a      	strb	r2, [r3, #13]
		}else
		{
			g_ADCT_BGS_TimerManager.BuzzerTimer.second--;
		}
	}
}
 800041a:	e005      	b.n	8000428 <ADCT_BGS_CheckBuzzerTimerRun+0x74>
			{
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute --;
			}
		}else
		{
			g_ADCT_BGS_TimerManager.BuzzerTimer.second--;
 800041c:	4b04      	ldr	r3, [pc, #16]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 800041e:	7b9b      	ldrb	r3, [r3, #14]
 8000420:	3b01      	subs	r3, #1
 8000422:	b2da      	uxtb	r2, r3
 8000424:	4b02      	ldr	r3, [pc, #8]	; (8000430 <ADCT_BGS_CheckBuzzerTimerRun+0x7c>)
 8000426:	739a      	strb	r2, [r3, #14]
		}
	}
}
 8000428:	bf00      	nop
 800042a:	bd80      	pop	{r7, pc}
 800042c:	200001f4 	.word	0x200001f4
 8000430:	200001e0 	.word	0x200001e0

08000434 <ADCT_BGS_CheckDelayOfftime>:
void ADCT_BGS_CheckDelayOfftime(void)
{
 8000434:	b480      	push	{r7}
 8000436:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE == ADCT_TRUE)
 8000438:	4b14      	ldr	r3, [pc, #80]	; (800048c <ADCT_BGS_CheckDelayOfftime+0x58>)
 800043a:	7a1b      	ldrb	r3, [r3, #8]
 800043c:	2b01      	cmp	r3, #1
 800043e:	d121      	bne.n	8000484 <ADCT_BGS_CheckDelayOfftime+0x50>
	{
		if(g_ADCT_BGS_TimerManager.StayOffTimer.second ==0)
 8000440:	4b13      	ldr	r3, [pc, #76]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 8000442:	7adb      	ldrb	r3, [r3, #11]
 8000444:	2b00      	cmp	r3, #0
 8000446:	d117      	bne.n	8000478 <ADCT_BGS_CheckDelayOfftime+0x44>
		{
			g_ADCT_BGS_TimerManager.StayOffTimer.second = 59;
 8000448:	4b11      	ldr	r3, [pc, #68]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 800044a:	223b      	movs	r2, #59	; 0x3b
 800044c:	72da      	strb	r2, [r3, #11]
			if(g_ADCT_BGS_TimerManager.StayOffTimer.minute == 0)
 800044e:	4b10      	ldr	r3, [pc, #64]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 8000450:	7a9b      	ldrb	r3, [r3, #10]
 8000452:	2b00      	cmp	r3, #0
 8000454:	d109      	bne.n	800046a <ADCT_BGS_CheckDelayOfftime+0x36>
			{
				g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE = ADCT_FALSE;
 8000456:	4b0d      	ldr	r3, [pc, #52]	; (800048c <ADCT_BGS_CheckDelayOfftime+0x58>)
 8000458:	2200      	movs	r2, #0
 800045a:	721a      	strb	r2, [r3, #8]
				g_ADCT_BGS_TimerManager.StayOffTimer.second = 0;
 800045c:	4b0c      	ldr	r3, [pc, #48]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 800045e:	2200      	movs	r2, #0
 8000460:	72da      	strb	r2, [r3, #11]
				g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED = ADCT_TRUE;
 8000462:	4b0a      	ldr	r3, [pc, #40]	; (800048c <ADCT_BGS_CheckDelayOfftime+0x58>)
 8000464:	2201      	movs	r2, #1
 8000466:	725a      	strb	r2, [r3, #9]
		else
		{
			g_ADCT_BGS_TimerManager.StayOffTimer.second -- ;
		}
	}
}
 8000468:	e00c      	b.n	8000484 <ADCT_BGS_CheckDelayOfftime+0x50>
				g_ADCT_BGS_TimerManager.StayOffTimer.second = 0;
				g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED = ADCT_TRUE;
			}
			else
			{
				g_ADCT_BGS_TimerManager.StayOffTimer.minute --;
 800046a:	4b09      	ldr	r3, [pc, #36]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 800046c:	7a9b      	ldrb	r3, [r3, #10]
 800046e:	3b01      	subs	r3, #1
 8000470:	b2da      	uxtb	r2, r3
 8000472:	4b07      	ldr	r3, [pc, #28]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 8000474:	729a      	strb	r2, [r3, #10]
		else
		{
			g_ADCT_BGS_TimerManager.StayOffTimer.second -- ;
		}
	}
}
 8000476:	e005      	b.n	8000484 <ADCT_BGS_CheckDelayOfftime+0x50>
				g_ADCT_BGS_TimerManager.StayOffTimer.minute --;
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.StayOffTimer.second -- ;
 8000478:	4b05      	ldr	r3, [pc, #20]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 800047a:	7adb      	ldrb	r3, [r3, #11]
 800047c:	3b01      	subs	r3, #1
 800047e:	b2da      	uxtb	r2, r3
 8000480:	4b03      	ldr	r3, [pc, #12]	; (8000490 <ADCT_BGS_CheckDelayOfftime+0x5c>)
 8000482:	72da      	strb	r2, [r3, #11]
		}
	}
}
 8000484:	bf00      	nop
 8000486:	46bd      	mov	sp, r7
 8000488:	bc80      	pop	{r7}
 800048a:	4770      	bx	lr
 800048c:	200001f4 	.word	0x200001f4
 8000490:	200001e0 	.word	0x200001e0

08000494 <ADCT_BGS_CheckTminFan>:
void ADCT_BGS_CheckTminFan(void)
{
 8000494:	b480      	push	{r7}
 8000496:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == ADCT_TRUE)
 8000498:	4b13      	ldr	r3, [pc, #76]	; (80004e8 <ADCT_BGS_CheckTminFan+0x54>)
 800049a:	789b      	ldrb	r3, [r3, #2]
 800049c:	2b01      	cmp	r3, #1
 800049e:	d11e      	bne.n	80004de <ADCT_BGS_CheckTminFan+0x4a>
	{
		if(g_ADCT_BGS_TimerManager.MinRuningTimerFan.second == 0)
 80004a0:	4b12      	ldr	r3, [pc, #72]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004a2:	7c5b      	ldrb	r3, [r3, #17]
 80004a4:	2b00      	cmp	r3, #0
 80004a6:	d114      	bne.n	80004d2 <ADCT_BGS_CheckTminFan+0x3e>
		{
			g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = 59;
 80004a8:	4b10      	ldr	r3, [pc, #64]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004aa:	223b      	movs	r2, #59	; 0x3b
 80004ac:	745a      	strb	r2, [r3, #17]
			if(g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute == 0)
 80004ae:	4b0f      	ldr	r3, [pc, #60]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004b0:	7c1b      	ldrb	r3, [r3, #16]
 80004b2:	2b00      	cmp	r3, #0
 80004b4:	d106      	bne.n	80004c4 <ADCT_BGS_CheckTminFan+0x30>
			{
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
 80004b6:	4b0c      	ldr	r3, [pc, #48]	; (80004e8 <ADCT_BGS_CheckTminFan+0x54>)
 80004b8:	2200      	movs	r2, #0
 80004ba:	709a      	strb	r2, [r3, #2]
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = 0;
 80004bc:	4b0b      	ldr	r3, [pc, #44]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004be:	2200      	movs	r2, #0
 80004c0:	745a      	strb	r2, [r3, #17]
		else
		{
			g_ADCT_BGS_TimerManager.MinRuningTimerFan.second -- ;
		}
	}
}
 80004c2:	e00c      	b.n	80004de <ADCT_BGS_CheckTminFan+0x4a>
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = 0;
			}
			else
			{
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute--;
 80004c4:	4b09      	ldr	r3, [pc, #36]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004c6:	7c1b      	ldrb	r3, [r3, #16]
 80004c8:	3b01      	subs	r3, #1
 80004ca:	b2da      	uxtb	r2, r3
 80004cc:	4b07      	ldr	r3, [pc, #28]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004ce:	741a      	strb	r2, [r3, #16]
		else
		{
			g_ADCT_BGS_TimerManager.MinRuningTimerFan.second -- ;
		}
	}
}
 80004d0:	e005      	b.n	80004de <ADCT_BGS_CheckTminFan+0x4a>
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute--;
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.MinRuningTimerFan.second -- ;
 80004d2:	4b06      	ldr	r3, [pc, #24]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004d4:	7c5b      	ldrb	r3, [r3, #17]
 80004d6:	3b01      	subs	r3, #1
 80004d8:	b2da      	uxtb	r2, r3
 80004da:	4b04      	ldr	r3, [pc, #16]	; (80004ec <ADCT_BGS_CheckTminFan+0x58>)
 80004dc:	745a      	strb	r2, [r3, #17]
		}
	}
}
 80004de:	bf00      	nop
 80004e0:	46bd      	mov	sp, r7
 80004e2:	bc80      	pop	{r7}
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	200001f4 	.word	0x200001f4
 80004ec:	200001e0 	.word	0x200001e0

080004f0 <ADCT_BGS_AlarmBuzzer>:

void ADCT_BGS_AlarmBuzzer(void)
{
 80004f0:	b580      	push	{r7, lr}
 80004f2:	af00      	add	r7, sp, #0
	if(g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag == ADCT_TRUE)
 80004f4:	4b15      	ldr	r3, [pc, #84]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 80004f6:	7adb      	ldrb	r3, [r3, #11]
 80004f8:	2b01      	cmp	r3, #1
 80004fa:	d125      	bne.n	8000548 <ADCT_BGS_AlarmBuzzer+0x58>
	{
		if(g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt == 0)
 80004fc:	4b13      	ldr	r3, [pc, #76]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 80004fe:	7b1b      	ldrb	r3, [r3, #12]
 8000500:	2b00      	cmp	r3, #0
 8000502:	d11b      	bne.n	800053c <ADCT_BGS_AlarmBuzzer+0x4c>
		{
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_FALSE;
 8000504:	4b11      	ldr	r3, [pc, #68]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 8000506:	2200      	movs	r2, #0
 8000508:	72da      	strb	r2, [r3, #11]
			g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE = ADCT_FALSE;
 800050a:	4b10      	ldr	r3, [pc, #64]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 800050c:	2200      	movs	r2, #0
 800050e:	70da      	strb	r2, [r3, #3]
			if(g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE == ADCT_FALSE)
 8000510:	4b0e      	ldr	r3, [pc, #56]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 8000512:	791b      	ldrb	r3, [r3, #4]
 8000514:	2b00      	cmp	r3, #0
 8000516:	d117      	bne.n	8000548 <ADCT_BGS_AlarmBuzzer+0x58>
			{
				g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE = ADCT_TRUE;
 8000518:	4b0c      	ldr	r3, [pc, #48]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 800051a:	2201      	movs	r2, #1
 800051c:	711a      	strb	r2, [r3, #4]
				g_ADCT_BGS_TimerManager.BuzzerTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_LOW );
 800051e:	200f      	movs	r0, #15
 8000520:	f002 fab6 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8000524:	4603      	mov	r3, r0
 8000526:	461a      	mov	r2, r3
 8000528:	4b09      	ldr	r3, [pc, #36]	; (8000550 <ADCT_BGS_AlarmBuzzer+0x60>)
 800052a:	731a      	strb	r2, [r3, #12]
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH );
 800052c:	2010      	movs	r0, #16
 800052e:	f002 faaf 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8000532:	4603      	mov	r3, r0
 8000534:	461a      	mov	r2, r3
 8000536:	4b06      	ldr	r3, [pc, #24]	; (8000550 <ADCT_BGS_AlarmBuzzer+0x60>)
 8000538:	735a      	strb	r2, [r3, #13]
		else
		{
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt -- ;
		}
	}
}
 800053a:	e005      	b.n	8000548 <ADCT_BGS_AlarmBuzzer+0x58>
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH );
			}
		}
		else
		{
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt -- ;
 800053c:	4b03      	ldr	r3, [pc, #12]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 800053e:	7b1b      	ldrb	r3, [r3, #12]
 8000540:	3b01      	subs	r3, #1
 8000542:	b2da      	uxtb	r2, r3
 8000544:	4b01      	ldr	r3, [pc, #4]	; (800054c <ADCT_BGS_AlarmBuzzer+0x5c>)
 8000546:	731a      	strb	r2, [r3, #12]
		}
	}
}
 8000548:	bf00      	nop
 800054a:	bd80      	pop	{r7, pc}
 800054c:	200001f4 	.word	0x200001f4
 8000550:	200001e0 	.word	0x200001e0

08000554 <ADCT_IO_FPT_GetValue>:
  * @brief Get value of I/Os.
  * @param pIOData        : data of I/Os
  * @retval None
  */
void ADCT_IO_FPT_GetValue(IO_MODULE_DATA *pIOData)
{
 8000554:	b580      	push	{r7, lr}
 8000556:	b082      	sub	sp, #8
 8000558:	af00      	add	r7, sp, #0
 800055a:	6078      	str	r0, [r7, #4]
	/*DOOR*/
	pIOData->ucDoor [0] = ADCT_BGS_DOOR_READ ;
 800055c:	2102      	movs	r1, #2
 800055e:	481d      	ldr	r0, [pc, #116]	; (80005d4 <ADCT_IO_FPT_GetValue+0x80>)
 8000560:	f003 fe9c 	bl	800429c <GPIO_ReadInputDataBit>
 8000564:	4603      	mov	r3, r0
 8000566:	461a      	mov	r2, r3
 8000568:	687b      	ldr	r3, [r7, #4]
 800056a:	70da      	strb	r2, [r3, #3]
	/*FIRE*/
	pIOData->ucFire = ADCT_BGS_FIRE_READ;
 800056c:	2108      	movs	r1, #8
 800056e:	4819      	ldr	r0, [pc, #100]	; (80005d4 <ADCT_IO_FPT_GetValue+0x80>)
 8000570:	f003 fe94 	bl	800429c <GPIO_ReadInputDataBit>
 8000574:	4603      	mov	r3, r0
 8000576:	461a      	mov	r2, r3
 8000578:	687b      	ldr	r3, [r7, #4]
 800057a:	701a      	strb	r2, [r3, #0]
	/*WATER*/
	pIOData->ucWater = ADCT_BGS_WATER_READ;
 800057c:	2110      	movs	r1, #16
 800057e:	4815      	ldr	r0, [pc, #84]	; (80005d4 <ADCT_IO_FPT_GetValue+0x80>)
 8000580:	f003 fe8c 	bl	800429c <GPIO_ReadInputDataBit>
 8000584:	4603      	mov	r3, r0
 8000586:	461a      	mov	r2, r3
 8000588:	687b      	ldr	r3, [r7, #4]
 800058a:	709a      	strb	r2, [r3, #2]
	/*SMOKE*/
	pIOData->ucSmoke = ADCT_BGS_SMOKE_READ;
 800058c:	2101      	movs	r1, #1
 800058e:	4811      	ldr	r0, [pc, #68]	; (80005d4 <ADCT_IO_FPT_GetValue+0x80>)
 8000590:	f003 fe84 	bl	800429c <GPIO_ReadInputDataBit>
 8000594:	4603      	mov	r3, r0
 8000596:	461a      	mov	r2, r3
 8000598:	687b      	ldr	r3, [r7, #4]
 800059a:	705a      	strb	r2, [r3, #1]

	/*BURGLAR*/
	pIOData->ucBurglar = ADCT_BGS_BURGLAR_READ;
 800059c:	2104      	movs	r1, #4
 800059e:	480d      	ldr	r0, [pc, #52]	; (80005d4 <ADCT_IO_FPT_GetValue+0x80>)
 80005a0:	f003 fe7c 	bl	800429c <GPIO_ReadInputDataBit>
 80005a4:	4603      	mov	r3, r0
 80005a6:	461a      	mov	r2, r3
 80005a8:	687b      	ldr	r3, [r7, #4]
 80005aa:	721a      	strb	r2, [r3, #8]
	/*BUZZER*/
	pIOData->ucBuzzer = ADCT_BGS_BUZZER_READ;
 80005ac:	2102      	movs	r1, #2
 80005ae:	480a      	ldr	r0, [pc, #40]	; (80005d8 <ADCT_IO_FPT_GetValue+0x84>)
 80005b0:	f003 fe74 	bl	800429c <GPIO_ReadInputDataBit>
 80005b4:	4603      	mov	r3, r0
 80005b6:	461a      	mov	r2, r3
 80005b8:	687b      	ldr	r3, [r7, #4]
 80005ba:	745a      	strb	r2, [r3, #17]
	/*LED*/
	pIOData->ucLed = ADCT_BGS_LAMP_READ;
 80005bc:	2101      	movs	r1, #1
 80005be:	4806      	ldr	r0, [pc, #24]	; (80005d8 <ADCT_IO_FPT_GetValue+0x84>)
 80005c0:	f003 fe6c 	bl	800429c <GPIO_ReadInputDataBit>
 80005c4:	4603      	mov	r3, r0
 80005c6:	461a      	mov	r2, r3
 80005c8:	687b      	ldr	r3, [r7, #4]
 80005ca:	749a      	strb	r2, [r3, #18]
}
 80005cc:	bf00      	nop
 80005ce:	3708      	adds	r7, #8
 80005d0:	46bd      	mov	sp, r7
 80005d2:	bd80      	pop	{r7, pc}
 80005d4:	40011000 	.word	0x40011000
 80005d8:	40010800 	.word	0x40010800

080005dc <ADCT_SYSTEM_FPT_CheckState_MODBUS>:
	GstSystemWarning.tempState.nextState = TEMP_MODE_NONE;
	TempStateTimer = TM_DELAY_TimerCreate(1000, 0, 0, ADCT_SYSTEM_FPT_TempTimer_Task, NULL);
}
#ifdef ADCT_MODBUS_ENABLED
void ADCT_SYSTEM_FPT_CheckState_MODBUS(void )
{
 80005dc:	b480      	push	{r7}
 80005de:	af00      	add	r7, sp, #0
	/* High Main voltage */
	if((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usHighMainVoltage)&&
 80005e0:	4b7e      	ldr	r3, [pc, #504]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 80005e2:	881a      	ldrh	r2, [r3, #0]
 80005e4:	4b7e      	ldr	r3, [pc, #504]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 80005e6:	899b      	ldrh	r3, [r3, #12]
 80005e8:	429a      	cmp	r2, r3
 80005ea:	d90d      	bls.n	8000608 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x2c>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_OFF))
 80005ec:	4b7d      	ldr	r3, [pc, #500]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80005ee:	685b      	ldr	r3, [r3, #4]
 80005f0:	08db      	lsrs	r3, r3, #3
 80005f2:	f003 0301 	and.w	r3, r3, #1
}
#ifdef ADCT_MODBUS_ENABLED
void ADCT_SYSTEM_FPT_CheckState_MODBUS(void )
{
	/* High Main voltage */
	if((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usHighMainVoltage)&&
 80005f6:	2b00      	cmp	r3, #0
 80005f8:	d106      	bne.n	8000608 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x2c>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_OFF))
	{
		/*Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_ON);
 80005fa:	4b7a      	ldr	r3, [pc, #488]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80005fc:	685b      	ldr	r3, [r3, #4]
 80005fe:	f043 0308 	orr.w	r3, r3, #8
 8000602:	4a78      	ldr	r2, [pc, #480]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000604:	6053      	str	r3, [r2, #4]
 8000606:	e012      	b.n	800062e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x52>

		/* Store log into EPPRROM */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usHighMainVoltage) &&
 8000608:	4b74      	ldr	r3, [pc, #464]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 800060a:	881a      	ldrh	r2, [r3, #0]
 800060c:	4b74      	ldr	r3, [pc, #464]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 800060e:	899b      	ldrh	r3, [r3, #12]
 8000610:	429a      	cmp	r2, r3
 8000612:	d20c      	bcs.n	800062e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x52>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_ON))
 8000614:	4b73      	ldr	r3, [pc, #460]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000616:	685b      	ldr	r3, [r3, #4]
 8000618:	08db      	lsrs	r3, r3, #3
 800061a:	f003 0301 	and.w	r3, r3, #1
		/*Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_ON);

		/* Store log into EPPRROM */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usHighMainVoltage) &&
 800061e:	2b00      	cmp	r3, #0
 8000620:	d005      	beq.n	800062e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x52>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_ON))
	{
		/* Set warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_OFF);
 8000622:	4b70      	ldr	r3, [pc, #448]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000624:	685b      	ldr	r3, [r3, #4]
 8000626:	f023 0308 	bic.w	r3, r3, #8
 800062a:	4a6e      	ldr	r2, [pc, #440]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800062c:	6053      	str	r3, [r2, #4]
		/* Store log into Epprom */
	}
	/* Low Main Voltage (SNMP_SYT_013) */
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
 800062e:	4b6b      	ldr	r3, [pc, #428]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 8000630:	881a      	ldrh	r2, [r3, #0]
 8000632:	4b6b      	ldr	r3, [pc, #428]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 8000634:	895b      	ldrh	r3, [r3, #10]
 8000636:	429a      	cmp	r2, r3
 8000638:	d20d      	bcs.n	8000656 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x7a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_OFF))
 800063a:	4b6a      	ldr	r3, [pc, #424]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800063c:	685b      	ldr	r3, [r3, #4]
 800063e:	089b      	lsrs	r3, r3, #2
 8000640:	f003 0301 	and.w	r3, r3, #1
		/* Set warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_OFF);
		/* Store log into Epprom */
	}
	/* Low Main Voltage (SNMP_SYT_013) */
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
 8000644:	2b00      	cmp	r3, #0
 8000646:	d106      	bne.n	8000656 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x7a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_ON);
 8000648:	4b66      	ldr	r3, [pc, #408]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800064a:	685b      	ldr	r3, [r3, #4]
 800064c:	f043 0304 	orr.w	r3, r3, #4
 8000650:	4a64      	ldr	r2, [pc, #400]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000652:	6053      	str	r3, [r2, #4]
 8000654:	e012      	b.n	800067c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xa0>
		/* Set log */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usLowMainVoltage) &&
 8000656:	4b61      	ldr	r3, [pc, #388]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 8000658:	881a      	ldrh	r2, [r3, #0]
 800065a:	4b61      	ldr	r3, [pc, #388]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 800065c:	895b      	ldrh	r3, [r3, #10]
 800065e:	429a      	cmp	r2, r3
 8000660:	d90c      	bls.n	800067c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xa0>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_ON))
 8000662:	4b60      	ldr	r3, [pc, #384]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000664:	685b      	ldr	r3, [r3, #4]
 8000666:	089b      	lsrs	r3, r3, #2
 8000668:	f003 0301 	and.w	r3, r3, #1
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_ON);
		/* Set log */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usLowMainVoltage) &&
 800066c:	2b00      	cmp	r3, #0
 800066e:	d005      	beq.n	800067c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xa0>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_OFF);
 8000670:	4b5c      	ldr	r3, [pc, #368]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000672:	685b      	ldr	r3, [r3, #4]
 8000674:	f023 0304 	bic.w	r3, r3, #4
 8000678:	4a5a      	ldr	r2, [pc, #360]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800067a:	6053      	str	r3, [r2, #4]
		/* Set Log */
	}

	/* Low Fuel (SNMP_SYT_015) */
	if((GstSystemStatus.mbData.usCurrentGenFuel < GstSystemSetting.usGenFuelLowValue) &&
 800067c:	4b57      	ldr	r3, [pc, #348]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 800067e:	885a      	ldrh	r2, [r3, #2]
 8000680:	4b57      	ldr	r3, [pc, #348]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 8000682:	89db      	ldrh	r3, [r3, #14]
 8000684:	429a      	cmp	r2, r3
 8000686:	d20d      	bcs.n	80006a4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xc8>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_OFF))
 8000688:	4b56      	ldr	r3, [pc, #344]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800068a:	685b      	ldr	r3, [r3, #4]
 800068c:	091b      	lsrs	r3, r3, #4
 800068e:	f003 0301 	and.w	r3, r3, #1
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_OFF);
		/* Set Log */
	}

	/* Low Fuel (SNMP_SYT_015) */
	if((GstSystemStatus.mbData.usCurrentGenFuel < GstSystemSetting.usGenFuelLowValue) &&
 8000692:	2b00      	cmp	r3, #0
 8000694:	d106      	bne.n	80006a4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xc8>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_ON);
 8000696:	4b53      	ldr	r3, [pc, #332]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000698:	685b      	ldr	r3, [r3, #4]
 800069a:	f043 0310 	orr.w	r3, r3, #16
 800069e:	4a51      	ldr	r2, [pc, #324]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006a0:	6053      	str	r3, [r2, #4]
 80006a2:	e012      	b.n	80006ca <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xee>
		/* Set Log */
	}
	else if ((GstSystemStatus.mbData.usCurrentGenFuel > GstSystemSetting.usGenFuelLowValue) &&
 80006a4:	4b4d      	ldr	r3, [pc, #308]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 80006a6:	885a      	ldrh	r2, [r3, #2]
 80006a8:	4b4d      	ldr	r3, [pc, #308]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 80006aa:	89db      	ldrh	r3, [r3, #14]
 80006ac:	429a      	cmp	r2, r3
 80006ae:	d90c      	bls.n	80006ca <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xee>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON))
 80006b0:	4b4c      	ldr	r3, [pc, #304]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006b2:	685b      	ldr	r3, [r3, #4]
 80006b4:	091b      	lsrs	r3, r3, #4
 80006b6:	f003 0301 	and.w	r3, r3, #1
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_ON);
		/* Set Log */
	}
	else if ((GstSystemStatus.mbData.usCurrentGenFuel > GstSystemSetting.usGenFuelLowValue) &&
 80006ba:	2b00      	cmp	r3, #0
 80006bc:	d005      	beq.n	80006ca <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xee>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_OFF);
 80006be:	4b49      	ldr	r3, [pc, #292]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006c0:	685b      	ldr	r3, [r3, #4]
 80006c2:	f023 0310 	bic.w	r3, r3, #16
 80006c6:	4a47      	ldr	r2, [pc, #284]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006c8:	6053      	str	r3, [r2, #4]
		/* Set Log */
	}
	/* Low Oil Pressure (SNMP_SYT_016) */
	if((GstSystemStatus.mbData.usCurrentGenOilPressure < GstSystemSetting.usGenOilPressureAlarmValue) &&
 80006ca:	4b44      	ldr	r3, [pc, #272]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 80006cc:	899a      	ldrh	r2, [r3, #12]
 80006ce:	4b44      	ldr	r3, [pc, #272]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 80006d0:	8b1b      	ldrh	r3, [r3, #24]
 80006d2:	429a      	cmp	r2, r3
 80006d4:	d20d      	bcs.n	80006f2 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x116>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_OFF))
 80006d6:	4b43      	ldr	r3, [pc, #268]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006d8:	685b      	ldr	r3, [r3, #4]
 80006da:	095b      	lsrs	r3, r3, #5
 80006dc:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_OFF);
		/* Set Log */
	}
	/* Low Oil Pressure (SNMP_SYT_016) */
	if((GstSystemStatus.mbData.usCurrentGenOilPressure < GstSystemSetting.usGenOilPressureAlarmValue) &&
 80006e0:	2b00      	cmp	r3, #0
 80006e2:	d106      	bne.n	80006f2 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x116>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS, WARN_ON);
 80006e4:	4b3f      	ldr	r3, [pc, #252]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006e6:	685b      	ldr	r3, [r3, #4]
 80006e8:	f043 0320 	orr.w	r3, r3, #32
 80006ec:	4a3d      	ldr	r2, [pc, #244]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80006ee:	6053      	str	r3, [r2, #4]
 80006f0:	e012      	b.n	8000718 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x13c>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenOilPressure > GstSystemSetting.usGenOilPressureAlarmValue) &&
 80006f2:	4b3a      	ldr	r3, [pc, #232]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 80006f4:	899a      	ldrh	r2, [r3, #12]
 80006f6:	4b3a      	ldr	r3, [pc, #232]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 80006f8:	8b1b      	ldrh	r3, [r3, #24]
 80006fa:	429a      	cmp	r2, r3
 80006fc:	d90c      	bls.n	8000718 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x13c>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_ON))
 80006fe:	4b39      	ldr	r3, [pc, #228]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000700:	685b      	ldr	r3, [r3, #4]
 8000702:	095b      	lsrs	r3, r3, #5
 8000704:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenOilPressure > GstSystemSetting.usGenOilPressureAlarmValue) &&
 8000708:	2b00      	cmp	r3, #0
 800070a:	d005      	beq.n	8000718 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x13c>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS, WARN_OFF);
 800070c:	4b35      	ldr	r3, [pc, #212]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800070e:	685b      	ldr	r3, [r3, #4]
 8000710:	f023 0320 	bic.w	r3, r3, #32
 8000714:	4a33      	ldr	r2, [pc, #204]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000716:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Generate Voltage (SNMP_SYT_017) */
	if((GstSystemStatus.mbData.usCurrentGenVoltage < GstSystemSetting.usGenVoltageAlarmValue) &&
 8000718:	4b30      	ldr	r3, [pc, #192]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 800071a:	889a      	ldrh	r2, [r3, #4]
 800071c:	4b30      	ldr	r3, [pc, #192]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 800071e:	8a1b      	ldrh	r3, [r3, #16]
 8000720:	429a      	cmp	r2, r3
 8000722:	d20d      	bcs.n	8000740 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x164>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_OFF))
 8000724:	4b2f      	ldr	r3, [pc, #188]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000726:	685b      	ldr	r3, [r3, #4]
 8000728:	099b      	lsrs	r3, r3, #6
 800072a:	f003 0301 	and.w	r3, r3, #1
		/* Set Log */

	}

	/* Low Generate Voltage (SNMP_SYT_017) */
	if((GstSystemStatus.mbData.usCurrentGenVoltage < GstSystemSetting.usGenVoltageAlarmValue) &&
 800072e:	2b00      	cmp	r3, #0
 8000730:	d106      	bne.n	8000740 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x164>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE, WARN_ON);
 8000732:	4b2c      	ldr	r3, [pc, #176]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000734:	685b      	ldr	r3, [r3, #4]
 8000736:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800073a:	4a2a      	ldr	r2, [pc, #168]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800073c:	6053      	str	r3, [r2, #4]
 800073e:	e012      	b.n	8000766 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x18a>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenVoltage > GstSystemSetting.usGenVoltageAlarmValue) &&
 8000740:	4b26      	ldr	r3, [pc, #152]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 8000742:	889a      	ldrh	r2, [r3, #4]
 8000744:	4b26      	ldr	r3, [pc, #152]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 8000746:	8a1b      	ldrh	r3, [r3, #16]
 8000748:	429a      	cmp	r2, r3
 800074a:	d90c      	bls.n	8000766 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x18a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_ON))
 800074c:	4b25      	ldr	r3, [pc, #148]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800074e:	685b      	ldr	r3, [r3, #4]
 8000750:	099b      	lsrs	r3, r3, #6
 8000752:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenVoltage > GstSystemSetting.usGenVoltageAlarmValue) &&
 8000756:	2b00      	cmp	r3, #0
 8000758:	d005      	beq.n	8000766 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x18a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE, WARN_OFF);
 800075a:	4b22      	ldr	r3, [pc, #136]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800075c:	685b      	ldr	r3, [r3, #4]
 800075e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000762:	4a20      	ldr	r2, [pc, #128]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000764:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Generate Battery (SNMP_SYT_018) */
	if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage < GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 8000766:	4b1d      	ldr	r3, [pc, #116]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 8000768:	88da      	ldrh	r2, [r3, #6]
 800076a:	4b1d      	ldr	r3, [pc, #116]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 800076c:	8a5b      	ldrh	r3, [r3, #18]
 800076e:	429a      	cmp	r2, r3
 8000770:	d20d      	bcs.n	800078e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b2>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_OFF))
 8000772:	4b1c      	ldr	r3, [pc, #112]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000774:	685b      	ldr	r3, [r3, #4]
 8000776:	09db      	lsrs	r3, r3, #7
 8000778:	f003 0301 	and.w	r3, r3, #1
		/* Set Log */

	}

	/* Low Generate Battery (SNMP_SYT_018) */
	if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage < GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 800077c:	2b00      	cmp	r3, #0
 800077e:	d106      	bne.n	800078e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b2>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENBAT, WARN_ON);
 8000780:	4b18      	ldr	r3, [pc, #96]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 8000782:	685b      	ldr	r3, [r3, #4]
 8000784:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000788:	4a16      	ldr	r2, [pc, #88]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800078a:	6053      	str	r3, [r2, #4]
 800078c:	e012      	b.n	80007b4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1d8>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage > GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 800078e:	4b13      	ldr	r3, [pc, #76]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 8000790:	88da      	ldrh	r2, [r3, #6]
 8000792:	4b13      	ldr	r3, [pc, #76]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 8000794:	8a5b      	ldrh	r3, [r3, #18]
 8000796:	429a      	cmp	r2, r3
 8000798:	d90c      	bls.n	80007b4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1d8>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_ON))
 800079a:	4b12      	ldr	r3, [pc, #72]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 800079c:	685b      	ldr	r3, [r3, #4]
 800079e:	09db      	lsrs	r3, r3, #7
 80007a0:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENBAT, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage > GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 80007a4:	2b00      	cmp	r3, #0
 80007a6:	d005      	beq.n	80007b4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1d8>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENBAT, WARN_OFF);
 80007a8:	4b0e      	ldr	r3, [pc, #56]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80007aa:	685b      	ldr	r3, [r3, #4]
 80007ac:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80007b0:	4a0c      	ldr	r2, [pc, #48]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80007b2:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Engine Speed (SNMP_SYT_019) */
	if((GstSystemStatus.mbData.usCurrentGenEngineSpeed < GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 80007b4:	4b09      	ldr	r3, [pc, #36]	; (80007dc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x200>)
 80007b6:	895a      	ldrh	r2, [r3, #10]
 80007b8:	4b09      	ldr	r3, [pc, #36]	; (80007e0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x204>)
 80007ba:	8adb      	ldrh	r3, [r3, #22]
 80007bc:	429a      	cmp	r2, r3
 80007be:	d213      	bcs.n	80007e8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x20c>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_OFF))
 80007c0:	4b08      	ldr	r3, [pc, #32]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80007c2:	685b      	ldr	r3, [r3, #4]
 80007c4:	0a1b      	lsrs	r3, r3, #8
 80007c6:	f003 0301 	and.w	r3, r3, #1
		/* Set Log */

	}

	/* Low Engine Speed (SNMP_SYT_019) */
	if((GstSystemStatus.mbData.usCurrentGenEngineSpeed < GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 80007ca:	2b00      	cmp	r3, #0
 80007cc:	d10c      	bne.n	80007e8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x20c>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWENSPEED, WARN_ON);
 80007ce:	4b05      	ldr	r3, [pc, #20]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80007d0:	685b      	ldr	r3, [r3, #4]
 80007d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80007d6:	4a03      	ldr	r2, [pc, #12]	; (80007e4 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x208>)
 80007d8:	6053      	str	r3, [r2, #4]
 80007da:	e018      	b.n	800080e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x232>
 80007dc:	20000250 	.word	0x20000250
 80007e0:	20000204 	.word	0x20000204
 80007e4:	20000248 	.word	0x20000248
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenEngineSpeed > GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 80007e8:	4b1e      	ldr	r3, [pc, #120]	; (8000864 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x288>)
 80007ea:	895a      	ldrh	r2, [r3, #10]
 80007ec:	4b1e      	ldr	r3, [pc, #120]	; (8000868 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x28c>)
 80007ee:	8adb      	ldrh	r3, [r3, #22]
 80007f0:	429a      	cmp	r2, r3
 80007f2:	d90c      	bls.n	800080e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x232>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_ON))
 80007f4:	4b1d      	ldr	r3, [pc, #116]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 80007f6:	685b      	ldr	r3, [r3, #4]
 80007f8:	0a1b      	lsrs	r3, r3, #8
 80007fa:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWENSPEED, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenEngineSpeed > GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 80007fe:	2b00      	cmp	r3, #0
 8000800:	d005      	beq.n	800080e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x232>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWENSPEED, WARN_OFF);
 8000802:	4b1a      	ldr	r3, [pc, #104]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 8000804:	685b      	ldr	r3, [r3, #4]
 8000806:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800080a:	4a18      	ldr	r2, [pc, #96]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 800080c:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Coolant Temperature (SNMP_SYT_020) */
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp < GstSystemSetting.usGenCoolantTempAlarmValue) &&
 800080e:	4b15      	ldr	r3, [pc, #84]	; (8000864 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x288>)
 8000810:	891a      	ldrh	r2, [r3, #8]
 8000812:	4b15      	ldr	r3, [pc, #84]	; (8000868 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x28c>)
 8000814:	8a9b      	ldrh	r3, [r3, #20]
 8000816:	429a      	cmp	r2, r3
 8000818:	d20c      	bcs.n	8000834 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x258>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_OFF))
 800081a:	4b14      	ldr	r3, [pc, #80]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 800081c:	685b      	ldr	r3, [r3, #4]
 800081e:	0a5b      	lsrs	r3, r3, #9
 8000820:	f003 0301 	and.w	r3, r3, #1
		/* Set Log */

	}

	/* Low Coolant Temperature (SNMP_SYT_020) */
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp < GstSystemSetting.usGenCoolantTempAlarmValue) &&
 8000824:	2b00      	cmp	r3, #0
 8000826:	d105      	bne.n	8000834 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x258>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP, WARN_ON);
 8000828:	4b10      	ldr	r3, [pc, #64]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 800082a:	685b      	ldr	r3, [r3, #4]
 800082c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000830:	4a0e      	ldr	r2, [pc, #56]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 8000832:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp > GstSystemSetting.usGenCoolantTempAlarmValue) &&
 8000834:	4b0b      	ldr	r3, [pc, #44]	; (8000864 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x288>)
 8000836:	891a      	ldrh	r2, [r3, #8]
 8000838:	4b0b      	ldr	r3, [pc, #44]	; (8000868 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x28c>)
 800083a:	8a9b      	ldrh	r3, [r3, #20]
 800083c:	429a      	cmp	r2, r3
 800083e:	d90c      	bls.n	800085a <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x27e>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_ON))
 8000840:	4b0a      	ldr	r3, [pc, #40]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 8000842:	685b      	ldr	r3, [r3, #4]
 8000844:	0a5b      	lsrs	r3, r3, #9
 8000846:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP, WARN_ON);
		/* Set Log */

	}
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp > GstSystemSetting.usGenCoolantTempAlarmValue) &&
 800084a:	2b00      	cmp	r3, #0
 800084c:	d005      	beq.n	800085a <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x27e>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP, WARN_OFF);
 800084e:	4b07      	ldr	r3, [pc, #28]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 8000850:	685b      	ldr	r3, [r3, #4]
 8000852:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000856:	4a05      	ldr	r2, [pc, #20]	; (800086c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x290>)
 8000858:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}
}
 800085a:	bf00      	nop
 800085c:	46bd      	mov	sp, r7
 800085e:	bc80      	pop	{r7}
 8000860:	4770      	bx	lr
 8000862:	bf00      	nop
 8000864:	20000250 	.word	0x20000250
 8000868:	20000204 	.word	0x20000204
 800086c:	20000248 	.word	0x20000248

08000870 <ADCT_SYSTEM_FPT_CheckState_IO>:
 * @brief Check system state of I/O.
 * @param None
 * @retval None
 */
void ADCT_SYSTEM_FPT_CheckState_IO(void)
{
 8000870:	b480      	push	{r7}
 8000872:	af00      	add	r7, sp, #0
	/* Fire (SNMP_SYT_007) */
	if(GstSystemStatus.ioData.ucFire != (ReadBit(GstSystemWarning.othWarn, WARN_FIRE)))
 8000874:	4b7d      	ldr	r3, [pc, #500]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000876:	7f9b      	ldrb	r3, [r3, #30]
 8000878:	461a      	mov	r2, r3
 800087a:	4b7d      	ldr	r3, [pc, #500]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 800087c:	685b      	ldr	r3, [r3, #4]
 800087e:	0a9b      	lsrs	r3, r3, #10
 8000880:	f003 0301 	and.w	r3, r3, #1
 8000884:	429a      	cmp	r2, r3
 8000886:	d01c      	beq.n	80008c2 <ADCT_SYSTEM_FPT_CheckState_IO+0x52>
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_FIRE, GstSystemStatus.ioData.ucFire);
 8000888:	4b78      	ldr	r3, [pc, #480]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 800088a:	7f9b      	ldrb	r3, [r3, #30]
 800088c:	2b00      	cmp	r3, #0
 800088e:	d006      	beq.n	800089e <ADCT_SYSTEM_FPT_CheckState_IO+0x2e>
 8000890:	4b77      	ldr	r3, [pc, #476]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000892:	685b      	ldr	r3, [r3, #4]
 8000894:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000898:	4a75      	ldr	r2, [pc, #468]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 800089a:	6053      	str	r3, [r2, #4]
 800089c:	e005      	b.n	80008aa <ADCT_SYSTEM_FPT_CheckState_IO+0x3a>
 800089e:	4b74      	ldr	r3, [pc, #464]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008a0:	685b      	ldr	r3, [r3, #4]
 80008a2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80008a6:	4a72      	ldr	r2, [pc, #456]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008a8:	6053      	str	r3, [r2, #4]
		if(GstSystemStatus.ioData.ucFire)
 80008aa:	4b70      	ldr	r3, [pc, #448]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80008ac:	7f9b      	ldrb	r3, [r3, #30]
 80008ae:	2b00      	cmp	r3, #0
 80008b0:	d007      	beq.n	80008c2 <ADCT_SYSTEM_FPT_CheckState_IO+0x52>
		{
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 80008b2:	4b70      	ldr	r3, [pc, #448]	; (8000a74 <ADCT_SYSTEM_FPT_CheckState_IO+0x204>)
 80008b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80008b6:	b2da      	uxtb	r2, r3
 80008b8:	4b6f      	ldr	r3, [pc, #444]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 80008ba:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 80008bc:	4b6e      	ldr	r3, [pc, #440]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 80008be:	2201      	movs	r2, #1
 80008c0:	72da      	strb	r2, [r3, #11]

		}
	}

	/* Smoke (SNMP_SYT_008) */
	if(GstSystemStatus.ioData.ucSmoke != (ReadBit(GstSystemWarning.othWarn, WARN_SMOKE)))
 80008c2:	4b6a      	ldr	r3, [pc, #424]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80008c4:	7fdb      	ldrb	r3, [r3, #31]
 80008c6:	461a      	mov	r2, r3
 80008c8:	4b69      	ldr	r3, [pc, #420]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008ca:	685b      	ldr	r3, [r3, #4]
 80008cc:	0adb      	lsrs	r3, r3, #11
 80008ce:	f003 0301 	and.w	r3, r3, #1
 80008d2:	429a      	cmp	r2, r3
 80008d4:	d01c      	beq.n	8000910 <ADCT_SYSTEM_FPT_CheckState_IO+0xa0>
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_SMOKE, GstSystemStatus.ioData.ucSmoke);
 80008d6:	4b65      	ldr	r3, [pc, #404]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80008d8:	7fdb      	ldrb	r3, [r3, #31]
 80008da:	2b00      	cmp	r3, #0
 80008dc:	d006      	beq.n	80008ec <ADCT_SYSTEM_FPT_CheckState_IO+0x7c>
 80008de:	4b64      	ldr	r3, [pc, #400]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008e0:	685b      	ldr	r3, [r3, #4]
 80008e2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80008e6:	4a62      	ldr	r2, [pc, #392]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008e8:	6053      	str	r3, [r2, #4]
 80008ea:	e005      	b.n	80008f8 <ADCT_SYSTEM_FPT_CheckState_IO+0x88>
 80008ec:	4b60      	ldr	r3, [pc, #384]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008ee:	685b      	ldr	r3, [r3, #4]
 80008f0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80008f4:	4a5e      	ldr	r2, [pc, #376]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80008f6:	6053      	str	r3, [r2, #4]
		if(GstSystemStatus.ioData.ucSmoke)
 80008f8:	4b5c      	ldr	r3, [pc, #368]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80008fa:	7fdb      	ldrb	r3, [r3, #31]
 80008fc:	2b00      	cmp	r3, #0
 80008fe:	d007      	beq.n	8000910 <ADCT_SYSTEM_FPT_CheckState_IO+0xa0>
		{
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000900:	4b5c      	ldr	r3, [pc, #368]	; (8000a74 <ADCT_SYSTEM_FPT_CheckState_IO+0x204>)
 8000902:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000904:	b2da      	uxtb	r2, r3
 8000906:	4b5c      	ldr	r3, [pc, #368]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000908:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 800090a:	4b5b      	ldr	r3, [pc, #364]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 800090c:	2201      	movs	r2, #1
 800090e:	72da      	strb	r2, [r3, #11]
			/* Set Log */

		}
	}
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
 8000910:	4b56      	ldr	r3, [pc, #344]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000912:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8000916:	2b00      	cmp	r3, #0
 8000918:	d113      	bne.n	8000942 <ADCT_SYSTEM_FPT_CheckState_IO+0xd2>
			GstSystemStatus.ioData.ucDoor[1] ||
 800091a:	4b54      	ldr	r3, [pc, #336]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 800091c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
			/* Set Log */

		}
	}
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
 8000920:	2b00      	cmp	r3, #0
 8000922:	d10e      	bne.n	8000942 <ADCT_SYSTEM_FPT_CheckState_IO+0xd2>
			GstSystemStatus.ioData.ucDoor[1] ||
			GstSystemStatus.ioData.ucDoor[2] ||
 8000924:	4b51      	ldr	r3, [pc, #324]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000926:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23

		}
	}
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
			GstSystemStatus.ioData.ucDoor[1] ||
 800092a:	2b00      	cmp	r3, #0
 800092c:	d109      	bne.n	8000942 <ADCT_SYSTEM_FPT_CheckState_IO+0xd2>
			GstSystemStatus.ioData.ucDoor[2] ||
			GstSystemStatus.ioData.ucDoor[3] ||
 800092e:	4b4f      	ldr	r3, [pc, #316]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000930:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
		}
	}
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
			GstSystemStatus.ioData.ucDoor[1] ||
			GstSystemStatus.ioData.ucDoor[2] ||
 8000934:	2b00      	cmp	r3, #0
 8000936:	d104      	bne.n	8000942 <ADCT_SYSTEM_FPT_CheckState_IO+0xd2>
			GstSystemStatus.ioData.ucDoor[3] ||
			GstSystemStatus.ioData.ucDoor[4]) &&
 8000938:	4b4c      	ldr	r3, [pc, #304]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 800093a:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
	}
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
			GstSystemStatus.ioData.ucDoor[1] ||
			GstSystemStatus.ioData.ucDoor[2] ||
			GstSystemStatus.ioData.ucDoor[3] ||
 800093e:	2b00      	cmp	r3, #0
 8000940:	d015      	beq.n	800096e <ADCT_SYSTEM_FPT_CheckState_IO+0xfe>
			GstSystemStatus.ioData.ucDoor[4]) &&
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_OFF))
 8000942:	4b4b      	ldr	r3, [pc, #300]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000944:	685b      	ldr	r3, [r3, #4]
 8000946:	0b1b      	lsrs	r3, r3, #12
 8000948:	f003 0301 	and.w	r3, r3, #1
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
			GstSystemStatus.ioData.ucDoor[1] ||
			GstSystemStatus.ioData.ucDoor[2] ||
			GstSystemStatus.ioData.ucDoor[3] ||
			GstSystemStatus.ioData.ucDoor[4]) &&
 800094c:	2b00      	cmp	r3, #0
 800094e:	d10e      	bne.n	800096e <ADCT_SYSTEM_FPT_CheckState_IO+0xfe>
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_DOOR, WARN_ON);
 8000950:	4b47      	ldr	r3, [pc, #284]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000952:	685b      	ldr	r3, [r3, #4]
 8000954:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000958:	4a45      	ldr	r2, [pc, #276]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 800095a:	6053      	str	r3, [r2, #4]
		/* Set Log */
		g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 800095c:	4b45      	ldr	r3, [pc, #276]	; (8000a74 <ADCT_SYSTEM_FPT_CheckState_IO+0x204>)
 800095e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000960:	b2da      	uxtb	r2, r3
 8000962:	4b45      	ldr	r3, [pc, #276]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000964:	731a      	strb	r2, [r3, #12]
		g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000966:	4b44      	ldr	r3, [pc, #272]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000968:	2201      	movs	r2, #1
 800096a:	72da      	strb	r2, [r3, #11]
 800096c:	e025      	b.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
 800096e:	4b3f      	ldr	r3, [pc, #252]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000970:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8000974:	2b00      	cmp	r3, #0
 8000976:	d120      	bne.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
 8000978:	4b3c      	ldr	r3, [pc, #240]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 800097a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
		WriteBit(GstSystemWarning.othWarn, WARN_DOOR, WARN_ON);
		/* Set Log */
		g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
		g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
 800097e:	2b00      	cmp	r3, #0
 8000980:	d11b      	bne.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
 8000982:	4b3a      	ldr	r3, [pc, #232]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000984:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
		/* Set Log */
		g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
		g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
 8000988:	2b00      	cmp	r3, #0
 800098a:	d116      	bne.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
			GstSystemStatus.ioData.ucDoor[3] == 0 &&
 800098c:	4b37      	ldr	r3, [pc, #220]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 800098e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
		g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
		g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
 8000992:	2b00      	cmp	r3, #0
 8000994:	d111      	bne.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
			GstSystemStatus.ioData.ucDoor[3] == 0 &&
			GstSystemStatus.ioData.ucDoor[4] == 0) &&
 8000996:	4b35      	ldr	r3, [pc, #212]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000998:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
		g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
			GstSystemStatus.ioData.ucDoor[3] == 0 &&
 800099c:	2b00      	cmp	r3, #0
 800099e:	d10c      	bne.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
			GstSystemStatus.ioData.ucDoor[4] == 0) &&
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON))
 80009a0:	4b33      	ldr	r3, [pc, #204]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009a2:	685b      	ldr	r3, [r3, #4]
 80009a4:	0b1b      	lsrs	r3, r3, #12
 80009a6:	f003 0301 	and.w	r3, r3, #1
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
			GstSystemStatus.ioData.ucDoor[3] == 0 &&
			GstSystemStatus.ioData.ucDoor[4] == 0) &&
 80009aa:	2b00      	cmp	r3, #0
 80009ac:	d005      	beq.n	80009ba <ADCT_SYSTEM_FPT_CheckState_IO+0x14a>
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_DOOR, WARN_OFF);
 80009ae:	4b30      	ldr	r3, [pc, #192]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009b0:	685b      	ldr	r3, [r3, #4]
 80009b2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80009b6:	4a2e      	ldr	r2, [pc, #184]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009b8:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}
	/* Burglar (SNMP_SYT_010) */
	if(GstSystemStatus.ioData.ucBurglar != (ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR)))
 80009ba:	4b2c      	ldr	r3, [pc, #176]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80009bc:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80009c0:	461a      	mov	r2, r3
 80009c2:	4b2b      	ldr	r3, [pc, #172]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009c4:	685b      	ldr	r3, [r3, #4]
 80009c6:	0b5b      	lsrs	r3, r3, #13
 80009c8:	f003 0301 	and.w	r3, r3, #1
 80009cc:	429a      	cmp	r2, r3
 80009ce:	d01e      	beq.n	8000a0e <ADCT_SYSTEM_FPT_CheckState_IO+0x19e>
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_BURGLAR, GstSystemStatus.ioData.ucBurglar);
 80009d0:	4b26      	ldr	r3, [pc, #152]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80009d2:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80009d6:	2b00      	cmp	r3, #0
 80009d8:	d006      	beq.n	80009e8 <ADCT_SYSTEM_FPT_CheckState_IO+0x178>
 80009da:	4b25      	ldr	r3, [pc, #148]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009dc:	685b      	ldr	r3, [r3, #4]
 80009de:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80009e2:	4a23      	ldr	r2, [pc, #140]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009e4:	6053      	str	r3, [r2, #4]
 80009e6:	e005      	b.n	80009f4 <ADCT_SYSTEM_FPT_CheckState_IO+0x184>
 80009e8:	4b21      	ldr	r3, [pc, #132]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009ea:	685b      	ldr	r3, [r3, #4]
 80009ec:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80009f0:	4a1f      	ldr	r2, [pc, #124]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 80009f2:	6053      	str	r3, [r2, #4]
		if(GstSystemStatus.ioData.ucBurglar)
 80009f4:	4b1d      	ldr	r3, [pc, #116]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 80009f6:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80009fa:	2b00      	cmp	r3, #0
 80009fc:	d007      	beq.n	8000a0e <ADCT_SYSTEM_FPT_CheckState_IO+0x19e>
		{
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 80009fe:	4b1d      	ldr	r3, [pc, #116]	; (8000a74 <ADCT_SYSTEM_FPT_CheckState_IO+0x204>)
 8000a00:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000a02:	b2da      	uxtb	r2, r3
 8000a04:	4b1c      	ldr	r3, [pc, #112]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000a06:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000a08:	4b1b      	ldr	r3, [pc, #108]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000a0a:	2201      	movs	r2, #1
 8000a0c:	72da      	strb	r2, [r3, #11]

		}
	}

	/* Water (SNMP_SYT_011) */
	if(GstSystemStatus.ioData.ucWater != (ReadBit(GstSystemWarning.othWarn, WARN_WATER)))
 8000a0e:	4b17      	ldr	r3, [pc, #92]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000a10:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000a14:	461a      	mov	r2, r3
 8000a16:	4b16      	ldr	r3, [pc, #88]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000a18:	685b      	ldr	r3, [r3, #4]
 8000a1a:	0b9b      	lsrs	r3, r3, #14
 8000a1c:	f003 0301 	and.w	r3, r3, #1
 8000a20:	429a      	cmp	r2, r3
 8000a22:	d01e      	beq.n	8000a62 <ADCT_SYSTEM_FPT_CheckState_IO+0x1f2>
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_WATER, GstSystemStatus.ioData.ucWater);
 8000a24:	4b11      	ldr	r3, [pc, #68]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000a26:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000a2a:	2b00      	cmp	r3, #0
 8000a2c:	d006      	beq.n	8000a3c <ADCT_SYSTEM_FPT_CheckState_IO+0x1cc>
 8000a2e:	4b10      	ldr	r3, [pc, #64]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000a30:	685b      	ldr	r3, [r3, #4]
 8000a32:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000a36:	4a0e      	ldr	r2, [pc, #56]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000a38:	6053      	str	r3, [r2, #4]
 8000a3a:	e005      	b.n	8000a48 <ADCT_SYSTEM_FPT_CheckState_IO+0x1d8>
 8000a3c:	4b0c      	ldr	r3, [pc, #48]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000a3e:	685b      	ldr	r3, [r3, #4]
 8000a40:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000a44:	4a0a      	ldr	r2, [pc, #40]	; (8000a70 <ADCT_SYSTEM_FPT_CheckState_IO+0x200>)
 8000a46:	6053      	str	r3, [r2, #4]
		if(GstSystemStatus.ioData.ucWater)
 8000a48:	4b08      	ldr	r3, [pc, #32]	; (8000a6c <ADCT_SYSTEM_FPT_CheckState_IO+0x1fc>)
 8000a4a:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000a4e:	2b00      	cmp	r3, #0
 8000a50:	d007      	beq.n	8000a62 <ADCT_SYSTEM_FPT_CheckState_IO+0x1f2>
		{
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000a52:	4b08      	ldr	r3, [pc, #32]	; (8000a74 <ADCT_SYSTEM_FPT_CheckState_IO+0x204>)
 8000a54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000a56:	b2da      	uxtb	r2, r3
 8000a58:	4b07      	ldr	r3, [pc, #28]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000a5a:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000a5c:	4b06      	ldr	r3, [pc, #24]	; (8000a78 <ADCT_SYSTEM_FPT_CheckState_IO+0x208>)
 8000a5e:	2201      	movs	r2, #1
 8000a60:	72da      	strb	r2, [r3, #11]
		{
			/* Set Log */

		}
	}
}
 8000a62:	bf00      	nop
 8000a64:	46bd      	mov	sp, r7
 8000a66:	bc80      	pop	{r7}
 8000a68:	4770      	bx	lr
 8000a6a:	bf00      	nop
 8000a6c:	20000250 	.word	0x20000250
 8000a70:	20000248 	.word	0x20000248
 8000a74:	20000204 	.word	0x20000204
 8000a78:	200001f4 	.word	0x200001f4

08000a7c <ADCT_SYSTEM_FPT_CheckState_DHT>:
 * @brief Check system state of DHT22.
 * @param None
 * @retval None
 */
void ADCT_SYSTEM_FPT_CheckState_DHT(void)
{
 8000a7c:	b480      	push	{r7}
 8000a7e:	af00      	add	r7, sp, #0
	/* Low Humidity (SNMP_SYT_005) */
	if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usLowHumidityH1) &&
 8000a80:	4b62      	ldr	r3, [pc, #392]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000a82:	8b1a      	ldrh	r2, [r3, #24]
 8000a84:	4b62      	ldr	r3, [pc, #392]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000a86:	88db      	ldrh	r3, [r3, #6]
 8000a88:	429a      	cmp	r2, r3
 8000a8a:	d20c      	bcs.n	8000aa6 <ADCT_SYSTEM_FPT_CheckState_DHT+0x2a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_OFF))
 8000a8c:	4b61      	ldr	r3, [pc, #388]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000a8e:	685b      	ldr	r3, [r3, #4]
 8000a90:	f003 0301 	and.w	r3, r3, #1
 * @retval None
 */
void ADCT_SYSTEM_FPT_CheckState_DHT(void)
{
	/* Low Humidity (SNMP_SYT_005) */
	if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usLowHumidityH1) &&
 8000a94:	2b00      	cmp	r3, #0
 8000a96:	d106      	bne.n	8000aa6 <ADCT_SYSTEM_FPT_CheckState_DHT+0x2a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_ON);
 8000a98:	4b5e      	ldr	r3, [pc, #376]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000a9a:	685b      	ldr	r3, [r3, #4]
 8000a9c:	f043 0301 	orr.w	r3, r3, #1
 8000aa0:	4a5c      	ldr	r2, [pc, #368]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000aa2:	6053      	str	r3, [r2, #4]
 8000aa4:	e011      	b.n	8000aca <ADCT_SYSTEM_FPT_CheckState_DHT+0x4e>
		/* Set Log */

	}
	else if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usLowHumidityH1) &&
 8000aa6:	4b59      	ldr	r3, [pc, #356]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000aa8:	8b1a      	ldrh	r2, [r3, #24]
 8000aaa:	4b59      	ldr	r3, [pc, #356]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000aac:	88db      	ldrh	r3, [r3, #6]
 8000aae:	429a      	cmp	r2, r3
 8000ab0:	d90b      	bls.n	8000aca <ADCT_SYSTEM_FPT_CheckState_DHT+0x4e>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON))
 8000ab2:	4b58      	ldr	r3, [pc, #352]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000ab4:	685b      	ldr	r3, [r3, #4]
 8000ab6:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usLowHumidityH1) &&
 8000aba:	2b00      	cmp	r3, #0
 8000abc:	d005      	beq.n	8000aca <ADCT_SYSTEM_FPT_CheckState_DHT+0x4e>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON))
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_OFF);
 8000abe:	4b55      	ldr	r3, [pc, #340]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000ac0:	685b      	ldr	r3, [r3, #4]
 8000ac2:	f023 0301 	bic.w	r3, r3, #1
 8000ac6:	4a53      	ldr	r2, [pc, #332]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000ac8:	6053      	str	r3, [r2, #4]
		/* Set Log */
	}

	/* High Humidity (SNMP_SYT_006) */
	if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usHighHumidityH2) &&
 8000aca:	4b50      	ldr	r3, [pc, #320]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000acc:	8b1a      	ldrh	r2, [r3, #24]
 8000ace:	4b50      	ldr	r3, [pc, #320]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000ad0:	891b      	ldrh	r3, [r3, #8]
 8000ad2:	429a      	cmp	r2, r3
 8000ad4:	d90d      	bls.n	8000af2 <ADCT_SYSTEM_FPT_CheckState_DHT+0x76>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_OFF))
 8000ad6:	4b4f      	ldr	r3, [pc, #316]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000ad8:	685b      	ldr	r3, [r3, #4]
 8000ada:	085b      	lsrs	r3, r3, #1
 8000adc:	f003 0301 	and.w	r3, r3, #1
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_OFF);
		/* Set Log */
	}

	/* High Humidity (SNMP_SYT_006) */
	if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usHighHumidityH2) &&
 8000ae0:	2b00      	cmp	r3, #0
 8000ae2:	d106      	bne.n	8000af2 <ADCT_SYSTEM_FPT_CheckState_DHT+0x76>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHHUMID, WARN_ON);
 8000ae4:	4b4b      	ldr	r3, [pc, #300]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000ae6:	685b      	ldr	r3, [r3, #4]
 8000ae8:	f043 0302 	orr.w	r3, r3, #2
 8000aec:	4a49      	ldr	r2, [pc, #292]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000aee:	6053      	str	r3, [r2, #4]
 8000af0:	e012      	b.n	8000b18 <ADCT_SYSTEM_FPT_CheckState_DHT+0x9c>
		/* Set Log */

	}
	else if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usHighHumidityH2) &&
 8000af2:	4b46      	ldr	r3, [pc, #280]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000af4:	8b1a      	ldrh	r2, [r3, #24]
 8000af6:	4b46      	ldr	r3, [pc, #280]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000af8:	891b      	ldrh	r3, [r3, #8]
 8000afa:	429a      	cmp	r2, r3
 8000afc:	d20c      	bcs.n	8000b18 <ADCT_SYSTEM_FPT_CheckState_DHT+0x9c>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON))
 8000afe:	4b45      	ldr	r3, [pc, #276]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b00:	685b      	ldr	r3, [r3, #4]
 8000b02:	085b      	lsrs	r3, r3, #1
 8000b04:	f003 0301 	and.w	r3, r3, #1
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHHUMID, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usHighHumidityH2) &&
 8000b08:	2b00      	cmp	r3, #0
 8000b0a:	d005      	beq.n	8000b18 <ADCT_SYSTEM_FPT_CheckState_DHT+0x9c>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON))
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHHUMID, WARN_OFF);
 8000b0c:	4b41      	ldr	r3, [pc, #260]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b0e:	685b      	ldr	r3, [r3, #4]
 8000b10:	f023 0302 	bic.w	r3, r3, #2
 8000b14:	4a3f      	ldr	r2, [pc, #252]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b16:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Temperature (SNMP_SYT_002) */
	if((GstSystemStatus.dhtData.usTemp_Main < GstSystemSetting.usLowTemperatureT1)&&
 8000b18:	4b3c      	ldr	r3, [pc, #240]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000b1a:	8ada      	ldrh	r2, [r3, #22]
 8000b1c:	4b3c      	ldr	r3, [pc, #240]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000b1e:	881b      	ldrh	r3, [r3, #0]
 8000b20:	429a      	cmp	r2, r3
 8000b22:	d210      	bcs.n	8000b46 <ADCT_SYSTEM_FPT_CheckState_DHT+0xca>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_OFF))
 8000b24:	4b3b      	ldr	r3, [pc, #236]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b26:	685b      	ldr	r3, [r3, #4]
 8000b28:	0c1b      	lsrs	r3, r3, #16
 8000b2a:	f003 0301 	and.w	r3, r3, #1
		/* Set Log */

	}

	/* Low Temperature (SNMP_SYT_002) */
	if((GstSystemStatus.dhtData.usTemp_Main < GstSystemSetting.usLowTemperatureT1)&&
 8000b2e:	2b00      	cmp	r3, #0
 8000b30:	d109      	bne.n	8000b46 <ADCT_SYSTEM_FPT_CheckState_DHT+0xca>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWTEMP, WARN_ON);
 8000b32:	4b38      	ldr	r3, [pc, #224]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b34:	685b      	ldr	r3, [r3, #4]
 8000b36:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000b3a:	4a36      	ldr	r2, [pc, #216]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b3c:	6053      	str	r3, [r2, #4]
		/* Set next state is LOW */
		GstSystemWarning.tempState.nextState = TEMP_MODE_LOW;
 8000b3e:	4b35      	ldr	r3, [pc, #212]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b40:	2201      	movs	r2, #1
 8000b42:	709a      	strb	r2, [r3, #2]
 8000b44:	e05e      	b.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
		/* Set Log */
		//ADCT_SDCARD_FPT_SetAlarmID(ALARM_LOW_TEMP_START);
	}
	else if((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1) &&
 8000b46:	4b31      	ldr	r3, [pc, #196]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000b48:	8ada      	ldrh	r2, [r3, #22]
 8000b4a:	4b31      	ldr	r3, [pc, #196]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000b4c:	881b      	ldrh	r3, [r3, #0]
 8000b4e:	429a      	cmp	r2, r3
 8000b50:	d320      	bcc.n	8000b94 <ADCT_SYSTEM_FPT_CheckState_DHT+0x118>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
 8000b52:	4b2e      	ldr	r3, [pc, #184]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000b54:	8ada      	ldrh	r2, [r3, #22]
 8000b56:	4b2e      	ldr	r3, [pc, #184]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000b58:	885b      	ldrh	r3, [r3, #2]
		/* Set next state is LOW */
		GstSystemWarning.tempState.nextState = TEMP_MODE_LOW;
		/* Set Log */
		//ADCT_SDCARD_FPT_SetAlarmID(ALARM_LOW_TEMP_START);
	}
	else if((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1) &&
 8000b5a:	429a      	cmp	r2, r3
 8000b5c:	d81a      	bhi.n	8000b94 <ADCT_SYSTEM_FPT_CheckState_DHT+0x118>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
	{
		/* Set next state is NORMAL */
		if(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON)
 8000b5e:	4b2d      	ldr	r3, [pc, #180]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b60:	685b      	ldr	r3, [r3, #4]
 8000b62:	0c1b      	lsrs	r3, r3, #16
 8000b64:	f003 0301 	and.w	r3, r3, #1
 8000b68:	2b00      	cmp	r3, #0
 8000b6a:	d005      	beq.n	8000b78 <ADCT_SYSTEM_FPT_CheckState_DHT+0xfc>
		{
		WriteBit(GstSystemWarning.othWarn, WARN_LOWTEMP, WARN_OFF);
 8000b6c:	4b29      	ldr	r3, [pc, #164]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b6e:	685b      	ldr	r3, [r3, #4]
 8000b70:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000b74:	4a27      	ldr	r2, [pc, #156]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b76:	6053      	str	r3, [r2, #4]
		/* Set log */
		}
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON)
 8000b78:	4b26      	ldr	r3, [pc, #152]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b7a:	685b      	ldr	r3, [r3, #4]
 8000b7c:	0bdb      	lsrs	r3, r3, #15
 8000b7e:	f003 0301 	and.w	r3, r3, #1
 8000b82:	2b00      	cmp	r3, #0
 8000b84:	d03e      	beq.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
		{

			WriteBit(GstSystemWarning.othWarn, WARN_HIGHTEMP, WARN_OFF);
 8000b86:	4b23      	ldr	r3, [pc, #140]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b88:	685b      	ldr	r3, [r3, #4]
 8000b8a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000b8e:	4a21      	ldr	r2, [pc, #132]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000b90:	6053      	str	r3, [r2, #4]
		if(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON)
		{
		WriteBit(GstSystemWarning.othWarn, WARN_LOWTEMP, WARN_OFF);
		/* Set log */
		}
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON)
 8000b92:	e037      	b.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
		}

	}

	/* High Temperature (SNMP_SYT_003) */
	else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 8000b94:	4b1d      	ldr	r3, [pc, #116]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000b96:	8ada      	ldrh	r2, [r3, #22]
 8000b98:	4b1d      	ldr	r3, [pc, #116]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000b9a:	885b      	ldrh	r3, [r3, #2]
 8000b9c:	429a      	cmp	r2, r3
 8000b9e:	d920      	bls.n	8000be2 <ADCT_SYSTEM_FPT_CheckState_DHT+0x166>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
 8000ba0:	4b1a      	ldr	r3, [pc, #104]	; (8000c0c <ADCT_SYSTEM_FPT_CheckState_DHT+0x190>)
 8000ba2:	8ada      	ldrh	r2, [r3, #22]
 8000ba4:	4b1a      	ldr	r3, [pc, #104]	; (8000c10 <ADCT_SYSTEM_FPT_CheckState_DHT+0x194>)
 8000ba6:	889b      	ldrh	r3, [r3, #4]
		}

	}

	/* High Temperature (SNMP_SYT_003) */
	else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 8000ba8:	429a      	cmp	r2, r3
 8000baa:	d81a      	bhi.n	8000be2 <ADCT_SYSTEM_FPT_CheckState_DHT+0x166>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
	{
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_OFF)
 8000bac:	4b19      	ldr	r3, [pc, #100]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bae:	685b      	ldr	r3, [r3, #4]
 8000bb0:	0bdb      	lsrs	r3, r3, #15
 8000bb2:	f003 0301 	and.w	r3, r3, #1
 8000bb6:	2b00      	cmp	r3, #0
 8000bb8:	d105      	bne.n	8000bc6 <ADCT_SYSTEM_FPT_CheckState_DHT+0x14a>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHTEMP, WARN_ON);
 8000bba:	4b16      	ldr	r3, [pc, #88]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bbc:	685b      	ldr	r3, [r3, #4]
 8000bbe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000bc2:	4a14      	ldr	r2, [pc, #80]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bc4:	6053      	str	r3, [r2, #4]
			/*Setlog*/
		}
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_ON)
 8000bc6:	4b13      	ldr	r3, [pc, #76]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bc8:	685b      	ldr	r3, [r3, #4]
 8000bca:	0c5b      	lsrs	r3, r3, #17
 8000bcc:	f003 0301 	and.w	r3, r3, #1
 8000bd0:	2b00      	cmp	r3, #0
 8000bd2:	d017      	beq.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP, WARN_OFF);
 8000bd4:	4b0f      	ldr	r3, [pc, #60]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bd6:	685b      	ldr	r3, [r3, #4]
 8000bd8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8000bdc:	4a0d      	ldr	r2, [pc, #52]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bde:	6053      	str	r3, [r2, #4]
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_OFF)
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHTEMP, WARN_ON);
			/*Setlog*/
		}
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_ON)
 8000be0:	e010      	b.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
	}
	/* Fan Temperature (SNMP_SYT_004) */
	else
	{
		/* Set next state is FAN */
		GstSystemWarning.tempState.nextState = TEMP_MODE_FAN;
 8000be2:	4b0c      	ldr	r3, [pc, #48]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000be4:	2203      	movs	r2, #3
 8000be6:	709a      	strb	r2, [r3, #2]
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_OFF)
 8000be8:	4b0a      	ldr	r3, [pc, #40]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bea:	685b      	ldr	r3, [r3, #4]
 8000bec:	0c5b      	lsrs	r3, r3, #17
 8000bee:	f003 0301 	and.w	r3, r3, #1
 8000bf2:	2b00      	cmp	r3, #0
 8000bf4:	d106      	bne.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP, WARN_ON);
 8000bf6:	4b07      	ldr	r3, [pc, #28]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000bf8:	685b      	ldr	r3, [r3, #4]
 8000bfa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000bfe:	4a05      	ldr	r2, [pc, #20]	; (8000c14 <ADCT_SYSTEM_FPT_CheckState_DHT+0x198>)
 8000c00:	6053      	str	r3, [r2, #4]
			/*Set log */
		}
	}

}
 8000c02:	e7ff      	b.n	8000c04 <ADCT_SYSTEM_FPT_CheckState_DHT+0x188>
 8000c04:	bf00      	nop
 8000c06:	46bd      	mov	sp, r7
 8000c08:	bc80      	pop	{r7}
 8000c0a:	4770      	bx	lr
 8000c0c:	20000250 	.word	0x20000250
 8000c10:	20000204 	.word	0x20000204
 8000c14:	20000248 	.word	0x20000248

08000c18 <ADCT_SystemFPT_CheckAlarm>:

uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
 8000c18:	b480      	push	{r7}
 8000c1a:	af00      	add	r7, sp, #0
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 8000c1c:	4b29      	ldr	r3, [pc, #164]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c1e:	685b      	ldr	r3, [r3, #4]
 8000c20:	0a9b      	lsrs	r3, r3, #10
 8000c22:	f003 0301 	and.w	r3, r3, #1

}

uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
	if(
 8000c26:	2b00      	cmp	r3, #0
 8000c28:	d144      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
 8000c2a:	4b26      	ldr	r3, [pc, #152]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c2c:	685b      	ldr	r3, [r3, #4]
 8000c2e:	0adb      	lsrs	r3, r3, #11
 8000c30:	f003 0301 	and.w	r3, r3, #1
}

uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 8000c34:	2b00      	cmp	r3, #0
 8000c36:	d13d      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
 8000c38:	4b22      	ldr	r3, [pc, #136]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c3a:	685b      	ldr	r3, [r3, #4]
 8000c3c:	0b1b      	lsrs	r3, r3, #12
 8000c3e:	f003 0301 	and.w	r3, r3, #1

uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
 8000c42:	2b00      	cmp	r3, #0
 8000c44:	d136      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
 8000c46:	4b1f      	ldr	r3, [pc, #124]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c48:	685b      	ldr	r3, [r3, #4]
 8000c4a:	0b5b      	lsrs	r3, r3, #13
 8000c4c:	f003 0301 	and.w	r3, r3, #1
uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
 8000c50:	2b00      	cmp	r3, #0
 8000c52:	d12f      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
 8000c54:	4b1b      	ldr	r3, [pc, #108]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c56:	685b      	ldr	r3, [r3, #4]
 8000c58:	0b9b      	lsrs	r3, r3, #14
 8000c5a:	f003 0301 	and.w	r3, r3, #1
{
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
 8000c5e:	2b00      	cmp	r3, #0
 8000c60:	d128      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
 8000c62:	4b18      	ldr	r3, [pc, #96]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c64:	685b      	ldr	r3, [r3, #4]
 8000c66:	f003 0301 	and.w	r3, r3, #1
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
 8000c6a:	2b00      	cmp	r3, #0
 8000c6c:	d122      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
 8000c6e:	4b15      	ldr	r3, [pc, #84]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c70:	685b      	ldr	r3, [r3, #4]
 8000c72:	085b      	lsrs	r3, r3, #1
 8000c74:	f003 0301 	and.w	r3, r3, #1
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
 8000c78:	2b00      	cmp	r3, #0
 8000c7a:	d11b      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON||
 8000c7c:	4b11      	ldr	r3, [pc, #68]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c7e:	685b      	ldr	r3, [r3, #4]
 8000c80:	091b      	lsrs	r3, r3, #4
 8000c82:	f003 0301 	and.w	r3, r3, #1
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
 8000c86:	2b00      	cmp	r3, #0
 8000c88:	d114      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON||
 8000c8a:	4b0e      	ldr	r3, [pc, #56]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c8c:	685b      	ldr	r3, [r3, #4]
 8000c8e:	0bdb      	lsrs	r3, r3, #15
 8000c90:	f003 0301 	and.w	r3, r3, #1
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON||
 8000c94:	2b00      	cmp	r3, #0
 8000c96:	d10d      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON||
 8000c98:	4b0a      	ldr	r3, [pc, #40]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000c9a:	685b      	ldr	r3, [r3, #4]
 8000c9c:	0c1b      	lsrs	r3, r3, #16
 8000c9e:	f003 0301 	and.w	r3, r3, #1
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON||
 8000ca2:	2b00      	cmp	r3, #0
 8000ca4:	d106      	bne.n	8000cb4 <ADCT_SystemFPT_CheckAlarm+0x9c>
			ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_ON
 8000ca6:	4b07      	ldr	r3, [pc, #28]	; (8000cc4 <ADCT_SystemFPT_CheckAlarm+0xac>)
 8000ca8:	685b      	ldr	r3, [r3, #4]
 8000caa:	0c5b      	lsrs	r3, r3, #17
 8000cac:	f003 0301 	and.w	r3, r3, #1
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON||
 8000cb0:	2b00      	cmp	r3, #0
 8000cb2:	d001      	beq.n	8000cb8 <ADCT_SystemFPT_CheckAlarm+0xa0>
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_ON
	)
	{
		return TRUE;
 8000cb4:	2301      	movs	r3, #1
 8000cb6:	e000      	b.n	8000cba <ADCT_SystemFPT_CheckAlarm+0xa2>
	}
	else
	{
		return FALSE;
 8000cb8:	2300      	movs	r3, #0
	}
}
 8000cba:	4618      	mov	r0, r3
 8000cbc:	46bd      	mov	sp, r7
 8000cbe:	bc80      	pop	{r7}
 8000cc0:	4770      	bx	lr
 8000cc2:	bf00      	nop
 8000cc4:	20000248 	.word	0x20000248

08000cc8 <ADCT_SystemFPT_CheckAlarm_Siren>:
uint8_t ADCT_SystemFPT_CheckAlarm_Siren(void)
{
 8000cc8:	b480      	push	{r7}
 8000cca:	af00      	add	r7, sp, #0
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 8000ccc:	4b14      	ldr	r3, [pc, #80]	; (8000d20 <ADCT_SystemFPT_CheckAlarm_Siren+0x58>)
 8000cce:	685b      	ldr	r3, [r3, #4]
 8000cd0:	0a9b      	lsrs	r3, r3, #10
 8000cd2:	f003 0301 	and.w	r3, r3, #1
 8000cd6:	2b00      	cmp	r3, #0
 8000cd8:	d11b      	bne.n	8000d12 <ADCT_SystemFPT_CheckAlarm_Siren+0x4a>
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON||
 8000cda:	4b11      	ldr	r3, [pc, #68]	; (8000d20 <ADCT_SystemFPT_CheckAlarm_Siren+0x58>)
 8000cdc:	685b      	ldr	r3, [r3, #4]
 8000cde:	0adb      	lsrs	r3, r3, #11
 8000ce0:	f003 0301 	and.w	r3, r3, #1
		return FALSE;
	}
}
uint8_t ADCT_SystemFPT_CheckAlarm_Siren(void)
{
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 8000ce4:	2b00      	cmp	r3, #0
 8000ce6:	d114      	bne.n	8000d12 <ADCT_SystemFPT_CheckAlarm_Siren+0x4a>
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON||
 8000ce8:	4b0d      	ldr	r3, [pc, #52]	; (8000d20 <ADCT_SystemFPT_CheckAlarm_Siren+0x58>)
 8000cea:	685b      	ldr	r3, [r3, #4]
 8000cec:	0b1b      	lsrs	r3, r3, #12
 8000cee:	f003 0301 	and.w	r3, r3, #1
	}
}
uint8_t ADCT_SystemFPT_CheckAlarm_Siren(void)
{
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON||
 8000cf2:	2b00      	cmp	r3, #0
 8000cf4:	d10d      	bne.n	8000d12 <ADCT_SystemFPT_CheckAlarm_Siren+0x4a>
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON||
 8000cf6:	4b0a      	ldr	r3, [pc, #40]	; (8000d20 <ADCT_SystemFPT_CheckAlarm_Siren+0x58>)
 8000cf8:	685b      	ldr	r3, [r3, #4]
 8000cfa:	0b5b      	lsrs	r3, r3, #13
 8000cfc:	f003 0301 	and.w	r3, r3, #1
}
uint8_t ADCT_SystemFPT_CheckAlarm_Siren(void)
{
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON||
 8000d00:	2b00      	cmp	r3, #0
 8000d02:	d106      	bne.n	8000d12 <ADCT_SystemFPT_CheckAlarm_Siren+0x4a>
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON
 8000d04:	4b06      	ldr	r3, [pc, #24]	; (8000d20 <ADCT_SystemFPT_CheckAlarm_Siren+0x58>)
 8000d06:	685b      	ldr	r3, [r3, #4]
 8000d08:	0b9b      	lsrs	r3, r3, #14
 8000d0a:	f003 0301 	and.w	r3, r3, #1
uint8_t ADCT_SystemFPT_CheckAlarm_Siren(void)
{
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON||
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON||
 8000d0e:	2b00      	cmp	r3, #0
 8000d10:	d001      	beq.n	8000d16 <ADCT_SystemFPT_CheckAlarm_Siren+0x4e>
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON
	)	{
		return TRUE;
 8000d12:	2301      	movs	r3, #1
 8000d14:	e000      	b.n	8000d18 <ADCT_SystemFPT_CheckAlarm_Siren+0x50>
	}
	else
	{

		return FALSE;
 8000d16:	2300      	movs	r3, #0
	}
}
 8000d18:	4618      	mov	r0, r3
 8000d1a:	46bd      	mov	sp, r7
 8000d1c:	bc80      	pop	{r7}
 8000d1e:	4770      	bx	lr
 8000d20:	20000248 	.word	0x20000248

08000d24 <ADCT_SystemFPT_RunOutput>:
void ADCT_SystemFPT_RunOutput(void)
{
 8000d24:	b580      	push	{r7, lr}
 8000d26:	b088      	sub	sp, #32
 8000d28:	af00      	add	r7, sp, #0
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON)
 8000d2a:	4b98      	ldr	r3, [pc, #608]	; (8000f8c <ADCT_SystemFPT_RunOutput+0x268>)
 8000d2c:	685b      	ldr	r3, [r3, #4]
 8000d2e:	0a9b      	lsrs	r3, r3, #10
 8000d30:	f003 0301 	and.w	r3, r3, #1
 8000d34:	2b00      	cmp	r3, #0
 8000d36:	d106      	bne.n	8000d46 <ADCT_SystemFPT_RunOutput+0x22>
 8000d38:	4b94      	ldr	r3, [pc, #592]	; (8000f8c <ADCT_SystemFPT_RunOutput+0x268>)
 8000d3a:	685b      	ldr	r3, [r3, #4]
 8000d3c:	0adb      	lsrs	r3, r3, #11
 8000d3e:	f003 0301 	and.w	r3, r3, #1
 8000d42:	2b00      	cmp	r3, #0
 8000d44:	d02a      	beq.n	8000d9c <ADCT_SystemFPT_RunOutput+0x78>
	{
		/* Off all AIR and FAN */
		ADCT_BGS_AIR_1_2_OFF();
 8000d46:	2140      	movs	r1, #64	; 0x40
 8000d48:	4891      	ldr	r0, [pc, #580]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d4a:	f003 facf 	bl	80042ec <GPIO_ResetBits>
 8000d4e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000d52:	4890      	ldr	r0, [pc, #576]	; (8000f94 <ADCT_SystemFPT_RunOutput+0x270>)
 8000d54:	f003 faca 	bl	80042ec <GPIO_ResetBits>
		ADCT_BGS_AIR_3_4_OFF();
 8000d58:	2180      	movs	r1, #128	; 0x80
 8000d5a:	488d      	ldr	r0, [pc, #564]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d5c:	f003 fac6 	bl	80042ec <GPIO_ResetBits>
 8000d60:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000d64:	488a      	ldr	r0, [pc, #552]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d66:	f003 fac1 	bl	80042ec <GPIO_ResetBits>
		g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = ADCT_FALSE;
 8000d6a:	4b8b      	ldr	r3, [pc, #556]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000d6c:	2200      	movs	r2, #0
 8000d6e:	701a      	strb	r2, [r3, #0]
		g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = ADCT_FALSE;
 8000d70:	4b89      	ldr	r3, [pc, #548]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000d72:	2200      	movs	r2, #0
 8000d74:	705a      	strb	r2, [r3, #1]
		ADCT_BGS_FAN_OFF();
 8000d76:	2104      	movs	r1, #4
 8000d78:	4885      	ldr	r0, [pc, #532]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d7a:	f003 fab7 	bl	80042ec <GPIO_ResetBits>
 8000d7e:	2108      	movs	r1, #8
 8000d80:	4883      	ldr	r0, [pc, #524]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d82:	f003 fab3 	bl	80042ec <GPIO_ResetBits>
 8000d86:	2110      	movs	r1, #16
 8000d88:	4881      	ldr	r0, [pc, #516]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d8a:	f003 faaf 	bl	80042ec <GPIO_ResetBits>
 8000d8e:	2120      	movs	r1, #32
 8000d90:	487f      	ldr	r0, [pc, #508]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000d92:	f003 faab 	bl	80042ec <GPIO_ResetBits>
		g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
 8000d96:	4b80      	ldr	r3, [pc, #512]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000d98:	2200      	movs	r2, #0
 8000d9a:	709a      	strb	r2, [r3, #2]
	}
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
 8000d9c:	4b7f      	ldr	r3, [pc, #508]	; (8000f9c <ADCT_SystemFPT_RunOutput+0x278>)
 8000d9e:	881a      	ldrh	r2, [r3, #0]
 8000da0:	4b7f      	ldr	r3, [pc, #508]	; (8000fa0 <ADCT_SystemFPT_RunOutput+0x27c>)
 8000da2:	895b      	ldrh	r3, [r3, #10]
 8000da4:	429a      	cmp	r2, r3
 8000da6:	d239      	bcs.n	8000e1c <ADCT_SystemFPT_RunOutput+0xf8>
			(GstSystemStatus.mbData.usCurrentGenVoltage != 0))
 8000da8:	4b7c      	ldr	r3, [pc, #496]	; (8000f9c <ADCT_SystemFPT_RunOutput+0x278>)
 8000daa:	889b      	ldrh	r3, [r3, #4]
		g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = ADCT_FALSE;
		g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = ADCT_FALSE;
		ADCT_BGS_FAN_OFF();
		g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
	}
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
 8000dac:	2b00      	cmp	r3, #0
 8000dae:	d035      	beq.n	8000e1c <ADCT_SystemFPT_RunOutput+0xf8>
			(GstSystemStatus.mbData.usCurrentGenVoltage != 0))
	{
		if(g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE == FALSE &&g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED == FALSE)
 8000db0:	4b79      	ldr	r3, [pc, #484]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000db2:	7a1b      	ldrb	r3, [r3, #8]
 8000db4:	2b00      	cmp	r3, #0
 8000db6:	d138      	bne.n	8000e2a <ADCT_SystemFPT_RunOutput+0x106>
 8000db8:	4b77      	ldr	r3, [pc, #476]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000dba:	7a5b      	ldrb	r3, [r3, #9]
 8000dbc:	2b00      	cmp	r3, #0
 8000dbe:	d134      	bne.n	8000e2a <ADCT_SystemFPT_RunOutput+0x106>
		{
			uint32_t temp_variable;
			temp_variable = GstSystemSetting.ulStayOffTime%3600 ;
 8000dc0:	4b77      	ldr	r3, [pc, #476]	; (8000fa0 <ADCT_SystemFPT_RunOutput+0x27c>)
 8000dc2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000dc4:	4a77      	ldr	r2, [pc, #476]	; (8000fa4 <ADCT_SystemFPT_RunOutput+0x280>)
 8000dc6:	fba2 1203 	umull	r1, r2, r2, r3
 8000dca:	0ad2      	lsrs	r2, r2, #11
 8000dcc:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8000dd0:	fb01 f202 	mul.w	r2, r1, r2
 8000dd4:	1a9b      	subs	r3, r3, r2
 8000dd6:	61fb      	str	r3, [r7, #28]
			g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE = TRUE;
 8000dd8:	4b6f      	ldr	r3, [pc, #444]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000dda:	2201      	movs	r2, #1
 8000ddc:	721a      	strb	r2, [r3, #8]
			g_ADCT_BGS_TimerManager.StayOffTimer.hour = GstSystemSetting.ulStayOffTime /3600;
 8000dde:	4b70      	ldr	r3, [pc, #448]	; (8000fa0 <ADCT_SystemFPT_RunOutput+0x27c>)
 8000de0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000de2:	4a70      	ldr	r2, [pc, #448]	; (8000fa4 <ADCT_SystemFPT_RunOutput+0x280>)
 8000de4:	fba2 2303 	umull	r2, r3, r2, r3
 8000de8:	0adb      	lsrs	r3, r3, #11
 8000dea:	b2da      	uxtb	r2, r3
 8000dec:	4b6e      	ldr	r3, [pc, #440]	; (8000fa8 <ADCT_SystemFPT_RunOutput+0x284>)
 8000dee:	725a      	strb	r2, [r3, #9]
			g_ADCT_BGS_TimerManager.StayOffTimer.minute = (uint8_t)(temp_variable/60);
 8000df0:	69fb      	ldr	r3, [r7, #28]
 8000df2:	4a6e      	ldr	r2, [pc, #440]	; (8000fac <ADCT_SystemFPT_RunOutput+0x288>)
 8000df4:	fba2 2303 	umull	r2, r3, r2, r3
 8000df8:	095b      	lsrs	r3, r3, #5
 8000dfa:	b2da      	uxtb	r2, r3
 8000dfc:	4b6a      	ldr	r3, [pc, #424]	; (8000fa8 <ADCT_SystemFPT_RunOutput+0x284>)
 8000dfe:	729a      	strb	r2, [r3, #10]
			g_ADCT_BGS_TimerManager.StayOffTimer.second = (uint8_t)(temp_variable%60);
 8000e00:	69f9      	ldr	r1, [r7, #28]
 8000e02:	4b6a      	ldr	r3, [pc, #424]	; (8000fac <ADCT_SystemFPT_RunOutput+0x288>)
 8000e04:	fba3 2301 	umull	r2, r3, r3, r1
 8000e08:	095a      	lsrs	r2, r3, #5
 8000e0a:	4613      	mov	r3, r2
 8000e0c:	011b      	lsls	r3, r3, #4
 8000e0e:	1a9b      	subs	r3, r3, r2
 8000e10:	009b      	lsls	r3, r3, #2
 8000e12:	1aca      	subs	r2, r1, r3
 8000e14:	b2d2      	uxtb	r2, r2
 8000e16:	4b64      	ldr	r3, [pc, #400]	; (8000fa8 <ADCT_SystemFPT_RunOutput+0x284>)
 8000e18:	72da      	strb	r2, [r3, #11]
		g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
	}
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
			(GstSystemStatus.mbData.usCurrentGenVoltage != 0))
	{
		if(g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE == FALSE &&g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED == FALSE)
 8000e1a:	e006      	b.n	8000e2a <ADCT_SystemFPT_RunOutput+0x106>
		}
	}
	else
	{
		//AC or gen recover
		g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED = FALSE;
 8000e1c:	4b5e      	ldr	r3, [pc, #376]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e1e:	2200      	movs	r2, #0
 8000e20:	725a      	strb	r2, [r3, #9]
		g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE = FALSE;
 8000e22:	4b5d      	ldr	r3, [pc, #372]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e24:	2200      	movs	r2, #0
 8000e26:	721a      	strb	r2, [r3, #8]
 8000e28:	e000      	b.n	8000e2c <ADCT_SystemFPT_RunOutput+0x108>
		g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
	}
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
			(GstSystemStatus.mbData.usCurrentGenVoltage != 0))
	{
		if(g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE == FALSE &&g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED == FALSE)
 8000e2a:	bf00      	nop
	{
		//AC or gen recover
		g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED = FALSE;
		g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE = FALSE;
	}
	if(g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED == TRUE)
 8000e2c:	4b5a      	ldr	r3, [pc, #360]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e2e:	7a5b      	ldrb	r3, [r3, #9]
 8000e30:	2b01      	cmp	r3, #1
 8000e32:	d118      	bne.n	8000e66 <ADCT_SystemFPT_RunOutput+0x142>
	{
		/* Off all AIR and FAN */
		ADCT_BGS_AIR_1_2_OFF();
 8000e34:	2140      	movs	r1, #64	; 0x40
 8000e36:	4856      	ldr	r0, [pc, #344]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000e38:	f003 fa58 	bl	80042ec <GPIO_ResetBits>
 8000e3c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000e40:	4854      	ldr	r0, [pc, #336]	; (8000f94 <ADCT_SystemFPT_RunOutput+0x270>)
 8000e42:	f003 fa53 	bl	80042ec <GPIO_ResetBits>
		ADCT_BGS_AIR_3_4_OFF();
 8000e46:	2180      	movs	r1, #128	; 0x80
 8000e48:	4851      	ldr	r0, [pc, #324]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000e4a:	f003 fa4f 	bl	80042ec <GPIO_ResetBits>
 8000e4e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000e52:	484f      	ldr	r0, [pc, #316]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000e54:	f003 fa4a 	bl	80042ec <GPIO_ResetBits>
		g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = ADCT_FALSE;
 8000e58:	4b4f      	ldr	r3, [pc, #316]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e5a:	2200      	movs	r2, #0
 8000e5c:	701a      	strb	r2, [r3, #0]
		g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = ADCT_FALSE;
 8000e5e:	4b4e      	ldr	r3, [pc, #312]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e60:	2200      	movs	r2, #0
 8000e62:	705a      	strb	r2, [r3, #1]
 8000e64:	e385      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
	}
	else
	{
		/* Low Temperature (SNMP_SYT_002) */
		if(GstSystemStatus.dhtData.usTemp_Main < GstSystemSetting.usLowTemperatureT1)
 8000e66:	4b4d      	ldr	r3, [pc, #308]	; (8000f9c <ADCT_SystemFPT_RunOutput+0x278>)
 8000e68:	8ada      	ldrh	r2, [r3, #22]
 8000e6a:	4b4d      	ldr	r3, [pc, #308]	; (8000fa0 <ADCT_SystemFPT_RunOutput+0x27c>)
 8000e6c:	881b      	ldrh	r3, [r3, #0]
 8000e6e:	429a      	cmp	r2, r3
 8000e70:	d268      	bcs.n	8000f44 <ADCT_SystemFPT_RunOutput+0x220>
		{
			// Detect if the t_min_timer is still running, if YES, output remains high
			if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE)
 8000e72:	4b49      	ldr	r3, [pc, #292]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e74:	795b      	ldrb	r3, [r3, #5]
 8000e76:	2b01      	cmp	r3, #1
 8000e78:	d10d      	bne.n	8000e96 <ADCT_SystemFPT_RunOutput+0x172>
 8000e7a:	4b47      	ldr	r3, [pc, #284]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000e7c:	781b      	ldrb	r3, [r3, #0]
 8000e7e:	2b00      	cmp	r3, #0
 8000e80:	d009      	beq.n	8000e96 <ADCT_SystemFPT_RunOutput+0x172>
			{
				ADCT_BGS_AIR_1_2_ON();
 8000e82:	2140      	movs	r1, #64	; 0x40
 8000e84:	4842      	ldr	r0, [pc, #264]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000e86:	f003 fa23 	bl	80042d0 <GPIO_SetBits>
 8000e8a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000e8e:	4841      	ldr	r0, [pc, #260]	; (8000f94 <ADCT_SystemFPT_RunOutput+0x270>)
 8000e90:	f003 fa1e 	bl	80042d0 <GPIO_SetBits>
 8000e94:	e00b      	b.n	8000eae <ADCT_SystemFPT_RunOutput+0x18a>
			}
			else
			{
				ADCT_BGS_AIR_1_2_OFF();
 8000e96:	2140      	movs	r1, #64	; 0x40
 8000e98:	483d      	ldr	r0, [pc, #244]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000e9a:	f003 fa27 	bl	80042ec <GPIO_ResetBits>
 8000e9e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000ea2:	483c      	ldr	r0, [pc, #240]	; (8000f94 <ADCT_SystemFPT_RunOutput+0x270>)
 8000ea4:	f003 fa22 	bl	80042ec <GPIO_ResetBits>
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = FALSE;
 8000ea8:	4b3b      	ldr	r3, [pc, #236]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000eaa:	2200      	movs	r2, #0
 8000eac:	701a      	strb	r2, [r3, #0]
			}
			// Detect if the t_min_timer is still running, if YES, output remains high
			if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE)
 8000eae:	4b3a      	ldr	r3, [pc, #232]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000eb0:	799b      	ldrb	r3, [r3, #6]
 8000eb2:	2b01      	cmp	r3, #1
 8000eb4:	d10d      	bne.n	8000ed2 <ADCT_SystemFPT_RunOutput+0x1ae>
 8000eb6:	4b38      	ldr	r3, [pc, #224]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000eb8:	785b      	ldrb	r3, [r3, #1]
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	d009      	beq.n	8000ed2 <ADCT_SystemFPT_RunOutput+0x1ae>
			{
				ADCT_BGS_AIR_3_4_ON();
 8000ebe:	2180      	movs	r1, #128	; 0x80
 8000ec0:	4833      	ldr	r0, [pc, #204]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000ec2:	f003 fa05 	bl	80042d0 <GPIO_SetBits>
 8000ec6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000eca:	4831      	ldr	r0, [pc, #196]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000ecc:	f003 fa00 	bl	80042d0 <GPIO_SetBits>
 8000ed0:	e00b      	b.n	8000eea <ADCT_SystemFPT_RunOutput+0x1c6>
			}
			else
			{
				ADCT_BGS_AIR_3_4_OFF();
 8000ed2:	2180      	movs	r1, #128	; 0x80
 8000ed4:	482e      	ldr	r0, [pc, #184]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000ed6:	f003 fa09 	bl	80042ec <GPIO_ResetBits>
 8000eda:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000ede:	482c      	ldr	r0, [pc, #176]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000ee0:	f003 fa04 	bl	80042ec <GPIO_ResetBits>
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
 8000ee4:	4b2c      	ldr	r3, [pc, #176]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000ee6:	2200      	movs	r2, #0
 8000ee8:	705a      	strb	r2, [r3, #1]
			}
			// Detect if the t_min_timer is still running, if YES, output remains high
			if(g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE)
 8000eea:	4b2b      	ldr	r3, [pc, #172]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000eec:	79db      	ldrb	r3, [r3, #7]
 8000eee:	2b01      	cmp	r3, #1
 8000ef0:	d114      	bne.n	8000f1c <ADCT_SystemFPT_RunOutput+0x1f8>
 8000ef2:	4b29      	ldr	r3, [pc, #164]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000ef4:	789b      	ldrb	r3, [r3, #2]
 8000ef6:	2b00      	cmp	r3, #0
 8000ef8:	d010      	beq.n	8000f1c <ADCT_SystemFPT_RunOutput+0x1f8>
			{
				ADCT_BGS_FAN_ON();
 8000efa:	2104      	movs	r1, #4
 8000efc:	4824      	ldr	r0, [pc, #144]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000efe:	f003 f9e7 	bl	80042d0 <GPIO_SetBits>
 8000f02:	2108      	movs	r1, #8
 8000f04:	4822      	ldr	r0, [pc, #136]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f06:	f003 f9e3 	bl	80042d0 <GPIO_SetBits>
 8000f0a:	2110      	movs	r1, #16
 8000f0c:	4820      	ldr	r0, [pc, #128]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f0e:	f003 f9df 	bl	80042d0 <GPIO_SetBits>
 8000f12:	2120      	movs	r1, #32
 8000f14:	481e      	ldr	r0, [pc, #120]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f16:	f003 f9db 	bl	80042d0 <GPIO_SetBits>
 8000f1a:	e32a      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
			}
			else
			{
				ADCT_BGS_FAN_OFF();
 8000f1c:	2104      	movs	r1, #4
 8000f1e:	481c      	ldr	r0, [pc, #112]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f20:	f003 f9e4 	bl	80042ec <GPIO_ResetBits>
 8000f24:	2108      	movs	r1, #8
 8000f26:	481a      	ldr	r0, [pc, #104]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f28:	f003 f9e0 	bl	80042ec <GPIO_ResetBits>
 8000f2c:	2110      	movs	r1, #16
 8000f2e:	4818      	ldr	r0, [pc, #96]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f30:	f003 f9dc 	bl	80042ec <GPIO_ResetBits>
 8000f34:	2120      	movs	r1, #32
 8000f36:	4816      	ldr	r0, [pc, #88]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f38:	f003 f9d8 	bl	80042ec <GPIO_ResetBits>
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
 8000f3c:	4b16      	ldr	r3, [pc, #88]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000f3e:	2200      	movs	r2, #0
 8000f40:	709a      	strb	r2, [r3, #2]
 8000f42:	e316      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
			}
		}
		else if ((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1 ) &&
 8000f44:	4b15      	ldr	r3, [pc, #84]	; (8000f9c <ADCT_SystemFPT_RunOutput+0x278>)
 8000f46:	8ada      	ldrh	r2, [r3, #22]
 8000f48:	4b15      	ldr	r3, [pc, #84]	; (8000fa0 <ADCT_SystemFPT_RunOutput+0x27c>)
 8000f4a:	881b      	ldrh	r3, [r3, #0]
 8000f4c:	429a      	cmp	r2, r3
 8000f4e:	f0c0 8123 	bcc.w	8001198 <ADCT_SystemFPT_RunOutput+0x474>
				(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
 8000f52:	4b12      	ldr	r3, [pc, #72]	; (8000f9c <ADCT_SystemFPT_RunOutput+0x278>)
 8000f54:	8ada      	ldrh	r2, [r3, #22]
 8000f56:	4b12      	ldr	r3, [pc, #72]	; (8000fa0 <ADCT_SystemFPT_RunOutput+0x27c>)
 8000f58:	885b      	ldrh	r3, [r3, #2]
			{
				ADCT_BGS_FAN_OFF();
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
			}
		}
		else if ((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1 ) &&
 8000f5a:	429a      	cmp	r2, r3
 8000f5c:	f200 811c 	bhi.w	8001198 <ADCT_SystemFPT_RunOutput+0x474>
				(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
		{
			if(g_ADCT_BGS_StateOutput.WITCH_AIR == TRUE)
 8000f60:	4b0d      	ldr	r3, [pc, #52]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000f62:	7a9b      	ldrb	r3, [r3, #10]
 8000f64:	2b01      	cmp	r3, #1
 8000f66:	d17e      	bne.n	8001066 <ADCT_SystemFPT_RunOutput+0x342>
			{
				// Detect if the t_min_timer is still running, if YES, output remains high
				if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == TRUE)
 8000f68:	4b0b      	ldr	r3, [pc, #44]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000f6a:	795b      	ldrb	r3, [r3, #5]
 8000f6c:	2b01      	cmp	r3, #1
 8000f6e:	d11f      	bne.n	8000fb0 <ADCT_SystemFPT_RunOutput+0x28c>
 8000f70:	4b09      	ldr	r3, [pc, #36]	; (8000f98 <ADCT_SystemFPT_RunOutput+0x274>)
 8000f72:	781b      	ldrb	r3, [r3, #0]
 8000f74:	2b01      	cmp	r3, #1
 8000f76:	d11b      	bne.n	8000fb0 <ADCT_SystemFPT_RunOutput+0x28c>
				{
					ADCT_BGS_AIR_1_2_ON();
 8000f78:	2140      	movs	r1, #64	; 0x40
 8000f7a:	4805      	ldr	r0, [pc, #20]	; (8000f90 <ADCT_SystemFPT_RunOutput+0x26c>)
 8000f7c:	f003 f9a8 	bl	80042d0 <GPIO_SetBits>
 8000f80:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000f84:	4803      	ldr	r0, [pc, #12]	; (8000f94 <ADCT_SystemFPT_RunOutput+0x270>)
 8000f86:	f003 f9a3 	bl	80042d0 <GPIO_SetBits>
 8000f8a:	e01d      	b.n	8000fc8 <ADCT_SystemFPT_RunOutput+0x2a4>
 8000f8c:	20000248 	.word	0x20000248
 8000f90:	40010800 	.word	0x40010800
 8000f94:	40011000 	.word	0x40011000
 8000f98:	200001f4 	.word	0x200001f4
 8000f9c:	20000250 	.word	0x20000250
 8000fa0:	20000204 	.word	0x20000204
 8000fa4:	91a2b3c5 	.word	0x91a2b3c5
 8000fa8:	200001e0 	.word	0x200001e0
 8000fac:	88888889 	.word	0x88888889
				}
				else
				{
					ADCT_BGS_AIR_1_2_OFF();
 8000fb0:	2140      	movs	r1, #64	; 0x40
 8000fb2:	48a1      	ldr	r0, [pc, #644]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8000fb4:	f003 f99a 	bl	80042ec <GPIO_ResetBits>
 8000fb8:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000fbc:	489f      	ldr	r0, [pc, #636]	; (800123c <ADCT_SystemFPT_RunOutput+0x518>)
 8000fbe:	f003 f995 	bl	80042ec <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = FALSE;
 8000fc2:	4b9f      	ldr	r3, [pc, #636]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8000fc4:	2200      	movs	r2, #0
 8000fc6:	701a      	strb	r2, [r3, #0]
				}
				// Detect if air 2 output just activate and run min_timer
				if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == TRUE)
 8000fc8:	4b9d      	ldr	r3, [pc, #628]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8000fca:	799b      	ldrb	r3, [r3, #6]
 8000fcc:	2b01      	cmp	r3, #1
 8000fce:	d13d      	bne.n	800104c <ADCT_SystemFPT_RunOutput+0x328>
 8000fd0:	4b9b      	ldr	r3, [pc, #620]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8000fd2:	785b      	ldrb	r3, [r3, #1]
 8000fd4:	2b01      	cmp	r3, #1
 8000fd6:	d139      	bne.n	800104c <ADCT_SystemFPT_RunOutput+0x328>
				{
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8000fd8:	4b9a      	ldr	r3, [pc, #616]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 8000fda:	6a1b      	ldr	r3, [r3, #32]
 8000fdc:	4a9a      	ldr	r2, [pc, #616]	; (8001248 <ADCT_SystemFPT_RunOutput+0x524>)
 8000fde:	fba2 1203 	umull	r1, r2, r2, r3
 8000fe2:	0ad2      	lsrs	r2, r2, #11
 8000fe4:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8000fe8:	fb01 f202 	mul.w	r2, r1, r2
 8000fec:	1a9b      	subs	r3, r3, r2
 8000fee:	61bb      	str	r3, [r7, #24]
					ADCT_BGS_AIR_3_4_ON();
 8000ff0:	2180      	movs	r1, #128	; 0x80
 8000ff2:	4891      	ldr	r0, [pc, #580]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8000ff4:	f003 f96c 	bl	80042d0 <GPIO_SetBits>
 8000ff8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000ffc:	488e      	ldr	r0, [pc, #568]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8000ffe:	f003 f967 	bl	80042d0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001002:	4b8f      	ldr	r3, [pc, #572]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001004:	2201      	movs	r2, #1
 8001006:	705a      	strb	r2, [r3, #1]
					g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = TRUE;
 8001008:	4b8d      	ldr	r3, [pc, #564]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 800100a:	2201      	movs	r2, #1
 800100c:	719a      	strb	r2, [r3, #6]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 800100e:	4b8d      	ldr	r3, [pc, #564]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 8001010:	6a1b      	ldr	r3, [r3, #32]
 8001012:	4a8d      	ldr	r2, [pc, #564]	; (8001248 <ADCT_SystemFPT_RunOutput+0x524>)
 8001014:	fba2 2303 	umull	r2, r3, r2, r3
 8001018:	0adb      	lsrs	r3, r3, #11
 800101a:	b2da      	uxtb	r2, r3
 800101c:	4b8b      	ldr	r3, [pc, #556]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 800101e:	719a      	strb	r2, [r3, #6]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
 8001020:	69bb      	ldr	r3, [r7, #24]
 8001022:	4a8b      	ldr	r2, [pc, #556]	; (8001250 <ADCT_SystemFPT_RunOutput+0x52c>)
 8001024:	fba2 2303 	umull	r2, r3, r2, r3
 8001028:	095b      	lsrs	r3, r3, #5
 800102a:	b2da      	uxtb	r2, r3
 800102c:	4b87      	ldr	r3, [pc, #540]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 800102e:	71da      	strb	r2, [r3, #7]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
 8001030:	69b9      	ldr	r1, [r7, #24]
 8001032:	4b87      	ldr	r3, [pc, #540]	; (8001250 <ADCT_SystemFPT_RunOutput+0x52c>)
 8001034:	fba3 2301 	umull	r2, r3, r3, r1
 8001038:	095a      	lsrs	r2, r3, #5
 800103a:	4613      	mov	r3, r2
 800103c:	011b      	lsls	r3, r3, #4
 800103e:	1a9b      	subs	r3, r3, r2
 8001040:	009b      	lsls	r3, r3, #2
 8001042:	1aca      	subs	r2, r1, r3
 8001044:	b2d2      	uxtb	r2, r2
 8001046:	4b81      	ldr	r3, [pc, #516]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 8001048:	721a      	strb	r2, [r3, #8]
					ADCT_BGS_AIR_1_2_OFF();
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = FALSE;
				}
				// Detect if air 2 output just activate and run min_timer
				if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == TRUE)
				{
 800104a:	e078      	b.n	800113e <ADCT_SystemFPT_RunOutput+0x41a>
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
				}
				else
				{
					ADCT_BGS_AIR_3_4_OFF();
 800104c:	2180      	movs	r1, #128	; 0x80
 800104e:	487a      	ldr	r0, [pc, #488]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001050:	f003 f94c 	bl	80042ec <GPIO_ResetBits>
 8001054:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001058:	4877      	ldr	r0, [pc, #476]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800105a:	f003 f947 	bl	80042ec <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
 800105e:	4b78      	ldr	r3, [pc, #480]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001060:	2200      	movs	r2, #0
 8001062:	705a      	strb	r2, [r3, #1]
 8001064:	e06b      	b.n	800113e <ADCT_SystemFPT_RunOutput+0x41a>
				}
			}
			else
			{
				if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE ==FALSE )
 8001066:	4b76      	ldr	r3, [pc, #472]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001068:	795b      	ldrb	r3, [r3, #5]
 800106a:	2b00      	cmp	r3, #0
 800106c:	d13d      	bne.n	80010ea <ADCT_SystemFPT_RunOutput+0x3c6>
 800106e:	4b74      	ldr	r3, [pc, #464]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001070:	781b      	ldrb	r3, [r3, #0]
 8001072:	2b00      	cmp	r3, #0
 8001074:	d139      	bne.n	80010ea <ADCT_SystemFPT_RunOutput+0x3c6>
				{
					ADCT_BGS_AIR_1_2_ON();
 8001076:	2140      	movs	r1, #64	; 0x40
 8001078:	486f      	ldr	r0, [pc, #444]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800107a:	f003 f929 	bl	80042d0 <GPIO_SetBits>
 800107e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001082:	486e      	ldr	r0, [pc, #440]	; (800123c <ADCT_SystemFPT_RunOutput+0x518>)
 8001084:	f003 f924 	bl	80042d0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 8001088:	4b6d      	ldr	r3, [pc, #436]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 800108a:	2201      	movs	r2, #1
 800108c:	701a      	strb	r2, [r3, #0]
					g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = TRUE;
 800108e:	4b6c      	ldr	r3, [pc, #432]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001090:	2201      	movs	r2, #1
 8001092:	715a      	strb	r2, [r3, #5]
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001094:	4b6b      	ldr	r3, [pc, #428]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 8001096:	6a1b      	ldr	r3, [r3, #32]
 8001098:	4a6b      	ldr	r2, [pc, #428]	; (8001248 <ADCT_SystemFPT_RunOutput+0x524>)
 800109a:	fba2 1203 	umull	r1, r2, r2, r3
 800109e:	0ad2      	lsrs	r2, r2, #11
 80010a0:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80010a4:	fb01 f202 	mul.w	r2, r1, r2
 80010a8:	1a9b      	subs	r3, r3, r2
 80010aa:	617b      	str	r3, [r7, #20]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80010ac:	4b65      	ldr	r3, [pc, #404]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 80010ae:	6a1b      	ldr	r3, [r3, #32]
 80010b0:	4a65      	ldr	r2, [pc, #404]	; (8001248 <ADCT_SystemFPT_RunOutput+0x524>)
 80010b2:	fba2 2303 	umull	r2, r3, r2, r3
 80010b6:	0adb      	lsrs	r3, r3, #11
 80010b8:	b2da      	uxtb	r2, r3
 80010ba:	4b64      	ldr	r3, [pc, #400]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 80010bc:	70da      	strb	r2, [r3, #3]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
 80010be:	697b      	ldr	r3, [r7, #20]
 80010c0:	4a63      	ldr	r2, [pc, #396]	; (8001250 <ADCT_SystemFPT_RunOutput+0x52c>)
 80010c2:	fba2 2303 	umull	r2, r3, r2, r3
 80010c6:	095b      	lsrs	r3, r3, #5
 80010c8:	b2da      	uxtb	r2, r3
 80010ca:	4b60      	ldr	r3, [pc, #384]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 80010cc:	711a      	strb	r2, [r3, #4]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
 80010ce:	6979      	ldr	r1, [r7, #20]
 80010d0:	4b5f      	ldr	r3, [pc, #380]	; (8001250 <ADCT_SystemFPT_RunOutput+0x52c>)
 80010d2:	fba3 2301 	umull	r2, r3, r3, r1
 80010d6:	095a      	lsrs	r2, r3, #5
 80010d8:	4613      	mov	r3, r2
 80010da:	011b      	lsls	r3, r3, #4
 80010dc:	1a9b      	subs	r3, r3, r2
 80010de:	009b      	lsls	r3, r3, #2
 80010e0:	1aca      	subs	r2, r1, r3
 80010e2:	b2d2      	uxtb	r2, r2
 80010e4:	4b59      	ldr	r3, [pc, #356]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 80010e6:	715a      	strb	r2, [r3, #5]
				}
			}
			else
			{
				if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE ==FALSE )
				{
 80010e8:	e00b      	b.n	8001102 <ADCT_SystemFPT_RunOutput+0x3de>
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;

				}
				else
				{
					ADCT_BGS_AIR_1_2_ON();
 80010ea:	2140      	movs	r1, #64	; 0x40
 80010ec:	4852      	ldr	r0, [pc, #328]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 80010ee:	f003 f8ef 	bl	80042d0 <GPIO_SetBits>
 80010f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80010f6:	4851      	ldr	r0, [pc, #324]	; (800123c <ADCT_SystemFPT_RunOutput+0x518>)
 80010f8:	f003 f8ea 	bl	80042d0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 80010fc:	4b50      	ldr	r3, [pc, #320]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 80010fe:	2201      	movs	r2, #1
 8001100:	701a      	strb	r2, [r3, #0]
				}
				// Detect if the t_min_timer is still running, if YES, output remains high
				if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == TRUE)
 8001102:	4b4f      	ldr	r3, [pc, #316]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001104:	799b      	ldrb	r3, [r3, #6]
 8001106:	2b01      	cmp	r3, #1
 8001108:	d10d      	bne.n	8001126 <ADCT_SystemFPT_RunOutput+0x402>
 800110a:	4b4d      	ldr	r3, [pc, #308]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 800110c:	785b      	ldrb	r3, [r3, #1]
 800110e:	2b01      	cmp	r3, #1
 8001110:	d109      	bne.n	8001126 <ADCT_SystemFPT_RunOutput+0x402>
				{
					ADCT_BGS_AIR_3_4_ON();
 8001112:	2180      	movs	r1, #128	; 0x80
 8001114:	4848      	ldr	r0, [pc, #288]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001116:	f003 f8db 	bl	80042d0 <GPIO_SetBits>
 800111a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800111e:	4846      	ldr	r0, [pc, #280]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001120:	f003 f8d6 	bl	80042d0 <GPIO_SetBits>
 8001124:	e00b      	b.n	800113e <ADCT_SystemFPT_RunOutput+0x41a>
				}
				else
				{
					ADCT_BGS_AIR_3_4_OFF();
 8001126:	2180      	movs	r1, #128	; 0x80
 8001128:	4843      	ldr	r0, [pc, #268]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800112a:	f003 f8df 	bl	80042ec <GPIO_ResetBits>
 800112e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001132:	4841      	ldr	r0, [pc, #260]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001134:	f003 f8da 	bl	80042ec <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
 8001138:	4b41      	ldr	r3, [pc, #260]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 800113a:	2200      	movs	r2, #0
 800113c:	705a      	strb	r2, [r3, #1]
				}
			}

			if(g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE)
 800113e:	4b40      	ldr	r3, [pc, #256]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001140:	79db      	ldrb	r3, [r3, #7]
 8001142:	2b01      	cmp	r3, #1
 8001144:	d114      	bne.n	8001170 <ADCT_SystemFPT_RunOutput+0x44c>
 8001146:	4b3e      	ldr	r3, [pc, #248]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001148:	789b      	ldrb	r3, [r3, #2]
 800114a:	2b01      	cmp	r3, #1
 800114c:	d110      	bne.n	8001170 <ADCT_SystemFPT_RunOutput+0x44c>
			{
				ADCT_BGS_FAN_ON();
 800114e:	2104      	movs	r1, #4
 8001150:	4839      	ldr	r0, [pc, #228]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001152:	f003 f8bd 	bl	80042d0 <GPIO_SetBits>
 8001156:	2108      	movs	r1, #8
 8001158:	4837      	ldr	r0, [pc, #220]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800115a:	f003 f8b9 	bl	80042d0 <GPIO_SetBits>
 800115e:	2110      	movs	r1, #16
 8001160:	4835      	ldr	r0, [pc, #212]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001162:	f003 f8b5 	bl	80042d0 <GPIO_SetBits>
 8001166:	2120      	movs	r1, #32
 8001168:	4833      	ldr	r0, [pc, #204]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800116a:	f003 f8b1 	bl	80042d0 <GPIO_SetBits>
					ADCT_BGS_AIR_3_4_OFF();
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
				}
			}

			if(g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE)
 800116e:	e200      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
			{
				ADCT_BGS_FAN_ON();
			}
			else
			{
				ADCT_BGS_FAN_OFF();
 8001170:	2104      	movs	r1, #4
 8001172:	4831      	ldr	r0, [pc, #196]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001174:	f003 f8ba 	bl	80042ec <GPIO_ResetBits>
 8001178:	2108      	movs	r1, #8
 800117a:	482f      	ldr	r0, [pc, #188]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800117c:	f003 f8b6 	bl	80042ec <GPIO_ResetBits>
 8001180:	2110      	movs	r1, #16
 8001182:	482d      	ldr	r0, [pc, #180]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 8001184:	f003 f8b2 	bl	80042ec <GPIO_ResetBits>
 8001188:	2120      	movs	r1, #32
 800118a:	482b      	ldr	r0, [pc, #172]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 800118c:	f003 f8ae 	bl	80042ec <GPIO_ResetBits>
				g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE = FALSE;
 8001190:	4b2b      	ldr	r3, [pc, #172]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 8001192:	2200      	movs	r2, #0
 8001194:	70da      	strb	r2, [r3, #3]
					ADCT_BGS_AIR_3_4_OFF();
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
				}
			}

			if(g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE)
 8001196:	e1ec      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
				ADCT_BGS_FAN_OFF();
				g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE = FALSE;
			}
		}
		/* High Temperature (SNMP_SYT_003) */
		else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 8001198:	4b2e      	ldr	r3, [pc, #184]	; (8001254 <ADCT_SystemFPT_RunOutput+0x530>)
 800119a:	8ada      	ldrh	r2, [r3, #22]
 800119c:	4b29      	ldr	r3, [pc, #164]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 800119e:	885b      	ldrh	r3, [r3, #2]
 80011a0:	429a      	cmp	r2, r3
 80011a2:	f240 80e0 	bls.w	8001366 <ADCT_SystemFPT_RunOutput+0x642>
				(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
 80011a6:	4b2b      	ldr	r3, [pc, #172]	; (8001254 <ADCT_SystemFPT_RunOutput+0x530>)
 80011a8:	8ada      	ldrh	r2, [r3, #22]
 80011aa:	4b26      	ldr	r3, [pc, #152]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 80011ac:	889b      	ldrh	r3, [r3, #4]
				ADCT_BGS_FAN_OFF();
				g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE = FALSE;
			}
		}
		/* High Temperature (SNMP_SYT_003) */
		else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 80011ae:	429a      	cmp	r2, r3
 80011b0:	f200 80d9 	bhi.w	8001366 <ADCT_SystemFPT_RunOutput+0x642>
				(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
		{
			// Detect if air 1 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 80011b4:	4b22      	ldr	r3, [pc, #136]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 80011b6:	795b      	ldrb	r3, [r3, #5]
 80011b8:	2b00      	cmp	r3, #0
 80011ba:	d14d      	bne.n	8001258 <ADCT_SystemFPT_RunOutput+0x534>
 80011bc:	4b20      	ldr	r3, [pc, #128]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 80011be:	781b      	ldrb	r3, [r3, #0]
 80011c0:	2b00      	cmp	r3, #0
 80011c2:	d149      	bne.n	8001258 <ADCT_SystemFPT_RunOutput+0x534>
				ADCT_BGS_AIR_1_2_ON();
 80011c4:	2140      	movs	r1, #64	; 0x40
 80011c6:	481c      	ldr	r0, [pc, #112]	; (8001238 <ADCT_SystemFPT_RunOutput+0x514>)
 80011c8:	f003 f882 	bl	80042d0 <GPIO_SetBits>
 80011cc:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80011d0:	481a      	ldr	r0, [pc, #104]	; (800123c <ADCT_SystemFPT_RunOutput+0x518>)
 80011d2:	f003 f87d 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 80011d6:	4b1a      	ldr	r3, [pc, #104]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 80011d8:	2201      	movs	r2, #1
 80011da:	701a      	strb	r2, [r3, #0]
				g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = TRUE;
 80011dc:	4b18      	ldr	r3, [pc, #96]	; (8001240 <ADCT_SystemFPT_RunOutput+0x51c>)
 80011de:	2201      	movs	r2, #1
 80011e0:	715a      	strb	r2, [r3, #5]
				uint32_t temp_variable;
				temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 80011e2:	4b18      	ldr	r3, [pc, #96]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 80011e4:	6a1b      	ldr	r3, [r3, #32]
 80011e6:	4a18      	ldr	r2, [pc, #96]	; (8001248 <ADCT_SystemFPT_RunOutput+0x524>)
 80011e8:	fba2 1203 	umull	r1, r2, r2, r3
 80011ec:	0ad2      	lsrs	r2, r2, #11
 80011ee:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80011f2:	fb01 f202 	mul.w	r2, r1, r2
 80011f6:	1a9b      	subs	r3, r3, r2
 80011f8:	613b      	str	r3, [r7, #16]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80011fa:	4b12      	ldr	r3, [pc, #72]	; (8001244 <ADCT_SystemFPT_RunOutput+0x520>)
 80011fc:	6a1b      	ldr	r3, [r3, #32]
 80011fe:	4a12      	ldr	r2, [pc, #72]	; (8001248 <ADCT_SystemFPT_RunOutput+0x524>)
 8001200:	fba2 2303 	umull	r2, r3, r2, r3
 8001204:	0adb      	lsrs	r3, r3, #11
 8001206:	b2da      	uxtb	r2, r3
 8001208:	4b10      	ldr	r3, [pc, #64]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 800120a:	70da      	strb	r2, [r3, #3]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
 800120c:	693b      	ldr	r3, [r7, #16]
 800120e:	4a10      	ldr	r2, [pc, #64]	; (8001250 <ADCT_SystemFPT_RunOutput+0x52c>)
 8001210:	fba2 2303 	umull	r2, r3, r2, r3
 8001214:	095b      	lsrs	r3, r3, #5
 8001216:	b2da      	uxtb	r2, r3
 8001218:	4b0c      	ldr	r3, [pc, #48]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 800121a:	711a      	strb	r2, [r3, #4]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
 800121c:	6939      	ldr	r1, [r7, #16]
 800121e:	4b0c      	ldr	r3, [pc, #48]	; (8001250 <ADCT_SystemFPT_RunOutput+0x52c>)
 8001220:	fba3 2301 	umull	r2, r3, r3, r1
 8001224:	095a      	lsrs	r2, r3, #5
 8001226:	4613      	mov	r3, r2
 8001228:	011b      	lsls	r3, r3, #4
 800122a:	1a9b      	subs	r3, r3, r2
 800122c:	009b      	lsls	r3, r3, #2
 800122e:	1aca      	subs	r2, r1, r3
 8001230:	b2d2      	uxtb	r2, r2
 8001232:	4b06      	ldr	r3, [pc, #24]	; (800124c <ADCT_SystemFPT_RunOutput+0x528>)
 8001234:	715a      	strb	r2, [r3, #5]
		/* High Temperature (SNMP_SYT_003) */
		else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
				(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
		{
			// Detect if air 1 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 8001236:	e01b      	b.n	8001270 <ADCT_SystemFPT_RunOutput+0x54c>
 8001238:	40010800 	.word	0x40010800
 800123c:	40011000 	.word	0x40011000
 8001240:	200001f4 	.word	0x200001f4
 8001244:	20000204 	.word	0x20000204
 8001248:	91a2b3c5 	.word	0x91a2b3c5
 800124c:	200001e0 	.word	0x200001e0
 8001250:	88888889 	.word	0x88888889
 8001254:	20000250 	.word	0x20000250
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
			}
			else {
				ADCT_BGS_AIR_1_2_ON();
 8001258:	2140      	movs	r1, #64	; 0x40
 800125a:	48b5      	ldr	r0, [pc, #724]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 800125c:	f003 f838 	bl	80042d0 <GPIO_SetBits>
 8001260:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001264:	48b3      	ldr	r0, [pc, #716]	; (8001534 <ADCT_SystemFPT_RunOutput+0x810>)
 8001266:	f003 f833 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 800126a:	4bb3      	ldr	r3, [pc, #716]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800126c:	2201      	movs	r2, #1
 800126e:	701a      	strb	r2, [r3, #0]
			}

			// Detect if air 2 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 8001270:	4bb1      	ldr	r3, [pc, #708]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001272:	799b      	ldrb	r3, [r3, #6]
 8001274:	2b00      	cmp	r3, #0
 8001276:	d13d      	bne.n	80012f4 <ADCT_SystemFPT_RunOutput+0x5d0>
 8001278:	4baf      	ldr	r3, [pc, #700]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800127a:	785b      	ldrb	r3, [r3, #1]
 800127c:	2b00      	cmp	r3, #0
 800127e:	d139      	bne.n	80012f4 <ADCT_SystemFPT_RunOutput+0x5d0>
				ADCT_BGS_AIR_3_4_ON();
 8001280:	2180      	movs	r1, #128	; 0x80
 8001282:	48ab      	ldr	r0, [pc, #684]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001284:	f003 f824 	bl	80042d0 <GPIO_SetBits>
 8001288:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800128c:	48a8      	ldr	r0, [pc, #672]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 800128e:	f003 f81f 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001292:	4ba9      	ldr	r3, [pc, #676]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001294:	2201      	movs	r2, #1
 8001296:	705a      	strb	r2, [r3, #1]
				g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = TRUE;
 8001298:	4ba7      	ldr	r3, [pc, #668]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800129a:	2201      	movs	r2, #1
 800129c:	719a      	strb	r2, [r3, #6]
				uint32_t temp_variable;
				temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 800129e:	4ba7      	ldr	r3, [pc, #668]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 80012a0:	6a1b      	ldr	r3, [r3, #32]
 80012a2:	4aa7      	ldr	r2, [pc, #668]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 80012a4:	fba2 1203 	umull	r1, r2, r2, r3
 80012a8:	0ad2      	lsrs	r2, r2, #11
 80012aa:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80012ae:	fb01 f202 	mul.w	r2, r1, r2
 80012b2:	1a9b      	subs	r3, r3, r2
 80012b4:	60fb      	str	r3, [r7, #12]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80012b6:	4ba1      	ldr	r3, [pc, #644]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 80012b8:	6a1b      	ldr	r3, [r3, #32]
 80012ba:	4aa1      	ldr	r2, [pc, #644]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 80012bc:	fba2 2303 	umull	r2, r3, r2, r3
 80012c0:	0adb      	lsrs	r3, r3, #11
 80012c2:	b2da      	uxtb	r2, r3
 80012c4:	4b9f      	ldr	r3, [pc, #636]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 80012c6:	719a      	strb	r2, [r3, #6]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
 80012c8:	68fb      	ldr	r3, [r7, #12]
 80012ca:	4a9f      	ldr	r2, [pc, #636]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 80012cc:	fba2 2303 	umull	r2, r3, r2, r3
 80012d0:	095b      	lsrs	r3, r3, #5
 80012d2:	b2da      	uxtb	r2, r3
 80012d4:	4b9b      	ldr	r3, [pc, #620]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 80012d6:	71da      	strb	r2, [r3, #7]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
 80012d8:	68f9      	ldr	r1, [r7, #12]
 80012da:	4b9b      	ldr	r3, [pc, #620]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 80012dc:	fba3 2301 	umull	r2, r3, r3, r1
 80012e0:	095a      	lsrs	r2, r3, #5
 80012e2:	4613      	mov	r3, r2
 80012e4:	011b      	lsls	r3, r3, #4
 80012e6:	1a9b      	subs	r3, r3, r2
 80012e8:	009b      	lsls	r3, r3, #2
 80012ea:	1aca      	subs	r2, r1, r3
 80012ec:	b2d2      	uxtb	r2, r2
 80012ee:	4b95      	ldr	r3, [pc, #596]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 80012f0:	721a      	strb	r2, [r3, #8]
				ADCT_BGS_AIR_1_2_ON();
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
			}

			// Detect if air 2 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 80012f2:	e00b      	b.n	800130c <ADCT_SystemFPT_RunOutput+0x5e8>
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
			}
			else {
				ADCT_BGS_AIR_3_4_ON();
 80012f4:	2180      	movs	r1, #128	; 0x80
 80012f6:	488e      	ldr	r0, [pc, #568]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 80012f8:	f002 ffea 	bl	80042d0 <GPIO_SetBits>
 80012fc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001300:	488b      	ldr	r0, [pc, #556]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001302:	f002 ffe5 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001306:	4b8c      	ldr	r3, [pc, #560]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001308:	2201      	movs	r2, #1
 800130a:	705a      	strb	r2, [r3, #1]
			}

			// Detect if the t_min_timer is still running, if YES, output remains high
			if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE) {
 800130c:	4b8a      	ldr	r3, [pc, #552]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800130e:	79db      	ldrb	r3, [r3, #7]
 8001310:	2b01      	cmp	r3, #1
 8001312:	d114      	bne.n	800133e <ADCT_SystemFPT_RunOutput+0x61a>
 8001314:	4b88      	ldr	r3, [pc, #544]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001316:	789b      	ldrb	r3, [r3, #2]
 8001318:	2b01      	cmp	r3, #1
 800131a:	d110      	bne.n	800133e <ADCT_SystemFPT_RunOutput+0x61a>
				ADCT_BGS_FAN_ON();
 800131c:	2104      	movs	r1, #4
 800131e:	4884      	ldr	r0, [pc, #528]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001320:	f002 ffd6 	bl	80042d0 <GPIO_SetBits>
 8001324:	2108      	movs	r1, #8
 8001326:	4882      	ldr	r0, [pc, #520]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001328:	f002 ffd2 	bl	80042d0 <GPIO_SetBits>
 800132c:	2110      	movs	r1, #16
 800132e:	4880      	ldr	r0, [pc, #512]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001330:	f002 ffce 	bl	80042d0 <GPIO_SetBits>
 8001334:	2120      	movs	r1, #32
 8001336:	487e      	ldr	r0, [pc, #504]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001338:	f002 ffca 	bl	80042d0 <GPIO_SetBits>
				ADCT_BGS_AIR_3_4_ON();
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
			}

			// Detect if the t_min_timer is still running, if YES, output remains high
			if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE) {
 800133c:	e119      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
				ADCT_BGS_FAN_ON();
			}
			else {
				ADCT_BGS_FAN_OFF();
 800133e:	2104      	movs	r1, #4
 8001340:	487b      	ldr	r0, [pc, #492]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001342:	f002 ffd3 	bl	80042ec <GPIO_ResetBits>
 8001346:	2108      	movs	r1, #8
 8001348:	4879      	ldr	r0, [pc, #484]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 800134a:	f002 ffcf 	bl	80042ec <GPIO_ResetBits>
 800134e:	2110      	movs	r1, #16
 8001350:	4877      	ldr	r0, [pc, #476]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001352:	f002 ffcb 	bl	80042ec <GPIO_ResetBits>
 8001356:	2120      	movs	r1, #32
 8001358:	4875      	ldr	r0, [pc, #468]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 800135a:	f002 ffc7 	bl	80042ec <GPIO_ResetBits>
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
 800135e:	4b76      	ldr	r3, [pc, #472]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001360:	2200      	movs	r2, #0
 8001362:	709a      	strb	r2, [r3, #2]
				ADCT_BGS_AIR_3_4_ON();
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
			}

			// Detect if the t_min_timer is still running, if YES, output remains high
			if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE) {
 8001364:	e105      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
		}
		else
			/* Fan Temperature (SNMP_SYT_004) */
		{
			// Detect if air 1 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 8001366:	4b74      	ldr	r3, [pc, #464]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001368:	795b      	ldrb	r3, [r3, #5]
 800136a:	2b00      	cmp	r3, #0
 800136c:	d13d      	bne.n	80013ea <ADCT_SystemFPT_RunOutput+0x6c6>
 800136e:	4b72      	ldr	r3, [pc, #456]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001370:	781b      	ldrb	r3, [r3, #0]
 8001372:	2b00      	cmp	r3, #0
 8001374:	d139      	bne.n	80013ea <ADCT_SystemFPT_RunOutput+0x6c6>
				ADCT_BGS_AIR_1_2_ON();
 8001376:	2140      	movs	r1, #64	; 0x40
 8001378:	486d      	ldr	r0, [pc, #436]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 800137a:	f002 ffa9 	bl	80042d0 <GPIO_SetBits>
 800137e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001382:	486c      	ldr	r0, [pc, #432]	; (8001534 <ADCT_SystemFPT_RunOutput+0x810>)
 8001384:	f002 ffa4 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 8001388:	4b6b      	ldr	r3, [pc, #428]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800138a:	2201      	movs	r2, #1
 800138c:	701a      	strb	r2, [r3, #0]
				g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = TRUE;
 800138e:	4b6a      	ldr	r3, [pc, #424]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001390:	2201      	movs	r2, #1
 8001392:	715a      	strb	r2, [r3, #5]
				uint32_t temp_variable;
				temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001394:	4b69      	ldr	r3, [pc, #420]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 8001396:	6a1b      	ldr	r3, [r3, #32]
 8001398:	4a69      	ldr	r2, [pc, #420]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 800139a:	fba2 1203 	umull	r1, r2, r2, r3
 800139e:	0ad2      	lsrs	r2, r2, #11
 80013a0:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80013a4:	fb01 f202 	mul.w	r2, r1, r2
 80013a8:	1a9b      	subs	r3, r3, r2
 80013aa:	60bb      	str	r3, [r7, #8]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80013ac:	4b63      	ldr	r3, [pc, #396]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 80013ae:	6a1b      	ldr	r3, [r3, #32]
 80013b0:	4a63      	ldr	r2, [pc, #396]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 80013b2:	fba2 2303 	umull	r2, r3, r2, r3
 80013b6:	0adb      	lsrs	r3, r3, #11
 80013b8:	b2da      	uxtb	r2, r3
 80013ba:	4b62      	ldr	r3, [pc, #392]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 80013bc:	70da      	strb	r2, [r3, #3]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
 80013be:	68bb      	ldr	r3, [r7, #8]
 80013c0:	4a61      	ldr	r2, [pc, #388]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 80013c2:	fba2 2303 	umull	r2, r3, r2, r3
 80013c6:	095b      	lsrs	r3, r3, #5
 80013c8:	b2da      	uxtb	r2, r3
 80013ca:	4b5e      	ldr	r3, [pc, #376]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 80013cc:	711a      	strb	r2, [r3, #4]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
 80013ce:	68b9      	ldr	r1, [r7, #8]
 80013d0:	4b5d      	ldr	r3, [pc, #372]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 80013d2:	fba3 2301 	umull	r2, r3, r3, r1
 80013d6:	095a      	lsrs	r2, r3, #5
 80013d8:	4613      	mov	r3, r2
 80013da:	011b      	lsls	r3, r3, #4
 80013dc:	1a9b      	subs	r3, r3, r2
 80013de:	009b      	lsls	r3, r3, #2
 80013e0:	1aca      	subs	r2, r1, r3
 80013e2:	b2d2      	uxtb	r2, r2
 80013e4:	4b57      	ldr	r3, [pc, #348]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 80013e6:	715a      	strb	r2, [r3, #5]
		}
		else
			/* Fan Temperature (SNMP_SYT_004) */
		{
			// Detect if air 1 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 80013e8:	e00b      	b.n	8001402 <ADCT_SystemFPT_RunOutput+0x6de>
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
			}
			else {
				ADCT_BGS_AIR_1_2_ON();
 80013ea:	2140      	movs	r1, #64	; 0x40
 80013ec:	4850      	ldr	r0, [pc, #320]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 80013ee:	f002 ff6f 	bl	80042d0 <GPIO_SetBits>
 80013f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013f6:	484f      	ldr	r0, [pc, #316]	; (8001534 <ADCT_SystemFPT_RunOutput+0x810>)
 80013f8:	f002 ff6a 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 80013fc:	4b4e      	ldr	r3, [pc, #312]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 80013fe:	2201      	movs	r2, #1
 8001400:	701a      	strb	r2, [r3, #0]
			}

			// Detect if air 2 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 8001402:	4b4d      	ldr	r3, [pc, #308]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001404:	799b      	ldrb	r3, [r3, #6]
 8001406:	2b00      	cmp	r3, #0
 8001408:	d13d      	bne.n	8001486 <ADCT_SystemFPT_RunOutput+0x762>
 800140a:	4b4b      	ldr	r3, [pc, #300]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800140c:	785b      	ldrb	r3, [r3, #1]
 800140e:	2b00      	cmp	r3, #0
 8001410:	d139      	bne.n	8001486 <ADCT_SystemFPT_RunOutput+0x762>
				ADCT_BGS_AIR_3_4_ON();
 8001412:	2180      	movs	r1, #128	; 0x80
 8001414:	4846      	ldr	r0, [pc, #280]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001416:	f002 ff5b 	bl	80042d0 <GPIO_SetBits>
 800141a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800141e:	4844      	ldr	r0, [pc, #272]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001420:	f002 ff56 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001424:	4b44      	ldr	r3, [pc, #272]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 8001426:	2201      	movs	r2, #1
 8001428:	705a      	strb	r2, [r3, #1]
				g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = TRUE;
 800142a:	4b43      	ldr	r3, [pc, #268]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800142c:	2201      	movs	r2, #1
 800142e:	719a      	strb	r2, [r3, #6]
				uint32_t temp_variable;
				temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001430:	4b42      	ldr	r3, [pc, #264]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 8001432:	6a1b      	ldr	r3, [r3, #32]
 8001434:	4a42      	ldr	r2, [pc, #264]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 8001436:	fba2 1203 	umull	r1, r2, r2, r3
 800143a:	0ad2      	lsrs	r2, r2, #11
 800143c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8001440:	fb01 f202 	mul.w	r2, r1, r2
 8001444:	1a9b      	subs	r3, r3, r2
 8001446:	607b      	str	r3, [r7, #4]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 8001448:	4b3c      	ldr	r3, [pc, #240]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 800144a:	6a1b      	ldr	r3, [r3, #32]
 800144c:	4a3c      	ldr	r2, [pc, #240]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 800144e:	fba2 2303 	umull	r2, r3, r2, r3
 8001452:	0adb      	lsrs	r3, r3, #11
 8001454:	b2da      	uxtb	r2, r3
 8001456:	4b3b      	ldr	r3, [pc, #236]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 8001458:	719a      	strb	r2, [r3, #6]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
 800145a:	687b      	ldr	r3, [r7, #4]
 800145c:	4a3a      	ldr	r2, [pc, #232]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 800145e:	fba2 2303 	umull	r2, r3, r2, r3
 8001462:	095b      	lsrs	r3, r3, #5
 8001464:	b2da      	uxtb	r2, r3
 8001466:	4b37      	ldr	r3, [pc, #220]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 8001468:	71da      	strb	r2, [r3, #7]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
 800146a:	6879      	ldr	r1, [r7, #4]
 800146c:	4b36      	ldr	r3, [pc, #216]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 800146e:	fba3 2301 	umull	r2, r3, r3, r1
 8001472:	095a      	lsrs	r2, r3, #5
 8001474:	4613      	mov	r3, r2
 8001476:	011b      	lsls	r3, r3, #4
 8001478:	1a9b      	subs	r3, r3, r2
 800147a:	009b      	lsls	r3, r3, #2
 800147c:	1aca      	subs	r2, r1, r3
 800147e:	b2d2      	uxtb	r2, r2
 8001480:	4b30      	ldr	r3, [pc, #192]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 8001482:	721a      	strb	r2, [r3, #8]
				ADCT_BGS_AIR_1_2_ON();
				g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
			}

			// Detect if air 2 output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 8001484:	e00b      	b.n	800149e <ADCT_SystemFPT_RunOutput+0x77a>
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
			}
			else {
				ADCT_BGS_AIR_3_4_ON();
 8001486:	2180      	movs	r1, #128	; 0x80
 8001488:	4829      	ldr	r0, [pc, #164]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 800148a:	f002 ff21 	bl	80042d0 <GPIO_SetBits>
 800148e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001492:	4827      	ldr	r0, [pc, #156]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 8001494:	f002 ff1c 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001498:	4b27      	ldr	r3, [pc, #156]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 800149a:	2201      	movs	r2, #1
 800149c:	705a      	strb	r2, [r3, #1]
			}

			// Detect if a fan output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == FALSE) {
 800149e:	4b26      	ldr	r3, [pc, #152]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 80014a0:	79db      	ldrb	r3, [r3, #7]
 80014a2:	2b00      	cmp	r3, #0
 80014a4:	d152      	bne.n	800154c <ADCT_SystemFPT_RunOutput+0x828>
 80014a6:	4b24      	ldr	r3, [pc, #144]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 80014a8:	789b      	ldrb	r3, [r3, #2]
 80014aa:	2b00      	cmp	r3, #0
 80014ac:	d14e      	bne.n	800154c <ADCT_SystemFPT_RunOutput+0x828>
				ADCT_BGS_FAN_ON();
 80014ae:	2104      	movs	r1, #4
 80014b0:	481f      	ldr	r0, [pc, #124]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 80014b2:	f002 ff0d 	bl	80042d0 <GPIO_SetBits>
 80014b6:	2108      	movs	r1, #8
 80014b8:	481d      	ldr	r0, [pc, #116]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 80014ba:	f002 ff09 	bl	80042d0 <GPIO_SetBits>
 80014be:	2110      	movs	r1, #16
 80014c0:	481b      	ldr	r0, [pc, #108]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 80014c2:	f002 ff05 	bl	80042d0 <GPIO_SetBits>
 80014c6:	2120      	movs	r1, #32
 80014c8:	4819      	ldr	r0, [pc, #100]	; (8001530 <ADCT_SystemFPT_RunOutput+0x80c>)
 80014ca:	f002 ff01 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = TRUE;
 80014ce:	4b1a      	ldr	r3, [pc, #104]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 80014d0:	2201      	movs	r2, #1
 80014d2:	709a      	strb	r2, [r3, #2]
				g_ADCT_BGS_StateOutput.FAN_TIMER_STATE = TRUE;
 80014d4:	4b18      	ldr	r3, [pc, #96]	; (8001538 <ADCT_SystemFPT_RunOutput+0x814>)
 80014d6:	2201      	movs	r2, #1
 80014d8:	71da      	strb	r2, [r3, #7]
				uint32_t temp_variable;
				temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 80014da:	4b18      	ldr	r3, [pc, #96]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 80014dc:	6a1b      	ldr	r3, [r3, #32]
 80014de:	4a18      	ldr	r2, [pc, #96]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 80014e0:	fba2 1203 	umull	r1, r2, r2, r3
 80014e4:	0ad2      	lsrs	r2, r2, #11
 80014e6:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80014ea:	fb01 f202 	mul.w	r2, r1, r2
 80014ee:	1a9b      	subs	r3, r3, r2
 80014f0:	603b      	str	r3, [r7, #0]
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80014f2:	4b12      	ldr	r3, [pc, #72]	; (800153c <ADCT_SystemFPT_RunOutput+0x818>)
 80014f4:	6a1b      	ldr	r3, [r3, #32]
 80014f6:	4a12      	ldr	r2, [pc, #72]	; (8001540 <ADCT_SystemFPT_RunOutput+0x81c>)
 80014f8:	fba2 2303 	umull	r2, r3, r2, r3
 80014fc:	0adb      	lsrs	r3, r3, #11
 80014fe:	b2da      	uxtb	r2, r3
 8001500:	4b10      	ldr	r3, [pc, #64]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 8001502:	73da      	strb	r2, [r3, #15]
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute = temp_variable/60;
 8001504:	683b      	ldr	r3, [r7, #0]
 8001506:	4a10      	ldr	r2, [pc, #64]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 8001508:	fba2 2303 	umull	r2, r3, r2, r3
 800150c:	095b      	lsrs	r3, r3, #5
 800150e:	b2da      	uxtb	r2, r3
 8001510:	4b0c      	ldr	r3, [pc, #48]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 8001512:	741a      	strb	r2, [r3, #16]
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = temp_variable%60;
 8001514:	6839      	ldr	r1, [r7, #0]
 8001516:	4b0c      	ldr	r3, [pc, #48]	; (8001548 <ADCT_SystemFPT_RunOutput+0x824>)
 8001518:	fba3 2301 	umull	r2, r3, r3, r1
 800151c:	095a      	lsrs	r2, r3, #5
 800151e:	4613      	mov	r3, r2
 8001520:	011b      	lsls	r3, r3, #4
 8001522:	1a9b      	subs	r3, r3, r2
 8001524:	009b      	lsls	r3, r3, #2
 8001526:	1aca      	subs	r2, r1, r3
 8001528:	b2d2      	uxtb	r2, r2
 800152a:	4b06      	ldr	r3, [pc, #24]	; (8001544 <ADCT_SystemFPT_RunOutput+0x820>)
 800152c:	745a      	strb	r2, [r3, #17]
				ADCT_BGS_AIR_3_4_ON();
				g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
			}

			// Detect if a fan output just activate and run min_timer
			if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == FALSE) {
 800152e:	e020      	b.n	8001572 <ADCT_SystemFPT_RunOutput+0x84e>
 8001530:	40010800 	.word	0x40010800
 8001534:	40011000 	.word	0x40011000
 8001538:	200001f4 	.word	0x200001f4
 800153c:	20000204 	.word	0x20000204
 8001540:	91a2b3c5 	.word	0x91a2b3c5
 8001544:	200001e0 	.word	0x200001e0
 8001548:	88888889 	.word	0x88888889
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.hour = GstSystemSetting.ulMinSwitchingTime/3600;
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute = temp_variable/60;
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = temp_variable%60;
			}
			else {
				ADCT_BGS_FAN_ON();
 800154c:	2104      	movs	r1, #4
 800154e:	483d      	ldr	r0, [pc, #244]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001550:	f002 febe 	bl	80042d0 <GPIO_SetBits>
 8001554:	2108      	movs	r1, #8
 8001556:	483b      	ldr	r0, [pc, #236]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001558:	f002 feba 	bl	80042d0 <GPIO_SetBits>
 800155c:	2110      	movs	r1, #16
 800155e:	4839      	ldr	r0, [pc, #228]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001560:	f002 feb6 	bl	80042d0 <GPIO_SetBits>
 8001564:	2120      	movs	r1, #32
 8001566:	4837      	ldr	r0, [pc, #220]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001568:	f002 feb2 	bl	80042d0 <GPIO_SetBits>
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = TRUE;
 800156c:	4b36      	ldr	r3, [pc, #216]	; (8001648 <ADCT_SystemFPT_RunOutput+0x924>)
 800156e:	2201      	movs	r2, #1
 8001570:	709a      	strb	r2, [r3, #2]
			}
		}
	}
	// Lamp alarm
	if (ADCT_SystemFPT_CheckAlarm()) {
 8001572:	f7ff fb51 	bl	8000c18 <ADCT_SystemFPT_CheckAlarm>
 8001576:	4603      	mov	r3, r0
 8001578:	2b00      	cmp	r3, #0
 800157a:	d005      	beq.n	8001588 <ADCT_SystemFPT_RunOutput+0x864>
		ADCT_BGS_RELAY_LAMP_ON();
 800157c:	2201      	movs	r2, #1
 800157e:	2101      	movs	r1, #1
 8001580:	4830      	ldr	r0, [pc, #192]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001582:	f002 fec1 	bl	8004308 <GPIO_WriteBit>
 8001586:	e004      	b.n	8001592 <ADCT_SystemFPT_RunOutput+0x86e>
	}
	else {
		ADCT_BGS_RELAY_LAMP_OFF();
 8001588:	2200      	movs	r2, #0
 800158a:	2101      	movs	r1, #1
 800158c:	482d      	ldr	r0, [pc, #180]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 800158e:	f002 febb 	bl	8004308 <GPIO_WriteBit>
	}

	// Siren alarm
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
 8001592:	4b2e      	ldr	r3, [pc, #184]	; (800164c <ADCT_SystemFPT_RunOutput+0x928>)
 8001594:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8001598:	2b00      	cmp	r3, #0
 800159a:	d105      	bne.n	80015a8 <ADCT_SystemFPT_RunOutput+0x884>
		ADCT_BGS_RELAY_BUZZER_OFF();
 800159c:	2200      	movs	r2, #0
 800159e:	2102      	movs	r1, #2
 80015a0:	4828      	ldr	r0, [pc, #160]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 80015a2:	f002 feb1 	bl	8004308 <GPIO_WriteBit>
		}
		else {
			ADCT_BGS_RELAY_BUZZER_OFF();
		}
	}
}
 80015a6:	e049      	b.n	800163c <ADCT_SystemFPT_RunOutput+0x918>
	// Siren alarm
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
 80015a8:	4b27      	ldr	r3, [pc, #156]	; (8001648 <ADCT_SystemFPT_RunOutput+0x924>)
 80015aa:	78db      	ldrb	r3, [r3, #3]
 80015ac:	2b01      	cmp	r3, #1
 80015ae:	d13e      	bne.n	800162e <ADCT_SystemFPT_RunOutput+0x90a>
 80015b0:	f7ff fb8a 	bl	8000cc8 <ADCT_SystemFPT_CheckAlarm_Siren>
 80015b4:	4603      	mov	r3, r0
 80015b6:	2b00      	cmp	r3, #0
 80015b8:	d039      	beq.n	800162e <ADCT_SystemFPT_RunOutput+0x90a>
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 80015ba:	4b25      	ldr	r3, [pc, #148]	; (8001650 <ADCT_SystemFPT_RunOutput+0x92c>)
 80015bc:	685b      	ldr	r3, [r3, #4]
 80015be:	0a9b      	lsrs	r3, r3, #10
 80015c0:	f003 0301 	and.w	r3, r3, #1
 80015c4:	2b00      	cmp	r3, #0
 80015c6:	d10d      	bne.n	80015e4 <ADCT_SystemFPT_RunOutput+0x8c0>
				ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == TRUE||
 80015c8:	4b21      	ldr	r3, [pc, #132]	; (8001650 <ADCT_SystemFPT_RunOutput+0x92c>)
 80015ca:	685b      	ldr	r3, [r3, #4]
 80015cc:	0adb      	lsrs	r3, r3, #11
 80015ce:	f003 0301 	and.w	r3, r3, #1
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 80015d2:	2b00      	cmp	r3, #0
 80015d4:	d106      	bne.n	80015e4 <ADCT_SystemFPT_RunOutput+0x8c0>
				ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == TRUE||
				ReadBit(GstSystemWarning.othWarn, WARN_WATER) == TRUE) {
 80015d6:	4b1e      	ldr	r3, [pc, #120]	; (8001650 <ADCT_SystemFPT_RunOutput+0x92c>)
 80015d8:	685b      	ldr	r3, [r3, #4]
 80015da:	0b9b      	lsrs	r3, r3, #14
 80015dc:	f003 0301 	and.w	r3, r3, #1
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
				ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == TRUE||
 80015e0:	2b00      	cmp	r3, #0
 80015e2:	d005      	beq.n	80015f0 <ADCT_SystemFPT_RunOutput+0x8cc>
				ReadBit(GstSystemWarning.othWarn, WARN_WATER) == TRUE) {
				ADCT_BGS_RELAY_BUZZER_ON();
 80015e4:	2201      	movs	r2, #1
 80015e6:	2102      	movs	r1, #2
 80015e8:	4816      	ldr	r0, [pc, #88]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 80015ea:	f002 fe8d 	bl	8004308 <GPIO_WriteBit>
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 80015ee:	e024      	b.n	800163a <ADCT_SystemFPT_RunOutput+0x916>
				ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == TRUE||
				ReadBit(GstSystemWarning.othWarn, WARN_WATER) == TRUE) {
				ADCT_BGS_RELAY_BUZZER_ON();
			}
			else if (ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON  || ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON) {
 80015f0:	4b17      	ldr	r3, [pc, #92]	; (8001650 <ADCT_SystemFPT_RunOutput+0x92c>)
 80015f2:	685b      	ldr	r3, [r3, #4]
 80015f4:	0b1b      	lsrs	r3, r3, #12
 80015f6:	f003 0301 	and.w	r3, r3, #1
 80015fa:	2b00      	cmp	r3, #0
 80015fc:	d106      	bne.n	800160c <ADCT_SystemFPT_RunOutput+0x8e8>
 80015fe:	4b14      	ldr	r3, [pc, #80]	; (8001650 <ADCT_SystemFPT_RunOutput+0x92c>)
 8001600:	685b      	ldr	r3, [r3, #4]
 8001602:	0b5b      	lsrs	r3, r3, #13
 8001604:	f003 0301 	and.w	r3, r3, #1
 8001608:	2b00      	cmp	r3, #0
 800160a:	d016      	beq.n	800163a <ADCT_SystemFPT_RunOutput+0x916>
				if (GstSystemSetting.ucDoorBurglarEnableAlarm == TRUE) {
 800160c:	4b0f      	ldr	r3, [pc, #60]	; (800164c <ADCT_SystemFPT_RunOutput+0x928>)
 800160e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8001612:	2b01      	cmp	r3, #1
 8001614:	d105      	bne.n	8001622 <ADCT_SystemFPT_RunOutput+0x8fe>
					ADCT_BGS_RELAY_BUZZER_ON();
 8001616:	2201      	movs	r2, #1
 8001618:	2102      	movs	r1, #2
 800161a:	480a      	ldr	r0, [pc, #40]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 800161c:	f002 fe74 	bl	8004308 <GPIO_WriteBit>
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 8001620:	e00b      	b.n	800163a <ADCT_SystemFPT_RunOutput+0x916>
			else if (ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON  || ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON) {
				if (GstSystemSetting.ucDoorBurglarEnableAlarm == TRUE) {
					ADCT_BGS_RELAY_BUZZER_ON();
				}
				else {
					ADCT_BGS_RELAY_BUZZER_OFF();
 8001622:	2200      	movs	r2, #0
 8001624:	2102      	movs	r1, #2
 8001626:	4807      	ldr	r0, [pc, #28]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001628:	f002 fe6e 	bl	8004308 <GPIO_WriteBit>
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 800162c:	e005      	b.n	800163a <ADCT_SystemFPT_RunOutput+0x916>
					ADCT_BGS_RELAY_BUZZER_OFF();
				}
			}
		}
		else {
			ADCT_BGS_RELAY_BUZZER_OFF();
 800162e:	2200      	movs	r2, #0
 8001630:	2102      	movs	r1, #2
 8001632:	4804      	ldr	r0, [pc, #16]	; (8001644 <ADCT_SystemFPT_RunOutput+0x920>)
 8001634:	f002 fe68 	bl	8004308 <GPIO_WriteBit>
		}
	}
}
 8001638:	e000      	b.n	800163c <ADCT_SystemFPT_RunOutput+0x918>
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
		ADCT_BGS_RELAY_BUZZER_OFF();
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 800163a:	bf00      	nop
		}
		else {
			ADCT_BGS_RELAY_BUZZER_OFF();
		}
	}
}
 800163c:	bf00      	nop
 800163e:	3720      	adds	r7, #32
 8001640:	46bd      	mov	sp, r7
 8001642:	bd80      	pop	{r7, pc}
 8001644:	40010800 	.word	0x40010800
 8001648:	200001f4 	.word	0x200001f4
 800164c:	20000204 	.word	0x20000204
 8001650:	20000248 	.word	0x20000248

08001654 <Delay>:
/**
 * @brief  Delays for amount of micro seconds
 * @param  micros: Number of microseconds for delay
 * @retval None
 */
__STATIC_INLINE void Delay(__IO uint32_t micros) {
 8001654:	b480      	push	{r7}
 8001656:	b085      	sub	sp, #20
 8001658:	af00      	add	r7, sp, #0
 800165a:	6078      	str	r0, [r7, #4]
#if !defined(STM32F0xx)
	uint32_t start = DWT->CYCCNT;
 800165c:	4b0c      	ldr	r3, [pc, #48]	; (8001690 <Delay+0x3c>)
 800165e:	685b      	ldr	r3, [r3, #4]
 8001660:	60fb      	str	r3, [r7, #12]

	/* Go to number of cycles for system */
	micros *= (SystemCoreClock / 1000000);
 8001662:	4b0c      	ldr	r3, [pc, #48]	; (8001694 <Delay+0x40>)
 8001664:	681b      	ldr	r3, [r3, #0]
 8001666:	4a0c      	ldr	r2, [pc, #48]	; (8001698 <Delay+0x44>)
 8001668:	fba2 2303 	umull	r2, r3, r2, r3
 800166c:	0c9b      	lsrs	r3, r3, #18
 800166e:	687a      	ldr	r2, [r7, #4]
 8001670:	fb02 f303 	mul.w	r3, r2, r3
 8001674:	607b      	str	r3, [r7, #4]

	/* Delay till end */
	while ((DWT->CYCCNT - start) < micros);
 8001676:	bf00      	nop
 8001678:	4b05      	ldr	r3, [pc, #20]	; (8001690 <Delay+0x3c>)
 800167a:	685a      	ldr	r2, [r3, #4]
 800167c:	68fb      	ldr	r3, [r7, #12]
 800167e:	1ad2      	subs	r2, r2, r3
 8001680:	687b      	ldr	r3, [r7, #4]
 8001682:	429a      	cmp	r2, r3
 8001684:	d3f8      	bcc.n	8001678 <Delay+0x24>
	micros *= (SystemCoreClock / 1000000) / 5;

	/* Wait till done */
	while (micros--);
#endif
}
 8001686:	bf00      	nop
 8001688:	3714      	adds	r7, #20
 800168a:	46bd      	mov	sp, r7
 800168c:	bc80      	pop	{r7}
 800168e:	4770      	bx	lr
 8001690:	e0001000 	.word	0xe0001000
 8001694:	2000001c 	.word	0x2000001c
 8001698:	431bde83 	.word	0x431bde83

0800169c <DHT22_Module_Init_Hardware>:
/******************************************************************************
 * Defines
 *****************************************************************************/

void DHT22_Module_Init_Hardware(void)
{
 800169c:	b580      	push	{r7, lr}
 800169e:	af00      	add	r7, sp, #0
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
 80016a0:	f44f 7040 	mov.w	r0, #768	; 0x300
 80016a4:	f002 f9fc 	bl	8003aa0 <NVIC_PriorityGroupConfig>
	TM_DELAY_Init();
 80016a8:	f002 f8be 	bl	8003828 <TM_DELAY_Init>
	vExtiInit();
 80016ac:	f000 fa56 	bl	8001b5c <vExtiInit>
	ADCT_BGS_DHT22Init();
 80016b0:	f000 f840 	bl	8001734 <ADCT_BGS_DHT22Init>
	vExtiStart();
 80016b4:	f000 fa8a 	bl	8001bcc <vExtiStart>
}
 80016b8:	bf00      	nop
 80016ba:	bd80      	pop	{r7, pc}

080016bc <ADCT_DHT22_FPT_GetValue>:
void ADCT_DHT22_FPT_GetValue(DHT22_MODULE_DATA *pDHT22Data)
{
 80016bc:	b580      	push	{r7, lr}
 80016be:	b082      	sub	sp, #8
 80016c0:	af00      	add	r7, sp, #0
 80016c2:	6078      	str	r0, [r7, #4]
	if(ADCT_BGS_DHT22Measuring(DHT22_Device_1) == ADCT_FALSE)
 80016c4:	2000      	movs	r0, #0
 80016c6:	f000 f9eb 	bl	8001aa0 <ADCT_BGS_DHT22Measuring>
 80016ca:	4603      	mov	r3, r0
 80016cc:	2b00      	cmp	r3, #0
 80016ce:	d113      	bne.n	80016f8 <ADCT_DHT22_FPT_GetValue+0x3c>
	{
		if (ADCT_BGS_DHT22_CheckCRC(DHT22_Device_1))
 80016d0:	2000      	movs	r0, #0
 80016d2:	f000 f923 	bl	800191c <ADCT_BGS_DHT22_CheckCRC>
 80016d6:	4603      	mov	r3, r0
 80016d8:	2b00      	cmp	r3, #0
 80016da:	d00d      	beq.n	80016f8 <ADCT_DHT22_FPT_GetValue+0x3c>
		{
			pDHT22Data->usTemp_Main = ADCT_BGS_DHT22GetTemp(DHT22_Device_1) ;
 80016dc:	2000      	movs	r0, #0
 80016de:	f000 f9ef 	bl	8001ac0 <ADCT_BGS_DHT22GetTemp>
 80016e2:	4603      	mov	r3, r0
 80016e4:	b29a      	uxth	r2, r3
 80016e6:	687b      	ldr	r3, [r7, #4]
 80016e8:	801a      	strh	r2, [r3, #0]
			pDHT22Data->usHumid_Main = ADCT_BGS_DHT22GetHumidity(DHT22_Device_1) ;
 80016ea:	2000      	movs	r0, #0
 80016ec:	f000 fa10 	bl	8001b10 <ADCT_BGS_DHT22GetHumidity>
 80016f0:	4603      	mov	r3, r0
 80016f2:	b29a      	uxth	r2, r3
 80016f4:	687b      	ldr	r3, [r7, #4]
 80016f6:	805a      	strh	r2, [r3, #2]
		}
	}
	if(ADCT_BGS_DHT22Measuring(DHT22_Device_2) == ADCT_FALSE)
 80016f8:	2001      	movs	r0, #1
 80016fa:	f000 f9d1 	bl	8001aa0 <ADCT_BGS_DHT22Measuring>
 80016fe:	4603      	mov	r3, r0
 8001700:	2b00      	cmp	r3, #0
 8001702:	d113      	bne.n	800172c <ADCT_DHT22_FPT_GetValue+0x70>
	{

		if (ADCT_BGS_DHT22_CheckCRC(DHT22_Device_2))
 8001704:	2001      	movs	r0, #1
 8001706:	f000 f909 	bl	800191c <ADCT_BGS_DHT22_CheckCRC>
 800170a:	4603      	mov	r3, r0
 800170c:	2b00      	cmp	r3, #0
 800170e:	d00d      	beq.n	800172c <ADCT_DHT22_FPT_GetValue+0x70>
		{
			pDHT22Data->usTemp_Sub = ADCT_BGS_DHT22GetTemp(DHT22_Device_2) ;
 8001710:	2001      	movs	r0, #1
 8001712:	f000 f9d5 	bl	8001ac0 <ADCT_BGS_DHT22GetTemp>
 8001716:	4603      	mov	r3, r0
 8001718:	b29a      	uxth	r2, r3
 800171a:	687b      	ldr	r3, [r7, #4]
 800171c:	809a      	strh	r2, [r3, #4]
			pDHT22Data->usHumid_Sub = ADCT_BGS_DHT22GetHumidity(DHT22_Device_2) ;
 800171e:	2001      	movs	r0, #1
 8001720:	f000 f9f6 	bl	8001b10 <ADCT_BGS_DHT22GetHumidity>
 8001724:	4603      	mov	r3, r0
 8001726:	b29a      	uxth	r2, r3
 8001728:	687b      	ldr	r3, [r7, #4]
 800172a:	80da      	strh	r2, [r3, #6]
		}
	}
}
 800172c:	bf00      	nop
 800172e:	3708      	adds	r7, #8
 8001730:	46bd      	mov	sp, r7
 8001732:	bd80      	pop	{r7, pc}

08001734 <ADCT_BGS_DHT22Init>:
static void ADCT_BGS_DHT22_02_CbkState(ExtiLineState_t state);
/******************************************************************************
 * Function definitions
 *****************************************************************************/
void ADCT_BGS_DHT22Init(void)
{
 8001734:	b580      	push	{r7, lr}
 8001736:	b082      	sub	sp, #8
 8001738:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(DHT22_01_CLK, ENABLE);
 800173a:	2101      	movs	r1, #1
 800173c:	2008      	movs	r0, #8
 800173e:	f003 fa93 	bl	8004c68 <RCC_APB2PeriphClockCmd>
	RCC_APB2PeriphClockCmd(DHT22_02_CLK, ENABLE);
 8001742:	2101      	movs	r1, #1
 8001744:	2010      	movs	r0, #16
 8001746:	f003 fa8f 	bl	8004c68 <RCC_APB2PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 800174a:	2101      	movs	r1, #1
 800174c:	2001      	movs	r0, #1
 800174e:	f003 fa8b 	bl	8004c68 <RCC_APB2PeriphClockCmd>
	vExtiAddCb(DHT22_01_PortSource, DHT22_01_PinSource, ADCT_BGS_DHT22_01_CbkState);
 8001752:	4a13      	ldr	r2, [pc, #76]	; (80017a0 <ADCT_BGS_DHT22Init+0x6c>)
 8001754:	2109      	movs	r1, #9
 8001756:	2001      	movs	r0, #1
 8001758:	f000 fa0c 	bl	8001b74 <vExtiAddCb>
	vExtiAddCb(DHT22_02_PortSource, DHT22_02_PinSource, ADCT_BGS_DHT22_02_CbkState);
 800175c:	4a11      	ldr	r2, [pc, #68]	; (80017a4 <ADCT_BGS_DHT22Init+0x70>)
 800175e:	210c      	movs	r1, #12
 8001760:	2002      	movs	r0, #2
 8001762:	f000 fa07 	bl	8001b74 <vExtiAddCb>
	GPIO_InitStructure.GPIO_Pin = DHT22_01_PIN;
 8001766:	f44f 7300 	mov.w	r3, #512	; 0x200
 800176a:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800176c:	2303      	movs	r3, #3
 800176e:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8001770:	2348      	movs	r3, #72	; 0x48
 8001772:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(DHT22_01_PORT, &GPIO_InitStructure);
 8001774:	1d3b      	adds	r3, r7, #4
 8001776:	4619      	mov	r1, r3
 8001778:	480b      	ldr	r0, [pc, #44]	; (80017a8 <ADCT_BGS_DHT22Init+0x74>)
 800177a:	f002 fcbf 	bl	80040fc <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = DHT22_02_PIN;
 800177e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001782:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001784:	2303      	movs	r3, #3
 8001786:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8001788:	2348      	movs	r3, #72	; 0x48
 800178a:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
 800178c:	1d3b      	adds	r3, r7, #4
 800178e:	4619      	mov	r1, r3
 8001790:	4806      	ldr	r0, [pc, #24]	; (80017ac <ADCT_BGS_DHT22Init+0x78>)
 8001792:	f002 fcb3 	bl	80040fc <GPIO_Init>
}
 8001796:	bf00      	nop
 8001798:	3708      	adds	r7, #8
 800179a:	46bd      	mov	sp, r7
 800179c:	bd80      	pop	{r7, pc}
 800179e:	bf00      	nop
 80017a0:	080017b1 	.word	0x080017b1
 80017a4:	08001861 	.word	0x08001861
 80017a8:	40010c00 	.word	0x40010c00
 80017ac:	40011000 	.word	0x40011000

080017b0 <ADCT_BGS_DHT22_01_CbkState>:

void ADCT_BGS_DHT22_01_CbkState(ExtiLineState_t state)
{
 80017b0:	b580      	push	{r7, lr}
 80017b2:	b084      	sub	sp, #16
 80017b4:	af00      	add	r7, sp, #0
 80017b6:	4603      	mov	r3, r0
 80017b8:	71fb      	strb	r3, [r7, #7]
	static uint32_t timeUs=0;
	static uint8_t cnt=0;
	uint32_t t;

	t=TimerGetUS();
 80017ba:	f002 f8dd 	bl	8003978 <TimerGetUS>
 80017be:	60f8      	str	r0, [r7, #12]

	if (g_DhtMeasuring[DHT22_Device_1])
 80017c0:	4b23      	ldr	r3, [pc, #140]	; (8001850 <ADCT_BGS_DHT22_01_CbkState+0xa0>)
 80017c2:	781b      	ldrb	r3, [r3, #0]
 80017c4:	2b00      	cmp	r3, #0
 80017c6:	d038      	beq.n	800183a <ADCT_BGS_DHT22_01_CbkState+0x8a>
	{
		if (state == LineState_Low) // last was low
 80017c8:	79fb      	ldrb	r3, [r7, #7]
 80017ca:	2b00      	cmp	r3, #0
 80017cc:	d138      	bne.n	8001840 <ADCT_BGS_DHT22_01_CbkState+0x90>
		{
			if (cnt)
 80017ce:	4b21      	ldr	r3, [pc, #132]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 80017d0:	781b      	ldrb	r3, [r3, #0]
 80017d2:	2b00      	cmp	r3, #0
 80017d4:	d020      	beq.n	8001818 <ADCT_BGS_DHT22_01_CbkState+0x68>
			{
				g_DhtRaw[DHT22_Device_1][ (cnt-1) / 8] <<= 1;
 80017d6:	4b1f      	ldr	r3, [pc, #124]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 80017d8:	781b      	ldrb	r3, [r3, #0]
 80017da:	3b01      	subs	r3, #1
 80017dc:	2b00      	cmp	r3, #0
 80017de:	da00      	bge.n	80017e2 <ADCT_BGS_DHT22_01_CbkState+0x32>
 80017e0:	3307      	adds	r3, #7
 80017e2:	10db      	asrs	r3, r3, #3
 80017e4:	4a1c      	ldr	r2, [pc, #112]	; (8001858 <ADCT_BGS_DHT22_01_CbkState+0xa8>)
 80017e6:	5cd2      	ldrb	r2, [r2, r3]
 80017e8:	0052      	lsls	r2, r2, #1
 80017ea:	b2d1      	uxtb	r1, r2
 80017ec:	4a1a      	ldr	r2, [pc, #104]	; (8001858 <ADCT_BGS_DHT22_01_CbkState+0xa8>)
 80017ee:	54d1      	strb	r1, [r2, r3]
				if ((t - timeUs) > 50) // 1
 80017f0:	4b1a      	ldr	r3, [pc, #104]	; (800185c <ADCT_BGS_DHT22_01_CbkState+0xac>)
 80017f2:	681b      	ldr	r3, [r3, #0]
 80017f4:	68fa      	ldr	r2, [r7, #12]
 80017f6:	1ad3      	subs	r3, r2, r3
 80017f8:	2b32      	cmp	r3, #50	; 0x32
 80017fa:	d90d      	bls.n	8001818 <ADCT_BGS_DHT22_01_CbkState+0x68>
					g_DhtRaw[DHT22_Device_1][(cnt-1) / 8] |= 1;
 80017fc:	4b15      	ldr	r3, [pc, #84]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 80017fe:	781b      	ldrb	r3, [r3, #0]
 8001800:	3b01      	subs	r3, #1
 8001802:	2b00      	cmp	r3, #0
 8001804:	da00      	bge.n	8001808 <ADCT_BGS_DHT22_01_CbkState+0x58>
 8001806:	3307      	adds	r3, #7
 8001808:	10db      	asrs	r3, r3, #3
 800180a:	4a13      	ldr	r2, [pc, #76]	; (8001858 <ADCT_BGS_DHT22_01_CbkState+0xa8>)
 800180c:	5cd2      	ldrb	r2, [r2, r3]
 800180e:	f042 0201 	orr.w	r2, r2, #1
 8001812:	b2d1      	uxtb	r1, r2
 8001814:	4a10      	ldr	r2, [pc, #64]	; (8001858 <ADCT_BGS_DHT22_01_CbkState+0xa8>)
 8001816:	54d1      	strb	r1, [r2, r3]
			}

			cnt++;
 8001818:	4b0e      	ldr	r3, [pc, #56]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 800181a:	781b      	ldrb	r3, [r3, #0]
 800181c:	3301      	adds	r3, #1
 800181e:	b2da      	uxtb	r2, r3
 8001820:	4b0c      	ldr	r3, [pc, #48]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 8001822:	701a      	strb	r2, [r3, #0]

			if (cnt >= 41) {
 8001824:	4b0b      	ldr	r3, [pc, #44]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 8001826:	781b      	ldrb	r3, [r3, #0]
 8001828:	2b28      	cmp	r3, #40	; 0x28
 800182a:	d909      	bls.n	8001840 <ADCT_BGS_DHT22_01_CbkState+0x90>
				g_DhtMeasuring[DHT22_Device_1] = 0;
 800182c:	4b08      	ldr	r3, [pc, #32]	; (8001850 <ADCT_BGS_DHT22_01_CbkState+0xa0>)
 800182e:	2200      	movs	r2, #0
 8001830:	701a      	strb	r2, [r3, #0]
				cnt = 0;
 8001832:	4b08      	ldr	r3, [pc, #32]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 8001834:	2200      	movs	r2, #0
 8001836:	701a      	strb	r2, [r3, #0]
 8001838:	e002      	b.n	8001840 <ADCT_BGS_DHT22_01_CbkState+0x90>
			}
		}
	} else
		cnt = 0;
 800183a:	4b06      	ldr	r3, [pc, #24]	; (8001854 <ADCT_BGS_DHT22_01_CbkState+0xa4>)
 800183c:	2200      	movs	r2, #0
 800183e:	701a      	strb	r2, [r3, #0]

	timeUs=t;
 8001840:	4a06      	ldr	r2, [pc, #24]	; (800185c <ADCT_BGS_DHT22_01_CbkState+0xac>)
 8001842:	68fb      	ldr	r3, [r7, #12]
 8001844:	6013      	str	r3, [r2, #0]
}
 8001846:	bf00      	nop
 8001848:	3710      	adds	r7, #16
 800184a:	46bd      	mov	sp, r7
 800184c:	bd80      	pop	{r7, pc}
 800184e:	bf00      	nop
 8001850:	200000ac 	.word	0x200000ac
 8001854:	200000ae 	.word	0x200000ae
 8001858:	200000a0 	.word	0x200000a0
 800185c:	200000b0 	.word	0x200000b0

08001860 <ADCT_BGS_DHT22_02_CbkState>:
void ADCT_BGS_DHT22_02_CbkState(ExtiLineState_t state)
{
 8001860:	b580      	push	{r7, lr}
 8001862:	b084      	sub	sp, #16
 8001864:	af00      	add	r7, sp, #0
 8001866:	4603      	mov	r3, r0
 8001868:	71fb      	strb	r3, [r7, #7]
	static uint32_t timeUs=0;
	static uint8_t cnt=0;
	uint32_t t;

	t=TimerGetUS();
 800186a:	f002 f885 	bl	8003978 <TimerGetUS>
 800186e:	60f8      	str	r0, [r7, #12]

	if (g_DhtMeasuring[DHT22_Device_2])
 8001870:	4b26      	ldr	r3, [pc, #152]	; (800190c <ADCT_BGS_DHT22_02_CbkState+0xac>)
 8001872:	785b      	ldrb	r3, [r3, #1]
 8001874:	2b00      	cmp	r3, #0
 8001876:	d03e      	beq.n	80018f6 <ADCT_BGS_DHT22_02_CbkState+0x96>
	{
		if (state == LineState_Low) // last was low
 8001878:	79fb      	ldrb	r3, [r7, #7]
 800187a:	2b00      	cmp	r3, #0
 800187c:	d13e      	bne.n	80018fc <ADCT_BGS_DHT22_02_CbkState+0x9c>
		{
			if (cnt)
 800187e:	4b24      	ldr	r3, [pc, #144]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 8001880:	781b      	ldrb	r3, [r3, #0]
 8001882:	2b00      	cmp	r3, #0
 8001884:	d026      	beq.n	80018d4 <ADCT_BGS_DHT22_02_CbkState+0x74>
			{
				g_DhtRaw[DHT22_Device_2][ (cnt-1) / 8] <<= 1;
 8001886:	4b22      	ldr	r3, [pc, #136]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 8001888:	781b      	ldrb	r3, [r3, #0]
 800188a:	3b01      	subs	r3, #1
 800188c:	2b00      	cmp	r3, #0
 800188e:	da00      	bge.n	8001892 <ADCT_BGS_DHT22_02_CbkState+0x32>
 8001890:	3307      	adds	r3, #7
 8001892:	10db      	asrs	r3, r3, #3
 8001894:	4a1f      	ldr	r2, [pc, #124]	; (8001914 <ADCT_BGS_DHT22_02_CbkState+0xb4>)
 8001896:	441a      	add	r2, r3
 8001898:	7952      	ldrb	r2, [r2, #5]
 800189a:	0052      	lsls	r2, r2, #1
 800189c:	b2d1      	uxtb	r1, r2
 800189e:	4a1d      	ldr	r2, [pc, #116]	; (8001914 <ADCT_BGS_DHT22_02_CbkState+0xb4>)
 80018a0:	4413      	add	r3, r2
 80018a2:	460a      	mov	r2, r1
 80018a4:	715a      	strb	r2, [r3, #5]
				if ((t - timeUs) > 50) // 1
 80018a6:	4b1c      	ldr	r3, [pc, #112]	; (8001918 <ADCT_BGS_DHT22_02_CbkState+0xb8>)
 80018a8:	681b      	ldr	r3, [r3, #0]
 80018aa:	68fa      	ldr	r2, [r7, #12]
 80018ac:	1ad3      	subs	r3, r2, r3
 80018ae:	2b32      	cmp	r3, #50	; 0x32
 80018b0:	d910      	bls.n	80018d4 <ADCT_BGS_DHT22_02_CbkState+0x74>
					g_DhtRaw[DHT22_Device_2][(cnt-1) / 8] |= 1;
 80018b2:	4b17      	ldr	r3, [pc, #92]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 80018b4:	781b      	ldrb	r3, [r3, #0]
 80018b6:	3b01      	subs	r3, #1
 80018b8:	2b00      	cmp	r3, #0
 80018ba:	da00      	bge.n	80018be <ADCT_BGS_DHT22_02_CbkState+0x5e>
 80018bc:	3307      	adds	r3, #7
 80018be:	10db      	asrs	r3, r3, #3
 80018c0:	4a14      	ldr	r2, [pc, #80]	; (8001914 <ADCT_BGS_DHT22_02_CbkState+0xb4>)
 80018c2:	441a      	add	r2, r3
 80018c4:	7952      	ldrb	r2, [r2, #5]
 80018c6:	f042 0201 	orr.w	r2, r2, #1
 80018ca:	b2d1      	uxtb	r1, r2
 80018cc:	4a11      	ldr	r2, [pc, #68]	; (8001914 <ADCT_BGS_DHT22_02_CbkState+0xb4>)
 80018ce:	4413      	add	r3, r2
 80018d0:	460a      	mov	r2, r1
 80018d2:	715a      	strb	r2, [r3, #5]
			}

			cnt++;
 80018d4:	4b0e      	ldr	r3, [pc, #56]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 80018d6:	781b      	ldrb	r3, [r3, #0]
 80018d8:	3301      	adds	r3, #1
 80018da:	b2da      	uxtb	r2, r3
 80018dc:	4b0c      	ldr	r3, [pc, #48]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 80018de:	701a      	strb	r2, [r3, #0]

			if (cnt >= 41) {
 80018e0:	4b0b      	ldr	r3, [pc, #44]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 80018e2:	781b      	ldrb	r3, [r3, #0]
 80018e4:	2b28      	cmp	r3, #40	; 0x28
 80018e6:	d909      	bls.n	80018fc <ADCT_BGS_DHT22_02_CbkState+0x9c>
				g_DhtMeasuring[DHT22_Device_2] = 0;
 80018e8:	4b08      	ldr	r3, [pc, #32]	; (800190c <ADCT_BGS_DHT22_02_CbkState+0xac>)
 80018ea:	2200      	movs	r2, #0
 80018ec:	705a      	strb	r2, [r3, #1]
				cnt = 0;
 80018ee:	4b08      	ldr	r3, [pc, #32]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 80018f0:	2200      	movs	r2, #0
 80018f2:	701a      	strb	r2, [r3, #0]
 80018f4:	e002      	b.n	80018fc <ADCT_BGS_DHT22_02_CbkState+0x9c>
			}
		}
	} else
		cnt = 0;
 80018f6:	4b06      	ldr	r3, [pc, #24]	; (8001910 <ADCT_BGS_DHT22_02_CbkState+0xb0>)
 80018f8:	2200      	movs	r2, #0
 80018fa:	701a      	strb	r2, [r3, #0]

	timeUs=t;
 80018fc:	4a06      	ldr	r2, [pc, #24]	; (8001918 <ADCT_BGS_DHT22_02_CbkState+0xb8>)
 80018fe:	68fb      	ldr	r3, [r7, #12]
 8001900:	6013      	str	r3, [r2, #0]
}
 8001902:	bf00      	nop
 8001904:	3710      	adds	r7, #16
 8001906:	46bd      	mov	sp, r7
 8001908:	bd80      	pop	{r7, pc}
 800190a:	bf00      	nop
 800190c:	200000ac 	.word	0x200000ac
 8001910:	200000b4 	.word	0x200000b4
 8001914:	200000a0 	.word	0x200000a0
 8001918:	200000b8 	.word	0x200000b8

0800191c <ADCT_BGS_DHT22_CheckCRC>:

uint8_t ADCT_BGS_DHT22_CheckCRC(ADCT_BGS_DHT22_devicetypes device)
{
 800191c:	b480      	push	{r7}
 800191e:	b085      	sub	sp, #20
 8001920:	af00      	add	r7, sp, #0
 8001922:	4603      	mov	r3, r0
 8001924:	71fb      	strb	r3, [r7, #7]
	uint8_t crc;
	crc=g_DhtRaw[device][0]+g_DhtRaw[device][1]+g_DhtRaw[device][2]+g_DhtRaw[device][3];
 8001926:	79fa      	ldrb	r2, [r7, #7]
 8001928:	491b      	ldr	r1, [pc, #108]	; (8001998 <ADCT_BGS_DHT22_CheckCRC+0x7c>)
 800192a:	4613      	mov	r3, r2
 800192c:	009b      	lsls	r3, r3, #2
 800192e:	4413      	add	r3, r2
 8001930:	440b      	add	r3, r1
 8001932:	7819      	ldrb	r1, [r3, #0]
 8001934:	79fa      	ldrb	r2, [r7, #7]
 8001936:	4818      	ldr	r0, [pc, #96]	; (8001998 <ADCT_BGS_DHT22_CheckCRC+0x7c>)
 8001938:	4613      	mov	r3, r2
 800193a:	009b      	lsls	r3, r3, #2
 800193c:	4413      	add	r3, r2
 800193e:	4403      	add	r3, r0
 8001940:	3301      	adds	r3, #1
 8001942:	781b      	ldrb	r3, [r3, #0]
 8001944:	440b      	add	r3, r1
 8001946:	b2d9      	uxtb	r1, r3
 8001948:	79fa      	ldrb	r2, [r7, #7]
 800194a:	4813      	ldr	r0, [pc, #76]	; (8001998 <ADCT_BGS_DHT22_CheckCRC+0x7c>)
 800194c:	4613      	mov	r3, r2
 800194e:	009b      	lsls	r3, r3, #2
 8001950:	4413      	add	r3, r2
 8001952:	4403      	add	r3, r0
 8001954:	3302      	adds	r3, #2
 8001956:	781b      	ldrb	r3, [r3, #0]
 8001958:	440b      	add	r3, r1
 800195a:	b2d9      	uxtb	r1, r3
 800195c:	79fa      	ldrb	r2, [r7, #7]
 800195e:	480e      	ldr	r0, [pc, #56]	; (8001998 <ADCT_BGS_DHT22_CheckCRC+0x7c>)
 8001960:	4613      	mov	r3, r2
 8001962:	009b      	lsls	r3, r3, #2
 8001964:	4413      	add	r3, r2
 8001966:	4403      	add	r3, r0
 8001968:	3303      	adds	r3, #3
 800196a:	781b      	ldrb	r3, [r3, #0]
 800196c:	440b      	add	r3, r1
 800196e:	73fb      	strb	r3, [r7, #15]
	return crc==g_DhtRaw[device][4];
 8001970:	79fa      	ldrb	r2, [r7, #7]
 8001972:	4909      	ldr	r1, [pc, #36]	; (8001998 <ADCT_BGS_DHT22_CheckCRC+0x7c>)
 8001974:	4613      	mov	r3, r2
 8001976:	009b      	lsls	r3, r3, #2
 8001978:	4413      	add	r3, r2
 800197a:	440b      	add	r3, r1
 800197c:	3304      	adds	r3, #4
 800197e:	781b      	ldrb	r3, [r3, #0]
 8001980:	7bfa      	ldrb	r2, [r7, #15]
 8001982:	429a      	cmp	r2, r3
 8001984:	bf0c      	ite	eq
 8001986:	2301      	moveq	r3, #1
 8001988:	2300      	movne	r3, #0
 800198a:	b2db      	uxtb	r3, r3
}
 800198c:	4618      	mov	r0, r3
 800198e:	3714      	adds	r7, #20
 8001990:	46bd      	mov	sp, r7
 8001992:	bc80      	pop	{r7}
 8001994:	4770      	bx	lr
 8001996:	bf00      	nop
 8001998:	200000a0 	.word	0x200000a0

0800199c <ADCT_BGS_DHT22Start>:

void ADCT_BGS_DHT22Start(ADCT_BGS_DHT22_devicetypes device)
{
 800199c:	b580      	push	{r7, lr}
 800199e:	b084      	sub	sp, #16
 80019a0:	af00      	add	r7, sp, #0
 80019a2:	4603      	mov	r3, r0
 80019a4:	71fb      	strb	r3, [r7, #7]
	GPIO_InitTypeDef GPIO_InitStructure;
	switch (device)
 80019a6:	79fb      	ldrb	r3, [r7, #7]
 80019a8:	2b00      	cmp	r3, #0
 80019aa:	d002      	beq.n	80019b2 <ADCT_BGS_DHT22Start+0x16>
 80019ac:	2b01      	cmp	r3, #1
 80019ae:	d034      	beq.n	8001a1a <ADCT_BGS_DHT22Start+0x7e>
		GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);

		g_DhtMeasuring[DHT22_Device_2] = 1;
		memset(&g_DhtRaw[DHT22_Device_2], 0, 5);
	}
	default : break;
 80019b0:	e066      	b.n	8001a80 <ADCT_BGS_DHT22Start+0xe4>
	{

	case DHT22_Device_1:
	{

		GPIO_InitStructure.GPIO_Pin = DHT22_01_PIN;
 80019b2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80019b6:	81bb      	strh	r3, [r7, #12]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80019b8:	2303      	movs	r3, #3
 80019ba:	73bb      	strb	r3, [r7, #14]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80019bc:	2310      	movs	r3, #16
 80019be:	73fb      	strb	r3, [r7, #15]
		GPIO_Init(DHT22_01_PORT, &GPIO_InitStructure);
 80019c0:	f107 030c 	add.w	r3, r7, #12
 80019c4:	4619      	mov	r1, r3
 80019c6:	4831      	ldr	r0, [pc, #196]	; (8001a8c <ADCT_BGS_DHT22Start+0xf0>)
 80019c8:	f002 fb98 	bl	80040fc <GPIO_Init>

		DHT22_01_PIN_LOW();
 80019cc:	f44f 7100 	mov.w	r1, #512	; 0x200
 80019d0:	482e      	ldr	r0, [pc, #184]	; (8001a8c <ADCT_BGS_DHT22Start+0xf0>)
 80019d2:	f002 fc8b 	bl	80042ec <GPIO_ResetBits>
		Delay(500);
 80019d6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80019da:	f7ff fe3b 	bl	8001654 <Delay>
		DHT22_01_PIN_HIGH();
 80019de:	f44f 7100 	mov.w	r1, #512	; 0x200
 80019e2:	482a      	ldr	r0, [pc, #168]	; (8001a8c <ADCT_BGS_DHT22Start+0xf0>)
 80019e4:	f002 fc74 	bl	80042d0 <GPIO_SetBits>
		Delay(40);
 80019e8:	2028      	movs	r0, #40	; 0x28
 80019ea:	f7ff fe33 	bl	8001654 <Delay>


		GPIO_InitStructure.GPIO_Pin = DHT22_01_PIN;
 80019ee:	f44f 7300 	mov.w	r3, #512	; 0x200
 80019f2:	81bb      	strh	r3, [r7, #12]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80019f4:	2303      	movs	r3, #3
 80019f6:	73bb      	strb	r3, [r7, #14]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80019f8:	2348      	movs	r3, #72	; 0x48
 80019fa:	73fb      	strb	r3, [r7, #15]
		GPIO_Init(DHT22_01_PORT, &GPIO_InitStructure);
 80019fc:	f107 030c 	add.w	r3, r7, #12
 8001a00:	4619      	mov	r1, r3
 8001a02:	4822      	ldr	r0, [pc, #136]	; (8001a8c <ADCT_BGS_DHT22Start+0xf0>)
 8001a04:	f002 fb7a 	bl	80040fc <GPIO_Init>

		g_DhtMeasuring[DHT22_Device_1] = 1;
 8001a08:	4b21      	ldr	r3, [pc, #132]	; (8001a90 <ADCT_BGS_DHT22Start+0xf4>)
 8001a0a:	2201      	movs	r2, #1
 8001a0c:	701a      	strb	r2, [r3, #0]
		memset(&g_DhtRaw[DHT22_Device_1], 0, 5);
 8001a0e:	2205      	movs	r2, #5
 8001a10:	2100      	movs	r1, #0
 8001a12:	4820      	ldr	r0, [pc, #128]	; (8001a94 <ADCT_BGS_DHT22Start+0xf8>)
 8001a14:	f003 ffde 	bl	80059d4 <memset>
		break;
 8001a18:	e033      	b.n	8001a82 <ADCT_BGS_DHT22Start+0xe6>
	}
	case DHT22_Device_2:
	{
		GPIO_InitStructure.GPIO_Pin = DHT22_02_PIN;
 8001a1a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001a1e:	81bb      	strh	r3, [r7, #12]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a20:	2303      	movs	r3, #3
 8001a22:	73bb      	strb	r3, [r7, #14]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8001a24:	2310      	movs	r3, #16
 8001a26:	73fb      	strb	r3, [r7, #15]
		GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
 8001a28:	f107 030c 	add.w	r3, r7, #12
 8001a2c:	4619      	mov	r1, r3
 8001a2e:	481a      	ldr	r0, [pc, #104]	; (8001a98 <ADCT_BGS_DHT22Start+0xfc>)
 8001a30:	f002 fb64 	bl	80040fc <GPIO_Init>

		DHT22_02_PIN_LOW();
 8001a34:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001a38:	4817      	ldr	r0, [pc, #92]	; (8001a98 <ADCT_BGS_DHT22Start+0xfc>)
 8001a3a:	f002 fc57 	bl	80042ec <GPIO_ResetBits>
		Delay(500);
 8001a3e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001a42:	f7ff fe07 	bl	8001654 <Delay>
		DHT22_02_PIN_HIGH();
 8001a46:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001a4a:	4813      	ldr	r0, [pc, #76]	; (8001a98 <ADCT_BGS_DHT22Start+0xfc>)
 8001a4c:	f002 fc40 	bl	80042d0 <GPIO_SetBits>
		Delay(40);
 8001a50:	2028      	movs	r0, #40	; 0x28
 8001a52:	f7ff fdff 	bl	8001654 <Delay>


		GPIO_InitStructure.GPIO_Pin = DHT22_02_PIN;
 8001a56:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001a5a:	81bb      	strh	r3, [r7, #12]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a5c:	2303      	movs	r3, #3
 8001a5e:	73bb      	strb	r3, [r7, #14]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8001a60:	2348      	movs	r3, #72	; 0x48
 8001a62:	73fb      	strb	r3, [r7, #15]
		GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
 8001a64:	f107 030c 	add.w	r3, r7, #12
 8001a68:	4619      	mov	r1, r3
 8001a6a:	480b      	ldr	r0, [pc, #44]	; (8001a98 <ADCT_BGS_DHT22Start+0xfc>)
 8001a6c:	f002 fb46 	bl	80040fc <GPIO_Init>

		g_DhtMeasuring[DHT22_Device_2] = 1;
 8001a70:	4b07      	ldr	r3, [pc, #28]	; (8001a90 <ADCT_BGS_DHT22Start+0xf4>)
 8001a72:	2201      	movs	r2, #1
 8001a74:	705a      	strb	r2, [r3, #1]
		memset(&g_DhtRaw[DHT22_Device_2], 0, 5);
 8001a76:	2205      	movs	r2, #5
 8001a78:	2100      	movs	r1, #0
 8001a7a:	4808      	ldr	r0, [pc, #32]	; (8001a9c <ADCT_BGS_DHT22Start+0x100>)
 8001a7c:	f003 ffaa 	bl	80059d4 <memset>
	}
	default : break;
 8001a80:	bf00      	nop
	}
}
 8001a82:	bf00      	nop
 8001a84:	3710      	adds	r7, #16
 8001a86:	46bd      	mov	sp, r7
 8001a88:	bd80      	pop	{r7, pc}
 8001a8a:	bf00      	nop
 8001a8c:	40010c00 	.word	0x40010c00
 8001a90:	200000ac 	.word	0x200000ac
 8001a94:	200000a0 	.word	0x200000a0
 8001a98:	40011000 	.word	0x40011000
 8001a9c:	200000a5 	.word	0x200000a5

08001aa0 <ADCT_BGS_DHT22Measuring>:


uint8_t ADCT_BGS_DHT22Measuring(ADCT_BGS_DHT22_devicetypes device)
{
 8001aa0:	b480      	push	{r7}
 8001aa2:	b083      	sub	sp, #12
 8001aa4:	af00      	add	r7, sp, #0
 8001aa6:	4603      	mov	r3, r0
 8001aa8:	71fb      	strb	r3, [r7, #7]
	return 	g_DhtMeasuring[device];
 8001aaa:	79fb      	ldrb	r3, [r7, #7]
 8001aac:	4a03      	ldr	r2, [pc, #12]	; (8001abc <ADCT_BGS_DHT22Measuring+0x1c>)
 8001aae:	5cd3      	ldrb	r3, [r2, r3]
}
 8001ab0:	4618      	mov	r0, r3
 8001ab2:	370c      	adds	r7, #12
 8001ab4:	46bd      	mov	sp, r7
 8001ab6:	bc80      	pop	{r7}
 8001ab8:	4770      	bx	lr
 8001aba:	bf00      	nop
 8001abc:	200000ac 	.word	0x200000ac

08001ac0 <ADCT_BGS_DHT22GetTemp>:

uint32_t ADCT_BGS_DHT22GetTemp(ADCT_BGS_DHT22_devicetypes device)
{
 8001ac0:	b480      	push	{r7}
 8001ac2:	b085      	sub	sp, #20
 8001ac4:	af00      	add	r7, sp, #0
 8001ac6:	4603      	mov	r3, r0
 8001ac8:	71fb      	strb	r3, [r7, #7]
	uint32_t res=0;
 8001aca:	2300      	movs	r3, #0
 8001acc:	60fb      	str	r3, [r7, #12]
	res=g_DhtRaw[device][2];
 8001ace:	79fa      	ldrb	r2, [r7, #7]
 8001ad0:	490e      	ldr	r1, [pc, #56]	; (8001b0c <ADCT_BGS_DHT22GetTemp+0x4c>)
 8001ad2:	4613      	mov	r3, r2
 8001ad4:	009b      	lsls	r3, r3, #2
 8001ad6:	4413      	add	r3, r2
 8001ad8:	440b      	add	r3, r1
 8001ada:	3302      	adds	r3, #2
 8001adc:	781b      	ldrb	r3, [r3, #0]
 8001ade:	60fb      	str	r3, [r7, #12]
	res<<=8;
 8001ae0:	68fb      	ldr	r3, [r7, #12]
 8001ae2:	021b      	lsls	r3, r3, #8
 8001ae4:	60fb      	str	r3, [r7, #12]
	res|=g_DhtRaw[device][3];
 8001ae6:	79fa      	ldrb	r2, [r7, #7]
 8001ae8:	4908      	ldr	r1, [pc, #32]	; (8001b0c <ADCT_BGS_DHT22GetTemp+0x4c>)
 8001aea:	4613      	mov	r3, r2
 8001aec:	009b      	lsls	r3, r3, #2
 8001aee:	4413      	add	r3, r2
 8001af0:	440b      	add	r3, r1
 8001af2:	3303      	adds	r3, #3
 8001af4:	781b      	ldrb	r3, [r3, #0]
 8001af6:	461a      	mov	r2, r3
 8001af8:	68fb      	ldr	r3, [r7, #12]
 8001afa:	4313      	orrs	r3, r2
 8001afc:	60fb      	str	r3, [r7, #12]
	return res;
 8001afe:	68fb      	ldr	r3, [r7, #12]
}
 8001b00:	4618      	mov	r0, r3
 8001b02:	3714      	adds	r7, #20
 8001b04:	46bd      	mov	sp, r7
 8001b06:	bc80      	pop	{r7}
 8001b08:	4770      	bx	lr
 8001b0a:	bf00      	nop
 8001b0c:	200000a0 	.word	0x200000a0

08001b10 <ADCT_BGS_DHT22GetHumidity>:

uint32_t ADCT_BGS_DHT22GetHumidity(ADCT_BGS_DHT22_devicetypes device)
{
 8001b10:	b480      	push	{r7}
 8001b12:	b085      	sub	sp, #20
 8001b14:	af00      	add	r7, sp, #0
 8001b16:	4603      	mov	r3, r0
 8001b18:	71fb      	strb	r3, [r7, #7]
	uint32_t res=0;
 8001b1a:	2300      	movs	r3, #0
 8001b1c:	60fb      	str	r3, [r7, #12]
	res=g_DhtRaw[device][0];
 8001b1e:	79fa      	ldrb	r2, [r7, #7]
 8001b20:	490d      	ldr	r1, [pc, #52]	; (8001b58 <ADCT_BGS_DHT22GetHumidity+0x48>)
 8001b22:	4613      	mov	r3, r2
 8001b24:	009b      	lsls	r3, r3, #2
 8001b26:	4413      	add	r3, r2
 8001b28:	440b      	add	r3, r1
 8001b2a:	781b      	ldrb	r3, [r3, #0]
 8001b2c:	60fb      	str	r3, [r7, #12]
	res<<=8;
 8001b2e:	68fb      	ldr	r3, [r7, #12]
 8001b30:	021b      	lsls	r3, r3, #8
 8001b32:	60fb      	str	r3, [r7, #12]
	res|=g_DhtRaw[device][1];
 8001b34:	79fa      	ldrb	r2, [r7, #7]
 8001b36:	4908      	ldr	r1, [pc, #32]	; (8001b58 <ADCT_BGS_DHT22GetHumidity+0x48>)
 8001b38:	4613      	mov	r3, r2
 8001b3a:	009b      	lsls	r3, r3, #2
 8001b3c:	4413      	add	r3, r2
 8001b3e:	440b      	add	r3, r1
 8001b40:	3301      	adds	r3, #1
 8001b42:	781b      	ldrb	r3, [r3, #0]
 8001b44:	461a      	mov	r2, r3
 8001b46:	68fb      	ldr	r3, [r7, #12]
 8001b48:	4313      	orrs	r3, r2
 8001b4a:	60fb      	str	r3, [r7, #12]
	return res;
 8001b4c:	68fb      	ldr	r3, [r7, #12]
}
 8001b4e:	4618      	mov	r0, r3
 8001b50:	3714      	adds	r7, #20
 8001b52:	46bd      	mov	sp, r7
 8001b54:	bc80      	pop	{r7}
 8001b56:	4770      	bx	lr
 8001b58:	200000a0 	.word	0x200000a0

08001b5c <vExtiInit>:
/******************************************************************************
 * Function definitions
 *****************************************************************************/

void vExtiInit(void)
{
 8001b5c:	b580      	push	{r7, lr}
 8001b5e:	af00      	add	r7, sp, #0
	memset(&g_ExtiConfig, 0, sizeof(ExtiConfig_t)*MAX_NUMS_OF_EXTI);
 8001b60:	22c0      	movs	r2, #192	; 0xc0
 8001b62:	2100      	movs	r1, #0
 8001b64:	4802      	ldr	r0, [pc, #8]	; (8001b70 <vExtiInit+0x14>)
 8001b66:	f003 ff35 	bl	80059d4 <memset>
}
 8001b6a:	bf00      	nop
 8001b6c:	bd80      	pop	{r7, pc}
 8001b6e:	bf00      	nop
 8001b70:	200000bc 	.word	0x200000bc

08001b74 <vExtiAddCb>:

void vExtiAddCb(uint8_t port, uint8_t line, vExtiCbState_t pCb)
{
 8001b74:	b480      	push	{r7}
 8001b76:	b083      	sub	sp, #12
 8001b78:	af00      	add	r7, sp, #0
 8001b7a:	4603      	mov	r3, r0
 8001b7c:	603a      	str	r2, [r7, #0]
 8001b7e:	71fb      	strb	r3, [r7, #7]
 8001b80:	460b      	mov	r3, r1
 8001b82:	71bb      	strb	r3, [r7, #6]
	g_ExtiConfig[line].port=port;
 8001b84:	79ba      	ldrb	r2, [r7, #6]
 8001b86:	4910      	ldr	r1, [pc, #64]	; (8001bc8 <vExtiAddCb+0x54>)
 8001b88:	4613      	mov	r3, r2
 8001b8a:	005b      	lsls	r3, r3, #1
 8001b8c:	4413      	add	r3, r2
 8001b8e:	009b      	lsls	r3, r3, #2
 8001b90:	440b      	add	r3, r1
 8001b92:	79fa      	ldrb	r2, [r7, #7]
 8001b94:	701a      	strb	r2, [r3, #0]
	g_ExtiConfig[line].cb=pCb;
 8001b96:	79ba      	ldrb	r2, [r7, #6]
 8001b98:	490b      	ldr	r1, [pc, #44]	; (8001bc8 <vExtiAddCb+0x54>)
 8001b9a:	4613      	mov	r3, r2
 8001b9c:	005b      	lsls	r3, r3, #1
 8001b9e:	4413      	add	r3, r2
 8001ba0:	009b      	lsls	r3, r3, #2
 8001ba2:	440b      	add	r3, r1
 8001ba4:	3304      	adds	r3, #4
 8001ba6:	683a      	ldr	r2, [r7, #0]
 8001ba8:	601a      	str	r2, [r3, #0]
	g_ExtiConfig[line].state=ENABLE;
 8001baa:	79ba      	ldrb	r2, [r7, #6]
 8001bac:	4906      	ldr	r1, [pc, #24]	; (8001bc8 <vExtiAddCb+0x54>)
 8001bae:	4613      	mov	r3, r2
 8001bb0:	005b      	lsls	r3, r3, #1
 8001bb2:	4413      	add	r3, r2
 8001bb4:	009b      	lsls	r3, r3, #2
 8001bb6:	440b      	add	r3, r1
 8001bb8:	3308      	adds	r3, #8
 8001bba:	2201      	movs	r2, #1
 8001bbc:	701a      	strb	r2, [r3, #0]
}
 8001bbe:	bf00      	nop
 8001bc0:	370c      	adds	r7, #12
 8001bc2:	46bd      	mov	sp, r7
 8001bc4:	bc80      	pop	{r7}
 8001bc6:	4770      	bx	lr
 8001bc8:	200000bc 	.word	0x200000bc

08001bcc <vExtiStart>:
{
	g_ExtiConfig[line].state=state;
}

void vExtiStart(void)
{
 8001bcc:	b580      	push	{r7, lr}
 8001bce:	b086      	sub	sp, #24
 8001bd0:	af00      	add	r7, sp, #0
	NVIC_InitTypeDef NVIC_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	uint32_t uExtiLines=0;
 8001bd2:	2300      	movs	r3, #0
 8001bd4:	617b      	str	r3, [r7, #20]
	uint8_t exti=0;
 8001bd6:	2300      	movs	r3, #0
 8001bd8:	74fb      	strb	r3, [r7, #19]

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;
 8001bda:	230a      	movs	r3, #10
 8001bdc:	737b      	strb	r3, [r7, #13]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 10;
 8001bde:	230a      	movs	r3, #10
 8001be0:	73bb      	strb	r3, [r7, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001be2:	2301      	movs	r3, #1
 8001be4:	73fb      	strb	r3, [r7, #15]

    for (exti=0;exti<MAX_NUMS_OF_EXTI;exti++)
 8001be6:	2300      	movs	r3, #0
 8001be8:	74fb      	strb	r3, [r7, #19]
 8001bea:	e05b      	b.n	8001ca4 <vExtiStart+0xd8>
	{
		if ((g_ExtiConfig[exti].state==ENABLE) && (g_ExtiConfig[exti].cb!=0))
 8001bec:	7cfa      	ldrb	r2, [r7, #19]
 8001bee:	4938      	ldr	r1, [pc, #224]	; (8001cd0 <vExtiStart+0x104>)
 8001bf0:	4613      	mov	r3, r2
 8001bf2:	005b      	lsls	r3, r3, #1
 8001bf4:	4413      	add	r3, r2
 8001bf6:	009b      	lsls	r3, r3, #2
 8001bf8:	440b      	add	r3, r1
 8001bfa:	3308      	adds	r3, #8
 8001bfc:	781b      	ldrb	r3, [r3, #0]
 8001bfe:	2b01      	cmp	r3, #1
 8001c00:	d14d      	bne.n	8001c9e <vExtiStart+0xd2>
 8001c02:	7cfa      	ldrb	r2, [r7, #19]
 8001c04:	4932      	ldr	r1, [pc, #200]	; (8001cd0 <vExtiStart+0x104>)
 8001c06:	4613      	mov	r3, r2
 8001c08:	005b      	lsls	r3, r3, #1
 8001c0a:	4413      	add	r3, r2
 8001c0c:	009b      	lsls	r3, r3, #2
 8001c0e:	440b      	add	r3, r1
 8001c10:	3304      	adds	r3, #4
 8001c12:	681b      	ldr	r3, [r3, #0]
 8001c14:	2b00      	cmp	r3, #0
 8001c16:	d042      	beq.n	8001c9e <vExtiStart+0xd2>
		{
			uExtiLines|=(1<<exti);	// set line for exti
 8001c18:	7cfb      	ldrb	r3, [r7, #19]
 8001c1a:	2201      	movs	r2, #1
 8001c1c:	fa02 f303 	lsl.w	r3, r2, r3
 8001c20:	461a      	mov	r2, r3
 8001c22:	697b      	ldr	r3, [r7, #20]
 8001c24:	4313      	orrs	r3, r2
 8001c26:	617b      	str	r3, [r7, #20]

			if (exti>9)
 8001c28:	7cfb      	ldrb	r3, [r7, #19]
 8001c2a:	2b09      	cmp	r3, #9
 8001c2c:	d902      	bls.n	8001c34 <vExtiStart+0x68>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 8001c2e:	2328      	movs	r3, #40	; 0x28
 8001c30:	733b      	strb	r3, [r7, #12]
 8001c32:	e022      	b.n	8001c7a <vExtiStart+0xae>
			else if (exti>4)
 8001c34:	7cfb      	ldrb	r3, [r7, #19]
 8001c36:	2b04      	cmp	r3, #4
 8001c38:	d902      	bls.n	8001c40 <vExtiStart+0x74>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
 8001c3a:	2317      	movs	r3, #23
 8001c3c:	733b      	strb	r3, [r7, #12]
 8001c3e:	e01c      	b.n	8001c7a <vExtiStart+0xae>
			else if (exti==4)
 8001c40:	7cfb      	ldrb	r3, [r7, #19]
 8001c42:	2b04      	cmp	r3, #4
 8001c44:	d102      	bne.n	8001c4c <vExtiStart+0x80>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
 8001c46:	230a      	movs	r3, #10
 8001c48:	733b      	strb	r3, [r7, #12]
 8001c4a:	e016      	b.n	8001c7a <vExtiStart+0xae>
			else if (exti==3)
 8001c4c:	7cfb      	ldrb	r3, [r7, #19]
 8001c4e:	2b03      	cmp	r3, #3
 8001c50:	d102      	bne.n	8001c58 <vExtiStart+0x8c>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;
 8001c52:	2309      	movs	r3, #9
 8001c54:	733b      	strb	r3, [r7, #12]
 8001c56:	e010      	b.n	8001c7a <vExtiStart+0xae>
			else if (exti==2)
 8001c58:	7cfb      	ldrb	r3, [r7, #19]
 8001c5a:	2b02      	cmp	r3, #2
 8001c5c:	d102      	bne.n	8001c64 <vExtiStart+0x98>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
 8001c5e:	2308      	movs	r3, #8
 8001c60:	733b      	strb	r3, [r7, #12]
 8001c62:	e00a      	b.n	8001c7a <vExtiStart+0xae>
			else if (exti==1)
 8001c64:	7cfb      	ldrb	r3, [r7, #19]
 8001c66:	2b01      	cmp	r3, #1
 8001c68:	d102      	bne.n	8001c70 <vExtiStart+0xa4>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
 8001c6a:	2307      	movs	r3, #7
 8001c6c:	733b      	strb	r3, [r7, #12]
 8001c6e:	e004      	b.n	8001c7a <vExtiStart+0xae>
			else if (exti==0)
 8001c70:	7cfb      	ldrb	r3, [r7, #19]
 8001c72:	2b00      	cmp	r3, #0
 8001c74:	d101      	bne.n	8001c7a <vExtiStart+0xae>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
 8001c76:	2306      	movs	r3, #6
 8001c78:	733b      	strb	r3, [r7, #12]
		    // Enable the EXTIxxxx Interrupt
		    NVIC_Init(&NVIC_InitStructure);
 8001c7a:	f107 030c 	add.w	r3, r7, #12
 8001c7e:	4618      	mov	r0, r3
 8001c80:	f001 ff20 	bl	8003ac4 <NVIC_Init>

		    // Connect EXTI LineXX to port
		    GPIO_EXTILineConfig(g_ExtiConfig[exti].port, exti);
 8001c84:	7cfa      	ldrb	r2, [r7, #19]
 8001c86:	4912      	ldr	r1, [pc, #72]	; (8001cd0 <vExtiStart+0x104>)
 8001c88:	4613      	mov	r3, r2
 8001c8a:	005b      	lsls	r3, r3, #1
 8001c8c:	4413      	add	r3, r2
 8001c8e:	009b      	lsls	r3, r3, #2
 8001c90:	440b      	add	r3, r1
 8001c92:	781b      	ldrb	r3, [r3, #0]
 8001c94:	7cfa      	ldrb	r2, [r7, #19]
 8001c96:	4611      	mov	r1, r2
 8001c98:	4618      	mov	r0, r3
 8001c9a:	f002 fb4d 	bl	8004338 <GPIO_EXTILineConfig>

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 10;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

    for (exti=0;exti<MAX_NUMS_OF_EXTI;exti++)
 8001c9e:	7cfb      	ldrb	r3, [r7, #19]
 8001ca0:	3301      	adds	r3, #1
 8001ca2:	74fb      	strb	r3, [r7, #19]
 8001ca4:	7cfb      	ldrb	r3, [r7, #19]
 8001ca6:	2b0f      	cmp	r3, #15
 8001ca8:	d9a0      	bls.n	8001bec <vExtiStart+0x20>
		    GPIO_EXTILineConfig(g_ExtiConfig[exti].port, exti);
		}
	}


    if (uExtiLines)	// if any of exti set
 8001caa:	697b      	ldr	r3, [r7, #20]
 8001cac:	2b00      	cmp	r3, #0
 8001cae:	d00b      	beq.n	8001cc8 <vExtiStart+0xfc>
    {
		// Configure EXTI Lines to generate an interrupt on rising or falling edge
		EXTI_InitStructure.EXTI_Line = uExtiLines;
 8001cb0:	697b      	ldr	r3, [r7, #20]
 8001cb2:	607b      	str	r3, [r7, #4]
		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8001cb4:	2300      	movs	r3, #0
 8001cb6:	723b      	strb	r3, [r7, #8]
		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8001cb8:	2310      	movs	r3, #16
 8001cba:	727b      	strb	r3, [r7, #9]
		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8001cbc:	2301      	movs	r3, #1
 8001cbe:	72bb      	strb	r3, [r7, #10]
		EXTI_Init(&EXTI_InitStructure);
 8001cc0:	1d3b      	adds	r3, r7, #4
 8001cc2:	4618      	mov	r0, r3
 8001cc4:	f002 f930 	bl	8003f28 <EXTI_Init>
    }
}
 8001cc8:	bf00      	nop
 8001cca:	3718      	adds	r7, #24
 8001ccc:	46bd      	mov	sp, r7
 8001cce:	bd80      	pop	{r7, pc}
 8001cd0:	200000bc 	.word	0x200000bc

08001cd4 <vExtiHandleInt>:
	// tbd
}

// Handle interrupt
void vExtiHandleInt(uint8_t line)
{
 8001cd4:	b580      	push	{r7, lr}
 8001cd6:	b084      	sub	sp, #16
 8001cd8:	af00      	add	r7, sp, #0
 8001cda:	4603      	mov	r3, r0
 8001cdc:	71fb      	strb	r3, [r7, #7]
	GPIO_TypeDef *pGPIO=0;
 8001cde:	2300      	movs	r3, #0
 8001ce0:	60fb      	str	r3, [r7, #12]

	if (g_ExtiConfig[line].state==ENABLE) // if interrupt handler enabled
 8001ce2:	79fa      	ldrb	r2, [r7, #7]
 8001ce4:	492b      	ldr	r1, [pc, #172]	; (8001d94 <vExtiHandleInt+0xc0>)
 8001ce6:	4613      	mov	r3, r2
 8001ce8:	005b      	lsls	r3, r3, #1
 8001cea:	4413      	add	r3, r2
 8001cec:	009b      	lsls	r3, r3, #2
 8001cee:	440b      	add	r3, r1
 8001cf0:	3308      	adds	r3, #8
 8001cf2:	781b      	ldrb	r3, [r3, #0]
 8001cf4:	2b01      	cmp	r3, #1
 8001cf6:	d148      	bne.n	8001d8a <vExtiHandleInt+0xb6>
	{
		if (g_ExtiConfig[line].cb!=0)		// and handler is set
 8001cf8:	79fa      	ldrb	r2, [r7, #7]
 8001cfa:	4926      	ldr	r1, [pc, #152]	; (8001d94 <vExtiHandleInt+0xc0>)
 8001cfc:	4613      	mov	r3, r2
 8001cfe:	005b      	lsls	r3, r3, #1
 8001d00:	4413      	add	r3, r2
 8001d02:	009b      	lsls	r3, r3, #2
 8001d04:	440b      	add	r3, r1
 8001d06:	3304      	adds	r3, #4
 8001d08:	681b      	ldr	r3, [r3, #0]
 8001d0a:	2b00      	cmp	r3, #0
 8001d0c:	d03d      	beq.n	8001d8a <vExtiHandleInt+0xb6>
		{
			switch(g_ExtiConfig[line].port)
 8001d0e:	79fa      	ldrb	r2, [r7, #7]
 8001d10:	4920      	ldr	r1, [pc, #128]	; (8001d94 <vExtiHandleInt+0xc0>)
 8001d12:	4613      	mov	r3, r2
 8001d14:	005b      	lsls	r3, r3, #1
 8001d16:	4413      	add	r3, r2
 8001d18:	009b      	lsls	r3, r3, #2
 8001d1a:	440b      	add	r3, r1
 8001d1c:	781b      	ldrb	r3, [r3, #0]
 8001d1e:	2b01      	cmp	r3, #1
 8001d20:	d007      	beq.n	8001d32 <vExtiHandleInt+0x5e>
 8001d22:	2b02      	cmp	r3, #2
 8001d24:	d008      	beq.n	8001d38 <vExtiHandleInt+0x64>
 8001d26:	2b00      	cmp	r3, #0
 8001d28:	d000      	beq.n	8001d2c <vExtiHandleInt+0x58>
				break;
			case GPIO_PortSourceGPIOC:
				pGPIO = GPIOC;
				break;
			default:
				break;
 8001d2a:	e008      	b.n	8001d3e <vExtiHandleInt+0x6a>
		if (g_ExtiConfig[line].cb!=0)		// and handler is set
		{
			switch(g_ExtiConfig[line].port)
			{
			case GPIO_PortSourceGPIOA:
				pGPIO = GPIOA;
 8001d2c:	4b1a      	ldr	r3, [pc, #104]	; (8001d98 <vExtiHandleInt+0xc4>)
 8001d2e:	60fb      	str	r3, [r7, #12]
				break;
 8001d30:	e005      	b.n	8001d3e <vExtiHandleInt+0x6a>
			case GPIO_PortSourceGPIOB:
				pGPIO = GPIOB;
 8001d32:	4b1a      	ldr	r3, [pc, #104]	; (8001d9c <vExtiHandleInt+0xc8>)
 8001d34:	60fb      	str	r3, [r7, #12]
				break;
 8001d36:	e002      	b.n	8001d3e <vExtiHandleInt+0x6a>
			case GPIO_PortSourceGPIOC:
				pGPIO = GPIOC;
 8001d38:	4b19      	ldr	r3, [pc, #100]	; (8001da0 <vExtiHandleInt+0xcc>)
 8001d3a:	60fb      	str	r3, [r7, #12]
				break;
 8001d3c:	bf00      	nop
			default:
				break;
			}

			if (pGPIO)
 8001d3e:	68fb      	ldr	r3, [r7, #12]
 8001d40:	2b00      	cmp	r3, #0
 8001d42:	d022      	beq.n	8001d8a <vExtiHandleInt+0xb6>
			{
				if (GPIO_ReadInputDataBit(pGPIO, (1 << line)) == 1)
 8001d44:	79fb      	ldrb	r3, [r7, #7]
 8001d46:	2201      	movs	r2, #1
 8001d48:	fa02 f303 	lsl.w	r3, r2, r3
 8001d4c:	b29b      	uxth	r3, r3
 8001d4e:	4619      	mov	r1, r3
 8001d50:	68f8      	ldr	r0, [r7, #12]
 8001d52:	f002 faa3 	bl	800429c <GPIO_ReadInputDataBit>
 8001d56:	4603      	mov	r3, r0
 8001d58:	2b01      	cmp	r3, #1
 8001d5a:	d10b      	bne.n	8001d74 <vExtiHandleInt+0xa0>
					g_ExtiConfig[line].cb(LineState_High);
 8001d5c:	79fa      	ldrb	r2, [r7, #7]
 8001d5e:	490d      	ldr	r1, [pc, #52]	; (8001d94 <vExtiHandleInt+0xc0>)
 8001d60:	4613      	mov	r3, r2
 8001d62:	005b      	lsls	r3, r3, #1
 8001d64:	4413      	add	r3, r2
 8001d66:	009b      	lsls	r3, r3, #2
 8001d68:	440b      	add	r3, r1
 8001d6a:	3304      	adds	r3, #4
 8001d6c:	681b      	ldr	r3, [r3, #0]
 8001d6e:	2001      	movs	r0, #1
 8001d70:	4798      	blx	r3
				else
					g_ExtiConfig[line].cb(LineState_Low);
			}
		}
	}
}
 8001d72:	e00a      	b.n	8001d8a <vExtiHandleInt+0xb6>
			if (pGPIO)
			{
				if (GPIO_ReadInputDataBit(pGPIO, (1 << line)) == 1)
					g_ExtiConfig[line].cb(LineState_High);
				else
					g_ExtiConfig[line].cb(LineState_Low);
 8001d74:	79fa      	ldrb	r2, [r7, #7]
 8001d76:	4907      	ldr	r1, [pc, #28]	; (8001d94 <vExtiHandleInt+0xc0>)
 8001d78:	4613      	mov	r3, r2
 8001d7a:	005b      	lsls	r3, r3, #1
 8001d7c:	4413      	add	r3, r2
 8001d7e:	009b      	lsls	r3, r3, #2
 8001d80:	440b      	add	r3, r1
 8001d82:	3304      	adds	r3, #4
 8001d84:	681b      	ldr	r3, [r3, #0]
 8001d86:	2000      	movs	r0, #0
 8001d88:	4798      	blx	r3
			}
		}
	}
}
 8001d8a:	bf00      	nop
 8001d8c:	3710      	adds	r7, #16
 8001d8e:	46bd      	mov	sp, r7
 8001d90:	bd80      	pop	{r7, pc}
 8001d92:	bf00      	nop
 8001d94:	200000bc 	.word	0x200000bc
 8001d98:	40010800 	.word	0x40010800
 8001d9c:	40010c00 	.word	0x40010c00
 8001da0:	40011000 	.word	0x40011000

08001da4 <EXTI0_IRQHandler>:
//
//This function handles External line 0 interrupt request.
//
//**************************************************************************
void EXTI0_IRQHandler(void)
{
 8001da4:	b580      	push	{r7, lr}
 8001da6:	af00      	add	r7, sp, #0
    if (EXTI_GetITStatus(EXTI_Line0) != RESET)
 8001da8:	2001      	movs	r0, #1
 8001daa:	f002 f92f 	bl	800400c <EXTI_GetITStatus>
 8001dae:	4603      	mov	r3, r0
 8001db0:	2b00      	cmp	r3, #0
 8001db2:	d002      	beq.n	8001dba <EXTI0_IRQHandler+0x16>
    {
        EXTI_ClearITPendingBit(EXTI_Line0);
 8001db4:	2001      	movs	r0, #1
 8001db6:	f002 f94d 	bl	8004054 <EXTI_ClearITPendingBit>
    }
    vExtiHandleInt(0);
 8001dba:	2000      	movs	r0, #0
 8001dbc:	f7ff ff8a 	bl	8001cd4 <vExtiHandleInt>
}
 8001dc0:	bf00      	nop
 8001dc2:	bd80      	pop	{r7, pc}

08001dc4 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void)
{
 8001dc4:	b580      	push	{r7, lr}
 8001dc6:	af00      	add	r7, sp, #0
    if (EXTI_GetITStatus(EXTI_Line1) != RESET)
 8001dc8:	2002      	movs	r0, #2
 8001dca:	f002 f91f 	bl	800400c <EXTI_GetITStatus>
 8001dce:	4603      	mov	r3, r0
 8001dd0:	2b00      	cmp	r3, #0
 8001dd2:	d002      	beq.n	8001dda <EXTI1_IRQHandler+0x16>
    {
        EXTI_ClearITPendingBit(EXTI_Line1);
 8001dd4:	2002      	movs	r0, #2
 8001dd6:	f002 f93d 	bl	8004054 <EXTI_ClearITPendingBit>
    }
    vExtiHandleInt(1);
 8001dda:	2001      	movs	r0, #1
 8001ddc:	f7ff ff7a 	bl	8001cd4 <vExtiHandleInt>
}
 8001de0:	bf00      	nop
 8001de2:	bd80      	pop	{r7, pc}

08001de4 <EXTI2_IRQHandler>:
void EXTI2_IRQHandler(void)
{
 8001de4:	b580      	push	{r7, lr}
 8001de6:	af00      	add	r7, sp, #0
    if (EXTI_GetITStatus(EXTI_Line2) != RESET)
 8001de8:	2004      	movs	r0, #4
 8001dea:	f002 f90f 	bl	800400c <EXTI_GetITStatus>
 8001dee:	4603      	mov	r3, r0
 8001df0:	2b00      	cmp	r3, #0
 8001df2:	d002      	beq.n	8001dfa <EXTI2_IRQHandler+0x16>
    {
        EXTI_ClearITPendingBit(EXTI_Line2);
 8001df4:	2004      	movs	r0, #4
 8001df6:	f002 f92d 	bl	8004054 <EXTI_ClearITPendingBit>
    }
    vExtiHandleInt(2);
 8001dfa:	2002      	movs	r0, #2
 8001dfc:	f7ff ff6a 	bl	8001cd4 <vExtiHandleInt>
}
 8001e00:	bf00      	nop
 8001e02:	bd80      	pop	{r7, pc}

08001e04 <EXTI15_10_IRQHandler>:
//
//This function handles External lines 10 to 15 interrupt request.
//
//**************************************************************************
void EXTI15_10_IRQHandler(void)
{
 8001e04:	b580      	push	{r7, lr}
 8001e06:	b082      	sub	sp, #8
 8001e08:	af00      	add	r7, sp, #0
	uint8_t line=0;
 8001e0a:	2300      	movs	r3, #0
 8001e0c:	71fb      	strb	r3, [r7, #7]

    if (EXTI_GetITStatus(EXTI_Line10) != RESET)
 8001e0e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001e12:	f002 f8fb 	bl	800400c <EXTI_GetITStatus>
 8001e16:	4603      	mov	r3, r0
 8001e18:	2b00      	cmp	r3, #0
 8001e1a:	d006      	beq.n	8001e2a <EXTI15_10_IRQHandler+0x26>
    {
    	line=10;
 8001e1c:	230a      	movs	r3, #10
 8001e1e:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line10);
 8001e20:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001e24:	f002 f916 	bl	8004054 <EXTI_ClearITPendingBit>
 8001e28:	e044      	b.n	8001eb4 <EXTI15_10_IRQHandler+0xb0>
    }
    else if (EXTI_GetITStatus(EXTI_Line11) != RESET)
 8001e2a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001e2e:	f002 f8ed 	bl	800400c <EXTI_GetITStatus>
 8001e32:	4603      	mov	r3, r0
 8001e34:	2b00      	cmp	r3, #0
 8001e36:	d006      	beq.n	8001e46 <EXTI15_10_IRQHandler+0x42>
    {
    	line=11;
 8001e38:	230b      	movs	r3, #11
 8001e3a:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line11);
 8001e3c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001e40:	f002 f908 	bl	8004054 <EXTI_ClearITPendingBit>
 8001e44:	e036      	b.n	8001eb4 <EXTI15_10_IRQHandler+0xb0>
    }
    else if (EXTI_GetITStatus(EXTI_Line12) != RESET)
 8001e46:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001e4a:	f002 f8df 	bl	800400c <EXTI_GetITStatus>
 8001e4e:	4603      	mov	r3, r0
 8001e50:	2b00      	cmp	r3, #0
 8001e52:	d006      	beq.n	8001e62 <EXTI15_10_IRQHandler+0x5e>
    {
    	line=12;
 8001e54:	230c      	movs	r3, #12
 8001e56:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line12);
 8001e58:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001e5c:	f002 f8fa 	bl	8004054 <EXTI_ClearITPendingBit>
 8001e60:	e028      	b.n	8001eb4 <EXTI15_10_IRQHandler+0xb0>
    }
    else if (EXTI_GetITStatus(EXTI_Line13) != RESET)
 8001e62:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001e66:	f002 f8d1 	bl	800400c <EXTI_GetITStatus>
 8001e6a:	4603      	mov	r3, r0
 8001e6c:	2b00      	cmp	r3, #0
 8001e6e:	d006      	beq.n	8001e7e <EXTI15_10_IRQHandler+0x7a>
    {
    	line=13;
 8001e70:	230d      	movs	r3, #13
 8001e72:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line13);
 8001e74:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001e78:	f002 f8ec 	bl	8004054 <EXTI_ClearITPendingBit>
 8001e7c:	e01a      	b.n	8001eb4 <EXTI15_10_IRQHandler+0xb0>
    }
    else if (EXTI_GetITStatus(EXTI_Line14) != RESET)
 8001e7e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001e82:	f002 f8c3 	bl	800400c <EXTI_GetITStatus>
 8001e86:	4603      	mov	r3, r0
 8001e88:	2b00      	cmp	r3, #0
 8001e8a:	d006      	beq.n	8001e9a <EXTI15_10_IRQHandler+0x96>
    {
    	line=14;
 8001e8c:	230e      	movs	r3, #14
 8001e8e:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line14);
 8001e90:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001e94:	f002 f8de 	bl	8004054 <EXTI_ClearITPendingBit>
 8001e98:	e00c      	b.n	8001eb4 <EXTI15_10_IRQHandler+0xb0>
    }
    else if (EXTI_GetITStatus(EXTI_Line15) != RESET)
 8001e9a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001e9e:	f002 f8b5 	bl	800400c <EXTI_GetITStatus>
 8001ea2:	4603      	mov	r3, r0
 8001ea4:	2b00      	cmp	r3, #0
 8001ea6:	d005      	beq.n	8001eb4 <EXTI15_10_IRQHandler+0xb0>
    {
    	line=15;
 8001ea8:	230f      	movs	r3, #15
 8001eaa:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line15);
 8001eac:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001eb0:	f002 f8d0 	bl	8004054 <EXTI_ClearITPendingBit>
    }

    vExtiHandleInt(line);
 8001eb4:	79fb      	ldrb	r3, [r7, #7]
 8001eb6:	4618      	mov	r0, r3
 8001eb8:	f7ff ff0c 	bl	8001cd4 <vExtiHandleInt>
}
 8001ebc:	bf00      	nop
 8001ebe:	3708      	adds	r7, #8
 8001ec0:	46bd      	mov	sp, r7
 8001ec2:	bd80      	pop	{r7, pc}

08001ec4 <EXTI9_5_IRQHandler>:
//
//This function handles External lines 9 to 5 interrupt request.
//
//**************************************************************************
void EXTI9_5_IRQHandler(void)
{
 8001ec4:	b580      	push	{r7, lr}
 8001ec6:	b082      	sub	sp, #8
 8001ec8:	af00      	add	r7, sp, #0
	uint8_t line=0;
 8001eca:	2300      	movs	r3, #0
 8001ecc:	71fb      	strb	r3, [r7, #7]

    if (EXTI_GetITStatus(EXTI_Line5) != RESET)
 8001ece:	2020      	movs	r0, #32
 8001ed0:	f002 f89c 	bl	800400c <EXTI_GetITStatus>
 8001ed4:	4603      	mov	r3, r0
 8001ed6:	2b00      	cmp	r3, #0
 8001ed8:	d005      	beq.n	8001ee6 <EXTI9_5_IRQHandler+0x22>
    {
    	line=5;
 8001eda:	2305      	movs	r3, #5
 8001edc:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line5);
 8001ede:	2020      	movs	r0, #32
 8001ee0:	f002 f8b8 	bl	8004054 <EXTI_ClearITPendingBit>
 8001ee4:	e032      	b.n	8001f4c <EXTI9_5_IRQHandler+0x88>
    }
    else if (EXTI_GetITStatus(EXTI_Line6) != RESET)
 8001ee6:	2040      	movs	r0, #64	; 0x40
 8001ee8:	f002 f890 	bl	800400c <EXTI_GetITStatus>
 8001eec:	4603      	mov	r3, r0
 8001eee:	2b00      	cmp	r3, #0
 8001ef0:	d005      	beq.n	8001efe <EXTI9_5_IRQHandler+0x3a>
    {
    	line=6;
 8001ef2:	2306      	movs	r3, #6
 8001ef4:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line6);
 8001ef6:	2040      	movs	r0, #64	; 0x40
 8001ef8:	f002 f8ac 	bl	8004054 <EXTI_ClearITPendingBit>
 8001efc:	e026      	b.n	8001f4c <EXTI9_5_IRQHandler+0x88>
    }
    else if (EXTI_GetITStatus(EXTI_Line7) != RESET)
 8001efe:	2080      	movs	r0, #128	; 0x80
 8001f00:	f002 f884 	bl	800400c <EXTI_GetITStatus>
 8001f04:	4603      	mov	r3, r0
 8001f06:	2b00      	cmp	r3, #0
 8001f08:	d005      	beq.n	8001f16 <EXTI9_5_IRQHandler+0x52>
    {
    	line=7;
 8001f0a:	2307      	movs	r3, #7
 8001f0c:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line7);
 8001f0e:	2080      	movs	r0, #128	; 0x80
 8001f10:	f002 f8a0 	bl	8004054 <EXTI_ClearITPendingBit>
 8001f14:	e01a      	b.n	8001f4c <EXTI9_5_IRQHandler+0x88>
    }
    else if (EXTI_GetITStatus(EXTI_Line8) != RESET)
 8001f16:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001f1a:	f002 f877 	bl	800400c <EXTI_GetITStatus>
 8001f1e:	4603      	mov	r3, r0
 8001f20:	2b00      	cmp	r3, #0
 8001f22:	d006      	beq.n	8001f32 <EXTI9_5_IRQHandler+0x6e>
    {
    	line=8;
 8001f24:	2308      	movs	r3, #8
 8001f26:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line8);
 8001f28:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001f2c:	f002 f892 	bl	8004054 <EXTI_ClearITPendingBit>
 8001f30:	e00c      	b.n	8001f4c <EXTI9_5_IRQHandler+0x88>
    }
    else if (EXTI_GetITStatus(EXTI_Line9) != RESET)
 8001f32:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001f36:	f002 f869 	bl	800400c <EXTI_GetITStatus>
 8001f3a:	4603      	mov	r3, r0
 8001f3c:	2b00      	cmp	r3, #0
 8001f3e:	d005      	beq.n	8001f4c <EXTI9_5_IRQHandler+0x88>
    {
    	line=9;
 8001f40:	2309      	movs	r3, #9
 8001f42:	71fb      	strb	r3, [r7, #7]
        EXTI_ClearITPendingBit(EXTI_Line9);
 8001f44:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001f48:	f002 f884 	bl	8004054 <EXTI_ClearITPendingBit>
    }

    vExtiHandleInt(line);
 8001f4c:	79fb      	ldrb	r3, [r7, #7]
 8001f4e:	4618      	mov	r0, r3
 8001f50:	f7ff fec0 	bl	8001cd4 <vExtiHandleInt>
}
 8001f54:	bf00      	nop
 8001f56:	3708      	adds	r7, #8
 8001f58:	46bd      	mov	sp, r7
 8001f5a:	bd80      	pop	{r7, pc}

08001f5c <EEPROM_LowLevel_Init>:
 * @brief  Initializes peripherals used by the I2C EEPROM driver.
 * @param  None
 * @retval None
 */
void EEPROM_LowLevel_Init(void)
{
 8001f5c:	b580      	push	{r7, lr}
 8001f5e:	b082      	sub	sp, #8
 8001f60:	af00      	add	r7, sp, #0

	GPIO_InitTypeDef  GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/*!< EEPROM_I2C_SCL_GPIO_CLK and EEPROM_I2C_SDA_GPIO_CLK Periph clock enable */
	RCC_APB2PeriphClockCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);
 8001f62:	2101      	movs	r1, #1
 8001f64:	2008      	movs	r0, #8
 8001f66:	f002 fe7f 	bl	8004c68 <RCC_APB2PeriphClockCmd>

	/*!< EEPROM_I2C Periph clock enable */
	RCC_APB1PeriphClockCmd(EEPROM_I2C_CLK, ENABLE);
 8001f6a:	2101      	movs	r1, #1
 8001f6c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8001f70:	f002 fe98 	bl	8004ca4 <RCC_APB1PeriphClockCmd>

	/*!< GPIO configuration */
	/*!< Configure EEPROM_I2C pins: SCL */
	GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_PIN;
 8001f74:	2340      	movs	r3, #64	; 0x40
 8001f76:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001f78:	2303      	movs	r3, #3
 8001f7a:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8001f7c:	231c      	movs	r3, #28
 8001f7e:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
 8001f80:	1d3b      	adds	r3, r7, #4
 8001f82:	4619      	mov	r1, r3
 8001f84:	4831      	ldr	r0, [pc, #196]	; (800204c <EEPROM_LowLevel_Init+0xf0>)
 8001f86:	f002 f8b9 	bl	80040fc <GPIO_Init>

	/*!< Configure EEPROM_I2C pins: SDA */
	GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_PIN;
 8001f8a:	2380      	movs	r3, #128	; 0x80
 8001f8c:	80bb      	strh	r3, [r7, #4]
	GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 8001f8e:	1d3b      	adds	r3, r7, #4
 8001f90:	4619      	mov	r1, r3
 8001f92:	482e      	ldr	r0, [pc, #184]	; (800204c <EEPROM_LowLevel_Init+0xf0>)
 8001f94:	f002 f8b2 	bl	80040fc <GPIO_Init>

	/* Configure and enable I2C DMA TX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EEPROM_I2C_DMA_TX_IRQn;
 8001f98:	2310      	movs	r3, #16
 8001f9a:	703b      	strb	r3, [r7, #0]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EEPROM_I2C_DMA_PREPRIO;
 8001f9c:	2303      	movs	r3, #3
 8001f9e:	707b      	strb	r3, [r7, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = EEPROM_I2C_DMA_SUBPRIO;
 8001fa0:	2303      	movs	r3, #3
 8001fa2:	70bb      	strb	r3, [r7, #2]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001fa4:	2301      	movs	r3, #1
 8001fa6:	70fb      	strb	r3, [r7, #3]
	NVIC_Init(&NVIC_InitStructure);
 8001fa8:	463b      	mov	r3, r7
 8001faa:	4618      	mov	r0, r3
 8001fac:	f001 fd8a 	bl	8003ac4 <NVIC_Init>

	/* Configure and enable I2C DMA RX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EEPROM_I2C_DMA_RX_IRQn;
 8001fb0:	2311      	movs	r3, #17
 8001fb2:	703b      	strb	r3, [r7, #0]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EEPROM_I2C_DMA_PREPRIO;
 8001fb4:	2303      	movs	r3, #3
 8001fb6:	707b      	strb	r3, [r7, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = EEPROM_I2C_DMA_SUBPRIO;
 8001fb8:	2303      	movs	r3, #3
 8001fba:	70bb      	strb	r3, [r7, #2]
	NVIC_Init(&NVIC_InitStructure);
 8001fbc:	463b      	mov	r3, r7
 8001fbe:	4618      	mov	r0, r3
 8001fc0:	f001 fd80 	bl	8003ac4 <NVIC_Init>

	/*!< I2C DMA TX and RX channels configuration */
	/* Enable the DMA clock */
	RCC_AHBPeriphClockCmd(EEPROM_I2C_DMA_CLK, ENABLE);
 8001fc4:	2101      	movs	r1, #1
 8001fc6:	2001      	movs	r0, #1
 8001fc8:	f002 fe30 	bl	8004c2c <RCC_AHBPeriphClockCmd>

	/* I2C TX DMA Channel configuration */
	DMA_DeInit(EEPROM_I2C_DMA_CHANNEL_TX);
 8001fcc:	4820      	ldr	r0, [pc, #128]	; (8002050 <EEPROM_LowLevel_Init+0xf4>)
 8001fce:	f001 fe35 	bl	8003c3c <DMA_DeInit>
	EEPROMDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)EEPROM_I2C_DR_Address;
 8001fd2:	4b20      	ldr	r3, [pc, #128]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001fd4:	4a20      	ldr	r2, [pc, #128]	; (8002058 <EEPROM_LowLevel_Init+0xfc>)
 8001fd6:	601a      	str	r2, [r3, #0]
	EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)0;   /* This parameter will be configured durig communication */
 8001fd8:	4b1e      	ldr	r3, [pc, #120]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001fda:	2200      	movs	r2, #0
 8001fdc:	605a      	str	r2, [r3, #4]
	EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;    /* This parameter will be configured durig communication */
 8001fde:	4b1d      	ldr	r3, [pc, #116]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001fe0:	2210      	movs	r2, #16
 8001fe2:	609a      	str	r2, [r3, #8]
	EEPROMDMA_InitStructure.DMA_BufferSize = 0xFFFF;            /* This parameter will be configured durig communication */
 8001fe4:	4b1b      	ldr	r3, [pc, #108]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001fe6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001fea:	60da      	str	r2, [r3, #12]
	EEPROMDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8001fec:	4b19      	ldr	r3, [pc, #100]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001fee:	2200      	movs	r2, #0
 8001ff0:	611a      	str	r2, [r3, #16]
	EEPROMDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8001ff2:	4b18      	ldr	r3, [pc, #96]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001ff4:	2280      	movs	r2, #128	; 0x80
 8001ff6:	615a      	str	r2, [r3, #20]
	EEPROMDMA_InitStructure.DMA_PeripheralDataSize = DMA_MemoryDataSize_Byte;
 8001ff8:	4b16      	ldr	r3, [pc, #88]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8001ffa:	2200      	movs	r2, #0
 8001ffc:	619a      	str	r2, [r3, #24]
	EEPROMDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8001ffe:	4b15      	ldr	r3, [pc, #84]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8002000:	2200      	movs	r2, #0
 8002002:	61da      	str	r2, [r3, #28]
	EEPROMDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8002004:	4b13      	ldr	r3, [pc, #76]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8002006:	2200      	movs	r2, #0
 8002008:	621a      	str	r2, [r3, #32]
	EEPROMDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 800200a:	4b12      	ldr	r3, [pc, #72]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 800200c:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8002010:	625a      	str	r2, [r3, #36]	; 0x24
	EEPROMDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8002012:	4b10      	ldr	r3, [pc, #64]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8002014:	2200      	movs	r2, #0
 8002016:	629a      	str	r2, [r3, #40]	; 0x28
	DMA_Init(EEPROM_I2C_DMA_CHANNEL_TX, &EEPROMDMA_InitStructure);
 8002018:	490e      	ldr	r1, [pc, #56]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 800201a:	480d      	ldr	r0, [pc, #52]	; (8002050 <EEPROM_LowLevel_Init+0xf4>)
 800201c:	f001 feca 	bl	8003db4 <DMA_Init>

	/* I2C RX DMA Channel configuration */
	DMA_DeInit(EEPROM_I2C_DMA_CHANNEL_RX);
 8002020:	480e      	ldr	r0, [pc, #56]	; (800205c <EEPROM_LowLevel_Init+0x100>)
 8002022:	f001 fe0b 	bl	8003c3c <DMA_DeInit>
	DMA_Init(EEPROM_I2C_DMA_CHANNEL_RX, &EEPROMDMA_InitStructure);
 8002026:	490b      	ldr	r1, [pc, #44]	; (8002054 <EEPROM_LowLevel_Init+0xf8>)
 8002028:	480c      	ldr	r0, [pc, #48]	; (800205c <EEPROM_LowLevel_Init+0x100>)
 800202a:	f001 fec3 	bl	8003db4 <DMA_Init>

	/* Enable the DMA Channels Interrupts */
	DMA_ITConfig(EEPROM_I2C_DMA_CHANNEL_TX, DMA_IT_TC, ENABLE);
 800202e:	2201      	movs	r2, #1
 8002030:	2102      	movs	r1, #2
 8002032:	4807      	ldr	r0, [pc, #28]	; (8002050 <EEPROM_LowLevel_Init+0xf4>)
 8002034:	f001 ff18 	bl	8003e68 <DMA_ITConfig>
	DMA_ITConfig(EEPROM_I2C_DMA_CHANNEL_RX, DMA_IT_TC, ENABLE);
 8002038:	2201      	movs	r2, #1
 800203a:	2102      	movs	r1, #2
 800203c:	4807      	ldr	r0, [pc, #28]	; (800205c <EEPROM_LowLevel_Init+0x100>)
 800203e:	f001 ff13 	bl	8003e68 <DMA_ITConfig>
}
 8002042:	bf00      	nop
 8002044:	3708      	adds	r7, #8
 8002046:	46bd      	mov	sp, r7
 8002048:	bd80      	pop	{r7, pc}
 800204a:	bf00      	nop
 800204c:	40010c00 	.word	0x40010c00
 8002050:	4002006c 	.word	0x4002006c
 8002054:	2000028c 	.word	0x2000028c
 8002058:	40005410 	.word	0x40005410
 800205c:	40020080 	.word	0x40020080

08002060 <EEPROM_LowLevel_DMAConfig>:
 * @brief  Initializes DMA channel used by the I2C EEPROM driver.
 * @param  None
 * @retval None
 */
void EEPROM_LowLevel_DMAConfig(uint32_t pBuffer, uint32_t BufferSize, uint32_t Direction)
{
 8002060:	b580      	push	{r7, lr}
 8002062:	b084      	sub	sp, #16
 8002064:	af00      	add	r7, sp, #0
 8002066:	60f8      	str	r0, [r7, #12]
 8002068:	60b9      	str	r1, [r7, #8]
 800206a:	607a      	str	r2, [r7, #4]
	/* Initialize the DMA with the new parameters */
	if (Direction == EEPROM_DIRECTION_TX)
 800206c:	687b      	ldr	r3, [r7, #4]
 800206e:	2b00      	cmp	r3, #0
 8002070:	d10d      	bne.n	800208e <EEPROM_LowLevel_DMAConfig+0x2e>
	{
		/* Configure the DMA Tx Channel with the buffer address and the buffer size */
		EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer;
 8002072:	4a0f      	ldr	r2, [pc, #60]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 8002074:	68fb      	ldr	r3, [r7, #12]
 8002076:	6053      	str	r3, [r2, #4]
		EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8002078:	4b0d      	ldr	r3, [pc, #52]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 800207a:	2210      	movs	r2, #16
 800207c:	609a      	str	r2, [r3, #8]
		EEPROMDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;
 800207e:	4a0c      	ldr	r2, [pc, #48]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 8002080:	68bb      	ldr	r3, [r7, #8]
 8002082:	60d3      	str	r3, [r2, #12]
		DMA_Init(EEPROM_I2C_DMA_CHANNEL_TX, &EEPROMDMA_InitStructure);
 8002084:	490a      	ldr	r1, [pc, #40]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 8002086:	480b      	ldr	r0, [pc, #44]	; (80020b4 <EEPROM_LowLevel_DMAConfig+0x54>)
 8002088:	f001 fe94 	bl	8003db4 <DMA_Init>
		EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer;
		EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
		EEPROMDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;
		DMA_Init(EEPROM_I2C_DMA_CHANNEL_RX, &EEPROMDMA_InitStructure);
	}
}
 800208c:	e00c      	b.n	80020a8 <EEPROM_LowLevel_DMAConfig+0x48>
		DMA_Init(EEPROM_I2C_DMA_CHANNEL_TX, &EEPROMDMA_InitStructure);
	}
	else
	{
		/* Configure the DMA Rx Channel with the buffer address and the buffer size */
		EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer;
 800208e:	4a08      	ldr	r2, [pc, #32]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 8002090:	68fb      	ldr	r3, [r7, #12]
 8002092:	6053      	str	r3, [r2, #4]
		EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8002094:	4b06      	ldr	r3, [pc, #24]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 8002096:	2200      	movs	r2, #0
 8002098:	609a      	str	r2, [r3, #8]
		EEPROMDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;
 800209a:	4a05      	ldr	r2, [pc, #20]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 800209c:	68bb      	ldr	r3, [r7, #8]
 800209e:	60d3      	str	r3, [r2, #12]
		DMA_Init(EEPROM_I2C_DMA_CHANNEL_RX, &EEPROMDMA_InitStructure);
 80020a0:	4903      	ldr	r1, [pc, #12]	; (80020b0 <EEPROM_LowLevel_DMAConfig+0x50>)
 80020a2:	4805      	ldr	r0, [pc, #20]	; (80020b8 <EEPROM_LowLevel_DMAConfig+0x58>)
 80020a4:	f001 fe86 	bl	8003db4 <DMA_Init>
	}
}
 80020a8:	bf00      	nop
 80020aa:	3710      	adds	r7, #16
 80020ac:	46bd      	mov	sp, r7
 80020ae:	bd80      	pop	{r7, pc}
 80020b0:	2000028c 	.word	0x2000028c
 80020b4:	4002006c 	.word	0x4002006c
 80020b8:	40020080 	.word	0x40020080

080020bc <EEPROM_Init>:
 * @brief  Initializes peripherals used by the I2C EEPROM driver.
 * @param  None
 * @retval None
 */
void EEPROM_Init(void)
{
 80020bc:	b580      	push	{r7, lr}
 80020be:	b084      	sub	sp, #16
 80020c0:	af00      	add	r7, sp, #0
	I2C_InitTypeDef  I2C_InitStructure;

	EEPROM_LowLevel_Init();
 80020c2:	f7ff ff4b 	bl	8001f5c <EEPROM_LowLevel_Init>

	/*!< I2C configuration */
	/* EEPROM_I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80020c6:	2300      	movs	r3, #0
 80020c8:	80bb      	strh	r3, [r7, #4]
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80020ca:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 80020ce:	80fb      	strh	r3, [r7, #6]
	I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;
 80020d0:	23a0      	movs	r3, #160	; 0xa0
 80020d2:	813b      	strh	r3, [r7, #8]
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80020d4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80020d8:	817b      	strh	r3, [r7, #10]
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80020da:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80020de:	81bb      	strh	r3, [r7, #12]
	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 80020e0:	4b0a      	ldr	r3, [pc, #40]	; (800210c <EEPROM_Init+0x50>)
 80020e2:	603b      	str	r3, [r7, #0]

	/* EEPROM_I2C Peripheral Enable */
	I2C_Cmd(EEPROM_I2C, ENABLE);
 80020e4:	2101      	movs	r1, #1
 80020e6:	480a      	ldr	r0, [pc, #40]	; (8002110 <EEPROM_Init+0x54>)
 80020e8:	f002 fa2a 	bl	8004540 <I2C_Cmd>
	/* Apply EEPROM_I2C configuration after enabling it */
	I2C_Init(EEPROM_I2C, &I2C_InitStructure);
 80020ec:	463b      	mov	r3, r7
 80020ee:	4619      	mov	r1, r3
 80020f0:	4807      	ldr	r0, [pc, #28]	; (8002110 <EEPROM_Init+0x54>)
 80020f2:	f002 f963 	bl	80043bc <I2C_Init>

	/* Enable the EEPROM_I2C peripheral DMA requests */
	I2C_DMACmd(EEPROM_I2C, ENABLE);
 80020f6:	2101      	movs	r1, #1
 80020f8:	4805      	ldr	r0, [pc, #20]	; (8002110 <EEPROM_Init+0x54>)
 80020fa:	f002 fa41 	bl	8004580 <I2C_DMACmd>

#if defined (EEPROM_M24C64_32)
	/*!< Select the EEPROM address according to the state of E0, E1, E2 pins */
	EEPROMAddress = EEPROM_HW_ADDRESS;
 80020fe:	4b05      	ldr	r3, [pc, #20]	; (8002114 <EEPROM_Init+0x58>)
 8002100:	22a0      	movs	r2, #160	; 0xa0
 8002102:	801a      	strh	r2, [r3, #0]
#endif /*!< EEPROM_M24C64_32 */
}
 8002104:	bf00      	nop
 8002106:	3710      	adds	r7, #16
 8002108:	46bd      	mov	sp, r7
 800210a:	bd80      	pop	{r7, pc}
 800210c:	000493e0 	.word	0x000493e0
 8002110:	40005400 	.word	0x40005400
 8002114:	2000017c 	.word	0x2000017c

08002118 <EEPROM_ReadBuffer>:
 *
 * @retval EEPROM_OK (0) if operation is correctly performed, else return value
 *         different from EEPROM_OK (0) or the timeout user callback.
 */
uint32_t EEPROM_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
{
 8002118:	b580      	push	{r7, lr}
 800211a:	b084      	sub	sp, #16
 800211c:	af00      	add	r7, sp, #0
 800211e:	60f8      	str	r0, [r7, #12]
 8002120:	460b      	mov	r3, r1
 8002122:	607a      	str	r2, [r7, #4]
 8002124:	817b      	strh	r3, [r7, #10]
	/* Set the pointer to the Number of data to be read. This pointer will be used
      by the DMA Transfer Completer interrupt Handler in order to reset the
      variable to 0. User should check on this variable in order to know if the
      DMA transfer has been complete or not. */
	EEPROMDataReadPointer = NumByteToRead;
 8002126:	4aa5      	ldr	r2, [pc, #660]	; (80023bc <EEPROM_ReadBuffer+0x2a4>)
 8002128:	687b      	ldr	r3, [r7, #4]
 800212a:	6013      	str	r3, [r2, #0]

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 800212c:	4ba4      	ldr	r3, [pc, #656]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800212e:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002132:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 8002134:	e00a      	b.n	800214c <EEPROM_ReadBuffer+0x34>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002136:	4ba2      	ldr	r3, [pc, #648]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002138:	681b      	ldr	r3, [r3, #0]
 800213a:	1e5a      	subs	r2, r3, #1
 800213c:	49a0      	ldr	r1, [pc, #640]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800213e:	600a      	str	r2, [r1, #0]
 8002140:	2b00      	cmp	r3, #0
 8002142:	d103      	bne.n	800214c <EEPROM_ReadBuffer+0x34>
 8002144:	f000 fc90 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002148:	4603      	mov	r3, r0
 800214a:	e132      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
      DMA transfer has been complete or not. */
	EEPROMDataReadPointer = NumByteToRead;

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 800214c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8002150:	489c      	ldr	r0, [pc, #624]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002152:	f002 fb21 	bl	8004798 <I2C_GetFlagStatus>
 8002156:	4603      	mov	r3, r0
 8002158:	2b00      	cmp	r3, #0
 800215a:	d1ec      	bne.n	8002136 <EEPROM_ReadBuffer+0x1e>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 800215c:	2101      	movs	r1, #1
 800215e:	4899      	ldr	r0, [pc, #612]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002160:	f002 fa4e 	bl	8004600 <I2C_GenerateSTART>

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002164:	4b96      	ldr	r3, [pc, #600]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002166:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800216a:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 800216c:	e00a      	b.n	8002184 <EEPROM_ReadBuffer+0x6c>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800216e:	4b94      	ldr	r3, [pc, #592]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002170:	681b      	ldr	r3, [r3, #0]
 8002172:	1e5a      	subs	r2, r3, #1
 8002174:	4992      	ldr	r1, [pc, #584]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002176:	600a      	str	r2, [r1, #0]
 8002178:	2b00      	cmp	r3, #0
 800217a:	d103      	bne.n	8002184 <EEPROM_ReadBuffer+0x6c>
 800217c:	f000 fc74 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002180:	4603      	mov	r3, r0
 8002182:	e116      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002184:	4990      	ldr	r1, [pc, #576]	; (80023c8 <EEPROM_ReadBuffer+0x2b0>)
 8002186:	488f      	ldr	r0, [pc, #572]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002188:	f002 fad6 	bl	8004738 <I2C_CheckEvent>
 800218c:	4603      	mov	r3, r0
 800218e:	2b00      	cmp	r3, #0
 8002190:	d0ed      	beq.n	800216e <EEPROM_ReadBuffer+0x56>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send EEPROM address for write */
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);
 8002192:	4b8e      	ldr	r3, [pc, #568]	; (80023cc <EEPROM_ReadBuffer+0x2b4>)
 8002194:	881b      	ldrh	r3, [r3, #0]
 8002196:	b29b      	uxth	r3, r3
 8002198:	b2db      	uxtb	r3, r3
 800219a:	2200      	movs	r2, #0
 800219c:	4619      	mov	r1, r3
 800219e:	4889      	ldr	r0, [pc, #548]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80021a0:	f002 faac 	bl	80046fc <I2C_Send7bitAddress>

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80021a4:	4b86      	ldr	r3, [pc, #536]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80021a6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80021aa:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 80021ac:	e00a      	b.n	80021c4 <EEPROM_ReadBuffer+0xac>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80021ae:	4b84      	ldr	r3, [pc, #528]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80021b0:	681b      	ldr	r3, [r3, #0]
 80021b2:	1e5a      	subs	r2, r3, #1
 80021b4:	4982      	ldr	r1, [pc, #520]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80021b6:	600a      	str	r2, [r1, #0]
 80021b8:	2b00      	cmp	r3, #0
 80021ba:	d103      	bne.n	80021c4 <EEPROM_ReadBuffer+0xac>
 80021bc:	f000 fc54 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80021c0:	4603      	mov	r3, r0
 80021c2:	e0f6      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
	/*!< Send EEPROM address for write */
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 80021c4:	4982      	ldr	r1, [pc, #520]	; (80023d0 <EEPROM_ReadBuffer+0x2b8>)
 80021c6:	487f      	ldr	r0, [pc, #508]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80021c8:	f002 fab6 	bl	8004738 <I2C_CheckEvent>
 80021cc:	4603      	mov	r3, r0
 80021ce:	2b00      	cmp	r3, #0
 80021d0:	d0ed      	beq.n	80021ae <EEPROM_ReadBuffer+0x96>
	I2C_SendData(EEPROM_I2C, ReadAddr);

#elif defined (EEPROM_M24C64_32)

	/*!< Send the EEPROM's internal address to read from: MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));
 80021d2:	897b      	ldrh	r3, [r7, #10]
 80021d4:	0a1b      	lsrs	r3, r3, #8
 80021d6:	b29b      	uxth	r3, r3
 80021d8:	b2db      	uxtb	r3, r3
 80021da:	4619      	mov	r1, r3
 80021dc:	4879      	ldr	r0, [pc, #484]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80021de:	f002 fa6f 	bl	80046c0 <I2C_SendData>

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80021e2:	4b77      	ldr	r3, [pc, #476]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80021e4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80021e8:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 80021ea:	e00a      	b.n	8002202 <EEPROM_ReadBuffer+0xea>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80021ec:	4b74      	ldr	r3, [pc, #464]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80021ee:	681b      	ldr	r3, [r3, #0]
 80021f0:	1e5a      	subs	r2, r3, #1
 80021f2:	4973      	ldr	r1, [pc, #460]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80021f4:	600a      	str	r2, [r1, #0]
 80021f6:	2b00      	cmp	r3, #0
 80021f8:	d103      	bne.n	8002202 <EEPROM_ReadBuffer+0xea>
 80021fa:	f000 fc35 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80021fe:	4603      	mov	r3, r0
 8002200:	e0d7      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
	/*!< Send the EEPROM's internal address to read from: MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8002202:	4974      	ldr	r1, [pc, #464]	; (80023d4 <EEPROM_ReadBuffer+0x2bc>)
 8002204:	486f      	ldr	r0, [pc, #444]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002206:	f002 fa97 	bl	8004738 <I2C_CheckEvent>
 800220a:	4603      	mov	r3, r0
 800220c:	2b00      	cmp	r3, #0
 800220e:	d0ed      	beq.n	80021ec <EEPROM_ReadBuffer+0xd4>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send the EEPROM's internal address to read from: LSB of the address */
	I2C_SendData(EEPROM_I2C, (uint8_t)(ReadAddr & 0x00FF));
 8002210:	897b      	ldrh	r3, [r7, #10]
 8002212:	b2db      	uxtb	r3, r3
 8002214:	4619      	mov	r1, r3
 8002216:	486b      	ldr	r0, [pc, #428]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002218:	f002 fa52 	bl	80046c0 <I2C_SendData>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 800221c:	4b68      	ldr	r3, [pc, #416]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800221e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002222:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF) == RESET)
 8002224:	e00a      	b.n	800223c <EEPROM_ReadBuffer+0x124>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002226:	4b66      	ldr	r3, [pc, #408]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002228:	681b      	ldr	r3, [r3, #0]
 800222a:	1e5a      	subs	r2, r3, #1
 800222c:	4964      	ldr	r1, [pc, #400]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800222e:	600a      	str	r2, [r1, #0]
 8002230:	2b00      	cmp	r3, #0
 8002232:	d103      	bne.n	800223c <EEPROM_ReadBuffer+0x124>
 8002234:	f000 fc18 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002238:	4603      	mov	r3, r0
 800223a:	e0ba      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF) == RESET)
 800223c:	4966      	ldr	r1, [pc, #408]	; (80023d8 <EEPROM_ReadBuffer+0x2c0>)
 800223e:	4861      	ldr	r0, [pc, #388]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002240:	f002 faaa 	bl	8004798 <I2C_GetFlagStatus>
 8002244:	4603      	mov	r3, r0
 8002246:	2b00      	cmp	r3, #0
 8002248:	d0ed      	beq.n	8002226 <EEPROM_ReadBuffer+0x10e>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send STRAT condition a second time */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 800224a:	2101      	movs	r1, #1
 800224c:	485d      	ldr	r0, [pc, #372]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 800224e:	f002 f9d7 	bl	8004600 <I2C_GenerateSTART>

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002252:	4b5b      	ldr	r3, [pc, #364]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002254:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002258:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 800225a:	e00a      	b.n	8002272 <EEPROM_ReadBuffer+0x15a>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800225c:	4b58      	ldr	r3, [pc, #352]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800225e:	681b      	ldr	r3, [r3, #0]
 8002260:	1e5a      	subs	r2, r3, #1
 8002262:	4957      	ldr	r1, [pc, #348]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002264:	600a      	str	r2, [r1, #0]
 8002266:	2b00      	cmp	r3, #0
 8002268:	d103      	bne.n	8002272 <EEPROM_ReadBuffer+0x15a>
 800226a:	f000 fbfd 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 800226e:	4603      	mov	r3, r0
 8002270:	e09f      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
	/*!< Send STRAT condition a second time */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002272:	4955      	ldr	r1, [pc, #340]	; (80023c8 <EEPROM_ReadBuffer+0x2b0>)
 8002274:	4853      	ldr	r0, [pc, #332]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002276:	f002 fa5f 	bl	8004738 <I2C_CheckEvent>
 800227a:	4603      	mov	r3, r0
 800227c:	2b00      	cmp	r3, #0
 800227e:	d0ed      	beq.n	800225c <EEPROM_ReadBuffer+0x144>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send EEPROM address for read */
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Receiver);
 8002280:	4b52      	ldr	r3, [pc, #328]	; (80023cc <EEPROM_ReadBuffer+0x2b4>)
 8002282:	881b      	ldrh	r3, [r3, #0]
 8002284:	b29b      	uxth	r3, r3
 8002286:	b2db      	uxtb	r3, r3
 8002288:	2201      	movs	r2, #1
 800228a:	4619      	mov	r1, r3
 800228c:	484d      	ldr	r0, [pc, #308]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 800228e:	f002 fa35 	bl	80046fc <I2C_Send7bitAddress>

	/* If number of data to be read is 1, then DMA couldn't be used */
	/* One Byte Master Reception procedure (POLLING) ---------------------------*/
	if ((uint16_t)(*NumByteToRead) < 2)
 8002292:	687b      	ldr	r3, [r7, #4]
 8002294:	881b      	ldrh	r3, [r3, #0]
 8002296:	2b01      	cmp	r3, #1
 8002298:	d864      	bhi.n	8002364 <EEPROM_ReadBuffer+0x24c>
	{
		/* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 800229a:	4b49      	ldr	r3, [pc, #292]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800229c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80022a0:	601a      	str	r2, [r3, #0]
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET)
 80022a2:	e00a      	b.n	80022ba <EEPROM_ReadBuffer+0x1a2>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80022a4:	4b46      	ldr	r3, [pc, #280]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80022a6:	681b      	ldr	r3, [r3, #0]
 80022a8:	1e5a      	subs	r2, r3, #1
 80022aa:	4945      	ldr	r1, [pc, #276]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80022ac:	600a      	str	r2, [r1, #0]
 80022ae:	2b00      	cmp	r3, #0
 80022b0:	d103      	bne.n	80022ba <EEPROM_ReadBuffer+0x1a2>
 80022b2:	f000 fbd9 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80022b6:	4603      	mov	r3, r0
 80022b8:	e07b      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
	/* One Byte Master Reception procedure (POLLING) ---------------------------*/
	if ((uint16_t)(*NumByteToRead) < 2)
	{
		/* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET)
 80022ba:	4948      	ldr	r1, [pc, #288]	; (80023dc <EEPROM_ReadBuffer+0x2c4>)
 80022bc:	4841      	ldr	r0, [pc, #260]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80022be:	f002 fa6b 	bl	8004798 <I2C_GetFlagStatus>
 80022c2:	4603      	mov	r3, r0
 80022c4:	2b00      	cmp	r3, #0
 80022c6:	d0ed      	beq.n	80022a4 <EEPROM_ReadBuffer+0x18c>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Disable Acknowledgement */
		I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);
 80022c8:	2100      	movs	r1, #0
 80022ca:	483e      	ldr	r0, [pc, #248]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80022cc:	f002 f9d8 	bl	8004680 <I2C_AcknowledgeConfig>

		/* Call User callback for critical section start (should typically disable interrupts) */
		EEPROM_EnterCriticalSection_UserCallback();
 80022d0:	f000 fbce 	bl	8002a70 <EEPROM_EnterCriticalSection_UserCallback>

		/* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
		(void)EEPROM_I2C->SR2;
 80022d4:	4b3b      	ldr	r3, [pc, #236]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80022d6:	8b1b      	ldrh	r3, [r3, #24]

		/*!< Send STOP Condition */
		I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 80022d8:	2101      	movs	r1, #1
 80022da:	483a      	ldr	r0, [pc, #232]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80022dc:	f002 f9b0 	bl	8004640 <I2C_GenerateSTOP>

		/* Call User callback for critical section end (should typically re-enable interrupts) */
		EEPROM_ExitCriticalSection_UserCallback();
 80022e0:	f000 fbce 	bl	8002a80 <EEPROM_ExitCriticalSection_UserCallback>

		/* Wait for the byte to be received */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80022e4:	4b36      	ldr	r3, [pc, #216]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80022e6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80022ea:	601a      	str	r2, [r3, #0]
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_RXNE) == RESET)
 80022ec:	e00a      	b.n	8002304 <EEPROM_ReadBuffer+0x1ec>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80022ee:	4b34      	ldr	r3, [pc, #208]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80022f0:	681b      	ldr	r3, [r3, #0]
 80022f2:	1e5a      	subs	r2, r3, #1
 80022f4:	4932      	ldr	r1, [pc, #200]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 80022f6:	600a      	str	r2, [r1, #0]
 80022f8:	2b00      	cmp	r3, #0
 80022fa:	d103      	bne.n	8002304 <EEPROM_ReadBuffer+0x1ec>
 80022fc:	f000 fbb4 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002300:	4603      	mov	r3, r0
 8002302:	e056      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
		/* Call User callback for critical section end (should typically re-enable interrupts) */
		EEPROM_ExitCriticalSection_UserCallback();

		/* Wait for the byte to be received */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_RXNE) == RESET)
 8002304:	4936      	ldr	r1, [pc, #216]	; (80023e0 <EEPROM_ReadBuffer+0x2c8>)
 8002306:	482f      	ldr	r0, [pc, #188]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002308:	f002 fa46 	bl	8004798 <I2C_GetFlagStatus>
 800230c:	4603      	mov	r3, r0
 800230e:	2b00      	cmp	r3, #0
 8002310:	d0ed      	beq.n	80022ee <EEPROM_ReadBuffer+0x1d6>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Read the byte received from the EEPROM */
		*pBuffer = I2C_ReceiveData(EEPROM_I2C);
 8002312:	482c      	ldr	r0, [pc, #176]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002314:	f002 f9e4 	bl	80046e0 <I2C_ReceiveData>
 8002318:	4603      	mov	r3, r0
 800231a:	461a      	mov	r2, r3
 800231c:	68fb      	ldr	r3, [r7, #12]
 800231e:	701a      	strb	r2, [r3, #0]

		/*!< Decrement the read bytes counter */
		(uint16_t)(*NumByteToRead)--;
 8002320:	687b      	ldr	r3, [r7, #4]
 8002322:	881b      	ldrh	r3, [r3, #0]
 8002324:	3b01      	subs	r3, #1
 8002326:	b29a      	uxth	r2, r3
 8002328:	687b      	ldr	r3, [r7, #4]
 800232a:	801a      	strh	r2, [r3, #0]

		/* Wait to make sure that STOP control bit has been cleared */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 800232c:	4b24      	ldr	r3, [pc, #144]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800232e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002332:	601a      	str	r2, [r3, #0]
		while(EEPROM_I2C->CR1 & I2C_CR1_STOP)
 8002334:	e00a      	b.n	800234c <EEPROM_ReadBuffer+0x234>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002336:	4b22      	ldr	r3, [pc, #136]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002338:	681b      	ldr	r3, [r3, #0]
 800233a:	1e5a      	subs	r2, r3, #1
 800233c:	4920      	ldr	r1, [pc, #128]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 800233e:	600a      	str	r2, [r1, #0]
 8002340:	2b00      	cmp	r3, #0
 8002342:	d103      	bne.n	800234c <EEPROM_ReadBuffer+0x234>
 8002344:	f000 fb90 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002348:	4603      	mov	r3, r0
 800234a:	e032      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
		/*!< Decrement the read bytes counter */
		(uint16_t)(*NumByteToRead)--;

		/* Wait to make sure that STOP control bit has been cleared */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(EEPROM_I2C->CR1 & I2C_CR1_STOP)
 800234c:	4b1d      	ldr	r3, [pc, #116]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 800234e:	881b      	ldrh	r3, [r3, #0]
 8002350:	b29b      	uxth	r3, r3
 8002352:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002356:	2b00      	cmp	r3, #0
 8002358:	d1ed      	bne.n	8002336 <EEPROM_ReadBuffer+0x21e>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Re-Enable Acknowledgement to be ready for another reception */
		I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);
 800235a:	2101      	movs	r1, #1
 800235c:	4819      	ldr	r0, [pc, #100]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 800235e:	f002 f98f 	bl	8004680 <I2C_AcknowledgeConfig>
 8002362:	e025      	b.n	80023b0 <EEPROM_ReadBuffer+0x298>
	}
	else/* More than one Byte Master Reception procedure (DMA) -----------------*/
	{
		/*!< Test on EV6 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002364:	4b16      	ldr	r3, [pc, #88]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002366:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800236a:	601a      	str	r2, [r3, #0]
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 800236c:	e00a      	b.n	8002384 <EEPROM_ReadBuffer+0x26c>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800236e:	4b14      	ldr	r3, [pc, #80]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002370:	681b      	ldr	r3, [r3, #0]
 8002372:	1e5a      	subs	r2, r3, #1
 8002374:	4912      	ldr	r1, [pc, #72]	; (80023c0 <EEPROM_ReadBuffer+0x2a8>)
 8002376:	600a      	str	r2, [r1, #0]
 8002378:	2b00      	cmp	r3, #0
 800237a:	d103      	bne.n	8002384 <EEPROM_ReadBuffer+0x26c>
 800237c:	f000 fb74 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002380:	4603      	mov	r3, r0
 8002382:	e016      	b.n	80023b2 <EEPROM_ReadBuffer+0x29a>
	}
	else/* More than one Byte Master Reception procedure (DMA) -----------------*/
	{
		/*!< Test on EV6 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 8002384:	4917      	ldr	r1, [pc, #92]	; (80023e4 <EEPROM_ReadBuffer+0x2cc>)
 8002386:	480f      	ldr	r0, [pc, #60]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 8002388:	f002 f9d6 	bl	8004738 <I2C_CheckEvent>
 800238c:	4603      	mov	r3, r0
 800238e:	2b00      	cmp	r3, #0
 8002390:	d0ed      	beq.n	800236e <EEPROM_ReadBuffer+0x256>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/* Configure the DMA Rx Channel with the buffer address and the buffer size */
		EEPROM_LowLevel_DMAConfig((uint32_t)pBuffer, (uint16_t)(*NumByteToRead), EEPROM_DIRECTION_RX);
 8002392:	68f8      	ldr	r0, [r7, #12]
 8002394:	687b      	ldr	r3, [r7, #4]
 8002396:	881b      	ldrh	r3, [r3, #0]
 8002398:	2201      	movs	r2, #1
 800239a:	4619      	mov	r1, r3
 800239c:	f7ff fe60 	bl	8002060 <EEPROM_LowLevel_DMAConfig>

		/* Inform the DMA that the next End Of Transfer Signal will be the last one */
		I2C_DMALastTransferCmd(EEPROM_I2C, ENABLE);
 80023a0:	2101      	movs	r1, #1
 80023a2:	4808      	ldr	r0, [pc, #32]	; (80023c4 <EEPROM_ReadBuffer+0x2ac>)
 80023a4:	f002 f90c 	bl	80045c0 <I2C_DMALastTransferCmd>

		/* Enable the DMA Rx Channel */
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_RX, ENABLE);
 80023a8:	2101      	movs	r1, #1
 80023aa:	480f      	ldr	r0, [pc, #60]	; (80023e8 <EEPROM_ReadBuffer+0x2d0>)
 80023ac:	f001 fd40 	bl	8003e30 <DMA_Cmd>
	}

	/* If all operations OK, return EEPROM_OK (0) */
	return EEPROM_OK;
 80023b0:	2300      	movs	r3, #0
}
 80023b2:	4618      	mov	r0, r3
 80023b4:	3710      	adds	r7, #16
 80023b6:	46bd      	mov	sp, r7
 80023b8:	bd80      	pop	{r7, pc}
 80023ba:	bf00      	nop
 80023bc:	20000288 	.word	0x20000288
 80023c0:	20000000 	.word	0x20000000
 80023c4:	40005400 	.word	0x40005400
 80023c8:	00030001 	.word	0x00030001
 80023cc:	2000017c 	.word	0x2000017c
 80023d0:	00070082 	.word	0x00070082
 80023d4:	00070084 	.word	0x00070084
 80023d8:	10000004 	.word	0x10000004
 80023dc:	10000002 	.word	0x10000002
 80023e0:	10000040 	.word	0x10000040
 80023e4:	00030002 	.word	0x00030002
 80023e8:	40020080 	.word	0x40020080

080023ec <EEPROM_WritePage>:
 *
 * @retval EEPROM_OK (0) if operation is correctly performed, else return value
 *         different from EEPROM_OK (0) or the timeout user callback.
 */
uint32_t EEPROM_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite)
{
 80023ec:	b580      	push	{r7, lr}
 80023ee:	b084      	sub	sp, #16
 80023f0:	af00      	add	r7, sp, #0
 80023f2:	60f8      	str	r0, [r7, #12]
 80023f4:	460b      	mov	r3, r1
 80023f6:	607a      	str	r2, [r7, #4]
 80023f8:	817b      	strh	r3, [r7, #10]
	/* Set the pointer to the Number of data to be written. This pointer will be used
      by the DMA Transfer Completer interrupt Handler in order to reset the
      variable to 0. User should check on this variable in order to know if the
      DMA transfer has been complete or not. */
	EEPROMDataWritePointer = NumByteToWrite;
 80023fa:	4a53      	ldr	r2, [pc, #332]	; (8002548 <EEPROM_WritePage+0x15c>)
 80023fc:	687b      	ldr	r3, [r7, #4]
 80023fe:	6013      	str	r3, [r2, #0]

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002400:	4b52      	ldr	r3, [pc, #328]	; (800254c <EEPROM_WritePage+0x160>)
 8002402:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002406:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 8002408:	e00a      	b.n	8002420 <EEPROM_WritePage+0x34>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800240a:	4b50      	ldr	r3, [pc, #320]	; (800254c <EEPROM_WritePage+0x160>)
 800240c:	681b      	ldr	r3, [r3, #0]
 800240e:	1e5a      	subs	r2, r3, #1
 8002410:	494e      	ldr	r1, [pc, #312]	; (800254c <EEPROM_WritePage+0x160>)
 8002412:	600a      	str	r2, [r1, #0]
 8002414:	2b00      	cmp	r3, #0
 8002416:	d103      	bne.n	8002420 <EEPROM_WritePage+0x34>
 8002418:	f000 fb26 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 800241c:	4603      	mov	r3, r0
 800241e:	e08e      	b.n	800253e <EEPROM_WritePage+0x152>
      DMA transfer has been complete or not. */
	EEPROMDataWritePointer = NumByteToWrite;

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 8002420:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8002424:	484a      	ldr	r0, [pc, #296]	; (8002550 <EEPROM_WritePage+0x164>)
 8002426:	f002 f9b7 	bl	8004798 <I2C_GetFlagStatus>
 800242a:	4603      	mov	r3, r0
 800242c:	2b00      	cmp	r3, #0
 800242e:	d1ec      	bne.n	800240a <EEPROM_WritePage+0x1e>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 8002430:	2101      	movs	r1, #1
 8002432:	4847      	ldr	r0, [pc, #284]	; (8002550 <EEPROM_WritePage+0x164>)
 8002434:	f002 f8e4 	bl	8004600 <I2C_GenerateSTART>

	/*!< Test on EV5 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002438:	4b44      	ldr	r3, [pc, #272]	; (800254c <EEPROM_WritePage+0x160>)
 800243a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800243e:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002440:	e00a      	b.n	8002458 <EEPROM_WritePage+0x6c>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002442:	4b42      	ldr	r3, [pc, #264]	; (800254c <EEPROM_WritePage+0x160>)
 8002444:	681b      	ldr	r3, [r3, #0]
 8002446:	1e5a      	subs	r2, r3, #1
 8002448:	4940      	ldr	r1, [pc, #256]	; (800254c <EEPROM_WritePage+0x160>)
 800244a:	600a      	str	r2, [r1, #0]
 800244c:	2b00      	cmp	r3, #0
 800244e:	d103      	bne.n	8002458 <EEPROM_WritePage+0x6c>
 8002450:	f000 fb0a 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002454:	4603      	mov	r3, r0
 8002456:	e072      	b.n	800253e <EEPROM_WritePage+0x152>
	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);

	/*!< Test on EV5 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002458:	493e      	ldr	r1, [pc, #248]	; (8002554 <EEPROM_WritePage+0x168>)
 800245a:	483d      	ldr	r0, [pc, #244]	; (8002550 <EEPROM_WritePage+0x164>)
 800245c:	f002 f96c 	bl	8004738 <I2C_CheckEvent>
 8002460:	4603      	mov	r3, r0
 8002462:	2b00      	cmp	r3, #0
 8002464:	d0ed      	beq.n	8002442 <EEPROM_WritePage+0x56>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send EEPROM address for write */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002466:	4b39      	ldr	r3, [pc, #228]	; (800254c <EEPROM_WritePage+0x160>)
 8002468:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800246c:	601a      	str	r2, [r3, #0]
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);
 800246e:	4b3a      	ldr	r3, [pc, #232]	; (8002558 <EEPROM_WritePage+0x16c>)
 8002470:	881b      	ldrh	r3, [r3, #0]
 8002472:	b29b      	uxth	r3, r3
 8002474:	b2db      	uxtb	r3, r3
 8002476:	2200      	movs	r2, #0
 8002478:	4619      	mov	r1, r3
 800247a:	4835      	ldr	r0, [pc, #212]	; (8002550 <EEPROM_WritePage+0x164>)
 800247c:	f002 f93e 	bl	80046fc <I2C_Send7bitAddress>

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002480:	4b32      	ldr	r3, [pc, #200]	; (800254c <EEPROM_WritePage+0x160>)
 8002482:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002486:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8002488:	e00a      	b.n	80024a0 <EEPROM_WritePage+0xb4>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800248a:	4b30      	ldr	r3, [pc, #192]	; (800254c <EEPROM_WritePage+0x160>)
 800248c:	681b      	ldr	r3, [r3, #0]
 800248e:	1e5a      	subs	r2, r3, #1
 8002490:	492e      	ldr	r1, [pc, #184]	; (800254c <EEPROM_WritePage+0x160>)
 8002492:	600a      	str	r2, [r1, #0]
 8002494:	2b00      	cmp	r3, #0
 8002496:	d103      	bne.n	80024a0 <EEPROM_WritePage+0xb4>
 8002498:	f000 fae6 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 800249c:	4603      	mov	r3, r0
 800249e:	e04e      	b.n	800253e <EEPROM_WritePage+0x152>
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 80024a0:	492e      	ldr	r1, [pc, #184]	; (800255c <EEPROM_WritePage+0x170>)
 80024a2:	482b      	ldr	r0, [pc, #172]	; (8002550 <EEPROM_WritePage+0x164>)
 80024a4:	f002 f948 	bl	8004738 <I2C_CheckEvent>
 80024a8:	4603      	mov	r3, r0
 80024aa:	2b00      	cmp	r3, #0
 80024ac:	d0ed      	beq.n	800248a <EEPROM_WritePage+0x9e>
	I2C_SendData(EEPROM_I2C, WriteAddr);

#elif defined(EEPROM_M24C64_32)

	/*!< Send the EEPROM's internal address to write to : MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));
 80024ae:	897b      	ldrh	r3, [r7, #10]
 80024b0:	0a1b      	lsrs	r3, r3, #8
 80024b2:	b29b      	uxth	r3, r3
 80024b4:	b2db      	uxtb	r3, r3
 80024b6:	4619      	mov	r1, r3
 80024b8:	4825      	ldr	r0, [pc, #148]	; (8002550 <EEPROM_WritePage+0x164>)
 80024ba:	f002 f901 	bl	80046c0 <I2C_SendData>

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80024be:	4b23      	ldr	r3, [pc, #140]	; (800254c <EEPROM_WritePage+0x160>)
 80024c0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80024c4:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 80024c6:	e00a      	b.n	80024de <EEPROM_WritePage+0xf2>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80024c8:	4b20      	ldr	r3, [pc, #128]	; (800254c <EEPROM_WritePage+0x160>)
 80024ca:	681b      	ldr	r3, [r3, #0]
 80024cc:	1e5a      	subs	r2, r3, #1
 80024ce:	491f      	ldr	r1, [pc, #124]	; (800254c <EEPROM_WritePage+0x160>)
 80024d0:	600a      	str	r2, [r1, #0]
 80024d2:	2b00      	cmp	r3, #0
 80024d4:	d103      	bne.n	80024de <EEPROM_WritePage+0xf2>
 80024d6:	f000 fac7 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80024da:	4603      	mov	r3, r0
 80024dc:	e02f      	b.n	800253e <EEPROM_WritePage+0x152>
	/*!< Send the EEPROM's internal address to write to : MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 80024de:	4920      	ldr	r1, [pc, #128]	; (8002560 <EEPROM_WritePage+0x174>)
 80024e0:	481b      	ldr	r0, [pc, #108]	; (8002550 <EEPROM_WritePage+0x164>)
 80024e2:	f002 f929 	bl	8004738 <I2C_CheckEvent>
 80024e6:	4603      	mov	r3, r0
 80024e8:	2b00      	cmp	r3, #0
 80024ea:	d0ed      	beq.n	80024c8 <EEPROM_WritePage+0xdc>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send the EEPROM's internal address to write to : LSB of the address */
	I2C_SendData(EEPROM_I2C, (uint8_t)(WriteAddr & 0x00FF));
 80024ec:	897b      	ldrh	r3, [r7, #10]
 80024ee:	b2db      	uxtb	r3, r3
 80024f0:	4619      	mov	r1, r3
 80024f2:	4817      	ldr	r0, [pc, #92]	; (8002550 <EEPROM_WritePage+0x164>)
 80024f4:	f002 f8e4 	bl	80046c0 <I2C_SendData>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80024f8:	4b14      	ldr	r3, [pc, #80]	; (800254c <EEPROM_WritePage+0x160>)
 80024fa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80024fe:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8002500:	e00a      	b.n	8002518 <EEPROM_WritePage+0x12c>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002502:	4b12      	ldr	r3, [pc, #72]	; (800254c <EEPROM_WritePage+0x160>)
 8002504:	681b      	ldr	r3, [r3, #0]
 8002506:	1e5a      	subs	r2, r3, #1
 8002508:	4910      	ldr	r1, [pc, #64]	; (800254c <EEPROM_WritePage+0x160>)
 800250a:	600a      	str	r2, [r1, #0]
 800250c:	2b00      	cmp	r3, #0
 800250e:	d103      	bne.n	8002518 <EEPROM_WritePage+0x12c>
 8002510:	f000 faaa 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002514:	4603      	mov	r3, r0
 8002516:	e012      	b.n	800253e <EEPROM_WritePage+0x152>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8002518:	4911      	ldr	r1, [pc, #68]	; (8002560 <EEPROM_WritePage+0x174>)
 800251a:	480d      	ldr	r0, [pc, #52]	; (8002550 <EEPROM_WritePage+0x164>)
 800251c:	f002 f90c 	bl	8004738 <I2C_CheckEvent>
 8002520:	4603      	mov	r3, r0
 8002522:	2b00      	cmp	r3, #0
 8002524:	d0ed      	beq.n	8002502 <EEPROM_WritePage+0x116>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/* Configure the DMA Tx Channel with the buffer address and the buffer size */
	EEPROM_LowLevel_DMAConfig((uint32_t)pBuffer, (uint8_t)(*NumByteToWrite), EEPROM_DIRECTION_TX);
 8002526:	68f8      	ldr	r0, [r7, #12]
 8002528:	687b      	ldr	r3, [r7, #4]
 800252a:	781b      	ldrb	r3, [r3, #0]
 800252c:	2200      	movs	r2, #0
 800252e:	4619      	mov	r1, r3
 8002530:	f7ff fd96 	bl	8002060 <EEPROM_LowLevel_DMAConfig>

	/* Enable the DMA Tx Channel */
	DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_TX, ENABLE);
 8002534:	2101      	movs	r1, #1
 8002536:	480b      	ldr	r0, [pc, #44]	; (8002564 <EEPROM_WritePage+0x178>)
 8002538:	f001 fc7a 	bl	8003e30 <DMA_Cmd>

	/* If all operations OK, return EEPROM_OK (0) */
	return EEPROM_OK;
 800253c:	2300      	movs	r3, #0
}
 800253e:	4618      	mov	r0, r3
 8002540:	3710      	adds	r7, #16
 8002542:	46bd      	mov	sp, r7
 8002544:	bd80      	pop	{r7, pc}
 8002546:	bf00      	nop
 8002548:	20000284 	.word	0x20000284
 800254c:	20000000 	.word	0x20000000
 8002550:	40005400 	.word	0x40005400
 8002554:	00030001 	.word	0x00030001
 8002558:	2000017c 	.word	0x2000017c
 800255c:	00070082 	.word	0x00070082
 8002560:	00070084 	.word	0x00070084
 8002564:	4002006c 	.word	0x4002006c

08002568 <EEPROM_WriteBuffer>:
 * @param  WriteAddr : EEPROM's internal address to write to.
 * @param  NumByteToWrite : number of bytes to write to the EEPROM.
 * @retval None
 */
void EEPROM_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
{
 8002568:	b580      	push	{r7, lr}
 800256a:	b084      	sub	sp, #16
 800256c:	af00      	add	r7, sp, #0
 800256e:	6078      	str	r0, [r7, #4]
 8002570:	460b      	mov	r3, r1
 8002572:	807b      	strh	r3, [r7, #2]
 8002574:	4613      	mov	r3, r2
 8002576:	803b      	strh	r3, [r7, #0]
	uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
 8002578:	2300      	movs	r3, #0
 800257a:	73fb      	strb	r3, [r7, #15]
 800257c:	2300      	movs	r3, #0
 800257e:	73bb      	strb	r3, [r7, #14]
 8002580:	2300      	movs	r3, #0
 8002582:	737b      	strb	r3, [r7, #13]
	uint16_t Addr = 0;
 8002584:	2300      	movs	r3, #0
 8002586:	817b      	strh	r3, [r7, #10]

	Addr = WriteAddr % EEPROM_PAGESIZE;
 8002588:	887b      	ldrh	r3, [r7, #2]
 800258a:	f003 031f 	and.w	r3, r3, #31
 800258e:	817b      	strh	r3, [r7, #10]
	count = EEPROM_PAGESIZE - Addr;
 8002590:	897b      	ldrh	r3, [r7, #10]
 8002592:	b2db      	uxtb	r3, r3
 8002594:	f1c3 0320 	rsb	r3, r3, #32
 8002598:	737b      	strb	r3, [r7, #13]
	NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;
 800259a:	883b      	ldrh	r3, [r7, #0]
 800259c:	095b      	lsrs	r3, r3, #5
 800259e:	b29b      	uxth	r3, r3
 80025a0:	73fb      	strb	r3, [r7, #15]
	NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;
 80025a2:	883b      	ldrh	r3, [r7, #0]
 80025a4:	b2db      	uxtb	r3, r3
 80025a6:	f003 031f 	and.w	r3, r3, #31
 80025aa:	73bb      	strb	r3, [r7, #14]

	/*!< If WriteAddr is EEPROM_PAGESIZE aligned  */
	if(Addr == 0)
 80025ac:	897b      	ldrh	r3, [r7, #10]
 80025ae:	2b00      	cmp	r3, #0
 80025b0:	d170      	bne.n	8002694 <EEPROM_WriteBuffer+0x12c>
	{
		/*!< If NumByteToWrite < EEPROM_PAGESIZE */
		if(NumOfPage == 0)
 80025b2:	7bfb      	ldrb	r3, [r7, #15]
 80025b4:	2b00      	cmp	r3, #0
 80025b6:	d144      	bne.n	8002642 <EEPROM_WriteBuffer+0xda>
		{
			/* Store the number of data to be written */
			EEPROMDataNum = NumOfSingle;
 80025b8:	4a98      	ldr	r2, [pc, #608]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80025ba:	7bbb      	ldrb	r3, [r7, #14]
 80025bc:	7013      	strb	r3, [r2, #0]
			/* Start writing data */
			EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80025be:	887b      	ldrh	r3, [r7, #2]
 80025c0:	4a96      	ldr	r2, [pc, #600]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80025c2:	4619      	mov	r1, r3
 80025c4:	6878      	ldr	r0, [r7, #4]
 80025c6:	f7ff ff11 	bl	80023ec <EEPROM_WritePage>
			/* Wait transfer through DMA to be complete */
			EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80025ca:	4b95      	ldr	r3, [pc, #596]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80025cc:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80025d0:	601a      	str	r2, [r3, #0]
			while (EEPROMDataNum > 0)
 80025d2:	e009      	b.n	80025e8 <EEPROM_WriteBuffer+0x80>
			{
				if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80025d4:	4b92      	ldr	r3, [pc, #584]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80025d6:	681b      	ldr	r3, [r3, #0]
 80025d8:	1e5a      	subs	r2, r3, #1
 80025da:	4991      	ldr	r1, [pc, #580]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80025dc:	600a      	str	r2, [r1, #0]
 80025de:	2b00      	cmp	r3, #0
 80025e0:	d102      	bne.n	80025e8 <EEPROM_WriteBuffer+0x80>
 80025e2:	f000 fa41 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80025e6:	e151      	b.n	800288c <EEPROM_WriteBuffer+0x324>
			EEPROMDataNum = NumOfSingle;
			/* Start writing data */
			EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
			/* Wait transfer through DMA to be complete */
			EEPROMTimeout = EEPROM_LONG_TIMEOUT;
			while (EEPROMDataNum > 0)
 80025e8:	4b8c      	ldr	r3, [pc, #560]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80025ea:	781b      	ldrb	r3, [r3, #0]
 80025ec:	b2db      	uxtb	r3, r3
 80025ee:	2b00      	cmp	r3, #0
 80025f0:	d1f0      	bne.n	80025d4 <EEPROM_WriteBuffer+0x6c>
			{
				if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
			}
			EEPROM_WaitEepromStandbyState();
 80025f2:	f000 f953 	bl	800289c <EEPROM_WaitEepromStandbyState>
 80025f6:	e149      	b.n	800288c <EEPROM_WriteBuffer+0x324>
		else
		{
			while(NumOfPage--)
			{
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
 80025f8:	4b88      	ldr	r3, [pc, #544]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80025fa:	2220      	movs	r2, #32
 80025fc:	701a      	strb	r2, [r3, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80025fe:	887b      	ldrh	r3, [r7, #2]
 8002600:	4a86      	ldr	r2, [pc, #536]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002602:	4619      	mov	r1, r3
 8002604:	6878      	ldr	r0, [r7, #4]
 8002606:	f7ff fef1 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 800260a:	4b85      	ldr	r3, [pc, #532]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800260c:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002610:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002612:	e009      	b.n	8002628 <EEPROM_WriteBuffer+0xc0>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002614:	4b82      	ldr	r3, [pc, #520]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002616:	681b      	ldr	r3, [r3, #0]
 8002618:	1e5a      	subs	r2, r3, #1
 800261a:	4981      	ldr	r1, [pc, #516]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800261c:	600a      	str	r2, [r1, #0]
 800261e:	2b00      	cmp	r3, #0
 8002620:	d102      	bne.n	8002628 <EEPROM_WriteBuffer+0xc0>
 8002622:	f000 fa21 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002626:	e131      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002628:	4b7c      	ldr	r3, [pc, #496]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 800262a:	781b      	ldrb	r3, [r3, #0]
 800262c:	b2db      	uxtb	r3, r3
 800262e:	2b00      	cmp	r3, #0
 8002630:	d1f0      	bne.n	8002614 <EEPROM_WriteBuffer+0xac>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002632:	f000 f933 	bl	800289c <EEPROM_WaitEepromStandbyState>
				WriteAddr +=  EEPROM_PAGESIZE;
 8002636:	887b      	ldrh	r3, [r7, #2]
 8002638:	3320      	adds	r3, #32
 800263a:	807b      	strh	r3, [r7, #2]
				pBuffer += EEPROM_PAGESIZE;
 800263c:	687b      	ldr	r3, [r7, #4]
 800263e:	3320      	adds	r3, #32
 8002640:	607b      	str	r3, [r7, #4]
			EEPROM_WaitEepromStandbyState();
		}
		/*!< If NumByteToWrite > EEPROM_PAGESIZE */
		else
		{
			while(NumOfPage--)
 8002642:	7bfb      	ldrb	r3, [r7, #15]
 8002644:	1e5a      	subs	r2, r3, #1
 8002646:	73fa      	strb	r2, [r7, #15]
 8002648:	2b00      	cmp	r3, #0
 800264a:	d1d5      	bne.n	80025f8 <EEPROM_WriteBuffer+0x90>
				EEPROM_WaitEepromStandbyState();
				WriteAddr +=  EEPROM_PAGESIZE;
				pBuffer += EEPROM_PAGESIZE;
			}

			if(NumOfSingle!=0)
 800264c:	7bbb      	ldrb	r3, [r7, #14]
 800264e:	2b00      	cmp	r3, #0
 8002650:	f000 811c 	beq.w	800288c <EEPROM_WriteBuffer+0x324>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
 8002654:	4a71      	ldr	r2, [pc, #452]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002656:	7bbb      	ldrb	r3, [r7, #14]
 8002658:	7013      	strb	r3, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 800265a:	887b      	ldrh	r3, [r7, #2]
 800265c:	4a6f      	ldr	r2, [pc, #444]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 800265e:	4619      	mov	r1, r3
 8002660:	6878      	ldr	r0, [r7, #4]
 8002662:	f7ff fec3 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002666:	4b6e      	ldr	r3, [pc, #440]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002668:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 800266c:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 800266e:	e009      	b.n	8002684 <EEPROM_WriteBuffer+0x11c>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002670:	4b6b      	ldr	r3, [pc, #428]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002672:	681b      	ldr	r3, [r3, #0]
 8002674:	1e5a      	subs	r2, r3, #1
 8002676:	496a      	ldr	r1, [pc, #424]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002678:	600a      	str	r2, [r1, #0]
 800267a:	2b00      	cmp	r3, #0
 800267c:	d102      	bne.n	8002684 <EEPROM_WriteBuffer+0x11c>
 800267e:	f000 f9f3 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002682:	e103      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002684:	4b65      	ldr	r3, [pc, #404]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002686:	781b      	ldrb	r3, [r3, #0]
 8002688:	b2db      	uxtb	r3, r3
 800268a:	2b00      	cmp	r3, #0
 800268c:	d1f0      	bne.n	8002670 <EEPROM_WriteBuffer+0x108>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 800268e:	f000 f905 	bl	800289c <EEPROM_WaitEepromStandbyState>
 8002692:	e0fb      	b.n	800288c <EEPROM_WriteBuffer+0x324>
	}
	/*!< If WriteAddr is not EEPROM_PAGESIZE aligned  */
	else
	{
		/*!< If NumByteToWrite < EEPROM_PAGESIZE */
		if(NumOfPage== 0)
 8002694:	7bfb      	ldrb	r3, [r7, #15]
 8002696:	2b00      	cmp	r3, #0
 8002698:	d16d      	bne.n	8002776 <EEPROM_WriteBuffer+0x20e>
		{
			/*!< If the number of data to be written is more than the remaining space
      in the current page: */
			if (NumByteToWrite > count)
 800269a:	7b7b      	ldrb	r3, [r7, #13]
 800269c:	b29b      	uxth	r3, r3
 800269e:	883a      	ldrh	r2, [r7, #0]
 80026a0:	429a      	cmp	r2, r3
 80026a2:	d948      	bls.n	8002736 <EEPROM_WriteBuffer+0x1ce>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = count;
 80026a4:	4a5d      	ldr	r2, [pc, #372]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80026a6:	7b7b      	ldrb	r3, [r7, #13]
 80026a8:	7013      	strb	r3, [r2, #0]
				/*!< Write the data conained in same page */
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80026aa:	887b      	ldrh	r3, [r7, #2]
 80026ac:	4a5b      	ldr	r2, [pc, #364]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80026ae:	4619      	mov	r1, r3
 80026b0:	6878      	ldr	r0, [r7, #4]
 80026b2:	f7ff fe9b 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80026b6:	4b5a      	ldr	r3, [pc, #360]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80026b8:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80026bc:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 80026be:	e009      	b.n	80026d4 <EEPROM_WriteBuffer+0x16c>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80026c0:	4b57      	ldr	r3, [pc, #348]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	1e5a      	subs	r2, r3, #1
 80026c6:	4956      	ldr	r1, [pc, #344]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80026c8:	600a      	str	r2, [r1, #0]
 80026ca:	2b00      	cmp	r3, #0
 80026cc:	d102      	bne.n	80026d4 <EEPROM_WriteBuffer+0x16c>
 80026ce:	f000 f9cb 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80026d2:	e0db      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				EEPROMDataNum = count;
				/*!< Write the data conained in same page */
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 80026d4:	4b51      	ldr	r3, [pc, #324]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80026d6:	781b      	ldrb	r3, [r3, #0]
 80026d8:	b2db      	uxtb	r3, r3
 80026da:	2b00      	cmp	r3, #0
 80026dc:	d1f0      	bne.n	80026c0 <EEPROM_WriteBuffer+0x158>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 80026de:	f000 f8dd 	bl	800289c <EEPROM_WaitEepromStandbyState>

				/* Store the number of data to be written */
				EEPROMDataNum = (NumByteToWrite - count);
 80026e2:	883b      	ldrh	r3, [r7, #0]
 80026e4:	b2da      	uxtb	r2, r3
 80026e6:	7b7b      	ldrb	r3, [r7, #13]
 80026e8:	1ad3      	subs	r3, r2, r3
 80026ea:	b2da      	uxtb	r2, r3
 80026ec:	4b4b      	ldr	r3, [pc, #300]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80026ee:	701a      	strb	r2, [r3, #0]
				/*!< Write the remaining data in the following page */
				EEPROM_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&EEPROMDataNum));
 80026f0:	7b7b      	ldrb	r3, [r7, #13]
 80026f2:	687a      	ldr	r2, [r7, #4]
 80026f4:	18d0      	adds	r0, r2, r3
 80026f6:	7b7b      	ldrb	r3, [r7, #13]
 80026f8:	b29a      	uxth	r2, r3
 80026fa:	887b      	ldrh	r3, [r7, #2]
 80026fc:	4413      	add	r3, r2
 80026fe:	b29b      	uxth	r3, r3
 8002700:	4a46      	ldr	r2, [pc, #280]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002702:	4619      	mov	r1, r3
 8002704:	f7ff fe72 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002708:	4b45      	ldr	r3, [pc, #276]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800270a:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 800270e:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002710:	e009      	b.n	8002726 <EEPROM_WriteBuffer+0x1be>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002712:	4b43      	ldr	r3, [pc, #268]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002714:	681b      	ldr	r3, [r3, #0]
 8002716:	1e5a      	subs	r2, r3, #1
 8002718:	4941      	ldr	r1, [pc, #260]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800271a:	600a      	str	r2, [r1, #0]
 800271c:	2b00      	cmp	r3, #0
 800271e:	d102      	bne.n	8002726 <EEPROM_WriteBuffer+0x1be>
 8002720:	f000 f9a2 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002724:	e0b2      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				EEPROMDataNum = (NumByteToWrite - count);
				/*!< Write the remaining data in the following page */
				EEPROM_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002726:	4b3d      	ldr	r3, [pc, #244]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002728:	781b      	ldrb	r3, [r3, #0]
 800272a:	b2db      	uxtb	r3, r3
 800272c:	2b00      	cmp	r3, #0
 800272e:	d1f0      	bne.n	8002712 <EEPROM_WriteBuffer+0x1aa>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002730:	f000 f8b4 	bl	800289c <EEPROM_WaitEepromStandbyState>
 8002734:	e0aa      	b.n	800288c <EEPROM_WriteBuffer+0x324>
			}
			else
			{
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
 8002736:	4a39      	ldr	r2, [pc, #228]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002738:	7bbb      	ldrb	r3, [r7, #14]
 800273a:	7013      	strb	r3, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 800273c:	887b      	ldrh	r3, [r7, #2]
 800273e:	4a37      	ldr	r2, [pc, #220]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002740:	4619      	mov	r1, r3
 8002742:	6878      	ldr	r0, [r7, #4]
 8002744:	f7ff fe52 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002748:	4b35      	ldr	r3, [pc, #212]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800274a:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 800274e:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002750:	e009      	b.n	8002766 <EEPROM_WriteBuffer+0x1fe>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002752:	4b33      	ldr	r3, [pc, #204]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002754:	681b      	ldr	r3, [r3, #0]
 8002756:	1e5a      	subs	r2, r3, #1
 8002758:	4931      	ldr	r1, [pc, #196]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800275a:	600a      	str	r2, [r1, #0]
 800275c:	2b00      	cmp	r3, #0
 800275e:	d102      	bne.n	8002766 <EEPROM_WriteBuffer+0x1fe>
 8002760:	f000 f982 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002764:	e092      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002766:	4b2d      	ldr	r3, [pc, #180]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 8002768:	781b      	ldrb	r3, [r3, #0]
 800276a:	b2db      	uxtb	r3, r3
 800276c:	2b00      	cmp	r3, #0
 800276e:	d1f0      	bne.n	8002752 <EEPROM_WriteBuffer+0x1ea>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002770:	f000 f894 	bl	800289c <EEPROM_WaitEepromStandbyState>
 8002774:	e08a      	b.n	800288c <EEPROM_WriteBuffer+0x324>
			}
		}
		/*!< If NumByteToWrite > EEPROM_PAGESIZE */
		else
		{
			NumByteToWrite -= count;
 8002776:	7b7b      	ldrb	r3, [r7, #13]
 8002778:	b29b      	uxth	r3, r3
 800277a:	883a      	ldrh	r2, [r7, #0]
 800277c:	1ad3      	subs	r3, r2, r3
 800277e:	803b      	strh	r3, [r7, #0]
			NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;
 8002780:	883b      	ldrh	r3, [r7, #0]
 8002782:	095b      	lsrs	r3, r3, #5
 8002784:	b29b      	uxth	r3, r3
 8002786:	73fb      	strb	r3, [r7, #15]
			NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;
 8002788:	883b      	ldrh	r3, [r7, #0]
 800278a:	b2db      	uxtb	r3, r3
 800278c:	f003 031f 	and.w	r3, r3, #31
 8002790:	73bb      	strb	r3, [r7, #14]

			if(count != 0)
 8002792:	7b7b      	ldrb	r3, [r7, #13]
 8002794:	2b00      	cmp	r3, #0
 8002796:	d052      	beq.n	800283e <EEPROM_WriteBuffer+0x2d6>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = count;
 8002798:	4a20      	ldr	r2, [pc, #128]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 800279a:	7b7b      	ldrb	r3, [r7, #13]
 800279c:	7013      	strb	r3, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 800279e:	887b      	ldrh	r3, [r7, #2]
 80027a0:	4a1e      	ldr	r2, [pc, #120]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80027a2:	4619      	mov	r1, r3
 80027a4:	6878      	ldr	r0, [r7, #4]
 80027a6:	f7ff fe21 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80027aa:	4b1d      	ldr	r3, [pc, #116]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80027ac:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80027b0:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 80027b2:	e009      	b.n	80027c8 <EEPROM_WriteBuffer+0x260>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80027b4:	4b1a      	ldr	r3, [pc, #104]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80027b6:	681b      	ldr	r3, [r3, #0]
 80027b8:	1e5a      	subs	r2, r3, #1
 80027ba:	4919      	ldr	r1, [pc, #100]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80027bc:	600a      	str	r2, [r1, #0]
 80027be:	2b00      	cmp	r3, #0
 80027c0:	d102      	bne.n	80027c8 <EEPROM_WriteBuffer+0x260>
 80027c2:	f000 f951 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80027c6:	e061      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				/* Store the number of data to be written */
				EEPROMDataNum = count;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 80027c8:	4b14      	ldr	r3, [pc, #80]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80027ca:	781b      	ldrb	r3, [r3, #0]
 80027cc:	b2db      	uxtb	r3, r3
 80027ce:	2b00      	cmp	r3, #0
 80027d0:	d1f0      	bne.n	80027b4 <EEPROM_WriteBuffer+0x24c>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 80027d2:	f000 f863 	bl	800289c <EEPROM_WaitEepromStandbyState>
				WriteAddr += count;
 80027d6:	7b7b      	ldrb	r3, [r7, #13]
 80027d8:	b29a      	uxth	r2, r3
 80027da:	887b      	ldrh	r3, [r7, #2]
 80027dc:	4413      	add	r3, r2
 80027de:	807b      	strh	r3, [r7, #2]
				pBuffer += count;
 80027e0:	7b7b      	ldrb	r3, [r7, #13]
 80027e2:	687a      	ldr	r2, [r7, #4]
 80027e4:	4413      	add	r3, r2
 80027e6:	607b      	str	r3, [r7, #4]
			}

			while(NumOfPage--)
 80027e8:	e029      	b.n	800283e <EEPROM_WriteBuffer+0x2d6>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
 80027ea:	4b0c      	ldr	r3, [pc, #48]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80027ec:	2220      	movs	r2, #32
 80027ee:	701a      	strb	r2, [r3, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80027f0:	887b      	ldrh	r3, [r7, #2]
 80027f2:	4a0a      	ldr	r2, [pc, #40]	; (800281c <EEPROM_WriteBuffer+0x2b4>)
 80027f4:	4619      	mov	r1, r3
 80027f6:	6878      	ldr	r0, [r7, #4]
 80027f8:	f7ff fdf8 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80027fc:	4b08      	ldr	r3, [pc, #32]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 80027fe:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002802:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002804:	e00e      	b.n	8002824 <EEPROM_WriteBuffer+0x2bc>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002806:	4b06      	ldr	r3, [pc, #24]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 8002808:	681b      	ldr	r3, [r3, #0]
 800280a:	1e5a      	subs	r2, r3, #1
 800280c:	4904      	ldr	r1, [pc, #16]	; (8002820 <EEPROM_WriteBuffer+0x2b8>)
 800280e:	600a      	str	r2, [r1, #0]
 8002810:	2b00      	cmp	r3, #0
 8002812:	d107      	bne.n	8002824 <EEPROM_WriteBuffer+0x2bc>
 8002814:	f000 f928 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002818:	e038      	b.n	800288c <EEPROM_WriteBuffer+0x324>
 800281a:	bf00      	nop
 800281c:	200002b8 	.word	0x200002b8
 8002820:	20000000 	.word	0x20000000
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002824:	4b1b      	ldr	r3, [pc, #108]	; (8002894 <EEPROM_WriteBuffer+0x32c>)
 8002826:	781b      	ldrb	r3, [r3, #0]
 8002828:	b2db      	uxtb	r3, r3
 800282a:	2b00      	cmp	r3, #0
 800282c:	d1eb      	bne.n	8002806 <EEPROM_WriteBuffer+0x29e>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 800282e:	f000 f835 	bl	800289c <EEPROM_WaitEepromStandbyState>
				WriteAddr +=  EEPROM_PAGESIZE;
 8002832:	887b      	ldrh	r3, [r7, #2]
 8002834:	3320      	adds	r3, #32
 8002836:	807b      	strh	r3, [r7, #2]
				pBuffer += EEPROM_PAGESIZE;
 8002838:	687b      	ldr	r3, [r7, #4]
 800283a:	3320      	adds	r3, #32
 800283c:	607b      	str	r3, [r7, #4]
				EEPROM_WaitEepromStandbyState();
				WriteAddr += count;
				pBuffer += count;
			}

			while(NumOfPage--)
 800283e:	7bfb      	ldrb	r3, [r7, #15]
 8002840:	1e5a      	subs	r2, r3, #1
 8002842:	73fa      	strb	r2, [r7, #15]
 8002844:	2b00      	cmp	r3, #0
 8002846:	d1d0      	bne.n	80027ea <EEPROM_WriteBuffer+0x282>
				}
				EEPROM_WaitEepromStandbyState();
				WriteAddr +=  EEPROM_PAGESIZE;
				pBuffer += EEPROM_PAGESIZE;
			}
			if(NumOfSingle != 0)
 8002848:	7bbb      	ldrb	r3, [r7, #14]
 800284a:	2b00      	cmp	r3, #0
 800284c:	d01e      	beq.n	800288c <EEPROM_WriteBuffer+0x324>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
 800284e:	4a11      	ldr	r2, [pc, #68]	; (8002894 <EEPROM_WriteBuffer+0x32c>)
 8002850:	7bbb      	ldrb	r3, [r7, #14]
 8002852:	7013      	strb	r3, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 8002854:	887b      	ldrh	r3, [r7, #2]
 8002856:	4a0f      	ldr	r2, [pc, #60]	; (8002894 <EEPROM_WriteBuffer+0x32c>)
 8002858:	4619      	mov	r1, r3
 800285a:	6878      	ldr	r0, [r7, #4]
 800285c:	f7ff fdc6 	bl	80023ec <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002860:	4b0d      	ldr	r3, [pc, #52]	; (8002898 <EEPROM_WriteBuffer+0x330>)
 8002862:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002866:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002868:	e009      	b.n	800287e <EEPROM_WriteBuffer+0x316>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 800286a:	4b0b      	ldr	r3, [pc, #44]	; (8002898 <EEPROM_WriteBuffer+0x330>)
 800286c:	681b      	ldr	r3, [r3, #0]
 800286e:	1e5a      	subs	r2, r3, #1
 8002870:	4909      	ldr	r1, [pc, #36]	; (8002898 <EEPROM_WriteBuffer+0x330>)
 8002872:	600a      	str	r2, [r1, #0]
 8002874:	2b00      	cmp	r3, #0
 8002876:	d102      	bne.n	800287e <EEPROM_WriteBuffer+0x316>
 8002878:	f000 f8f6 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 800287c:	e006      	b.n	800288c <EEPROM_WriteBuffer+0x324>
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 800287e:	4b05      	ldr	r3, [pc, #20]	; (8002894 <EEPROM_WriteBuffer+0x32c>)
 8002880:	781b      	ldrb	r3, [r3, #0]
 8002882:	b2db      	uxtb	r3, r3
 8002884:	2b00      	cmp	r3, #0
 8002886:	d1f0      	bne.n	800286a <EEPROM_WriteBuffer+0x302>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002888:	f000 f808 	bl	800289c <EEPROM_WaitEepromStandbyState>
			}
		}
	}
}
 800288c:	3710      	adds	r7, #16
 800288e:	46bd      	mov	sp, r7
 8002890:	bd80      	pop	{r7, pc}
 8002892:	bf00      	nop
 8002894:	200002b8 	.word	0x200002b8
 8002898:	20000000 	.word	0x20000000

0800289c <EEPROM_WaitEepromStandbyState>:
 * @param  None
 * @retval EEPROM_OK (0) if operation is correctly performed, else return value
 *         different from EEPROM_OK (0) or the timeout user callback.
 */
uint32_t EEPROM_WaitEepromStandbyState(void)
{
 800289c:	b580      	push	{r7, lr}
 800289e:	b082      	sub	sp, #8
 80028a0:	af00      	add	r7, sp, #0
	__IO uint16_t tmpSR1 = 0;
 80028a2:	2300      	movs	r3, #0
 80028a4:	80fb      	strh	r3, [r7, #6]
	__IO uint32_t EEPROMTrials = 0;
 80028a6:	2300      	movs	r3, #0
 80028a8:	603b      	str	r3, [r7, #0]

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80028aa:	4b3a      	ldr	r3, [pc, #232]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 80028ac:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80028b0:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80028b2:	e00a      	b.n	80028ca <EEPROM_WaitEepromStandbyState+0x2e>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80028b4:	4b37      	ldr	r3, [pc, #220]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 80028b6:	681b      	ldr	r3, [r3, #0]
 80028b8:	1e5a      	subs	r2, r3, #1
 80028ba:	4936      	ldr	r1, [pc, #216]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 80028bc:	600a      	str	r2, [r1, #0]
 80028be:	2b00      	cmp	r3, #0
 80028c0:	d103      	bne.n	80028ca <EEPROM_WaitEepromStandbyState+0x2e>
 80028c2:	f000 f8d1 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80028c6:	4603      	mov	r3, r0
 80028c8:	e060      	b.n	800298c <EEPROM_WaitEepromStandbyState+0xf0>
	__IO uint16_t tmpSR1 = 0;
	__IO uint32_t EEPROMTrials = 0;

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80028ca:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 80028ce:	4832      	ldr	r0, [pc, #200]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 80028d0:	f001 ff62 	bl	8004798 <I2C_GetFlagStatus>
 80028d4:	4603      	mov	r3, r0
 80028d6:	2b00      	cmp	r3, #0
 80028d8:	d1ec      	bne.n	80028b4 <EEPROM_WaitEepromStandbyState+0x18>
     of trials is reached (this number is defined by EEPROM_MAX_TRIALS_NUMBER define
     in stm32_eval_i2c_ee.h file) */
	while (1)
	{
		/*!< Send START condition */
		I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 80028da:	2101      	movs	r1, #1
 80028dc:	482e      	ldr	r0, [pc, #184]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 80028de:	f001 fe8f 	bl	8004600 <I2C_GenerateSTART>

		/*!< Test on EV5 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80028e2:	4b2c      	ldr	r3, [pc, #176]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 80028e4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80028e8:	601a      	str	r2, [r3, #0]
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80028ea:	e00a      	b.n	8002902 <EEPROM_WaitEepromStandbyState+0x66>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80028ec:	4b29      	ldr	r3, [pc, #164]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 80028ee:	681b      	ldr	r3, [r3, #0]
 80028f0:	1e5a      	subs	r2, r3, #1
 80028f2:	4928      	ldr	r1, [pc, #160]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 80028f4:	600a      	str	r2, [r1, #0]
 80028f6:	2b00      	cmp	r3, #0
 80028f8:	d103      	bne.n	8002902 <EEPROM_WaitEepromStandbyState+0x66>
 80028fa:	f000 f8b5 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 80028fe:	4603      	mov	r3, r0
 8002900:	e044      	b.n	800298c <EEPROM_WaitEepromStandbyState+0xf0>
		/*!< Send START condition */
		I2C_GenerateSTART(EEPROM_I2C, ENABLE);

		/*!< Test on EV5 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002902:	4926      	ldr	r1, [pc, #152]	; (800299c <EEPROM_WaitEepromStandbyState+0x100>)
 8002904:	4824      	ldr	r0, [pc, #144]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 8002906:	f001 ff17 	bl	8004738 <I2C_CheckEvent>
 800290a:	4603      	mov	r3, r0
 800290c:	2b00      	cmp	r3, #0
 800290e:	d0ed      	beq.n	80028ec <EEPROM_WaitEepromStandbyState+0x50>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Send EEPROM address for write */
		I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);
 8002910:	4b23      	ldr	r3, [pc, #140]	; (80029a0 <EEPROM_WaitEepromStandbyState+0x104>)
 8002912:	881b      	ldrh	r3, [r3, #0]
 8002914:	b29b      	uxth	r3, r3
 8002916:	b2db      	uxtb	r3, r3
 8002918:	2200      	movs	r2, #0
 800291a:	4619      	mov	r1, r3
 800291c:	481e      	ldr	r0, [pc, #120]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 800291e:	f001 feed 	bl	80046fc <I2C_Send7bitAddress>

		/* Wait for ADDR flag to be set (Slave acknowledged his address) */
		EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002922:	4b1c      	ldr	r3, [pc, #112]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 8002924:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002928:	601a      	str	r2, [r3, #0]
		do
		{
			/* Get the current value of the SR1 register */
			tmpSR1 = EEPROM_I2C->SR1;
 800292a:	4b1b      	ldr	r3, [pc, #108]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 800292c:	8a9b      	ldrh	r3, [r3, #20]
 800292e:	b29b      	uxth	r3, r3
 8002930:	80fb      	strh	r3, [r7, #6]

			/* Update the timeout value and exit if it reach 0 */
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002932:	4b18      	ldr	r3, [pc, #96]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 8002934:	681b      	ldr	r3, [r3, #0]
 8002936:	1e5a      	subs	r2, r3, #1
 8002938:	4916      	ldr	r1, [pc, #88]	; (8002994 <EEPROM_WaitEepromStandbyState+0xf8>)
 800293a:	600a      	str	r2, [r1, #0]
 800293c:	2b00      	cmp	r3, #0
 800293e:	d103      	bne.n	8002948 <EEPROM_WaitEepromStandbyState+0xac>
 8002940:	f000 f892 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 8002944:	4603      	mov	r3, r0
 8002946:	e021      	b.n	800298c <EEPROM_WaitEepromStandbyState+0xf0>
		}
		/* Keep looping till the Address is acknowledged or the AF flag is
       set (address not acknowledged at time) */
		while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);
 8002948:	88fb      	ldrh	r3, [r7, #6]
 800294a:	b29b      	uxth	r3, r3
 800294c:	461a      	mov	r2, r3
 800294e:	f240 4302 	movw	r3, #1026	; 0x402
 8002952:	4013      	ands	r3, r2
 8002954:	2b00      	cmp	r3, #0
 8002956:	d0e8      	beq.n	800292a <EEPROM_WaitEepromStandbyState+0x8e>

		/* Check if the ADDR flag has been set */
		if (tmpSR1 & I2C_SR1_ADDR)
 8002958:	88fb      	ldrh	r3, [r7, #6]
 800295a:	b29b      	uxth	r3, r3
 800295c:	f003 0302 	and.w	r3, r3, #2
 8002960:	2b00      	cmp	r3, #0
 8002962:	d007      	beq.n	8002974 <EEPROM_WaitEepromStandbyState+0xd8>
		{
			/* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already
         been read) */
			(void)EEPROM_I2C->SR2;
 8002964:	4b0c      	ldr	r3, [pc, #48]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 8002966:	8b1b      	ldrh	r3, [r3, #24]

			/*!< STOP condition */
			I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 8002968:	2101      	movs	r1, #1
 800296a:	480b      	ldr	r0, [pc, #44]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 800296c:	f001 fe68 	bl	8004640 <I2C_GenerateSTOP>

			/* Exit the function */
			return EEPROM_OK;
 8002970:	2300      	movs	r3, #0
 8002972:	e00b      	b.n	800298c <EEPROM_WaitEepromStandbyState+0xf0>
		}
		else
		{
			/*!< Clear AF flag */
			I2C_ClearFlag(EEPROM_I2C, I2C_FLAG_AF);
 8002974:	490b      	ldr	r1, [pc, #44]	; (80029a4 <EEPROM_WaitEepromStandbyState+0x108>)
 8002976:	4808      	ldr	r0, [pc, #32]	; (8002998 <EEPROM_WaitEepromStandbyState+0xfc>)
 8002978:	f001 ff40 	bl	80047fc <I2C_ClearFlag>
		}

		/* Check if the maximum allowed numbe of trials has bee reached */
		if (EEPROMTrials++ == EEPROM_MAX_TRIALS_NUMBER)
 800297c:	683b      	ldr	r3, [r7, #0]
 800297e:	1c5a      	adds	r2, r3, #1
 8002980:	603a      	str	r2, [r7, #0]
 8002982:	2b96      	cmp	r3, #150	; 0x96
 8002984:	d1a9      	bne.n	80028da <EEPROM_WaitEepromStandbyState+0x3e>
		{
			/* If the maximum number of trials has been reached, exit the function */
			return EEPROM_TIMEOUT_UserCallback();
 8002986:	f000 f86f 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
 800298a:	4603      	mov	r3, r0
		}
	}
}
 800298c:	4618      	mov	r0, r3
 800298e:	3708      	adds	r7, #8
 8002990:	46bd      	mov	sp, r7
 8002992:	bd80      	pop	{r7, pc}
 8002994:	20000000 	.word	0x20000000
 8002998:	40005400 	.word	0x40005400
 800299c:	00030001 	.word	0x00030001
 80029a0:	2000017c 	.word	0x2000017c
 80029a4:	10000400 	.word	0x10000400

080029a8 <DMA1_Channel6_IRQHandler>:
 * @brief  This function handles the DMA Tx Channel interrupt Handler.
 * @param  None
 * @retval None
 */
void EEPROM_I2C_DMA_TX_IRQHandler(void)
{
 80029a8:	b580      	push	{r7, lr}
 80029aa:	af00      	add	r7, sp, #0
	/* Check if the DMA transfer is complete */
	if(DMA_GetFlagStatus(EEPROM_I2C_DMA_FLAG_TX_TC) != RESET)
 80029ac:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80029b0:	f001 fa78 	bl	8003ea4 <DMA_GetFlagStatus>
 80029b4:	4603      	mov	r3, r0
 80029b6:	2b00      	cmp	r3, #0
 80029b8:	d028      	beq.n	8002a0c <DMA1_Channel6_IRQHandler+0x64>
	{
		/* Disable the DMA Tx Channel and Clear all its Flags */
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_TX, DISABLE);
 80029ba:	2100      	movs	r1, #0
 80029bc:	4814      	ldr	r0, [pc, #80]	; (8002a10 <DMA1_Channel6_IRQHandler+0x68>)
 80029be:	f001 fa37 	bl	8003e30 <DMA_Cmd>
		DMA_ClearFlag(EEPROM_I2C_DMA_FLAG_TX_GL);
 80029c2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80029c6:	f001 fa95 	bl	8003ef4 <DMA_ClearFlag>

		/*!< Wait till all data have been physically transferred on the bus */
		EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80029ca:	4b12      	ldr	r3, [pc, #72]	; (8002a14 <DMA1_Channel6_IRQHandler+0x6c>)
 80029cc:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80029d0:	601a      	str	r2, [r3, #0]
		while(!I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF))
 80029d2:	e008      	b.n	80029e6 <DMA1_Channel6_IRQHandler+0x3e>
		{
			if((EEPROMTimeout--) == 0) EEPROM_TIMEOUT_UserCallback();
 80029d4:	4b0f      	ldr	r3, [pc, #60]	; (8002a14 <DMA1_Channel6_IRQHandler+0x6c>)
 80029d6:	681b      	ldr	r3, [r3, #0]
 80029d8:	1e5a      	subs	r2, r3, #1
 80029da:	490e      	ldr	r1, [pc, #56]	; (8002a14 <DMA1_Channel6_IRQHandler+0x6c>)
 80029dc:	600a      	str	r2, [r1, #0]
 80029de:	2b00      	cmp	r3, #0
 80029e0:	d101      	bne.n	80029e6 <DMA1_Channel6_IRQHandler+0x3e>
 80029e2:	f000 f841 	bl	8002a68 <EEPROM_TIMEOUT_UserCallback>
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_TX, DISABLE);
		DMA_ClearFlag(EEPROM_I2C_DMA_FLAG_TX_GL);

		/*!< Wait till all data have been physically transferred on the bus */
		EEPROMTimeout = EEPROM_LONG_TIMEOUT;
		while(!I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF))
 80029e6:	490c      	ldr	r1, [pc, #48]	; (8002a18 <DMA1_Channel6_IRQHandler+0x70>)
 80029e8:	480c      	ldr	r0, [pc, #48]	; (8002a1c <DMA1_Channel6_IRQHandler+0x74>)
 80029ea:	f001 fed5 	bl	8004798 <I2C_GetFlagStatus>
 80029ee:	4603      	mov	r3, r0
 80029f0:	2b00      	cmp	r3, #0
 80029f2:	d0ef      	beq.n	80029d4 <DMA1_Channel6_IRQHandler+0x2c>
		{
			if((EEPROMTimeout--) == 0) EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Send STOP condition */
		I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 80029f4:	2101      	movs	r1, #1
 80029f6:	4809      	ldr	r0, [pc, #36]	; (8002a1c <DMA1_Channel6_IRQHandler+0x74>)
 80029f8:	f001 fe22 	bl	8004640 <I2C_GenerateSTOP>

		/* Perform a read on SR1 and SR2 register to clear eventualaly pending flags */
		(void)EEPROM_I2C->SR1;
 80029fc:	4b07      	ldr	r3, [pc, #28]	; (8002a1c <DMA1_Channel6_IRQHandler+0x74>)
 80029fe:	8a9b      	ldrh	r3, [r3, #20]
		(void)EEPROM_I2C->SR2;
 8002a00:	4b06      	ldr	r3, [pc, #24]	; (8002a1c <DMA1_Channel6_IRQHandler+0x74>)
 8002a02:	8b1b      	ldrh	r3, [r3, #24]

		/* Reset the variable holding the number of data to be written */
		*EEPROMDataWritePointer = 0;
 8002a04:	4b06      	ldr	r3, [pc, #24]	; (8002a20 <DMA1_Channel6_IRQHandler+0x78>)
 8002a06:	681b      	ldr	r3, [r3, #0]
 8002a08:	2200      	movs	r2, #0
 8002a0a:	701a      	strb	r2, [r3, #0]
	}
}
 8002a0c:	bf00      	nop
 8002a0e:	bd80      	pop	{r7, pc}
 8002a10:	4002006c 	.word	0x4002006c
 8002a14:	20000000 	.word	0x20000000
 8002a18:	10000004 	.word	0x10000004
 8002a1c:	40005400 	.word	0x40005400
 8002a20:	20000284 	.word	0x20000284

08002a24 <DMA1_Channel7_IRQHandler>:
 * @brief  This function handles the DMA Rx Channel interrupt Handler.
 * @param  None
 * @retval None
 */
void EEPROM_I2C_DMA_RX_IRQHandler(void)
{
 8002a24:	b580      	push	{r7, lr}
 8002a26:	af00      	add	r7, sp, #0
	/* Check if the DMA transfer is complete */
	if(DMA_GetFlagStatus(EEPROM_I2C_DMA_FLAG_RX_TC) != RESET)
 8002a28:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8002a2c:	f001 fa3a 	bl	8003ea4 <DMA_GetFlagStatus>
 8002a30:	4603      	mov	r3, r0
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d00f      	beq.n	8002a56 <DMA1_Channel7_IRQHandler+0x32>
	{
		/*!< Send STOP Condition */
		I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 8002a36:	2101      	movs	r1, #1
 8002a38:	4808      	ldr	r0, [pc, #32]	; (8002a5c <DMA1_Channel7_IRQHandler+0x38>)
 8002a3a:	f001 fe01 	bl	8004640 <I2C_GenerateSTOP>

		/* Disable the DMA Rx Channel and Clear all its Flags */
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_RX, DISABLE);
 8002a3e:	2100      	movs	r1, #0
 8002a40:	4807      	ldr	r0, [pc, #28]	; (8002a60 <DMA1_Channel7_IRQHandler+0x3c>)
 8002a42:	f001 f9f5 	bl	8003e30 <DMA_Cmd>
		DMA_ClearFlag(EEPROM_I2C_DMA_FLAG_RX_GL);
 8002a46:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8002a4a:	f001 fa53 	bl	8003ef4 <DMA_ClearFlag>

		/* Reset the variable holding the number of data to be read */
		*EEPROMDataReadPointer = 0;
 8002a4e:	4b05      	ldr	r3, [pc, #20]	; (8002a64 <DMA1_Channel7_IRQHandler+0x40>)
 8002a50:	681b      	ldr	r3, [r3, #0]
 8002a52:	2200      	movs	r2, #0
 8002a54:	801a      	strh	r2, [r3, #0]
	}
}
 8002a56:	bf00      	nop
 8002a58:	bd80      	pop	{r7, pc}
 8002a5a:	bf00      	nop
 8002a5c:	40005400 	.word	0x40005400
 8002a60:	40020080 	.word	0x40020080
 8002a64:	20000288 	.word	0x20000288

08002a68 <EEPROM_TIMEOUT_UserCallback>:
 * @brief  Basic management of the timeout situation.
 * @param  None.
 * @retval None.
 */
uint32_t EEPROM_TIMEOUT_UserCallback(void)
{
 8002a68:	b480      	push	{r7}
 8002a6a:	af00      	add	r7, sp, #0
	/* Block communication and all processes */
	while (1)
	{
	}
 8002a6c:	e7fe      	b.n	8002a6c <EEPROM_TIMEOUT_UserCallback+0x4>
 8002a6e:	bf00      	nop

08002a70 <EEPROM_EnterCriticalSection_UserCallback>:
 *         application.
 * @param  None.
 * @retval None.
 */
void EEPROM_EnterCriticalSection_UserCallback(void)
{
 8002a70:	b480      	push	{r7}
 8002a72:	af00      	add	r7, sp, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8002a74:	b672      	cpsid	i
	__disable_irq();
}
 8002a76:	bf00      	nop
 8002a78:	46bd      	mov	sp, r7
 8002a7a:	bc80      	pop	{r7}
 8002a7c:	4770      	bx	lr
 8002a7e:	bf00      	nop

08002a80 <EEPROM_ExitCriticalSection_UserCallback>:
 *         application.
 * @param  None.
 * @retval None.
 */
void EEPROM_ExitCriticalSection_UserCallback(void)
{
 8002a80:	b480      	push	{r7}
 8002a82:	af00      	add	r7, sp, #0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 8002a84:	b662      	cpsie	i
	__enable_irq();
}
 8002a86:	bf00      	nop
 8002a88:	46bd      	mov	sp, r7
 8002a8a:	bc80      	pop	{r7}
 8002a8c:	4770      	bx	lr
 8002a8e:	bf00      	nop

08002a90 <ADCT_AT24C64_ReadOneByte>:

uint8_t ADCT_AT24C64_ReadOneByte(uint16_t Address_ui16 )
{
 8002a90:	b580      	push	{r7, lr}
 8002a92:	b084      	sub	sp, #16
 8002a94:	af00      	add	r7, sp, #0
 8002a96:	4603      	mov	r3, r0
 8002a98:	80fb      	strh	r3, [r7, #6]
	volatile uint16_t NumDataRead_ui16 = 1;
 8002a9a:	2301      	movs	r3, #1
 8002a9c:	81fb      	strh	r3, [r7, #14]
	uint8_t data_ui8;
	EEPROM_ReadBuffer(&data_ui8, Address_ui16, (uint16_t *)(&NumDataRead_ui16));
 8002a9e:	f107 020e 	add.w	r2, r7, #14
 8002aa2:	88f9      	ldrh	r1, [r7, #6]
 8002aa4:	f107 030d 	add.w	r3, r7, #13
 8002aa8:	4618      	mov	r0, r3
 8002aaa:	f7ff fb35 	bl	8002118 <EEPROM_ReadBuffer>
	while(NumDataRead_ui16 >0)
 8002aae:	bf00      	nop
 8002ab0:	89fb      	ldrh	r3, [r7, #14]
 8002ab2:	b29b      	uxth	r3, r3
 8002ab4:	2b00      	cmp	r3, #0
 8002ab6:	d1fb      	bne.n	8002ab0 <ADCT_AT24C64_ReadOneByte+0x20>
	{

	}
	return data_ui8;
 8002ab8:	7b7b      	ldrb	r3, [r7, #13]
}
 8002aba:	4618      	mov	r0, r3
 8002abc:	3710      	adds	r7, #16
 8002abe:	46bd      	mov	sp, r7
 8002ac0:	bd80      	pop	{r7, pc}
 8002ac2:	bf00      	nop

08002ac4 <ADCT_AT24C64_WriteOneBytes>:
{
	uint8_t txbuffer_a[2] = {(uint8_t)(ui16data%256), (uint8_t)(ui16data >> 8) };
	EEPROM_WriteBuffer(txbuffer_a , ui16MemAddr , 2 );
}
void ADCT_AT24C64_WriteOneBytes(uint16_t ui16MemAddr, uint8_t ui8data)
{
 8002ac4:	b580      	push	{r7, lr}
 8002ac6:	b082      	sub	sp, #8
 8002ac8:	af00      	add	r7, sp, #0
 8002aca:	4603      	mov	r3, r0
 8002acc:	460a      	mov	r2, r1
 8002ace:	80fb      	strh	r3, [r7, #6]
 8002ad0:	4613      	mov	r3, r2
 8002ad2:	717b      	strb	r3, [r7, #5]
	EEPROM_WriteBuffer(&ui8data , ui16MemAddr , 1 );
 8002ad4:	88f9      	ldrh	r1, [r7, #6]
 8002ad6:	1d7b      	adds	r3, r7, #5
 8002ad8:	2201      	movs	r2, #1
 8002ada:	4618      	mov	r0, r3
 8002adc:	f7ff fd44 	bl	8002568 <EEPROM_WriteBuffer>
}
 8002ae0:	bf00      	nop
 8002ae2:	3708      	adds	r7, #8
 8002ae4:	46bd      	mov	sp, r7
 8002ae6:	bd80      	pop	{r7, pc}

08002ae8 <ADCT_BGS_Button_Init>:
static void BUTTON_ENTER_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType);
static void BUTTON_CANCEL_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType);
static void BUTTON_UP_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType);
static void BUTTON_DOWN_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType);
void ADCT_BGS_Button_Init(void )
{
 8002ae8:	b580      	push	{r7, lr}
 8002aea:	b082      	sub	sp, #8
 8002aec:	af02      	add	r7, sp, #8
	/* Enter button initialization  */
	EnterButton = TM_BUTTON_Init(ENTER_BUTTON_GPIO_PORT,ENTER_BUTTON_GPIO_CLK,ENTER_BUTTON_PIN, 0, BUTTON_ENTER_Callback);
 8002aee:	4b26      	ldr	r3, [pc, #152]	; (8002b88 <ADCT_BGS_Button_Init+0xa0>)
 8002af0:	9300      	str	r3, [sp, #0]
 8002af2:	2300      	movs	r3, #0
 8002af4:	2201      	movs	r2, #1
 8002af6:	2108      	movs	r1, #8
 8002af8:	4824      	ldr	r0, [pc, #144]	; (8002b8c <ADCT_BGS_Button_Init+0xa4>)
 8002afa:	f000 f887 	bl	8002c0c <TM_BUTTON_Init>
 8002afe:	4602      	mov	r2, r0
 8002b00:	4b23      	ldr	r3, [pc, #140]	; (8002b90 <ADCT_BGS_Button_Init+0xa8>)
 8002b02:	601a      	str	r2, [r3, #0]
	/* ESC button initialization */
	CancelButton = TM_BUTTON_Init(ESC_BUTTON_GPIO_PORT,ESC_BUTTON_GPIO_CLK,ESC_BUTTON_PIN, 0, BUTTON_CANCEL_Callback);
 8002b04:	4b23      	ldr	r3, [pc, #140]	; (8002b94 <ADCT_BGS_Button_Init+0xac>)
 8002b06:	9300      	str	r3, [sp, #0]
 8002b08:	2300      	movs	r3, #0
 8002b0a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002b0e:	2108      	movs	r1, #8
 8002b10:	481e      	ldr	r0, [pc, #120]	; (8002b8c <ADCT_BGS_Button_Init+0xa4>)
 8002b12:	f000 f87b 	bl	8002c0c <TM_BUTTON_Init>
 8002b16:	4602      	mov	r2, r0
 8002b18:	4b1f      	ldr	r3, [pc, #124]	; (8002b98 <ADCT_BGS_Button_Init+0xb0>)
 8002b1a:	601a      	str	r2, [r3, #0]
	/* Up button initialization */
	UpButton = TM_BUTTON_Init(UP_BUTTON_GPIO_PORT,UP_BUTTON_GPIO_CLK,UP_BUTTON_PIN, 0, BUTTON_UP_Callback);
 8002b1c:	4b1f      	ldr	r3, [pc, #124]	; (8002b9c <ADCT_BGS_Button_Init+0xb4>)
 8002b1e:	9300      	str	r3, [sp, #0]
 8002b20:	2300      	movs	r3, #0
 8002b22:	2204      	movs	r2, #4
 8002b24:	2108      	movs	r1, #8
 8002b26:	4819      	ldr	r0, [pc, #100]	; (8002b8c <ADCT_BGS_Button_Init+0xa4>)
 8002b28:	f000 f870 	bl	8002c0c <TM_BUTTON_Init>
 8002b2c:	4602      	mov	r2, r0
 8002b2e:	4b1c      	ldr	r3, [pc, #112]	; (8002ba0 <ADCT_BGS_Button_Init+0xb8>)
 8002b30:	601a      	str	r2, [r3, #0]
	/* Down button initialization */
	DownButton = TM_BUTTON_Init(DOWN_BUTTON_GPIO_PORT,DOWN_BUTTON_GPIO_CLK,DOWN_BUTTON_PIN, 0, BUTTON_DOWN_Callback);
 8002b32:	4b1c      	ldr	r3, [pc, #112]	; (8002ba4 <ADCT_BGS_Button_Init+0xbc>)
 8002b34:	9300      	str	r3, [sp, #0]
 8002b36:	2300      	movs	r3, #0
 8002b38:	2202      	movs	r2, #2
 8002b3a:	2108      	movs	r1, #8
 8002b3c:	4813      	ldr	r0, [pc, #76]	; (8002b8c <ADCT_BGS_Button_Init+0xa4>)
 8002b3e:	f000 f865 	bl	8002c0c <TM_BUTTON_Init>
 8002b42:	4602      	mov	r2, r0
 8002b44:	4b18      	ldr	r3, [pc, #96]	; (8002ba8 <ADCT_BGS_Button_Init+0xc0>)
 8002b46:	601a      	str	r2, [r3, #0]

	TM_BUTTON_SetPressTime(EnterButton, 30, 200);
 8002b48:	4b11      	ldr	r3, [pc, #68]	; (8002b90 <ADCT_BGS_Button_Init+0xa8>)
 8002b4a:	681b      	ldr	r3, [r3, #0]
 8002b4c:	22c8      	movs	r2, #200	; 0xc8
 8002b4e:	211e      	movs	r1, #30
 8002b50:	4618      	mov	r0, r3
 8002b52:	f000 f8b7 	bl	8002cc4 <TM_BUTTON_SetPressTime>
	TM_BUTTON_SetPressTime(CancelButton, 30, 200);
 8002b56:	4b10      	ldr	r3, [pc, #64]	; (8002b98 <ADCT_BGS_Button_Init+0xb0>)
 8002b58:	681b      	ldr	r3, [r3, #0]
 8002b5a:	22c8      	movs	r2, #200	; 0xc8
 8002b5c:	211e      	movs	r1, #30
 8002b5e:	4618      	mov	r0, r3
 8002b60:	f000 f8b0 	bl	8002cc4 <TM_BUTTON_SetPressTime>
	TM_BUTTON_SetPressTime(UpButton, 30, 200);
 8002b64:	4b0e      	ldr	r3, [pc, #56]	; (8002ba0 <ADCT_BGS_Button_Init+0xb8>)
 8002b66:	681b      	ldr	r3, [r3, #0]
 8002b68:	22c8      	movs	r2, #200	; 0xc8
 8002b6a:	211e      	movs	r1, #30
 8002b6c:	4618      	mov	r0, r3
 8002b6e:	f000 f8a9 	bl	8002cc4 <TM_BUTTON_SetPressTime>
	TM_BUTTON_SetPressTime(DownButton, 30, 200);
 8002b72:	4b0d      	ldr	r3, [pc, #52]	; (8002ba8 <ADCT_BGS_Button_Init+0xc0>)
 8002b74:	681b      	ldr	r3, [r3, #0]
 8002b76:	22c8      	movs	r2, #200	; 0xc8
 8002b78:	211e      	movs	r1, #30
 8002b7a:	4618      	mov	r0, r3
 8002b7c:	f000 f8a2 	bl	8002cc4 <TM_BUTTON_SetPressTime>
}
 8002b80:	bf00      	nop
 8002b82:	46bd      	mov	sp, r7
 8002b84:	bd80      	pop	{r7, pc}
 8002b86:	bf00      	nop
 8002b88:	08002bad 	.word	0x08002bad
 8002b8c:	40010c00 	.word	0x40010c00
 8002b90:	200002c8 	.word	0x200002c8
 8002b94:	08002bc5 	.word	0x08002bc5
 8002b98:	200002bc 	.word	0x200002bc
 8002b9c:	08002bdd 	.word	0x08002bdd
 8002ba0:	200002c0 	.word	0x200002c0
 8002ba4:	08002bf5 	.word	0x08002bf5
 8002ba8:	200002c4 	.word	0x200002c4

08002bac <BUTTON_ENTER_Callback>:

static void BUTTON_ENTER_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 8002bac:	b480      	push	{r7}
 8002bae:	b083      	sub	sp, #12
 8002bb0:	af00      	add	r7, sp, #0
 8002bb2:	6078      	str	r0, [r7, #4]
 8002bb4:	460b      	mov	r3, r1
 8002bb6:	70fb      	strb	r3, [r7, #3]

}
 8002bb8:	bf00      	nop
 8002bba:	370c      	adds	r7, #12
 8002bbc:	46bd      	mov	sp, r7
 8002bbe:	bc80      	pop	{r7}
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop

08002bc4 <BUTTON_CANCEL_Callback>:
static void BUTTON_CANCEL_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 8002bc4:	b480      	push	{r7}
 8002bc6:	b083      	sub	sp, #12
 8002bc8:	af00      	add	r7, sp, #0
 8002bca:	6078      	str	r0, [r7, #4]
 8002bcc:	460b      	mov	r3, r1
 8002bce:	70fb      	strb	r3, [r7, #3]

}
 8002bd0:	bf00      	nop
 8002bd2:	370c      	adds	r7, #12
 8002bd4:	46bd      	mov	sp, r7
 8002bd6:	bc80      	pop	{r7}
 8002bd8:	4770      	bx	lr
 8002bda:	bf00      	nop

08002bdc <BUTTON_UP_Callback>:
static void BUTTON_UP_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 8002bdc:	b480      	push	{r7}
 8002bde:	b083      	sub	sp, #12
 8002be0:	af00      	add	r7, sp, #0
 8002be2:	6078      	str	r0, [r7, #4]
 8002be4:	460b      	mov	r3, r1
 8002be6:	70fb      	strb	r3, [r7, #3]

}
 8002be8:	bf00      	nop
 8002bea:	370c      	adds	r7, #12
 8002bec:	46bd      	mov	sp, r7
 8002bee:	bc80      	pop	{r7}
 8002bf0:	4770      	bx	lr
 8002bf2:	bf00      	nop

08002bf4 <BUTTON_DOWN_Callback>:
static void BUTTON_DOWN_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 8002bf4:	b480      	push	{r7}
 8002bf6:	b083      	sub	sp, #12
 8002bf8:	af00      	add	r7, sp, #0
 8002bfa:	6078      	str	r0, [r7, #4]
 8002bfc:	460b      	mov	r3, r1
 8002bfe:	70fb      	strb	r3, [r7, #3]

}
 8002c00:	bf00      	nop
 8002c02:	370c      	adds	r7, #12
 8002c04:	46bd      	mov	sp, r7
 8002c06:	bc80      	pop	{r7}
 8002c08:	4770      	bx	lr
 8002c0a:	bf00      	nop

08002c0c <TM_BUTTON_Init>:
static TM_BUTTON_INT_t Buttons;

/* Internal functions */
static void TM_BUTTON_INT_CheckButton(TM_BUTTON_t* ButtonStruct);

TM_BUTTON_t* TM_BUTTON_Init(GPIO_TypeDef* GPIOx, uint32_t GPIO_CLOCK, uint16_t GPIO_Pin, uint8_t ButtonState, void (*ButtonHandler)(TM_BUTTON_t*, TM_BUTTON_PressType_t)) {
 8002c0c:	b580      	push	{r7, lr}
 8002c0e:	b086      	sub	sp, #24
 8002c10:	af00      	add	r7, sp, #0
 8002c12:	60f8      	str	r0, [r7, #12]
 8002c14:	60b9      	str	r1, [r7, #8]
 8002c16:	4611      	mov	r1, r2
 8002c18:	461a      	mov	r2, r3
 8002c1a:	460b      	mov	r3, r1
 8002c1c:	80fb      	strh	r3, [r7, #6]
 8002c1e:	4613      	mov	r3, r2
 8002c20:	717b      	strb	r3, [r7, #5]
	TM_BUTTON_t* ButtonStruct;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* Check if available */
	if (Buttons.ButtonsCount >= BUTTON_MAX_BUTTONS) {
 8002c22:	4b27      	ldr	r3, [pc, #156]	; (8002cc0 <TM_BUTTON_Init+0xb4>)
 8002c24:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002c26:	2b09      	cmp	r3, #9
 8002c28:	d901      	bls.n	8002c2e <TM_BUTTON_Init+0x22>
		return NULL;
 8002c2a:	2300      	movs	r3, #0
 8002c2c:	e044      	b.n	8002cb8 <TM_BUTTON_Init+0xac>
	}
	
	/* Allocate memory for button */
	ButtonStruct = (TM_BUTTON_t *) malloc(sizeof(TM_BUTTON_t));
 8002c2e:	2018      	movs	r0, #24
 8002c30:	f002 fec8 	bl	80059c4 <malloc>
 8002c34:	4603      	mov	r3, r0
 8002c36:	617b      	str	r3, [r7, #20]
	
	/* Check if allocated */
	if (ButtonStruct == NULL) {
 8002c38:	697b      	ldr	r3, [r7, #20]
 8002c3a:	2b00      	cmp	r3, #0
 8002c3c:	d101      	bne.n	8002c42 <TM_BUTTON_Init+0x36>
		return NULL;
 8002c3e:	2300      	movs	r3, #0
 8002c40:	e03a      	b.n	8002cb8 <TM_BUTTON_Init+0xac>
	}
	
	/* Save settings */
	ButtonStruct->GPIOx = GPIOx;
 8002c42:	697b      	ldr	r3, [r7, #20]
 8002c44:	68fa      	ldr	r2, [r7, #12]
 8002c46:	601a      	str	r2, [r3, #0]
	ButtonStruct->GPIO_Pin = GPIO_Pin;
 8002c48:	697b      	ldr	r3, [r7, #20]
 8002c4a:	88fa      	ldrh	r2, [r7, #6]
 8002c4c:	809a      	strh	r2, [r3, #4]
	ButtonStruct->GPIO_State = ButtonState ? 1 : 0;
 8002c4e:	797b      	ldrb	r3, [r7, #5]
 8002c50:	2b00      	cmp	r3, #0
 8002c52:	bf14      	ite	ne
 8002c54:	2301      	movne	r3, #1
 8002c56:	2300      	moveq	r3, #0
 8002c58:	b2db      	uxtb	r3, r3
 8002c5a:	461a      	mov	r2, r3
 8002c5c:	697b      	ldr	r3, [r7, #20]
 8002c5e:	719a      	strb	r2, [r3, #6]
	ButtonStruct->ButtonHandler = ButtonHandler;
 8002c60:	697b      	ldr	r3, [r7, #20]
 8002c62:	6a3a      	ldr	r2, [r7, #32]
 8002c64:	609a      	str	r2, [r3, #8]
	ButtonStruct->State = BUTTON_STATE_START;
 8002c66:	697b      	ldr	r3, [r7, #20]
 8002c68:	2200      	movs	r2, #0
 8002c6a:	745a      	strb	r2, [r3, #17]
	
	/* Set default values */
	ButtonStruct->PressNormalTime = BUTTON_NORMAL_PRESS_TIME;
 8002c6c:	697b      	ldr	r3, [r7, #20]
 8002c6e:	2264      	movs	r2, #100	; 0x64
 8002c70:	829a      	strh	r2, [r3, #20]
	ButtonStruct->PressLongTime = BUTTON_LONG_PRESS_TIME;
 8002c72:	697b      	ldr	r3, [r7, #20]
 8002c74:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8002c78:	82da      	strh	r2, [r3, #22]
	ButtonStruct->PressDebounceTime = BUTTON_DEBOUNCE_TIME;
 8002c7a:	697b      	ldr	r3, [r7, #20]
 8002c7c:	2205      	movs	r2, #5
 8002c7e:	825a      	strh	r2, [r3, #18]
	
	/* Init GPIO pin as input with proper pull resistor */
	RCC_APB2PeriphClockCmd(GPIO_CLOCK, ENABLE);
 8002c80:	2101      	movs	r1, #1
 8002c82:	68b8      	ldr	r0, [r7, #8]
 8002c84:	f001 fff0 	bl	8004c68 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin;
 8002c88:	88fb      	ldrh	r3, [r7, #6]
 8002c8a:	823b      	strh	r3, [r7, #16]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002c8c:	2303      	movs	r3, #3
 8002c8e:	74bb      	strb	r3, [r7, #18]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 8002c90:	2328      	movs	r3, #40	; 0x28
 8002c92:	74fb      	strb	r3, [r7, #19]
	GPIO_Init(GPIOx, &GPIO_InitStructure);
 8002c94:	f107 0310 	add.w	r3, r7, #16
 8002c98:	4619      	mov	r1, r3
 8002c9a:	68f8      	ldr	r0, [r7, #12]
 8002c9c:	f001 fa2e 	bl	80040fc <GPIO_Init>
	/* Save button */
	Buttons.Buttons[Buttons.ButtonsCount++] = ButtonStruct;
 8002ca0:	4b07      	ldr	r3, [pc, #28]	; (8002cc0 <TM_BUTTON_Init+0xb4>)
 8002ca2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002ca4:	1c5a      	adds	r2, r3, #1
 8002ca6:	b291      	uxth	r1, r2
 8002ca8:	4a05      	ldr	r2, [pc, #20]	; (8002cc0 <TM_BUTTON_Init+0xb4>)
 8002caa:	8511      	strh	r1, [r2, #40]	; 0x28
 8002cac:	4619      	mov	r1, r3
 8002cae:	4a04      	ldr	r2, [pc, #16]	; (8002cc0 <TM_BUTTON_Init+0xb4>)
 8002cb0:	697b      	ldr	r3, [r7, #20]
 8002cb2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	
	/* Return button pointer */
	return ButtonStruct;
 8002cb6:	697b      	ldr	r3, [r7, #20]
}
 8002cb8:	4618      	mov	r0, r3
 8002cba:	3718      	adds	r7, #24
 8002cbc:	46bd      	mov	sp, r7
 8002cbe:	bd80      	pop	{r7, pc}
 8002cc0:	20000180 	.word	0x20000180

08002cc4 <TM_BUTTON_SetPressTime>:

TM_BUTTON_t* TM_BUTTON_SetPressTime(TM_BUTTON_t* ButtonStruct, uint16_t Normal, uint16_t Long) {
 8002cc4:	b480      	push	{r7}
 8002cc6:	b083      	sub	sp, #12
 8002cc8:	af00      	add	r7, sp, #0
 8002cca:	6078      	str	r0, [r7, #4]
 8002ccc:	460b      	mov	r3, r1
 8002cce:	807b      	strh	r3, [r7, #2]
 8002cd0:	4613      	mov	r3, r2
 8002cd2:	803b      	strh	r3, [r7, #0]
	/* Set values */
	ButtonStruct->PressNormalTime = Normal;
 8002cd4:	687b      	ldr	r3, [r7, #4]
 8002cd6:	887a      	ldrh	r2, [r7, #2]
 8002cd8:	829a      	strh	r2, [r3, #20]
	ButtonStruct->PressLongTime = Long;
 8002cda:	687b      	ldr	r3, [r7, #4]
 8002cdc:	883a      	ldrh	r2, [r7, #0]
 8002cde:	82da      	strh	r2, [r3, #22]
	
	/* Return pointer */
	return ButtonStruct;
 8002ce0:	687b      	ldr	r3, [r7, #4]
}
 8002ce2:	4618      	mov	r0, r3
 8002ce4:	370c      	adds	r7, #12
 8002ce6:	46bd      	mov	sp, r7
 8002ce8:	bc80      	pop	{r7}
 8002cea:	4770      	bx	lr

08002cec <TM_BUTTON_Update>:

void TM_BUTTON_Update(void) {
 8002cec:	b580      	push	{r7, lr}
 8002cee:	b082      	sub	sp, #8
 8002cf0:	af00      	add	r7, sp, #0
	uint16_t i;
	
	/* Go through all buttons */
	for (i = 0; i < Buttons.ButtonsCount; i++) {
 8002cf2:	2300      	movs	r3, #0
 8002cf4:	80fb      	strh	r3, [r7, #6]
 8002cf6:	e009      	b.n	8002d0c <TM_BUTTON_Update+0x20>
		/* Check button */
		TM_BUTTON_INT_CheckButton(Buttons.Buttons[i]);
 8002cf8:	88fb      	ldrh	r3, [r7, #6]
 8002cfa:	4a09      	ldr	r2, [pc, #36]	; (8002d20 <TM_BUTTON_Update+0x34>)
 8002cfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002d00:	4618      	mov	r0, r3
 8002d02:	f000 f80f 	bl	8002d24 <TM_BUTTON_INT_CheckButton>

void TM_BUTTON_Update(void) {
	uint16_t i;
	
	/* Go through all buttons */
	for (i = 0; i < Buttons.ButtonsCount; i++) {
 8002d06:	88fb      	ldrh	r3, [r7, #6]
 8002d08:	3301      	adds	r3, #1
 8002d0a:	80fb      	strh	r3, [r7, #6]
 8002d0c:	4b04      	ldr	r3, [pc, #16]	; (8002d20 <TM_BUTTON_Update+0x34>)
 8002d0e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002d10:	88fa      	ldrh	r2, [r7, #6]
 8002d12:	429a      	cmp	r2, r3
 8002d14:	d3f0      	bcc.n	8002cf8 <TM_BUTTON_Update+0xc>
		/* Check button */
		TM_BUTTON_INT_CheckButton(Buttons.Buttons[i]);
	}
}
 8002d16:	bf00      	nop
 8002d18:	3708      	adds	r7, #8
 8002d1a:	46bd      	mov	sp, r7
 8002d1c:	bd80      	pop	{r7, pc}
 8002d1e:	bf00      	nop
 8002d20:	20000180 	.word	0x20000180

08002d24 <TM_BUTTON_INT_CheckButton>:

/* Internal functions */
static void TM_BUTTON_INT_CheckButton(TM_BUTTON_t* ButtonStruct) {
 8002d24:	b580      	push	{r7, lr}
 8002d26:	b084      	sub	sp, #16
 8002d28:	af00      	add	r7, sp, #0
 8002d2a:	6078      	str	r0, [r7, #4]
	uint32_t now, status;
	
	/* Read values */
	now = TM_DELAY_Time();
 8002d2c:	4b4d      	ldr	r3, [pc, #308]	; (8002e64 <TM_BUTTON_INT_CheckButton+0x140>)
 8002d2e:	681b      	ldr	r3, [r3, #0]
 8002d30:	60fb      	str	r3, [r7, #12]
	status = GPIO_ReadInputDataBit(ButtonStruct->GPIOx, ButtonStruct->GPIO_Pin);
 8002d32:	687b      	ldr	r3, [r7, #4]
 8002d34:	681a      	ldr	r2, [r3, #0]
 8002d36:	687b      	ldr	r3, [r7, #4]
 8002d38:	889b      	ldrh	r3, [r3, #4]
 8002d3a:	4619      	mov	r1, r3
 8002d3c:	4610      	mov	r0, r2
 8002d3e:	f001 faad 	bl	800429c <GPIO_ReadInputDataBit>
 8002d42:	4603      	mov	r3, r0
 8002d44:	60bb      	str	r3, [r7, #8]
	
	/* First stage */
	if (ButtonStruct->State == BUTTON_STATE_START) {
 8002d46:	687b      	ldr	r3, [r7, #4]
 8002d48:	7c5b      	ldrb	r3, [r3, #17]
 8002d4a:	2b00      	cmp	r3, #0
 8002d4c:	d10b      	bne.n	8002d66 <TM_BUTTON_INT_CheckButton+0x42>
		/* Check if pressed */
		if (status == ButtonStruct->GPIO_State) {
 8002d4e:	687b      	ldr	r3, [r7, #4]
 8002d50:	799b      	ldrb	r3, [r3, #6]
 8002d52:	461a      	mov	r2, r3
 8002d54:	68bb      	ldr	r3, [r7, #8]
 8002d56:	429a      	cmp	r2, r3
 8002d58:	d105      	bne.n	8002d66 <TM_BUTTON_INT_CheckButton+0x42>
			/* Button pressed, go to stage BUTTON_STATE_START */
			ButtonStruct->State = BUTTON_STATE_DEBOUNCE;
 8002d5a:	687b      	ldr	r3, [r7, #4]
 8002d5c:	2201      	movs	r2, #1
 8002d5e:	745a      	strb	r2, [r3, #17]
			
			/* Save pressed time */
			ButtonStruct->StartTime = now;
 8002d60:	687b      	ldr	r3, [r7, #4]
 8002d62:	68fa      	ldr	r2, [r7, #12]
 8002d64:	60da      	str	r2, [r3, #12]
		}
	}

	if (ButtonStruct->State == BUTTON_STATE_DEBOUNCE) {
 8002d66:	687b      	ldr	r3, [r7, #4]
 8002d68:	7c5b      	ldrb	r3, [r3, #17]
 8002d6a:	2b01      	cmp	r3, #1
 8002d6c:	d123      	bne.n	8002db6 <TM_BUTTON_INT_CheckButton+0x92>
		/* Button still pressed */
		/* Check for debounce */
		if (status == ButtonStruct->GPIO_State) {
 8002d6e:	687b      	ldr	r3, [r7, #4]
 8002d70:	799b      	ldrb	r3, [r3, #6]
 8002d72:	461a      	mov	r2, r3
 8002d74:	68bb      	ldr	r3, [r7, #8]
 8002d76:	429a      	cmp	r2, r3
 8002d78:	d114      	bne.n	8002da4 <TM_BUTTON_INT_CheckButton+0x80>
			if ((now - ButtonStruct->StartTime) > ButtonStruct->PressDebounceTime) {
 8002d7a:	687b      	ldr	r3, [r7, #4]
 8002d7c:	68db      	ldr	r3, [r3, #12]
 8002d7e:	68fa      	ldr	r2, [r7, #12]
 8002d80:	1ad3      	subs	r3, r2, r3
 8002d82:	687a      	ldr	r2, [r7, #4]
 8002d84:	8a52      	ldrh	r2, [r2, #18]
 8002d86:	4293      	cmp	r3, r2
 8002d88:	d915      	bls.n	8002db6 <TM_BUTTON_INT_CheckButton+0x92>
				/* Button debounce OK, Goto Normal Press */
				ButtonStruct->State = BUTTON_STATE_PRESSED;
 8002d8a:	687b      	ldr	r3, [r7, #4]
 8002d8c:	2202      	movs	r2, #2
 8002d8e:	745a      	strb	r2, [r3, #17]

				/* Try to call user function */
				if (ButtonStruct->ButtonHandler) {
 8002d90:	687b      	ldr	r3, [r7, #4]
 8002d92:	689b      	ldr	r3, [r3, #8]
 8002d94:	2b00      	cmp	r3, #0
 8002d96:	d00e      	beq.n	8002db6 <TM_BUTTON_INT_CheckButton+0x92>
					/* Call function callback */
					ButtonStruct->ButtonHandler(ButtonStruct, TM_BUTTON_PressType_OnPressed);
 8002d98:	687b      	ldr	r3, [r7, #4]
 8002d9a:	689b      	ldr	r3, [r3, #8]
 8002d9c:	2100      	movs	r1, #0
 8002d9e:	6878      	ldr	r0, [r7, #4]
 8002da0:	4798      	blx	r3
 8002da2:	e008      	b.n	8002db6 <TM_BUTTON_INT_CheckButton+0x92>
				}
			}
		} else if (status != ButtonStruct->GPIO_State) {
 8002da4:	687b      	ldr	r3, [r7, #4]
 8002da6:	799b      	ldrb	r3, [r3, #6]
 8002da8:	461a      	mov	r2, r3
 8002daa:	68bb      	ldr	r3, [r7, #8]
 8002dac:	429a      	cmp	r2, r3
 8002dae:	d002      	beq.n	8002db6 <TM_BUTTON_INT_CheckButton+0x92>
			/* Not pressed */
			/* It was bounce, start over */
			/* Go to state BUTTON_STATE_START */
			ButtonStruct->State = BUTTON_STATE_START;
 8002db0:	687b      	ldr	r3, [r7, #4]
 8002db2:	2200      	movs	r2, #0
 8002db4:	745a      	strb	r2, [r3, #17]
		}
	}
	
	if (ButtonStruct->State == BUTTON_STATE_PRESSED) {
 8002db6:	687b      	ldr	r3, [r7, #4]
 8002db8:	7c5b      	ldrb	r3, [r3, #17]
 8002dba:	2b02      	cmp	r3, #2
 8002dbc:	d13c      	bne.n	8002e38 <TM_BUTTON_INT_CheckButton+0x114>
		/* Button still pressed */
		/* Check for long press */
		if (status == ButtonStruct->GPIO_State) {
 8002dbe:	687b      	ldr	r3, [r7, #4]
 8002dc0:	799b      	ldrb	r3, [r3, #6]
 8002dc2:	461a      	mov	r2, r3
 8002dc4:	68bb      	ldr	r3, [r7, #8]
 8002dc6:	429a      	cmp	r2, r3
 8002dc8:	d114      	bne.n	8002df4 <TM_BUTTON_INT_CheckButton+0xd0>
			if ((now - ButtonStruct->StartTime) > ButtonStruct->PressLongTime) {
 8002dca:	687b      	ldr	r3, [r7, #4]
 8002dcc:	68db      	ldr	r3, [r3, #12]
 8002dce:	68fa      	ldr	r2, [r7, #12]
 8002dd0:	1ad3      	subs	r3, r2, r3
 8002dd2:	687a      	ldr	r2, [r7, #4]
 8002dd4:	8ad2      	ldrh	r2, [r2, #22]
 8002dd6:	4293      	cmp	r3, r2
 8002dd8:	d92e      	bls.n	8002e38 <TM_BUTTON_INT_CheckButton+0x114>
				/* Button pressed OK, call function */
				if (ButtonStruct->ButtonHandler) {
 8002dda:	687b      	ldr	r3, [r7, #4]
 8002ddc:	689b      	ldr	r3, [r3, #8]
 8002dde:	2b00      	cmp	r3, #0
 8002de0:	d004      	beq.n	8002dec <TM_BUTTON_INT_CheckButton+0xc8>
					/* Call function callback */
					ButtonStruct->ButtonHandler(ButtonStruct, TM_BUTTON_PressType_Long);
 8002de2:	687b      	ldr	r3, [r7, #4]
 8002de4:	689b      	ldr	r3, [r3, #8]
 8002de6:	2103      	movs	r1, #3
 8002de8:	6878      	ldr	r0, [r7, #4]
 8002dea:	4798      	blx	r3
				}
				
				/* Go to stage BUTTON_STATE_WAITRELEASE */
				ButtonStruct->State = BUTTON_STATE_WAITRELEASE;
 8002dec:	687b      	ldr	r3, [r7, #4]
 8002dee:	2203      	movs	r2, #3
 8002df0:	745a      	strb	r2, [r3, #17]
 8002df2:	e021      	b.n	8002e38 <TM_BUTTON_INT_CheckButton+0x114>
			}
		} else if (status != ButtonStruct->GPIO_State) {
 8002df4:	687b      	ldr	r3, [r7, #4]
 8002df6:	799b      	ldrb	r3, [r3, #6]
 8002df8:	461a      	mov	r2, r3
 8002dfa:	68bb      	ldr	r3, [r7, #8]
 8002dfc:	429a      	cmp	r2, r3
 8002dfe:	d018      	beq.n	8002e32 <TM_BUTTON_INT_CheckButton+0x10e>
			/* Not pressed */
			if ((now - ButtonStruct->StartTime) > ButtonStruct->PressNormalTime) {
 8002e00:	687b      	ldr	r3, [r7, #4]
 8002e02:	68db      	ldr	r3, [r3, #12]
 8002e04:	68fa      	ldr	r2, [r7, #12]
 8002e06:	1ad3      	subs	r3, r2, r3
 8002e08:	687a      	ldr	r2, [r7, #4]
 8002e0a:	8a92      	ldrh	r2, [r2, #20]
 8002e0c:	4293      	cmp	r3, r2
 8002e0e:	d90c      	bls.n	8002e2a <TM_BUTTON_INT_CheckButton+0x106>
				/* Button pressed OK, call function */
				if (ButtonStruct->ButtonHandler) {
 8002e10:	687b      	ldr	r3, [r7, #4]
 8002e12:	689b      	ldr	r3, [r3, #8]
 8002e14:	2b00      	cmp	r3, #0
 8002e16:	d004      	beq.n	8002e22 <TM_BUTTON_INT_CheckButton+0xfe>
					/* Call function callback */
					ButtonStruct->ButtonHandler(ButtonStruct, TM_BUTTON_PressType_Normal);
 8002e18:	687b      	ldr	r3, [r7, #4]
 8002e1a:	689b      	ldr	r3, [r3, #8]
 8002e1c:	2102      	movs	r1, #2
 8002e1e:	6878      	ldr	r0, [r7, #4]
 8002e20:	4798      	blx	r3
				}
				
				/* Go to stage BUTTON_STATE_WAITRELEASE */
				ButtonStruct->State = BUTTON_STATE_WAITRELEASE;
 8002e22:	687b      	ldr	r3, [r7, #4]
 8002e24:	2203      	movs	r2, #3
 8002e26:	745a      	strb	r2, [r3, #17]
 8002e28:	e006      	b.n	8002e38 <TM_BUTTON_INT_CheckButton+0x114>
			} else {
				/* Go to state BUTTON_STATE_START */
				ButtonStruct->State = BUTTON_STATE_START;
 8002e2a:	687b      	ldr	r3, [r7, #4]
 8002e2c:	2200      	movs	r2, #0
 8002e2e:	745a      	strb	r2, [r3, #17]
 8002e30:	e002      	b.n	8002e38 <TM_BUTTON_INT_CheckButton+0x114>
			}
		} else {
			/* Go to state BUTTON_STATE_START */
			ButtonStruct->State = BUTTON_STATE_START;
 8002e32:	687b      	ldr	r3, [r7, #4]
 8002e34:	2200      	movs	r2, #0
 8002e36:	745a      	strb	r2, [r3, #17]
		}
	}
	
	if (ButtonStruct->State == BUTTON_STATE_WAITRELEASE) {
 8002e38:	687b      	ldr	r3, [r7, #4]
 8002e3a:	7c5b      	ldrb	r3, [r3, #17]
 8002e3c:	2b03      	cmp	r3, #3
 8002e3e:	d108      	bne.n	8002e52 <TM_BUTTON_INT_CheckButton+0x12e>
		/* Wait till button released */
		if (status != ButtonStruct->GPIO_State) {
 8002e40:	687b      	ldr	r3, [r7, #4]
 8002e42:	799b      	ldrb	r3, [r3, #6]
 8002e44:	461a      	mov	r2, r3
 8002e46:	68bb      	ldr	r3, [r7, #8]
 8002e48:	429a      	cmp	r2, r3
 8002e4a:	d002      	beq.n	8002e52 <TM_BUTTON_INT_CheckButton+0x12e>
			/* Go to stage 0 again */
			ButtonStruct->State = BUTTON_STATE_START;
 8002e4c:	687b      	ldr	r3, [r7, #4]
 8002e4e:	2200      	movs	r2, #0
 8002e50:	745a      	strb	r2, [r3, #17]
		}
	}
	
	/* Save current status */
	ButtonStruct->LastStatus = status;
 8002e52:	68bb      	ldr	r3, [r7, #8]
 8002e54:	b2da      	uxtb	r2, r3
 8002e56:	687b      	ldr	r3, [r7, #4]
 8002e58:	741a      	strb	r2, [r3, #16]
}
 8002e5a:	bf00      	nop
 8002e5c:	3710      	adds	r7, #16
 8002e5e:	46bd      	mov	sp, r7
 8002e60:	bd80      	pop	{r7, pc}
 8002e62:	bf00      	nop
 8002e64:	200001b0 	.word	0x200001b0

08002e68 <USART3_IRQHandler>:
	*pucByte = (CHAR) USART_ReceiveData( ADCT_BGS_RS485_USART_PORT );
	return TRUE;
}

void USART3_IRQHandler( void )
{
 8002e68:	b580      	push	{r7, lr}
 8002e6a:	af00      	add	r7, sp, #0
	if ( USART_GetITStatus( ADCT_BGS_RS485_USART_PORT, USART_IT_RXNE ) != RESET )
 8002e6c:	f240 5125 	movw	r1, #1317	; 0x525
 8002e70:	480f      	ldr	r0, [pc, #60]	; (8002eb0 <USART3_IRQHandler+0x48>)
 8002e72:	f002 f8a7 	bl	8004fc4 <USART_GetITStatus>
 8002e76:	4603      	mov	r3, r0
 8002e78:	2b00      	cmp	r3, #0
 8002e7a:	d007      	beq.n	8002e8c <USART3_IRQHandler+0x24>
	{
		USART_ClearITPendingBit( ADCT_BGS_RS485_USART_PORT, USART_IT_RXNE );
 8002e7c:	f240 5125 	movw	r1, #1317	; 0x525
 8002e80:	480b      	ldr	r0, [pc, #44]	; (8002eb0 <USART3_IRQHandler+0x48>)
 8002e82:	f002 f8f9 	bl	8005078 <USART_ClearITPendingBit>
		pxMBFrameCBByteReceived();
 8002e86:	4b0b      	ldr	r3, [pc, #44]	; (8002eb4 <USART3_IRQHandler+0x4c>)
 8002e88:	681b      	ldr	r3, [r3, #0]
 8002e8a:	4798      	blx	r3

	}
	if ( USART_GetITStatus( ADCT_BGS_RS485_USART_PORT, USART_IT_TXE ) != RESET )
 8002e8c:	f240 7127 	movw	r1, #1831	; 0x727
 8002e90:	4807      	ldr	r0, [pc, #28]	; (8002eb0 <USART3_IRQHandler+0x48>)
 8002e92:	f002 f897 	bl	8004fc4 <USART_GetITStatus>
 8002e96:	4603      	mov	r3, r0
 8002e98:	2b00      	cmp	r3, #0
 8002e9a:	d007      	beq.n	8002eac <USART3_IRQHandler+0x44>
	{
		USART_ClearITPendingBit( ADCT_BGS_RS485_USART_PORT, USART_IT_TXE );
 8002e9c:	f240 7127 	movw	r1, #1831	; 0x727
 8002ea0:	4803      	ldr	r0, [pc, #12]	; (8002eb0 <USART3_IRQHandler+0x48>)
 8002ea2:	f002 f8e9 	bl	8005078 <USART_ClearITPendingBit>
		pxMBFrameCBTransmitterEmpty();
 8002ea6:	4b04      	ldr	r3, [pc, #16]	; (8002eb8 <USART3_IRQHandler+0x50>)
 8002ea8:	681b      	ldr	r3, [r3, #0]
 8002eaa:	4798      	blx	r3
	}
}
 8002eac:	bf00      	nop
 8002eae:	bd80      	pop	{r7, pc}
 8002eb0:	40004800 	.word	0x40004800
 8002eb4:	200002d4 	.word	0x200002d4
 8002eb8:	200002cc 	.word	0x200002cc

08002ebc <TIM4_IRQHandler>:
{
    TIM_Cmd( TIM4, DISABLE );
}

void TIM4_IRQHandler( void )
{
 8002ebc:	b580      	push	{r7, lr}
 8002ebe:	af00      	add	r7, sp, #0
    if ( TIM_GetITStatus( TIM4, TIM_IT_Update ) != RESET )
 8002ec0:	2101      	movs	r1, #1
 8002ec2:	4807      	ldr	r0, [pc, #28]	; (8002ee0 <TIM4_IRQHandler+0x24>)
 8002ec4:	f002 f844 	bl	8004f50 <TIM_GetITStatus>
 8002ec8:	4603      	mov	r3, r0
 8002eca:	2b00      	cmp	r3, #0
 8002ecc:	d006      	beq.n	8002edc <TIM4_IRQHandler+0x20>
    {
        TIM_ClearITPendingBit( TIM4, TIM_IT_Update );
 8002ece:	2101      	movs	r1, #1
 8002ed0:	4803      	ldr	r0, [pc, #12]	; (8002ee0 <TIM4_IRQHandler+0x24>)
 8002ed2:	f002 f867 	bl	8004fa4 <TIM_ClearITPendingBit>

        (void) pxMBPortCBTimerExpired();
 8002ed6:	4b03      	ldr	r3, [pc, #12]	; (8002ee4 <TIM4_IRQHandler+0x28>)
 8002ed8:	681b      	ldr	r3, [r3, #0]
 8002eda:	4798      	blx	r3
    }
}
 8002edc:	bf00      	nop
 8002ede:	bd80      	pop	{r7, pc}
 8002ee0:	40000800 	.word	0x40000800
 8002ee4:	200002d0 	.word	0x200002d0

08002ee8 <ADCT_Relay_Init>:
 *  Created on: Dec 25, 2016
 *      Author: Administrator
 */
#include "ADCT_Relay.h"
void ADCT_Relay_Init(void )
{
 8002ee8:	b580      	push	{r7, lr}
 8002eea:	b082      	sub	sp, #8
 8002eec:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	/* GPIO Periph clock enable */
	RCC_APB2PeriphClockCmd(ADCT_BGS_CTRL_RELAY_S_CLK|ADCT_BGS_CTRL_RELAY_B09_CLK|ADCT_BGS_CTRL_RELAY_B10_CLK, ENABLE);
 8002eee:	2101      	movs	r1, #1
 8002ef0:	2014      	movs	r0, #20
 8002ef2:	f001 feb9 	bl	8004c68 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_CTRL_RELAY_S01|ADCT_BGS_CTRL_RELAY_S02|ADCT_BGS_CTRL_RELAY_S03|ADCT_BGS_CTRL_RELAY_S04|ADCT_BGS_CTRL_RELAY_S05|ADCT_BGS_CTRL_RELAY_S06|ADCT_BGS_CTRL_RELAY_S07|ADCT_BGS_CTRL_RELAY_S08;
 8002ef6:	23ff      	movs	r3, #255	; 0xff
 8002ef8:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002efa:	2303      	movs	r3, #3
 8002efc:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8002efe:	2310      	movs	r3, #16
 8002f00:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(ADCT_BGS_CTRL_RELAY_S_PORT, &GPIO_InitStructure);
 8002f02:	1d3b      	adds	r3, r7, #4
 8002f04:	4619      	mov	r1, r3
 8002f06:	480f      	ldr	r0, [pc, #60]	; (8002f44 <ADCT_Relay_Init+0x5c>)
 8002f08:	f001 f8f8 	bl	80040fc <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_CTRL_RELAY_B09;
 8002f0c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002f10:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002f12:	2303      	movs	r3, #3
 8002f14:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8002f16:	2310      	movs	r3, #16
 8002f18:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(ADCT_BGS_CTRL_RELAY_B09_PORT, &GPIO_InitStructure);
 8002f1a:	1d3b      	adds	r3, r7, #4
 8002f1c:	4619      	mov	r1, r3
 8002f1e:	480a      	ldr	r0, [pc, #40]	; (8002f48 <ADCT_Relay_Init+0x60>)
 8002f20:	f001 f8ec 	bl	80040fc <GPIO_Init>
	/* Disable the Serial Wire Jtag Debug Port SWJ-DP */
	//GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_CTRL_RELAY_B10;
 8002f24:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8002f28:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002f2a:	2303      	movs	r3, #3
 8002f2c:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8002f2e:	2310      	movs	r3, #16
 8002f30:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(ADCT_BGS_CTRL_RELAY_B10_PORT, &GPIO_InitStructure);
 8002f32:	1d3b      	adds	r3, r7, #4
 8002f34:	4619      	mov	r1, r3
 8002f36:	4803      	ldr	r0, [pc, #12]	; (8002f44 <ADCT_Relay_Init+0x5c>)
 8002f38:	f001 f8e0 	bl	80040fc <GPIO_Init>
}
 8002f3c:	bf00      	nop
 8002f3e:	3708      	adds	r7, #8
 8002f40:	46bd      	mov	sp, r7
 8002f42:	bd80      	pop	{r7, pc}
 8002f44:	40010800 	.word	0x40010800
 8002f48:	40011000 	.word	0x40011000

08002f4c <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8002f4c:	b480      	push	{r7}
 8002f4e:	b083      	sub	sp, #12
 8002f50:	af00      	add	r7, sp, #0
 8002f52:	4603      	mov	r3, r0
 8002f54:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
 8002f56:	4909      	ldr	r1, [pc, #36]	; (8002f7c <NVIC_ClearPendingIRQ+0x30>)
 8002f58:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002f5c:	095b      	lsrs	r3, r3, #5
 8002f5e:	79fa      	ldrb	r2, [r7, #7]
 8002f60:	f002 021f 	and.w	r2, r2, #31
 8002f64:	2001      	movs	r0, #1
 8002f66:	fa00 f202 	lsl.w	r2, r0, r2
 8002f6a:	3360      	adds	r3, #96	; 0x60
 8002f6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8002f70:	bf00      	nop
 8002f72:	370c      	adds	r7, #12
 8002f74:	46bd      	mov	sp, r7
 8002f76:	bc80      	pop	{r7}
 8002f78:	4770      	bx	lr
 8002f7a:	bf00      	nop
 8002f7c:	e000e100 	.word	0xe000e100

08002f80 <RTC_Configuration>:
 *   RTC clock
 * @param  None
 * @retval : None
 */
void RTC_Configuration()
{
 8002f80:	b580      	push	{r7, lr}
 8002f82:	b082      	sub	sp, #8
 8002f84:	af00      	add	r7, sp, #0
	uint16_t WaitForOscSource;

	/*Allow access to Backup Registers*/
	PWR_BackupAccessCmd(ENABLE);
 8002f86:	2001      	movs	r0, #1
 8002f88:	f001 fc4e 	bl	8004828 <PWR_BackupAccessCmd>

	//if(BKP_ReadBackupRegister(BKP_DR1)==CONFIGURATION_DONE)
	bkupdata = BKP_ReadBackupRegister(BKP_DR1);
 8002f8c:	2004      	movs	r0, #4
 8002f8e:	f000 fe3d 	bl	8003c0c <BKP_ReadBackupRegister>
 8002f92:	4603      	mov	r3, r0
 8002f94:	461a      	mov	r2, r3
 8002f96:	4b5a      	ldr	r3, [pc, #360]	; (8003100 <RTC_Configuration+0x180>)
 8002f98:	601a      	str	r2, [r3, #0]
	if(bkupdata==CONFIGURATION_RESET)
 8002f9a:	4b59      	ldr	r3, [pc, #356]	; (8003100 <RTC_Configuration+0x180>)
 8002f9c:	681b      	ldr	r3, [r3, #0]
 8002f9e:	2b00      	cmp	r3, #0
 8002fa0:	d16c      	bne.n	800307c <RTC_Configuration+0xfc>
	{
		/*Enables the clock to Backup and power interface peripherals    */
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP | RCC_APB1Periph_PWR,ENABLE);
 8002fa2:	2101      	movs	r1, #1
 8002fa4:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 8002fa8:	f001 fe7c 	bl	8004ca4 <RCC_APB1PeriphClockCmd>
		/* Backup Domain Reset */
		BKP_DeInit();
 8002fac:	f000 fdec 	bl	8003b88 <BKP_DeInit>

		s_DateStructVar.Month=DEFAULT_MONTH ;
 8002fb0:	4b54      	ldr	r3, [pc, #336]	; (8003104 <RTC_Configuration+0x184>)
 8002fb2:	220c      	movs	r2, #12
 8002fb4:	701a      	strb	r2, [r3, #0]
		s_DateStructVar.Day=DEFAULT_DAY;
 8002fb6:	4b53      	ldr	r3, [pc, #332]	; (8003104 <RTC_Configuration+0x184>)
 8002fb8:	221a      	movs	r2, #26
 8002fba:	705a      	strb	r2, [r3, #1]
		s_DateStructVar.Year=DEFAULT_YEAR;
 8002fbc:	4b51      	ldr	r3, [pc, #324]	; (8003104 <RTC_Configuration+0x184>)
 8002fbe:	f44f 62fc 	mov.w	r2, #2016	; 0x7e0
 8002fc2:	805a      	strh	r2, [r3, #2]
		SummerTimeCorrect = OCTOBER_FLAG_SET;
 8002fc4:	4b50      	ldr	r3, [pc, #320]	; (8003108 <RTC_Configuration+0x188>)
 8002fc6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8002fca:	801a      	strh	r2, [r3, #0]
		BKP_WriteBackupRegister(BKP_DR7,SummerTimeCorrect);
 8002fcc:	4b4e      	ldr	r3, [pc, #312]	; (8003108 <RTC_Configuration+0x188>)
 8002fce:	881b      	ldrh	r3, [r3, #0]
 8002fd0:	4619      	mov	r1, r3
 8002fd2:	201c      	movs	r0, #28
 8002fd4:	f000 fdfe 	bl	8003bd4 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR2,s_DateStructVar.Month);
 8002fd8:	4b4a      	ldr	r3, [pc, #296]	; (8003104 <RTC_Configuration+0x184>)
 8002fda:	781b      	ldrb	r3, [r3, #0]
 8002fdc:	b29b      	uxth	r3, r3
 8002fde:	4619      	mov	r1, r3
 8002fe0:	2008      	movs	r0, #8
 8002fe2:	f000 fdf7 	bl	8003bd4 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR3,s_DateStructVar.Day);
 8002fe6:	4b47      	ldr	r3, [pc, #284]	; (8003104 <RTC_Configuration+0x184>)
 8002fe8:	785b      	ldrb	r3, [r3, #1]
 8002fea:	b29b      	uxth	r3, r3
 8002fec:	4619      	mov	r1, r3
 8002fee:	200c      	movs	r0, #12
 8002ff0:	f000 fdf0 	bl	8003bd4 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR4,s_DateStructVar.Year);
 8002ff4:	4b43      	ldr	r3, [pc, #268]	; (8003104 <RTC_Configuration+0x184>)
 8002ff6:	885b      	ldrh	r3, [r3, #2]
 8002ff8:	4619      	mov	r1, r3
 8002ffa:	2010      	movs	r0, #16
 8002ffc:	f000 fdea 	bl	8003bd4 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR1, CONFIGURATION_DONE);
 8003000:	f64a 21aa 	movw	r1, #43690	; 0xaaaa
 8003004:	2004      	movs	r0, #4
 8003006:	f000 fde5 	bl	8003bd4 <BKP_WriteBackupRegister>
		/*Enable 32.768 kHz external oscillator */
		RCC_LSEConfig(RCC_LSE_ON);
 800300a:	2001      	movs	r0, #1
 800300c:	f001 fd1c 	bl	8004a48 <RCC_LSEConfig>

		for(WaitForOscSource=0;WaitForOscSource<5000;WaitForOscSource++)
 8003010:	2300      	movs	r3, #0
 8003012:	80fb      	strh	r3, [r7, #6]
 8003014:	e002      	b.n	800301c <RTC_Configuration+0x9c>
 8003016:	88fb      	ldrh	r3, [r7, #6]
 8003018:	3301      	adds	r3, #1
 800301a:	80fb      	strh	r3, [r7, #6]
 800301c:	88fb      	ldrh	r3, [r7, #6]
 800301e:	f241 3287 	movw	r2, #4999	; 0x1387
 8003022:	4293      	cmp	r3, r2
 8003024:	d9f7      	bls.n	8003016 <RTC_Configuration+0x96>
		{
		}
		while ((RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET))
 8003026:	bf00      	nop
 8003028:	2041      	movs	r0, #65	; 0x41
 800302a:	f001 fe69 	bl	8004d00 <RCC_GetFlagStatus>
 800302e:	4603      	mov	r3, r0
 8003030:	2b00      	cmp	r3, #0
 8003032:	d0f9      	beq.n	8003028 <RTC_Configuration+0xa8>
		        // Wait till LSE is ready
		       ;
		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
 8003034:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003038:	f001 fd26 	bl	8004a88 <RCC_RTCCLKConfig>
		/* RTC Enabled */
		RCC_RTCCLKCmd(ENABLE);
 800303c:	2001      	movs	r0, #1
 800303e:	f001 fd35 	bl	8004aac <RCC_RTCCLKCmd>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 8003042:	f001 ff37 	bl	8004eb4 <RTC_WaitForLastTask>
		/* Setting RTC Interrupts-Seconds interrupt enabled */
		/* Enable the RTC Second */
		RTC_ITConfig(RTC_IT_SEC , ENABLE);
 8003046:	2101      	movs	r1, #1
 8003048:	2001      	movs	r0, #1
 800304a:	f001 fe93 	bl	8004d74 <RTC_ITConfig>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 800304e:	f001 ff31 	bl	8004eb4 <RTC_WaitForLastTask>

		BKP_WriteBackupRegister(BKP_DR6, 1);
 8003052:	2101      	movs	r1, #1
 8003054:	2018      	movs	r0, #24
 8003056:	f000 fdbd 	bl	8003bd4 <BKP_WriteBackupRegister>

		/* Set RTC prescaler: set RTC period to 1 sec */
		RTC_SetPrescaler(32765); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
 800305a:	f647 70fd 	movw	r0, #32765	; 0x7ffd
 800305e:	f001 ff0f 	bl	8004e80 <RTC_SetPrescaler>
		/* Prescaler is set to 32766 instead of 32768 to compensate for
        lower as well as higher frequencies*/
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 8003062:	f001 ff27 	bl	8004eb4 <RTC_WaitForLastTask>

		/* Set default system time to 09 : 24 : 00 */
		SetTime(DEFAULT_HOURS,DEFAULT_MINUTES,DEFAULT_SECONDS);
 8003066:	2200      	movs	r2, #0
 8003068:	210b      	movs	r1, #11
 800306a:	2008      	movs	r0, #8
 800306c:	f000 f8a6 	bl	80031bc <SetTime>
		BKP_WriteBackupRegister(BKP_DR1, CONFIGURATION_DONE);
 8003070:	f64a 21aa 	movw	r1, #43690	; 0xaaaa
 8003074:	2004      	movs	r0, #4
 8003076:	f000 fdad 	bl	8003bd4 <BKP_WriteBackupRegister>
 800307a:	e017      	b.n	80030ac <RTC_Configuration+0x12c>
	}
	else
	{
		/* PWR and BKP clocks selection */
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 800307c:	2101      	movs	r1, #1
 800307e:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 8003082:	f001 fe0f 	bl	8004ca4 <RCC_APB1PeriphClockCmd>
		for(WaitForOscSource=0;WaitForOscSource<5000;WaitForOscSource++);
 8003086:	2300      	movs	r3, #0
 8003088:	80fb      	strh	r3, [r7, #6]
 800308a:	e002      	b.n	8003092 <RTC_Configuration+0x112>
 800308c:	88fb      	ldrh	r3, [r7, #6]
 800308e:	3301      	adds	r3, #1
 8003090:	80fb      	strh	r3, [r7, #6]
 8003092:	88fb      	ldrh	r3, [r7, #6]
 8003094:	f241 3287 	movw	r2, #4999	; 0x1387
 8003098:	4293      	cmp	r3, r2
 800309a:	d9f7      	bls.n	800308c <RTC_Configuration+0x10c>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 800309c:	f001 ff0a 	bl	8004eb4 <RTC_WaitForLastTask>
		/* Enable the RTC Second */
		RTC_ITConfig(RTC_IT_SEC, ENABLE);
 80030a0:	2101      	movs	r1, #1
 80030a2:	2001      	movs	r0, #1
 80030a4:	f001 fe66 	bl	8004d74 <RTC_ITConfig>
		RTC_WaitForLastTask();
 80030a8:	f001 ff04 	bl	8004eb4 <RTC_WaitForLastTask>
	}

	/* Check if how many days are elapsed in power down/Low Power Mode-
   Updates Date that many Times*/
	CheckForDaysElapsed();
 80030ac:	f000 fa0a 	bl	80034c4 <CheckForDaysElapsed>
	ClockSource = BKP_ReadBackupRegister(BKP_DR6);
 80030b0:	2018      	movs	r0, #24
 80030b2:	f000 fdab 	bl	8003c0c <BKP_ReadBackupRegister>
 80030b6:	4603      	mov	r3, r0
 80030b8:	b2da      	uxtb	r2, r3
 80030ba:	4b14      	ldr	r3, [pc, #80]	; (800310c <RTC_Configuration+0x18c>)
 80030bc:	701a      	strb	r2, [r3, #0]
	s_DateStructVar.Month = BKP_ReadBackupRegister(BKP_DR2);
 80030be:	2008      	movs	r0, #8
 80030c0:	f000 fda4 	bl	8003c0c <BKP_ReadBackupRegister>
 80030c4:	4603      	mov	r3, r0
 80030c6:	b2da      	uxtb	r2, r3
 80030c8:	4b0e      	ldr	r3, [pc, #56]	; (8003104 <RTC_Configuration+0x184>)
 80030ca:	701a      	strb	r2, [r3, #0]
	s_DateStructVar.Day = BKP_ReadBackupRegister(BKP_DR3);
 80030cc:	200c      	movs	r0, #12
 80030ce:	f000 fd9d 	bl	8003c0c <BKP_ReadBackupRegister>
 80030d2:	4603      	mov	r3, r0
 80030d4:	b2da      	uxtb	r2, r3
 80030d6:	4b0b      	ldr	r3, [pc, #44]	; (8003104 <RTC_Configuration+0x184>)
 80030d8:	705a      	strb	r2, [r3, #1]
	s_DateStructVar.Year = BKP_ReadBackupRegister(BKP_DR4);
 80030da:	2010      	movs	r0, #16
 80030dc:	f000 fd96 	bl	8003c0c <BKP_ReadBackupRegister>
 80030e0:	4603      	mov	r3, r0
 80030e2:	461a      	mov	r2, r3
 80030e4:	4b07      	ldr	r3, [pc, #28]	; (8003104 <RTC_Configuration+0x184>)
 80030e6:	805a      	strh	r2, [r3, #2]
	SummerTimeCorrect = BKP_ReadBackupRegister(BKP_DR7);
 80030e8:	201c      	movs	r0, #28
 80030ea:	f000 fd8f 	bl	8003c0c <BKP_ReadBackupRegister>
 80030ee:	4603      	mov	r3, r0
 80030f0:	461a      	mov	r2, r3
 80030f2:	4b05      	ldr	r3, [pc, #20]	; (8003108 <RTC_Configuration+0x188>)
 80030f4:	801a      	strh	r2, [r3, #0]
}
 80030f6:	bf00      	nop
 80030f8:	3708      	adds	r7, #8
 80030fa:	46bd      	mov	sp, r7
 80030fc:	bd80      	pop	{r7, pc}
 80030fe:	bf00      	nop
 8003100:	20000004 	.word	0x20000004
 8003104:	200002e0 	.word	0x200002e0
 8003108:	200002ea 	.word	0x200002ea
 800310c:	200002ec 	.word	0x200002ec

08003110 <RTC_RCC_Configuration>:
		}
	}
}

void RTC_RCC_Configuration(void)
{
 8003110:	b580      	push	{r7, lr}
 8003112:	b082      	sub	sp, #8
 8003114:	af00      	add	r7, sp, #0

	/* Enable HSE */
	//RCC_HSEConfig(RCC_HSE_ON);

	/* Wait till HSE is ready */
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
 8003116:	f001 fbc3 	bl	80048a0 <RCC_WaitForHSEStartUp>
 800311a:	4603      	mov	r3, r0
 800311c:	71fb      	strb	r3, [r7, #7]

	if(HSEStartUpStatus == SUCCESS)
 800311e:	79fb      	ldrb	r3, [r7, #7]
 8003120:	2b01      	cmp	r3, #1
 8003122:	d128      	bne.n	8003176 <RTC_RCC_Configuration+0x66>
	{
		/* Enable Prefetch Buffer */
		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 8003124:	2010      	movs	r0, #16
 8003126:	f000 ffbf 	bl	80040a8 <FLASH_PrefetchBufferCmd>

		/* Flash 2 wait state */
		FLASH_SetLatency(FLASH_Latency_2);
 800312a:	2002      	movs	r0, #2
 800312c:	f000 ffa0 	bl	8004070 <FLASH_SetLatency>

		/* HCLK = SYSCLK */
		RCC_HCLKConfig(RCC_SYSCLK_Div1);
 8003130:	2000      	movs	r0, #0
 8003132:	f001 fc35 	bl	80049a0 <RCC_HCLKConfig>

		/* PCLK2 = HCLK */
		RCC_PCLK2Config(RCC_HCLK_Div1);
 8003136:	2000      	movs	r0, #0
 8003138:	f001 fc6a 	bl	8004a10 <RCC_PCLK2Config>

		/* PCLK1 = HCLK/2 */
		RCC_PCLK1Config(RCC_HCLK_Div2);
 800313c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8003140:	f001 fc4a 	bl	80049d8 <RCC_PCLK1Config>
		//RCC_PCLK1Config(RCC_HCLK_Div1);
		/* PLLCLK = 8MHz * 9 = 72 MHz */
		/* PLLCLK = 12MHz * 6 = 72 MHz */
		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
 8003144:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
 8003148:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800314c:	f001 fbd0 	bl	80048f0 <RCC_PLLConfig>
		//RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
		/* Enable PLL */
		RCC_PLLCmd(ENABLE);
 8003150:	2001      	movs	r0, #1
 8003152:	f001 fbeb 	bl	800492c <RCC_PLLCmd>

		/* Wait till PLL is ready */
		while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
 8003156:	bf00      	nop
 8003158:	2039      	movs	r0, #57	; 0x39
 800315a:	f001 fdd1 	bl	8004d00 <RCC_GetFlagStatus>
 800315e:	4603      	mov	r3, r0
 8003160:	2b00      	cmp	r3, #0
 8003162:	d0f9      	beq.n	8003158 <RTC_RCC_Configuration+0x48>
		{
		}

		/* Select PLL as system clock source */
		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 8003164:	2002      	movs	r0, #2
 8003166:	f001 fbf1 	bl	800494c <RCC_SYSCLKConfig>

		/* Wait till PLL is used as system clock source */
		while(RCC_GetSYSCLKSource() != 0x08)
 800316a:	bf00      	nop
 800316c:	f001 fc0a 	bl	8004984 <RCC_GetSYSCLKSource>
 8003170:	4603      	mov	r3, r0
 8003172:	2b08      	cmp	r3, #8
 8003174:	d1fa      	bne.n	800316c <RTC_RCC_Configuration+0x5c>
		{
		}
	}

}
 8003176:	bf00      	nop
 8003178:	3708      	adds	r7, #8
 800317a:	46bd      	mov	sp, r7
 800317c:	bd80      	pop	{r7, pc}
 800317e:	bf00      	nop

08003180 <ADCT_BGS_RTC_Init>:
 * @brief  RTC Initialisation Routine
 * @param  None
 * @retval : None
 */
void ADCT_BGS_RTC_Init(void)
{
 8003180:	b580      	push	{r7, lr}
 8003182:	af00      	add	r7, sp, #0
	RTC_RCC_Configuration();
 8003184:	f7ff ffc4 	bl	8003110 <RTC_RCC_Configuration>
	/*Enables the clock to Backup and power interface peripherals    */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP | RCC_APB1Periph_PWR,ENABLE);// Enable PWR/BKP
 8003188:	2101      	movs	r1, #1
 800318a:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 800318e:	f001 fd89 	bl	8004ca4 <RCC_APB1PeriphClockCmd>
	/* Unlock the Flash Program Erase controller */
	FLASH_Unlock();
 8003192:	f000 ffa1 	bl	80040d8 <FLASH_Unlock>
	RTC_NVIC_Configuration();
 8003196:	f000 f9cf 	bl	8003538 <RTC_NVIC_Configuration>
	/* RTC Configuration*/
	RTC_Configuration();
 800319a:	f7ff fef1 	bl	8002f80 <RTC_Configuration>
	/*RTC_NVIC Configuration */

	BKP_RTCOutputConfig(BKP_RTCOutputSource_None);
 800319e:	2000      	movs	r0, #0
 80031a0:	f000 fcfc 	bl	8003b9c <BKP_RTCOutputConfig>
	/* Configure PVD Supervisor to disable the Tamper Interrupt when voltage drops
  below 2.5 volts*/
	PWR_PVDCmd(ENABLE);
 80031a4:	2001      	movs	r0, #1
 80031a6:	f001 fb4f 	bl	8004848 <PWR_PVDCmd>
	PWR_PVDLevelConfig(PWR_PVDLevel_2V5);
 80031aa:	2060      	movs	r0, #96	; 0x60
 80031ac:	f001 fb5c 	bl	8004868 <PWR_PVDLevelConfig>
	PWR_BackupAccessCmd(ENABLE);
 80031b0:	2001      	movs	r0, #1
 80031b2:	f001 fb39 	bl	8004828 <PWR_BackupAccessCmd>

}
 80031b6:	bf00      	nop
 80031b8:	bd80      	pop	{r7, pc}
 80031ba:	bf00      	nop

080031bc <SetTime>:
 * @brief  Sets the RTC Current Counter Value
 * @param Hour, Minute and Seconds data
 * @retval : None
 */
void SetTime(uint8_t Hour,uint8_t Minute,uint8_t Seconds)
{
 80031bc:	b580      	push	{r7, lr}
 80031be:	b084      	sub	sp, #16
 80031c0:	af00      	add	r7, sp, #0
 80031c2:	4603      	mov	r3, r0
 80031c4:	71fb      	strb	r3, [r7, #7]
 80031c6:	460b      	mov	r3, r1
 80031c8:	71bb      	strb	r3, [r7, #6]
 80031ca:	4613      	mov	r3, r2
 80031cc:	717b      	strb	r3, [r7, #5]
	uint32_t CounterValue;

	CounterValue=((Hour * 3600)+ (Minute * 60)+Seconds);
 80031ce:	79fb      	ldrb	r3, [r7, #7]
 80031d0:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80031d4:	fb02 f103 	mul.w	r1, r2, r3
 80031d8:	79ba      	ldrb	r2, [r7, #6]
 80031da:	4613      	mov	r3, r2
 80031dc:	011b      	lsls	r3, r3, #4
 80031de:	1a9b      	subs	r3, r3, r2
 80031e0:	009b      	lsls	r3, r3, #2
 80031e2:	18ca      	adds	r2, r1, r3
 80031e4:	797b      	ldrb	r3, [r7, #5]
 80031e6:	4413      	add	r3, r2
 80031e8:	60fb      	str	r3, [r7, #12]

	RTC_WaitForLastTask();
 80031ea:	f001 fe63 	bl	8004eb4 <RTC_WaitForLastTask>
	RTC_SetCounter(CounterValue);
 80031ee:	68f8      	ldr	r0, [r7, #12]
 80031f0:	f001 fe2e 	bl	8004e50 <RTC_SetCounter>
	RTC_WaitForLastTask();
 80031f4:	f001 fe5e 	bl	8004eb4 <RTC_WaitForLastTask>
}
 80031f8:	bf00      	nop
 80031fa:	3710      	adds	r7, #16
 80031fc:	46bd      	mov	sp, r7
 80031fe:	bd80      	pop	{r7, pc}

08003200 <DateUpdate>:
 * @brief Updates the Date (This function is called when 1 Day has elapsed
 * @param None
 * @retval :None
 */
void DateUpdate(void)
{
 8003200:	b580      	push	{r7, lr}
 8003202:	af00      	add	r7, sp, #0
	s_DateStructVar.Month=BKP_ReadBackupRegister(BKP_DR2);
 8003204:	2008      	movs	r0, #8
 8003206:	f000 fd01 	bl	8003c0c <BKP_ReadBackupRegister>
 800320a:	4603      	mov	r3, r0
 800320c:	b2da      	uxtb	r2, r3
 800320e:	4b63      	ldr	r3, [pc, #396]	; (800339c <DateUpdate+0x19c>)
 8003210:	701a      	strb	r2, [r3, #0]
	s_DateStructVar.Year=BKP_ReadBackupRegister(BKP_DR4);
 8003212:	2010      	movs	r0, #16
 8003214:	f000 fcfa 	bl	8003c0c <BKP_ReadBackupRegister>
 8003218:	4603      	mov	r3, r0
 800321a:	461a      	mov	r2, r3
 800321c:	4b5f      	ldr	r3, [pc, #380]	; (800339c <DateUpdate+0x19c>)
 800321e:	805a      	strh	r2, [r3, #2]
	s_DateStructVar.Day=BKP_ReadBackupRegister(BKP_DR3);
 8003220:	200c      	movs	r0, #12
 8003222:	f000 fcf3 	bl	8003c0c <BKP_ReadBackupRegister>
 8003226:	4603      	mov	r3, r0
 8003228:	b2da      	uxtb	r2, r3
 800322a:	4b5c      	ldr	r3, [pc, #368]	; (800339c <DateUpdate+0x19c>)
 800322c:	705a      	strb	r2, [r3, #1]

	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
 800322e:	4b5b      	ldr	r3, [pc, #364]	; (800339c <DateUpdate+0x19c>)
 8003230:	781b      	ldrb	r3, [r3, #0]
 8003232:	2b01      	cmp	r3, #1
 8003234:	d017      	beq.n	8003266 <DateUpdate+0x66>
 8003236:	4b59      	ldr	r3, [pc, #356]	; (800339c <DateUpdate+0x19c>)
 8003238:	781b      	ldrb	r3, [r3, #0]
 800323a:	2b03      	cmp	r3, #3
 800323c:	d013      	beq.n	8003266 <DateUpdate+0x66>
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
 800323e:	4b57      	ldr	r3, [pc, #348]	; (800339c <DateUpdate+0x19c>)
 8003240:	781b      	ldrb	r3, [r3, #0]
{
	s_DateStructVar.Month=BKP_ReadBackupRegister(BKP_DR2);
	s_DateStructVar.Year=BKP_ReadBackupRegister(BKP_DR4);
	s_DateStructVar.Day=BKP_ReadBackupRegister(BKP_DR3);

	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
 8003242:	2b05      	cmp	r3, #5
 8003244:	d00f      	beq.n	8003266 <DateUpdate+0x66>
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
 8003246:	4b55      	ldr	r3, [pc, #340]	; (800339c <DateUpdate+0x19c>)
 8003248:	781b      	ldrb	r3, [r3, #0]
 800324a:	2b07      	cmp	r3, #7
 800324c:	d00b      	beq.n	8003266 <DateUpdate+0x66>
			s_DateStructVar.Month == 8 || s_DateStructVar.Month == 10 \
 800324e:	4b53      	ldr	r3, [pc, #332]	; (800339c <DateUpdate+0x19c>)
 8003250:	781b      	ldrb	r3, [r3, #0]
	s_DateStructVar.Month=BKP_ReadBackupRegister(BKP_DR2);
	s_DateStructVar.Year=BKP_ReadBackupRegister(BKP_DR4);
	s_DateStructVar.Day=BKP_ReadBackupRegister(BKP_DR3);

	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
 8003252:	2b08      	cmp	r3, #8
 8003254:	d007      	beq.n	8003266 <DateUpdate+0x66>
			s_DateStructVar.Month == 8 || s_DateStructVar.Month == 10 \
 8003256:	4b51      	ldr	r3, [pc, #324]	; (800339c <DateUpdate+0x19c>)
 8003258:	781b      	ldrb	r3, [r3, #0]
 800325a:	2b0a      	cmp	r3, #10
 800325c:	d003      	beq.n	8003266 <DateUpdate+0x66>
			|| s_DateStructVar.Month == 12)
 800325e:	4b4f      	ldr	r3, [pc, #316]	; (800339c <DateUpdate+0x19c>)
 8003260:	781b      	ldrb	r3, [r3, #0]
 8003262:	2b0c      	cmp	r3, #12
 8003264:	d125      	bne.n	80032b2 <DateUpdate+0xb2>
	{
		if(s_DateStructVar.Day < 31)
 8003266:	4b4d      	ldr	r3, [pc, #308]	; (800339c <DateUpdate+0x19c>)
 8003268:	785b      	ldrb	r3, [r3, #1]
 800326a:	2b1e      	cmp	r3, #30
 800326c:	d806      	bhi.n	800327c <DateUpdate+0x7c>
		{
			s_DateStructVar.Day++;
 800326e:	4b4b      	ldr	r3, [pc, #300]	; (800339c <DateUpdate+0x19c>)
 8003270:	785b      	ldrb	r3, [r3, #1]
 8003272:	3301      	adds	r3, #1
 8003274:	b2da      	uxtb	r2, r3
 8003276:	4b49      	ldr	r3, [pc, #292]	; (800339c <DateUpdate+0x19c>)
 8003278:	705a      	strb	r2, [r3, #1]
	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
			s_DateStructVar.Month == 8 || s_DateStructVar.Month == 10 \
			|| s_DateStructVar.Month == 12)
	{
		if(s_DateStructVar.Day < 31)
 800327a:	e078      	b.n	800336e <DateUpdate+0x16e>
			s_DateStructVar.Day++;
		}
		/* Date structure member: s_DateStructVar.Day = 31 */
		else
		{
			if(s_DateStructVar.Month != 12)
 800327c:	4b47      	ldr	r3, [pc, #284]	; (800339c <DateUpdate+0x19c>)
 800327e:	781b      	ldrb	r3, [r3, #0]
 8003280:	2b0c      	cmp	r3, #12
 8003282:	d009      	beq.n	8003298 <DateUpdate+0x98>
			{
				s_DateStructVar.Month++;
 8003284:	4b45      	ldr	r3, [pc, #276]	; (800339c <DateUpdate+0x19c>)
 8003286:	781b      	ldrb	r3, [r3, #0]
 8003288:	3301      	adds	r3, #1
 800328a:	b2da      	uxtb	r2, r3
 800328c:	4b43      	ldr	r3, [pc, #268]	; (800339c <DateUpdate+0x19c>)
 800328e:	701a      	strb	r2, [r3, #0]
				s_DateStructVar.Day = 1;
 8003290:	4b42      	ldr	r3, [pc, #264]	; (800339c <DateUpdate+0x19c>)
 8003292:	2201      	movs	r2, #1
 8003294:	705a      	strb	r2, [r3, #1]
	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
			s_DateStructVar.Month == 8 || s_DateStructVar.Month == 10 \
			|| s_DateStructVar.Month == 12)
	{
		if(s_DateStructVar.Day < 31)
 8003296:	e06a      	b.n	800336e <DateUpdate+0x16e>
				s_DateStructVar.Day = 1;
			}
			/* Date structure member: s_DateStructVar.Day = 31 & s_DateStructVar.Month =12 */
			else
			{
				s_DateStructVar.Month = 1;
 8003298:	4b40      	ldr	r3, [pc, #256]	; (800339c <DateUpdate+0x19c>)
 800329a:	2201      	movs	r2, #1
 800329c:	701a      	strb	r2, [r3, #0]
				s_DateStructVar.Day = 1;
 800329e:	4b3f      	ldr	r3, [pc, #252]	; (800339c <DateUpdate+0x19c>)
 80032a0:	2201      	movs	r2, #1
 80032a2:	705a      	strb	r2, [r3, #1]
				s_DateStructVar.Year++;
 80032a4:	4b3d      	ldr	r3, [pc, #244]	; (800339c <DateUpdate+0x19c>)
 80032a6:	885b      	ldrh	r3, [r3, #2]
 80032a8:	3301      	adds	r3, #1
 80032aa:	b29a      	uxth	r2, r3
 80032ac:	4b3b      	ldr	r3, [pc, #236]	; (800339c <DateUpdate+0x19c>)
 80032ae:	805a      	strh	r2, [r3, #2]
	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
			s_DateStructVar.Month == 8 || s_DateStructVar.Month == 10 \
			|| s_DateStructVar.Month == 12)
	{
		if(s_DateStructVar.Day < 31)
 80032b0:	e05d      	b.n	800336e <DateUpdate+0x16e>
				s_DateStructVar.Day = 1;
				s_DateStructVar.Year++;
			}
		}
	}
	else if(s_DateStructVar.Month == 4 || s_DateStructVar.Month == 6 \
 80032b2:	4b3a      	ldr	r3, [pc, #232]	; (800339c <DateUpdate+0x19c>)
 80032b4:	781b      	ldrb	r3, [r3, #0]
 80032b6:	2b04      	cmp	r3, #4
 80032b8:	d00b      	beq.n	80032d2 <DateUpdate+0xd2>
 80032ba:	4b38      	ldr	r3, [pc, #224]	; (800339c <DateUpdate+0x19c>)
 80032bc:	781b      	ldrb	r3, [r3, #0]
 80032be:	2b06      	cmp	r3, #6
 80032c0:	d007      	beq.n	80032d2 <DateUpdate+0xd2>
			|| s_DateStructVar.Month == 9 ||s_DateStructVar.Month == 11)
 80032c2:	4b36      	ldr	r3, [pc, #216]	; (800339c <DateUpdate+0x19c>)
 80032c4:	781b      	ldrb	r3, [r3, #0]
 80032c6:	2b09      	cmp	r3, #9
 80032c8:	d003      	beq.n	80032d2 <DateUpdate+0xd2>
 80032ca:	4b34      	ldr	r3, [pc, #208]	; (800339c <DateUpdate+0x19c>)
 80032cc:	781b      	ldrb	r3, [r3, #0]
 80032ce:	2b0b      	cmp	r3, #11
 80032d0:	d114      	bne.n	80032fc <DateUpdate+0xfc>
	{
		if(s_DateStructVar.Day < 30)
 80032d2:	4b32      	ldr	r3, [pc, #200]	; (800339c <DateUpdate+0x19c>)
 80032d4:	785b      	ldrb	r3, [r3, #1]
 80032d6:	2b1d      	cmp	r3, #29
 80032d8:	d806      	bhi.n	80032e8 <DateUpdate+0xe8>
		{
			s_DateStructVar.Day++;
 80032da:	4b30      	ldr	r3, [pc, #192]	; (800339c <DateUpdate+0x19c>)
 80032dc:	785b      	ldrb	r3, [r3, #1]
 80032de:	3301      	adds	r3, #1
 80032e0:	b2da      	uxtb	r2, r3
 80032e2:	4b2e      	ldr	r3, [pc, #184]	; (800339c <DateUpdate+0x19c>)
 80032e4:	705a      	strb	r2, [r3, #1]
		}
	}
	else if(s_DateStructVar.Month == 4 || s_DateStructVar.Month == 6 \
			|| s_DateStructVar.Month == 9 ||s_DateStructVar.Month == 11)
	{
		if(s_DateStructVar.Day < 30)
 80032e6:	e042      	b.n	800336e <DateUpdate+0x16e>
			s_DateStructVar.Day++;
		}
		/* Date structure member: s_DateStructVar.Day = 30 */
		else
		{
			s_DateStructVar.Month++;
 80032e8:	4b2c      	ldr	r3, [pc, #176]	; (800339c <DateUpdate+0x19c>)
 80032ea:	781b      	ldrb	r3, [r3, #0]
 80032ec:	3301      	adds	r3, #1
 80032ee:	b2da      	uxtb	r2, r3
 80032f0:	4b2a      	ldr	r3, [pc, #168]	; (800339c <DateUpdate+0x19c>)
 80032f2:	701a      	strb	r2, [r3, #0]
			s_DateStructVar.Day = 1;
 80032f4:	4b29      	ldr	r3, [pc, #164]	; (800339c <DateUpdate+0x19c>)
 80032f6:	2201      	movs	r2, #1
 80032f8:	705a      	strb	r2, [r3, #1]
		}
	}
	else if(s_DateStructVar.Month == 4 || s_DateStructVar.Month == 6 \
			|| s_DateStructVar.Month == 9 ||s_DateStructVar.Month == 11)
	{
		if(s_DateStructVar.Day < 30)
 80032fa:	e038      	b.n	800336e <DateUpdate+0x16e>
		{
			s_DateStructVar.Month++;
			s_DateStructVar.Day = 1;
		}
	}
	else if(s_DateStructVar.Month == 2)
 80032fc:	4b27      	ldr	r3, [pc, #156]	; (800339c <DateUpdate+0x19c>)
 80032fe:	781b      	ldrb	r3, [r3, #0]
 8003300:	2b02      	cmp	r3, #2
 8003302:	d134      	bne.n	800336e <DateUpdate+0x16e>
	{
		if(s_DateStructVar.Day < 28)
 8003304:	4b25      	ldr	r3, [pc, #148]	; (800339c <DateUpdate+0x19c>)
 8003306:	785b      	ldrb	r3, [r3, #1]
 8003308:	2b1b      	cmp	r3, #27
 800330a:	d806      	bhi.n	800331a <DateUpdate+0x11a>
		{
			s_DateStructVar.Day++;
 800330c:	4b23      	ldr	r3, [pc, #140]	; (800339c <DateUpdate+0x19c>)
 800330e:	785b      	ldrb	r3, [r3, #1]
 8003310:	3301      	adds	r3, #1
 8003312:	b2da      	uxtb	r2, r3
 8003314:	4b21      	ldr	r3, [pc, #132]	; (800339c <DateUpdate+0x19c>)
 8003316:	705a      	strb	r2, [r3, #1]
 8003318:	e029      	b.n	800336e <DateUpdate+0x16e>
		}
		else if(s_DateStructVar.Day == 28)
 800331a:	4b20      	ldr	r3, [pc, #128]	; (800339c <DateUpdate+0x19c>)
 800331c:	785b      	ldrb	r3, [r3, #1]
 800331e:	2b1c      	cmp	r3, #28
 8003320:	d118      	bne.n	8003354 <DateUpdate+0x154>
		{
			/* Leap Year Correction */
			if(CheckLeap(s_DateStructVar.Year))
 8003322:	4b1e      	ldr	r3, [pc, #120]	; (800339c <DateUpdate+0x19c>)
 8003324:	885b      	ldrh	r3, [r3, #2]
 8003326:	4618      	mov	r0, r3
 8003328:	f000 f83a 	bl	80033a0 <CheckLeap>
 800332c:	4603      	mov	r3, r0
 800332e:	2b00      	cmp	r3, #0
 8003330:	d006      	beq.n	8003340 <DateUpdate+0x140>
			{
				s_DateStructVar.Day++;
 8003332:	4b1a      	ldr	r3, [pc, #104]	; (800339c <DateUpdate+0x19c>)
 8003334:	785b      	ldrb	r3, [r3, #1]
 8003336:	3301      	adds	r3, #1
 8003338:	b2da      	uxtb	r2, r3
 800333a:	4b18      	ldr	r3, [pc, #96]	; (800339c <DateUpdate+0x19c>)
 800333c:	705a      	strb	r2, [r3, #1]
 800333e:	e016      	b.n	800336e <DateUpdate+0x16e>
			}
			else
			{
				s_DateStructVar.Month++;
 8003340:	4b16      	ldr	r3, [pc, #88]	; (800339c <DateUpdate+0x19c>)
 8003342:	781b      	ldrb	r3, [r3, #0]
 8003344:	3301      	adds	r3, #1
 8003346:	b2da      	uxtb	r2, r3
 8003348:	4b14      	ldr	r3, [pc, #80]	; (800339c <DateUpdate+0x19c>)
 800334a:	701a      	strb	r2, [r3, #0]
				s_DateStructVar.Day = 1;
 800334c:	4b13      	ldr	r3, [pc, #76]	; (800339c <DateUpdate+0x19c>)
 800334e:	2201      	movs	r2, #1
 8003350:	705a      	strb	r2, [r3, #1]
 8003352:	e00c      	b.n	800336e <DateUpdate+0x16e>
			}
		}
		else if(s_DateStructVar.Day == 29)
 8003354:	4b11      	ldr	r3, [pc, #68]	; (800339c <DateUpdate+0x19c>)
 8003356:	785b      	ldrb	r3, [r3, #1]
 8003358:	2b1d      	cmp	r3, #29
 800335a:	d108      	bne.n	800336e <DateUpdate+0x16e>
		{
			s_DateStructVar.Month++;
 800335c:	4b0f      	ldr	r3, [pc, #60]	; (800339c <DateUpdate+0x19c>)
 800335e:	781b      	ldrb	r3, [r3, #0]
 8003360:	3301      	adds	r3, #1
 8003362:	b2da      	uxtb	r2, r3
 8003364:	4b0d      	ldr	r3, [pc, #52]	; (800339c <DateUpdate+0x19c>)
 8003366:	701a      	strb	r2, [r3, #0]
			s_DateStructVar.Day = 1;
 8003368:	4b0c      	ldr	r3, [pc, #48]	; (800339c <DateUpdate+0x19c>)
 800336a:	2201      	movs	r2, #1
 800336c:	705a      	strb	r2, [r3, #1]
		}
	}

	BKP_WriteBackupRegister(BKP_DR2,s_DateStructVar.Month);
 800336e:	4b0b      	ldr	r3, [pc, #44]	; (800339c <DateUpdate+0x19c>)
 8003370:	781b      	ldrb	r3, [r3, #0]
 8003372:	b29b      	uxth	r3, r3
 8003374:	4619      	mov	r1, r3
 8003376:	2008      	movs	r0, #8
 8003378:	f000 fc2c 	bl	8003bd4 <BKP_WriteBackupRegister>
	BKP_WriteBackupRegister(BKP_DR3,s_DateStructVar.Day);
 800337c:	4b07      	ldr	r3, [pc, #28]	; (800339c <DateUpdate+0x19c>)
 800337e:	785b      	ldrb	r3, [r3, #1]
 8003380:	b29b      	uxth	r3, r3
 8003382:	4619      	mov	r1, r3
 8003384:	200c      	movs	r0, #12
 8003386:	f000 fc25 	bl	8003bd4 <BKP_WriteBackupRegister>
	BKP_WriteBackupRegister(BKP_DR4,s_DateStructVar.Year);
 800338a:	4b04      	ldr	r3, [pc, #16]	; (800339c <DateUpdate+0x19c>)
 800338c:	885b      	ldrh	r3, [r3, #2]
 800338e:	4619      	mov	r1, r3
 8003390:	2010      	movs	r0, #16
 8003392:	f000 fc1f 	bl	8003bd4 <BKP_WriteBackupRegister>
}
 8003396:	bf00      	nop
 8003398:	bd80      	pop	{r7, pc}
 800339a:	bf00      	nop
 800339c:	200002e0 	.word	0x200002e0

080033a0 <CheckLeap>:
 * @param  None
 * @retval : 1: leap year
 *   0: not leap year
 */
uint8_t CheckLeap(uint16_t Year)
{
 80033a0:	b480      	push	{r7}
 80033a2:	b083      	sub	sp, #12
 80033a4:	af00      	add	r7, sp, #0
 80033a6:	4603      	mov	r3, r0
 80033a8:	80fb      	strh	r3, [r7, #6]
	if((Year%400)==0)
 80033aa:	88fb      	ldrh	r3, [r7, #6]
 80033ac:	4a14      	ldr	r2, [pc, #80]	; (8003400 <CheckLeap+0x60>)
 80033ae:	fba2 1203 	umull	r1, r2, r2, r3
 80033b2:	09d2      	lsrs	r2, r2, #7
 80033b4:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80033b8:	fb01 f202 	mul.w	r2, r1, r2
 80033bc:	1a9b      	subs	r3, r3, r2
 80033be:	b29b      	uxth	r3, r3
 80033c0:	2b00      	cmp	r3, #0
 80033c2:	d101      	bne.n	80033c8 <CheckLeap+0x28>
	{
		return LEAP;
 80033c4:	2301      	movs	r3, #1
 80033c6:	e016      	b.n	80033f6 <CheckLeap+0x56>
	}
	else if((Year%100)==0)
 80033c8:	88fb      	ldrh	r3, [r7, #6]
 80033ca:	4a0d      	ldr	r2, [pc, #52]	; (8003400 <CheckLeap+0x60>)
 80033cc:	fba2 1203 	umull	r1, r2, r2, r3
 80033d0:	0952      	lsrs	r2, r2, #5
 80033d2:	2164      	movs	r1, #100	; 0x64
 80033d4:	fb01 f202 	mul.w	r2, r1, r2
 80033d8:	1a9b      	subs	r3, r3, r2
 80033da:	b29b      	uxth	r3, r3
 80033dc:	2b00      	cmp	r3, #0
 80033de:	d101      	bne.n	80033e4 <CheckLeap+0x44>
	{
		return NOT_LEAP;
 80033e0:	2300      	movs	r3, #0
 80033e2:	e008      	b.n	80033f6 <CheckLeap+0x56>
	}
	else if((Year%4)==0)
 80033e4:	88fb      	ldrh	r3, [r7, #6]
 80033e6:	f003 0303 	and.w	r3, r3, #3
 80033ea:	b29b      	uxth	r3, r3
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	d101      	bne.n	80033f4 <CheckLeap+0x54>
	{
		return LEAP;
 80033f0:	2301      	movs	r3, #1
 80033f2:	e000      	b.n	80033f6 <CheckLeap+0x56>
	}
	else
	{
		return NOT_LEAP;
 80033f4:	2300      	movs	r3, #0
	}
}
 80033f6:	4618      	mov	r0, r3
 80033f8:	370c      	adds	r7, #12
 80033fa:	46bd      	mov	sp, r7
 80033fc:	bc80      	pop	{r7}
 80033fe:	4770      	bx	lr
 8003400:	51eb851f 	.word	0x51eb851f

08003404 <WeekDay>:
 * @brief Determines the weekday
 * @param Year,Month and Day
 * @retval :Returns the CurrentWeekDay Number 0- Sunday 6- Saturday
 */
uint16_t WeekDay(uint16_t CurrentYear,uint8_t CurrentMonth,uint8_t CurrentDay)
{
 8003404:	b490      	push	{r4, r7}
 8003406:	b086      	sub	sp, #24
 8003408:	af00      	add	r7, sp, #0
 800340a:	4603      	mov	r3, r0
 800340c:	80fb      	strh	r3, [r7, #6]
 800340e:	460b      	mov	r3, r1
 8003410:	717b      	strb	r3, [r7, #5]
 8003412:	4613      	mov	r3, r2
 8003414:	713b      	strb	r3, [r7, #4]
	uint16_t Temp1,Temp2,Temp3,Temp4,CurrentWeekDay;

	if(CurrentMonth < 3)
 8003416:	797b      	ldrb	r3, [r7, #5]
 8003418:	2b02      	cmp	r3, #2
 800341a:	d805      	bhi.n	8003428 <WeekDay+0x24>
	{
		CurrentMonth=CurrentMonth + 12;
 800341c:	797b      	ldrb	r3, [r7, #5]
 800341e:	330c      	adds	r3, #12
 8003420:	717b      	strb	r3, [r7, #5]
		CurrentYear=CurrentYear-1;
 8003422:	88fb      	ldrh	r3, [r7, #6]
 8003424:	3b01      	subs	r3, #1
 8003426:	80fb      	strh	r3, [r7, #6]
	}

	Temp1=(6*(CurrentMonth + 1))/10;
 8003428:	797b      	ldrb	r3, [r7, #5]
 800342a:	1c5a      	adds	r2, r3, #1
 800342c:	4613      	mov	r3, r2
 800342e:	005b      	lsls	r3, r3, #1
 8003430:	4413      	add	r3, r2
 8003432:	005b      	lsls	r3, r3, #1
 8003434:	4a20      	ldr	r2, [pc, #128]	; (80034b8 <WeekDay+0xb4>)
 8003436:	fb82 1203 	smull	r1, r2, r2, r3
 800343a:	1092      	asrs	r2, r2, #2
 800343c:	17db      	asrs	r3, r3, #31
 800343e:	1ad3      	subs	r3, r2, r3
 8003440:	82fb      	strh	r3, [r7, #22]
	Temp2=CurrentYear/4;
 8003442:	88fb      	ldrh	r3, [r7, #6]
 8003444:	089b      	lsrs	r3, r3, #2
 8003446:	82bb      	strh	r3, [r7, #20]
	Temp3=CurrentYear/100;
 8003448:	88fb      	ldrh	r3, [r7, #6]
 800344a:	4a1c      	ldr	r2, [pc, #112]	; (80034bc <WeekDay+0xb8>)
 800344c:	fba2 2303 	umull	r2, r3, r2, r3
 8003450:	095b      	lsrs	r3, r3, #5
 8003452:	827b      	strh	r3, [r7, #18]
	Temp4=CurrentYear/400;
 8003454:	88fb      	ldrh	r3, [r7, #6]
 8003456:	4a19      	ldr	r2, [pc, #100]	; (80034bc <WeekDay+0xb8>)
 8003458:	fba2 2303 	umull	r2, r3, r2, r3
 800345c:	09db      	lsrs	r3, r3, #7
 800345e:	823b      	strh	r3, [r7, #16]
	CurrentWeekDay=CurrentDay + (2 * CurrentMonth) + Temp1 \
 8003460:	793b      	ldrb	r3, [r7, #4]
 8003462:	b29a      	uxth	r2, r3
 8003464:	797b      	ldrb	r3, [r7, #5]
 8003466:	b29b      	uxth	r3, r3
 8003468:	005b      	lsls	r3, r3, #1
 800346a:	b29b      	uxth	r3, r3
 800346c:	4413      	add	r3, r2
 800346e:	b29a      	uxth	r2, r3
 8003470:	8afb      	ldrh	r3, [r7, #22]
 8003472:	4413      	add	r3, r2
 8003474:	b29a      	uxth	r2, r3
 8003476:	88fb      	ldrh	r3, [r7, #6]
 8003478:	4413      	add	r3, r2
 800347a:	b29a      	uxth	r2, r3
 800347c:	8abb      	ldrh	r3, [r7, #20]
 800347e:	4413      	add	r3, r2
 8003480:	b29a      	uxth	r2, r3
 8003482:	8a7b      	ldrh	r3, [r7, #18]
 8003484:	1ad3      	subs	r3, r2, r3
 8003486:	b29a      	uxth	r2, r3
 8003488:	8a3b      	ldrh	r3, [r7, #16]
 800348a:	4413      	add	r3, r2
 800348c:	b29b      	uxth	r3, r3
 800348e:	3301      	adds	r3, #1
 8003490:	81fb      	strh	r3, [r7, #14]
			+ CurrentYear + Temp2 - Temp3 + Temp4 +1;
	CurrentWeekDay = CurrentWeekDay % 7;
 8003492:	89fa      	ldrh	r2, [r7, #14]
 8003494:	4b0a      	ldr	r3, [pc, #40]	; (80034c0 <WeekDay+0xbc>)
 8003496:	fba2 3403 	umull	r3, r4, r2, r3
 800349a:	1b11      	subs	r1, r2, r4
 800349c:	0849      	lsrs	r1, r1, #1
 800349e:	190b      	adds	r3, r1, r4
 80034a0:	0899      	lsrs	r1, r3, #2
 80034a2:	460b      	mov	r3, r1
 80034a4:	00db      	lsls	r3, r3, #3
 80034a6:	1a5b      	subs	r3, r3, r1
 80034a8:	1ad3      	subs	r3, r2, r3
 80034aa:	81fb      	strh	r3, [r7, #14]

	return(CurrentWeekDay);
 80034ac:	89fb      	ldrh	r3, [r7, #14]
}
 80034ae:	4618      	mov	r0, r3
 80034b0:	3718      	adds	r7, #24
 80034b2:	46bd      	mov	sp, r7
 80034b4:	bc90      	pop	{r4, r7}
 80034b6:	4770      	bx	lr
 80034b8:	66666667 	.word	0x66666667
 80034bc:	51eb851f 	.word	0x51eb851f
 80034c0:	24924925 	.word	0x24924925

080034c4 <CheckForDaysElapsed>:
 *   elapsed and updates date that many times
 * @param None
 * @retval :None
 */
void CheckForDaysElapsed(void)
{
 80034c4:	b590      	push	{r4, r7, lr}
 80034c6:	b083      	sub	sp, #12
 80034c8:	af00      	add	r7, sp, #0
	uint8_t DaysElapsed;

	if((RTC_GetCounter() / SECONDS_IN_DAY) != 0)
 80034ca:	f001 fc99 	bl	8004e00 <RTC_GetCounter>
 80034ce:	4602      	mov	r2, r0
 80034d0:	4b16      	ldr	r3, [pc, #88]	; (800352c <CheckForDaysElapsed+0x68>)
 80034d2:	429a      	cmp	r2, r3
 80034d4:	d925      	bls.n	8003522 <CheckForDaysElapsed+0x5e>
	{
		for(DaysElapsed = 0; DaysElapsed < (RTC_GetCounter() / SECONDS_IN_DAY) ;DaysElapsed++)
 80034d6:	2300      	movs	r3, #0
 80034d8:	71fb      	strb	r3, [r7, #7]
 80034da:	e004      	b.n	80034e6 <CheckForDaysElapsed+0x22>
		{
			DateUpdate();
 80034dc:	f7ff fe90 	bl	8003200 <DateUpdate>
{
	uint8_t DaysElapsed;

	if((RTC_GetCounter() / SECONDS_IN_DAY) != 0)
	{
		for(DaysElapsed = 0; DaysElapsed < (RTC_GetCounter() / SECONDS_IN_DAY) ;DaysElapsed++)
 80034e0:	79fb      	ldrb	r3, [r7, #7]
 80034e2:	3301      	adds	r3, #1
 80034e4:	71fb      	strb	r3, [r7, #7]
 80034e6:	79fc      	ldrb	r4, [r7, #7]
 80034e8:	f001 fc8a 	bl	8004e00 <RTC_GetCounter>
 80034ec:	4602      	mov	r2, r0
 80034ee:	4b10      	ldr	r3, [pc, #64]	; (8003530 <CheckForDaysElapsed+0x6c>)
 80034f0:	fba3 1302 	umull	r1, r3, r3, r2
 80034f4:	1ad2      	subs	r2, r2, r3
 80034f6:	0852      	lsrs	r2, r2, #1
 80034f8:	4413      	add	r3, r2
 80034fa:	0c1b      	lsrs	r3, r3, #16
 80034fc:	429c      	cmp	r4, r3
 80034fe:	d3ed      	bcc.n	80034dc <CheckForDaysElapsed+0x18>
		{
			DateUpdate();
		}

		RTC_SetCounter(RTC_GetCounter() % SECONDS_IN_DAY);
 8003500:	f001 fc7e 	bl	8004e00 <RTC_GetCounter>
 8003504:	4602      	mov	r2, r0
 8003506:	4b0a      	ldr	r3, [pc, #40]	; (8003530 <CheckForDaysElapsed+0x6c>)
 8003508:	fba3 1302 	umull	r1, r3, r3, r2
 800350c:	1ad1      	subs	r1, r2, r3
 800350e:	0849      	lsrs	r1, r1, #1
 8003510:	440b      	add	r3, r1
 8003512:	0c1b      	lsrs	r3, r3, #16
 8003514:	4907      	ldr	r1, [pc, #28]	; (8003534 <CheckForDaysElapsed+0x70>)
 8003516:	fb01 f303 	mul.w	r3, r1, r3
 800351a:	1ad3      	subs	r3, r2, r3
 800351c:	4618      	mov	r0, r3
 800351e:	f001 fc97 	bl	8004e50 <RTC_SetCounter>
	}
}
 8003522:	bf00      	nop
 8003524:	370c      	adds	r7, #12
 8003526:	46bd      	mov	sp, r7
 8003528:	bd90      	pop	{r4, r7, pc}
 800352a:	bf00      	nop
 800352c:	0001517e 	.word	0x0001517e
 8003530:	845db0a3 	.word	0x845db0a3
 8003534:	0001517f 	.word	0x0001517f

08003538 <RTC_NVIC_Configuration>:
 * @brief  Configures RTC Interrupts
 * @param  None
 * @retval : None
 */
void RTC_NVIC_Configuration(void)
{
 8003538:	b580      	push	{r7, lr}
 800353a:	b082      	sub	sp, #8
 800353c:	af00      	add	r7, sp, #0
	NVIC_InitTypeDef NVIC_InitStructure;
	/* Configure one bit for preemption priority */
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	/* Enable the RTC Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
 800353e:	2303      	movs	r3, #3
 8003540:	713b      	strb	r3, [r7, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
 8003542:	2304      	movs	r3, #4
 8003544:	717b      	strb	r3, [r7, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
 8003546:	2304      	movs	r3, #4
 8003548:	71bb      	strb	r3, [r7, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800354a:	2301      	movs	r3, #1
 800354c:	71fb      	strb	r3, [r7, #7]
	NVIC_Init(&NVIC_InitStructure);
 800354e:	1d3b      	adds	r3, r7, #4
 8003550:	4618      	mov	r0, r3
 8003552:	f000 fab7 	bl	8003ac4 <NVIC_Init>
}
 8003556:	bf00      	nop
 8003558:	3708      	adds	r7, #8
 800355a:	46bd      	mov	sp, r7
 800355c:	bd80      	pop	{r7, pc}
 800355e:	bf00      	nop

08003560 <RTC_IRQHandler>:
 * @brief  This function handles RTC_IRQHandler .
 * @param  None
 * @retval : None
 */
void RTC_IRQHandler(void)
{
 8003560:	b580      	push	{r7, lr}
 8003562:	b082      	sub	sp, #8
 8003564:	af00      	add	r7, sp, #0
	uint8_t Month,Day;
	uint16_t Year;

	Month = BKP_ReadBackupRegister(BKP_DR2);
 8003566:	2008      	movs	r0, #8
 8003568:	f000 fb50 	bl	8003c0c <BKP_ReadBackupRegister>
 800356c:	4603      	mov	r3, r0
 800356e:	71fb      	strb	r3, [r7, #7]
	Day = BKP_ReadBackupRegister(BKP_DR3);
 8003570:	200c      	movs	r0, #12
 8003572:	f000 fb4b 	bl	8003c0c <BKP_ReadBackupRegister>
 8003576:	4603      	mov	r3, r0
 8003578:	71bb      	strb	r3, [r7, #6]
	Year = BKP_ReadBackupRegister(BKP_DR4);
 800357a:	2010      	movs	r0, #16
 800357c:	f000 fb46 	bl	8003c0c <BKP_ReadBackupRegister>
 8003580:	4603      	mov	r3, r0
 8003582:	80bb      	strh	r3, [r7, #4]
	if(RTC_GetITStatus(RTC_IT_SEC) !=RESET )
 8003584:	2001      	movs	r0, #1
 8003586:	f001 fca5 	bl	8004ed4 <RTC_GetITStatus>
 800358a:	4603      	mov	r3, r0
 800358c:	2b00      	cmp	r3, #0
 800358e:	d005      	beq.n	800359c <RTC_IRQHandler+0x3c>
	{
		NVIC_ClearPendingIRQ(RTC_IRQn);
 8003590:	2003      	movs	r0, #3
 8003592:	f7ff fcdb 	bl	8002f4c <NVIC_ClearPendingIRQ>
		RTC_ClearITPendingBit(RTC_IT_SEC);
 8003596:	2001      	movs	r0, #1
 8003598:	f001 fcc4 	bl	8004f24 <RTC_ClearITPendingBit>
	}

	/* If counter is equal to 86399: one day was elapsed */
	/* This takes care of date change and resetting of counter in case of
  power on - Run mode/ Main supply switched on condition*/
	if(RTC_GetCounter() == 86399)
 800359c:	f001 fc30 	bl	8004e00 <RTC_GetCounter>
 80035a0:	4602      	mov	r2, r0
 80035a2:	4b59      	ldr	r3, [pc, #356]	; (8003708 <RTC_IRQHandler+0x1a8>)
 80035a4:	429a      	cmp	r2, r3
 80035a6:	d108      	bne.n	80035ba <RTC_IRQHandler+0x5a>
	{
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80035a8:	f001 fc84 	bl	8004eb4 <RTC_WaitForLastTask>
		/* Reset counter value */
		RTC_SetCounter(0x0);
 80035ac:	2000      	movs	r0, #0
 80035ae:	f001 fc4f 	bl	8004e50 <RTC_SetCounter>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80035b2:	f001 fc7f 	bl	8004eb4 <RTC_WaitForLastTask>

		/* Increment the date */
		DateUpdate();
 80035b6:	f7ff fe23 	bl	8003200 <DateUpdate>
	}

	if((RTC_GetCounter()/3600 == 1)&&(((RTC_GetCounter()%3600)/60) == 59)&&
 80035ba:	f001 fc21 	bl	8004e00 <RTC_GetCounter>
 80035be:	4603      	mov	r3, r0
 80035c0:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 80035c4:	f5b3 6f61 	cmp.w	r3, #3600	; 0xe10
 80035c8:	f080 8099 	bcs.w	80036fe <RTC_IRQHandler+0x19e>
 80035cc:	f001 fc18 	bl	8004e00 <RTC_GetCounter>
 80035d0:	4602      	mov	r2, r0
 80035d2:	4b4e      	ldr	r3, [pc, #312]	; (800370c <RTC_IRQHandler+0x1ac>)
 80035d4:	fba3 1302 	umull	r1, r3, r3, r2
 80035d8:	0adb      	lsrs	r3, r3, #11
 80035da:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80035de:	fb01 f303 	mul.w	r3, r1, r3
 80035e2:	1ad3      	subs	r3, r2, r3
 80035e4:	f6a3 53d4 	subw	r3, r3, #3540	; 0xdd4
 80035e8:	2b3b      	cmp	r3, #59	; 0x3b
 80035ea:	f200 8088 	bhi.w	80036fe <RTC_IRQHandler+0x19e>
			(((RTC_GetCounter()%3600)%60) == 59))
 80035ee:	f001 fc07 	bl	8004e00 <RTC_GetCounter>
 80035f2:	4603      	mov	r3, r0
 80035f4:	4a45      	ldr	r2, [pc, #276]	; (800370c <RTC_IRQHandler+0x1ac>)
 80035f6:	fba2 1203 	umull	r1, r2, r2, r3
 80035fa:	0ad2      	lsrs	r2, r2, #11
 80035fc:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8003600:	fb01 f202 	mul.w	r2, r1, r2
 8003604:	1a9a      	subs	r2, r3, r2
 8003606:	4b42      	ldr	r3, [pc, #264]	; (8003710 <RTC_IRQHandler+0x1b0>)
 8003608:	fba3 1302 	umull	r1, r3, r3, r2
 800360c:	0959      	lsrs	r1, r3, #5
 800360e:	460b      	mov	r3, r1
 8003610:	011b      	lsls	r3, r3, #4
 8003612:	1a5b      	subs	r3, r3, r1
 8003614:	009b      	lsls	r3, r3, #2
 8003616:	1ad1      	subs	r1, r2, r3

		/* Increment the date */
		DateUpdate();
	}

	if((RTC_GetCounter()/3600 == 1)&&(((RTC_GetCounter()%3600)/60) == 59)&&
 8003618:	293b      	cmp	r1, #59	; 0x3b
 800361a:	d170      	bne.n	80036fe <RTC_IRQHandler+0x19e>
			(((RTC_GetCounter()%3600)%60) == 59))
	{
		/* March Correction */
		if((Month == 3) && (Day >24))
 800361c:	79fb      	ldrb	r3, [r7, #7]
 800361e:	2b03      	cmp	r3, #3
 8003620:	d133      	bne.n	800368a <RTC_IRQHandler+0x12a>
 8003622:	79bb      	ldrb	r3, [r7, #6]
 8003624:	2b18      	cmp	r3, #24
 8003626:	d930      	bls.n	800368a <RTC_IRQHandler+0x12a>
		{
			if(WeekDay(Year,Month,Day)==0)
 8003628:	79ba      	ldrb	r2, [r7, #6]
 800362a:	79f9      	ldrb	r1, [r7, #7]
 800362c:	88bb      	ldrh	r3, [r7, #4]
 800362e:	4618      	mov	r0, r3
 8003630:	f7ff fee8 	bl	8003404 <WeekDay>
 8003634:	4603      	mov	r3, r0
 8003636:	2b00      	cmp	r3, #0
 8003638:	d127      	bne.n	800368a <RTC_IRQHandler+0x12a>
			{
				if((SummerTimeCorrect & 0x8000) == 0x8000)
 800363a:	4b36      	ldr	r3, [pc, #216]	; (8003714 <RTC_IRQHandler+0x1b4>)
 800363c:	881b      	ldrh	r3, [r3, #0]
 800363e:	b21b      	sxth	r3, r3
 8003640:	2b00      	cmp	r3, #0
 8003642:	da22      	bge.n	800368a <RTC_IRQHandler+0x12a>
				{
					RTC_SetCounter(RTC_GetCounter() + 3601);
 8003644:	f001 fbdc 	bl	8004e00 <RTC_GetCounter>
 8003648:	4603      	mov	r3, r0
 800364a:	f603 6311 	addw	r3, r3, #3601	; 0xe11
 800364e:	4618      	mov	r0, r3
 8003650:	f001 fbfe 	bl	8004e50 <RTC_SetCounter>

					/* Reset March correction flag */
					SummerTimeCorrect &= 0x7FFF;
 8003654:	4b2f      	ldr	r3, [pc, #188]	; (8003714 <RTC_IRQHandler+0x1b4>)
 8003656:	881b      	ldrh	r3, [r3, #0]
 8003658:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800365c:	b29a      	uxth	r2, r3
 800365e:	4b2d      	ldr	r3, [pc, #180]	; (8003714 <RTC_IRQHandler+0x1b4>)
 8003660:	801a      	strh	r2, [r3, #0]

					/* Set October correction flag  */
					SummerTimeCorrect |= 0x4000;
 8003662:	4b2c      	ldr	r3, [pc, #176]	; (8003714 <RTC_IRQHandler+0x1b4>)
 8003664:	881b      	ldrh	r3, [r3, #0]
 8003666:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800366a:	b29a      	uxth	r2, r3
 800366c:	4b29      	ldr	r3, [pc, #164]	; (8003714 <RTC_IRQHandler+0x1b4>)
 800366e:	801a      	strh	r2, [r3, #0]
					SummerTimeCorrect |= Year;
 8003670:	4b28      	ldr	r3, [pc, #160]	; (8003714 <RTC_IRQHandler+0x1b4>)
 8003672:	881a      	ldrh	r2, [r3, #0]
 8003674:	88bb      	ldrh	r3, [r7, #4]
 8003676:	4313      	orrs	r3, r2
 8003678:	b29a      	uxth	r2, r3
 800367a:	4b26      	ldr	r3, [pc, #152]	; (8003714 <RTC_IRQHandler+0x1b4>)
 800367c:	801a      	strh	r2, [r3, #0]
					BKP_WriteBackupRegister(BKP_DR7,SummerTimeCorrect);
 800367e:	4b25      	ldr	r3, [pc, #148]	; (8003714 <RTC_IRQHandler+0x1b4>)
 8003680:	881b      	ldrh	r3, [r3, #0]
 8003682:	4619      	mov	r1, r3
 8003684:	201c      	movs	r0, #28
 8003686:	f000 faa5 	bl	8003bd4 <BKP_WriteBackupRegister>
				}
			}
		}
		/* October Correction */
		if((Month == 10) && (Day >24))
 800368a:	79fb      	ldrb	r3, [r7, #7]
 800368c:	2b0a      	cmp	r3, #10
 800368e:	d136      	bne.n	80036fe <RTC_IRQHandler+0x19e>
 8003690:	79bb      	ldrb	r3, [r7, #6]
 8003692:	2b18      	cmp	r3, #24
 8003694:	d933      	bls.n	80036fe <RTC_IRQHandler+0x19e>
		{
			if(WeekDay(Year,Month,Day)==0)
 8003696:	79ba      	ldrb	r2, [r7, #6]
 8003698:	79f9      	ldrb	r1, [r7, #7]
 800369a:	88bb      	ldrh	r3, [r7, #4]
 800369c:	4618      	mov	r0, r3
 800369e:	f7ff feb1 	bl	8003404 <WeekDay>
 80036a2:	4603      	mov	r3, r0
 80036a4:	2b00      	cmp	r3, #0
 80036a6:	d12a      	bne.n	80036fe <RTC_IRQHandler+0x19e>
			{
				if((SummerTimeCorrect & 0x4000) == 0x4000)
 80036a8:	4b1a      	ldr	r3, [pc, #104]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036aa:	881b      	ldrh	r3, [r3, #0]
 80036ac:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80036b0:	2b00      	cmp	r3, #0
 80036b2:	d024      	beq.n	80036fe <RTC_IRQHandler+0x19e>
				{
					RTC_SetCounter(RTC_GetCounter() - 3599);
 80036b4:	f001 fba4 	bl	8004e00 <RTC_GetCounter>
 80036b8:	4603      	mov	r3, r0
 80036ba:	f6a3 630f 	subw	r3, r3, #3599	; 0xe0f
 80036be:	4618      	mov	r0, r3
 80036c0:	f001 fbc6 	bl	8004e50 <RTC_SetCounter>

					/* Reset October correction flag */
					SummerTimeCorrect &= 0xBFFF;
 80036c4:	4b13      	ldr	r3, [pc, #76]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036c6:	881b      	ldrh	r3, [r3, #0]
 80036c8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80036cc:	b29a      	uxth	r2, r3
 80036ce:	4b11      	ldr	r3, [pc, #68]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036d0:	801a      	strh	r2, [r3, #0]

					/* Set March correction flag  */
					SummerTimeCorrect |= 0x8000;
 80036d2:	4b10      	ldr	r3, [pc, #64]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036d4:	881b      	ldrh	r3, [r3, #0]
 80036d6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80036da:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80036de:	b29a      	uxth	r2, r3
 80036e0:	4b0c      	ldr	r3, [pc, #48]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036e2:	801a      	strh	r2, [r3, #0]
					SummerTimeCorrect |= Year;
 80036e4:	4b0b      	ldr	r3, [pc, #44]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036e6:	881a      	ldrh	r2, [r3, #0]
 80036e8:	88bb      	ldrh	r3, [r7, #4]
 80036ea:	4313      	orrs	r3, r2
 80036ec:	b29a      	uxth	r2, r3
 80036ee:	4b09      	ldr	r3, [pc, #36]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036f0:	801a      	strh	r2, [r3, #0]
					BKP_WriteBackupRegister(BKP_DR7,SummerTimeCorrect);
 80036f2:	4b08      	ldr	r3, [pc, #32]	; (8003714 <RTC_IRQHandler+0x1b4>)
 80036f4:	881b      	ldrh	r3, [r3, #0]
 80036f6:	4619      	mov	r1, r3
 80036f8:	201c      	movs	r0, #28
 80036fa:	f000 fa6b 	bl	8003bd4 <BKP_WriteBackupRegister>
				}
			}
		}
	}
}
 80036fe:	bf00      	nop
 8003700:	3708      	adds	r7, #8
 8003702:	46bd      	mov	sp, r7
 8003704:	bd80      	pop	{r7, pc}
 8003706:	bf00      	nop
 8003708:	0001517f 	.word	0x0001517f
 800370c:	91a2b3c5 	.word	0x91a2b3c5
 8003710:	88888889 	.word	0x88888889
 8003714:	200002ea 	.word	0x200002ea

08003718 <ADCT_BGS_Sensor_Input_Init>:
 *      Author: Administrator
 */
#include "ADCT_Sensor.h"

void ADCT_BGS_Sensor_Input_Init(void)
{
 8003718:	b580      	push	{r7, lr}
 800371a:	b082      	sub	sp, #8
 800371c:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	/* GPIO Periph clock enable */
	RCC_APB2PeriphClockCmd(ADCT_BGS_INPUT_CLK|ADCT_BGS_AC_GEN_INPUT_CLK, ENABLE);
 800371e:	2101      	movs	r1, #1
 8003720:	2018      	movs	r0, #24
 8003722:	f001 faa1 	bl	8004c68 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_INT_SMOKE|ADCT_BGS_INT_DOOR|ADCT_BGS_INT_BURGLAR|ADCT_BGS_INT_FIRE|ADCT_BGS_INT_WATER;
 8003726:	231f      	movs	r3, #31
 8003728:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800372a:	2303      	movs	r3, #3
 800372c:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 800372e:	2348      	movs	r3, #72	; 0x48
 8003730:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(ADCT_BGS_INPUT_PORT, &GPIO_InitStructure);
 8003732:	1d3b      	adds	r3, r7, #4
 8003734:	4619      	mov	r1, r3
 8003736:	4809      	ldr	r0, [pc, #36]	; (800375c <ADCT_BGS_Sensor_Input_Init+0x44>)
 8003738:	f000 fce0 	bl	80040fc <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_INPUT_AC|ADCT_BGS_INPUT_GEN;
 800373c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8003740:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003742:	2303      	movs	r3, #3
 8003744:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8003746:	2348      	movs	r3, #72	; 0x48
 8003748:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(ADCT_BGS_AC_GEN_INPUT_PORT, &GPIO_InitStructure);
 800374a:	1d3b      	adds	r3, r7, #4
 800374c:	4619      	mov	r1, r3
 800374e:	4804      	ldr	r0, [pc, #16]	; (8003760 <ADCT_BGS_Sensor_Input_Init+0x48>)
 8003750:	f000 fcd4 	bl	80040fc <GPIO_Init>
}
 8003754:	bf00      	nop
 8003756:	3708      	adds	r7, #8
 8003758:	46bd      	mov	sp, r7
 800375a:	bd80      	pop	{r7, pc}
 800375c:	40011000 	.word	0x40011000
 8003760:	40010c00 	.word	0x40010c00

08003764 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003764:	b480      	push	{r7}
 8003766:	b083      	sub	sp, #12
 8003768:	af00      	add	r7, sp, #0
 800376a:	4603      	mov	r3, r0
 800376c:	6039      	str	r1, [r7, #0]
 800376e:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8003770:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003774:	2b00      	cmp	r3, #0
 8003776:	da0b      	bge.n	8003790 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8003778:	490d      	ldr	r1, [pc, #52]	; (80037b0 <NVIC_SetPriority+0x4c>)
 800377a:	79fb      	ldrb	r3, [r7, #7]
 800377c:	f003 030f 	and.w	r3, r3, #15
 8003780:	3b04      	subs	r3, #4
 8003782:	683a      	ldr	r2, [r7, #0]
 8003784:	b2d2      	uxtb	r2, r2
 8003786:	0112      	lsls	r2, r2, #4
 8003788:	b2d2      	uxtb	r2, r2
 800378a:	440b      	add	r3, r1
 800378c:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
 800378e:	e009      	b.n	80037a4 <NVIC_SetPriority+0x40>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8003790:	4908      	ldr	r1, [pc, #32]	; (80037b4 <NVIC_SetPriority+0x50>)
 8003792:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003796:	683a      	ldr	r2, [r7, #0]
 8003798:	b2d2      	uxtb	r2, r2
 800379a:	0112      	lsls	r2, r2, #4
 800379c:	b2d2      	uxtb	r2, r2
 800379e:	440b      	add	r3, r1
 80037a0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80037a4:	bf00      	nop
 80037a6:	370c      	adds	r7, #12
 80037a8:	46bd      	mov	sp, r7
 80037aa:	bc80      	pop	{r7}
 80037ac:	4770      	bx	lr
 80037ae:	bf00      	nop
 80037b0:	e000ed00 	.word	0xe000ed00
 80037b4:	e000e100 	.word	0xe000e100

080037b8 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80037b8:	b580      	push	{r7, lr}
 80037ba:	b082      	sub	sp, #8
 80037bc:	af00      	add	r7, sp, #0
 80037be:	6078      	str	r0, [r7, #4]
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
 80037c0:	687b      	ldr	r3, [r7, #4]
 80037c2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80037c6:	d301      	bcc.n	80037cc <SysTick_Config+0x14>
 80037c8:	2301      	movs	r3, #1
 80037ca:	e011      	b.n	80037f0 <SysTick_Config+0x38>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 80037cc:	4a0a      	ldr	r2, [pc, #40]	; (80037f8 <SysTick_Config+0x40>)
 80037ce:	687b      	ldr	r3, [r7, #4]
 80037d0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80037d4:	3b01      	subs	r3, #1
 80037d6:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
 80037d8:	210f      	movs	r1, #15
 80037da:	f04f 30ff 	mov.w	r0, #4294967295
 80037de:	f7ff ffc1 	bl	8003764 <NVIC_SetPriority>
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80037e2:	4b05      	ldr	r3, [pc, #20]	; (80037f8 <SysTick_Config+0x40>)
 80037e4:	2200      	movs	r2, #0
 80037e6:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80037e8:	4b03      	ldr	r3, [pc, #12]	; (80037f8 <SysTick_Config+0x40>)
 80037ea:	2207      	movs	r2, #7
 80037ec:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
 80037ee:	2300      	movs	r3, #0
}
 80037f0:	4618      	mov	r0, r3
 80037f2:	3708      	adds	r7, #8
 80037f4:	46bd      	mov	sp, r7
 80037f6:	bd80      	pop	{r7, pc}
 80037f8:	e000e010 	.word	0xe000e010

080037fc <ADCT_BGS_Systick_Init>:
/* Functions for delay */
__IO uint32_t TM_Time2 = 0;
__IO uint32_t TM_Time = 0;
/* initialization system tick 1ms */
void ADCT_BGS_Systick_Init(void )
{
 80037fc:	b580      	push	{r7, lr}
 80037fe:	af00      	add	r7, sp, #0
	if (SysTick_Config(SystemCoreClock / 1000))
 8003800:	4b07      	ldr	r3, [pc, #28]	; (8003820 <ADCT_BGS_Systick_Init+0x24>)
 8003802:	681b      	ldr	r3, [r3, #0]
 8003804:	4a07      	ldr	r2, [pc, #28]	; (8003824 <ADCT_BGS_Systick_Init+0x28>)
 8003806:	fba2 2303 	umull	r2, r3, r2, r3
 800380a:	099b      	lsrs	r3, r3, #6
 800380c:	4618      	mov	r0, r3
 800380e:	f7ff ffd3 	bl	80037b8 <SysTick_Config>
 8003812:	4603      	mov	r3, r0
 8003814:	2b00      	cmp	r3, #0
 8003816:	d000      	beq.n	800381a <ADCT_BGS_Systick_Init+0x1e>
	{
		/* Capture error */
		while (1)
		{
		}
 8003818:	e7fe      	b.n	8003818 <ADCT_BGS_Systick_Init+0x1c>
	}
}
 800381a:	bf00      	nop
 800381c:	bd80      	pop	{r7, pc}
 800381e:	bf00      	nop
 8003820:	2000001c 	.word	0x2000001c
 8003824:	10624dd3 	.word	0x10624dd3

08003828 <TM_DELAY_Init>:
} TM_DELAY_Timers_t;

/* Custom timers structure */
static TM_DELAY_Timers_t CustomTimers = {0};

uint32_t TM_DELAY_Init(void) {
 8003828:	b480      	push	{r7}
 800382a:	b083      	sub	sp, #12
 800382c:	af00      	add	r7, sp, #0
#if !defined(STM32F0xx)
	uint32_t c;

    /* Enable TRC */
    CoreDebug->DEMCR &= ~0x01000000;
 800382e:	4a14      	ldr	r2, [pc, #80]	; (8003880 <TM_DELAY_Init+0x58>)
 8003830:	4b13      	ldr	r3, [pc, #76]	; (8003880 <TM_DELAY_Init+0x58>)
 8003832:	68db      	ldr	r3, [r3, #12]
 8003834:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8003838:	60d3      	str	r3, [r2, #12]
    CoreDebug->DEMCR |=  0x01000000;
 800383a:	4a11      	ldr	r2, [pc, #68]	; (8003880 <TM_DELAY_Init+0x58>)
 800383c:	4b10      	ldr	r3, [pc, #64]	; (8003880 <TM_DELAY_Init+0x58>)
 800383e:	68db      	ldr	r3, [r3, #12]
 8003840:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003844:	60d3      	str	r3, [r2, #12]

    /* Enable counter */
    DWT->CTRL &= ~0x00000001;
 8003846:	4a0f      	ldr	r2, [pc, #60]	; (8003884 <TM_DELAY_Init+0x5c>)
 8003848:	4b0e      	ldr	r3, [pc, #56]	; (8003884 <TM_DELAY_Init+0x5c>)
 800384a:	681b      	ldr	r3, [r3, #0]
 800384c:	f023 0301 	bic.w	r3, r3, #1
 8003850:	6013      	str	r3, [r2, #0]
    DWT->CTRL |=  0x00000001;
 8003852:	4a0c      	ldr	r2, [pc, #48]	; (8003884 <TM_DELAY_Init+0x5c>)
 8003854:	4b0b      	ldr	r3, [pc, #44]	; (8003884 <TM_DELAY_Init+0x5c>)
 8003856:	681b      	ldr	r3, [r3, #0]
 8003858:	f043 0301 	orr.w	r3, r3, #1
 800385c:	6013      	str	r3, [r2, #0]

    /* Reset counter */
    DWT->CYCCNT = 0;
 800385e:	4b09      	ldr	r3, [pc, #36]	; (8003884 <TM_DELAY_Init+0x5c>)
 8003860:	2200      	movs	r2, #0
 8003862:	605a      	str	r2, [r3, #4]

	/* Check if DWT has started */
	c = DWT->CYCCNT;
 8003864:	4b07      	ldr	r3, [pc, #28]	; (8003884 <TM_DELAY_Init+0x5c>)
 8003866:	685b      	ldr	r3, [r3, #4]
 8003868:	607b      	str	r3, [r7, #4]

	/* 2 dummys */
	__ASM volatile ("NOP");
 800386a:	bf00      	nop
	__ASM volatile ("NOP");
 800386c:	bf00      	nop

	/* Return difference, if result is zero, DWT has not started */
	return (DWT->CYCCNT - c);
 800386e:	4b05      	ldr	r3, [pc, #20]	; (8003884 <TM_DELAY_Init+0x5c>)
 8003870:	685a      	ldr	r2, [r3, #4]
 8003872:	687b      	ldr	r3, [r7, #4]
 8003874:	1ad3      	subs	r3, r2, r3
#else
	/* Return OK */
	return 1;
#endif
}
 8003876:	4618      	mov	r0, r3
 8003878:	370c      	adds	r7, #12
 800387a:	46bd      	mov	sp, r7
 800387c:	bc80      	pop	{r7}
 800387e:	4770      	bx	lr
 8003880:	e000edf0 	.word	0xe000edf0
 8003884:	e0001000 	.word	0xe0001000

08003888 <TM_DELAY_TimerCreate>:

TM_DELAY_Timer_t* TM_DELAY_TimerCreate(uint32_t ReloadValue, uint8_t AutoReloadCmd, uint8_t StartTimer, void (*TM_DELAY_CustomTimerCallback)(struct _TM_DELAY_Timer_t*, void *), void* UserParameters) {
 8003888:	b580      	push	{r7, lr}
 800388a:	b086      	sub	sp, #24
 800388c:	af00      	add	r7, sp, #0
 800388e:	60f8      	str	r0, [r7, #12]
 8003890:	607b      	str	r3, [r7, #4]
 8003892:	460b      	mov	r3, r1
 8003894:	72fb      	strb	r3, [r7, #11]
 8003896:	4613      	mov	r3, r2
 8003898:	72bb      	strb	r3, [r7, #10]
	TM_DELAY_Timer_t* tmp;

	/* Check if available */
	if (CustomTimers.Count >= DELAY_MAX_CUSTOM_TIMERS) {
 800389a:	4b1f      	ldr	r3, [pc, #124]	; (8003918 <TM_DELAY_TimerCreate+0x90>)
 800389c:	781b      	ldrb	r3, [r3, #0]
 800389e:	2b04      	cmp	r3, #4
 80038a0:	d901      	bls.n	80038a6 <TM_DELAY_TimerCreate+0x1e>
		return NULL;
 80038a2:	2300      	movs	r3, #0
 80038a4:	e034      	b.n	8003910 <TM_DELAY_TimerCreate+0x88>
	}

	/* Try to allocate memory for timer structure */
	tmp = (TM_DELAY_Timer_t *) LIB_ALLOC_FUNC(sizeof(TM_DELAY_Timer_t));
 80038a6:	2014      	movs	r0, #20
 80038a8:	f002 f88c 	bl	80059c4 <malloc>
 80038ac:	4603      	mov	r3, r0
 80038ae:	617b      	str	r3, [r7, #20]

	/* Check if allocated */
	if (tmp == NULL) {
 80038b0:	697b      	ldr	r3, [r7, #20]
 80038b2:	2b00      	cmp	r3, #0
 80038b4:	d101      	bne.n	80038ba <TM_DELAY_TimerCreate+0x32>
		return NULL;
 80038b6:	2300      	movs	r3, #0
 80038b8:	e02a      	b.n	8003910 <TM_DELAY_TimerCreate+0x88>
	}

	/* Fill settings */
	tmp->ARR = ReloadValue;
 80038ba:	697b      	ldr	r3, [r7, #20]
 80038bc:	68fa      	ldr	r2, [r7, #12]
 80038be:	605a      	str	r2, [r3, #4]
	tmp->CNT = tmp->ARR;
 80038c0:	697b      	ldr	r3, [r7, #20]
 80038c2:	685a      	ldr	r2, [r3, #4]
 80038c4:	697b      	ldr	r3, [r7, #20]
 80038c6:	609a      	str	r2, [r3, #8]
	tmp->Flags.F.AREN = AutoReloadCmd;
 80038c8:	7afb      	ldrb	r3, [r7, #11]
 80038ca:	f003 0301 	and.w	r3, r3, #1
 80038ce:	b2d9      	uxtb	r1, r3
 80038d0:	697a      	ldr	r2, [r7, #20]
 80038d2:	7813      	ldrb	r3, [r2, #0]
 80038d4:	f361 0300 	bfi	r3, r1, #0, #1
 80038d8:	7013      	strb	r3, [r2, #0]
	tmp->Flags.F.CNTEN = StartTimer;
 80038da:	7abb      	ldrb	r3, [r7, #10]
 80038dc:	f003 0301 	and.w	r3, r3, #1
 80038e0:	b2d9      	uxtb	r1, r3
 80038e2:	697a      	ldr	r2, [r7, #20]
 80038e4:	7813      	ldrb	r3, [r2, #0]
 80038e6:	f361 0341 	bfi	r3, r1, #1, #1
 80038ea:	7013      	strb	r3, [r2, #0]
	tmp->Callback = TM_DELAY_CustomTimerCallback;
 80038ec:	697b      	ldr	r3, [r7, #20]
 80038ee:	687a      	ldr	r2, [r7, #4]
 80038f0:	60da      	str	r2, [r3, #12]
	tmp->UserParameters = UserParameters;
 80038f2:	697b      	ldr	r3, [r7, #20]
 80038f4:	6a3a      	ldr	r2, [r7, #32]
 80038f6:	611a      	str	r2, [r3, #16]

	/* Increase number of timers in memory */
	CustomTimers.Timers[CustomTimers.Count++] = tmp;
 80038f8:	4b07      	ldr	r3, [pc, #28]	; (8003918 <TM_DELAY_TimerCreate+0x90>)
 80038fa:	781b      	ldrb	r3, [r3, #0]
 80038fc:	1c5a      	adds	r2, r3, #1
 80038fe:	b2d1      	uxtb	r1, r2
 8003900:	4a05      	ldr	r2, [pc, #20]	; (8003918 <TM_DELAY_TimerCreate+0x90>)
 8003902:	7011      	strb	r1, [r2, #0]
 8003904:	4a04      	ldr	r2, [pc, #16]	; (8003918 <TM_DELAY_TimerCreate+0x90>)
 8003906:	009b      	lsls	r3, r3, #2
 8003908:	4413      	add	r3, r2
 800390a:	697a      	ldr	r2, [r7, #20]
 800390c:	605a      	str	r2, [r3, #4]

	/* Return pointer to user */
	return tmp;
 800390e:	697b      	ldr	r3, [r7, #20]
}
 8003910:	4618      	mov	r0, r3
 8003912:	3718      	adds	r7, #24
 8003914:	46bd      	mov	sp, r7
 8003916:	bd80      	pop	{r7, pc}
 8003918:	200001b4 	.word	0x200001b4

0800391c <TM_DELAY_TimerStop>:
	if (!irq) {
		__enable_irq();
	}
}

TM_DELAY_Timer_t* TM_DELAY_TimerStop(TM_DELAY_Timer_t* Timer) {
 800391c:	b480      	push	{r7}
 800391e:	b083      	sub	sp, #12
 8003920:	af00      	add	r7, sp, #0
 8003922:	6078      	str	r0, [r7, #4]
	/* Disable timer */
	Timer->Flags.F.CNTEN = 0;
 8003924:	687a      	ldr	r2, [r7, #4]
 8003926:	7813      	ldrb	r3, [r2, #0]
 8003928:	f36f 0341 	bfc	r3, #1, #1
 800392c:	7013      	strb	r3, [r2, #0]

	/* Return pointer */
	return Timer;
 800392e:	687b      	ldr	r3, [r7, #4]
}
 8003930:	4618      	mov	r0, r3
 8003932:	370c      	adds	r7, #12
 8003934:	46bd      	mov	sp, r7
 8003936:	bc80      	pop	{r7}
 8003938:	4770      	bx	lr
 800393a:	bf00      	nop

0800393c <TM_DELAY_TimerStart>:

TM_DELAY_Timer_t* TM_DELAY_TimerStart(TM_DELAY_Timer_t* Timer) {
 800393c:	b480      	push	{r7}
 800393e:	b083      	sub	sp, #12
 8003940:	af00      	add	r7, sp, #0
 8003942:	6078      	str	r0, [r7, #4]
	/* Enable timer */
	Timer->Flags.F.CNTEN = 1;
 8003944:	687a      	ldr	r2, [r7, #4]
 8003946:	7813      	ldrb	r3, [r2, #0]
 8003948:	f043 0302 	orr.w	r3, r3, #2
 800394c:	7013      	strb	r3, [r2, #0]

	/* Return pointer */
	return Timer;
 800394e:	687b      	ldr	r3, [r7, #4]
}
 8003950:	4618      	mov	r0, r3
 8003952:	370c      	adds	r7, #12
 8003954:	46bd      	mov	sp, r7
 8003956:	bc80      	pop	{r7}
 8003958:	4770      	bx	lr
 800395a:	bf00      	nop

0800395c <TM_DELAY_TimerAutoReloadValue>:

	/* Return pointer */
	return Timer;
}

TM_DELAY_Timer_t* TM_DELAY_TimerAutoReloadValue(TM_DELAY_Timer_t* Timer, uint32_t AutoReloadValue) {
 800395c:	b480      	push	{r7}
 800395e:	b083      	sub	sp, #12
 8003960:	af00      	add	r7, sp, #0
 8003962:	6078      	str	r0, [r7, #4]
 8003964:	6039      	str	r1, [r7, #0]
	/* Reset timer */
	Timer->ARR = AutoReloadValue;
 8003966:	687b      	ldr	r3, [r7, #4]
 8003968:	683a      	ldr	r2, [r7, #0]
 800396a:	605a      	str	r2, [r3, #4]

	/* Return pointer */
	return Timer;
 800396c:	687b      	ldr	r3, [r7, #4]
}
 800396e:	4618      	mov	r0, r3
 8003970:	370c      	adds	r7, #12
 8003972:	46bd      	mov	sp, r7
 8003974:	bc80      	pop	{r7}
 8003976:	4770      	bx	lr

08003978 <TimerGetUS>:
//	/* NOTE: This function Should not be modified, when the callback is needed,
//           the TM_DELAY_1msHandler could be implemented in the user file
//	*/
//}
uint32_t TimerGetUS(void)
{
 8003978:	b480      	push	{r7}
 800397a:	af00      	add	r7, sp, #0
	return ( DWT->CYCCNT/72);
 800397c:	4b04      	ldr	r3, [pc, #16]	; (8003990 <TimerGetUS+0x18>)
 800397e:	685b      	ldr	r3, [r3, #4]
 8003980:	4a04      	ldr	r2, [pc, #16]	; (8003994 <TimerGetUS+0x1c>)
 8003982:	fba2 2303 	umull	r2, r3, r2, r3
 8003986:	091b      	lsrs	r3, r3, #4
}
 8003988:	4618      	mov	r0, r3
 800398a:	46bd      	mov	sp, r7
 800398c:	bc80      	pop	{r7}
 800398e:	4770      	bx	lr
 8003990:	e0001000 	.word	0xe0001000
 8003994:	38e38e39 	.word	0x38e38e39

08003998 <HAL_IncTick>:
/***************************************************/
/*       Custom HAL function implementations       */
/***************************************************/

/* Called from Systick handler */
void HAL_IncTick(void) {
 8003998:	b580      	push	{r7, lr}
 800399a:	b082      	sub	sp, #8
 800399c:	af00      	add	r7, sp, #0
	uint8_t i;

	/* Increase system time */
	TM_Time++;
 800399e:	4b3d      	ldr	r3, [pc, #244]	; (8003a94 <HAL_IncTick+0xfc>)
 80039a0:	681b      	ldr	r3, [r3, #0]
 80039a2:	3301      	adds	r3, #1
 80039a4:	4a3b      	ldr	r2, [pc, #236]	; (8003a94 <HAL_IncTick+0xfc>)
 80039a6:	6013      	str	r3, [r2, #0]

	/* Decrease other system time */
	if (TM_Time2) {
 80039a8:	4b3b      	ldr	r3, [pc, #236]	; (8003a98 <HAL_IncTick+0x100>)
 80039aa:	681b      	ldr	r3, [r3, #0]
 80039ac:	2b00      	cmp	r3, #0
 80039ae:	d004      	beq.n	80039ba <HAL_IncTick+0x22>
		TM_Time2--;
 80039b0:	4b39      	ldr	r3, [pc, #228]	; (8003a98 <HAL_IncTick+0x100>)
 80039b2:	681b      	ldr	r3, [r3, #0]
 80039b4:	3b01      	subs	r3, #1
 80039b6:	4a38      	ldr	r2, [pc, #224]	; (8003a98 <HAL_IncTick+0x100>)
 80039b8:	6013      	str	r3, [r2, #0]
	}

	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
 80039ba:	2300      	movs	r3, #0
 80039bc:	71fb      	strb	r3, [r7, #7]
 80039be:	e05f      	b.n	8003a80 <HAL_IncTick+0xe8>
		/* Check if timer is enabled */
		if (
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
 80039c0:	79fb      	ldrb	r3, [r7, #7]
 80039c2:	4a36      	ldr	r2, [pc, #216]	; (8003a9c <HAL_IncTick+0x104>)
 80039c4:	009b      	lsls	r3, r3, #2
 80039c6:	4413      	add	r3, r2
 80039c8:	685b      	ldr	r3, [r3, #4]

	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
		/* Check if timer is enabled */
		if (
 80039ca:	2b00      	cmp	r3, #0
 80039cc:	d055      	beq.n	8003a7a <HAL_IncTick+0xe2>
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
			CustomTimers.Timers[i]->Flags.F.CNTEN /*!< Timer is enabled */
 80039ce:	79fb      	ldrb	r3, [r7, #7]
 80039d0:	4a32      	ldr	r2, [pc, #200]	; (8003a9c <HAL_IncTick+0x104>)
 80039d2:	009b      	lsls	r3, r3, #2
 80039d4:	4413      	add	r3, r2
 80039d6:	685b      	ldr	r3, [r3, #4]
	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
		/* Check if timer is enabled */
		if (
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
 80039d8:	781b      	ldrb	r3, [r3, #0]
 80039da:	f003 0302 	and.w	r3, r3, #2
 80039de:	b2db      	uxtb	r3, r3
 80039e0:	2b00      	cmp	r3, #0
 80039e2:	d04a      	beq.n	8003a7a <HAL_IncTick+0xe2>
			CustomTimers.Timers[i]->Flags.F.CNTEN /*!< Timer is enabled */
		) {
			/* Decrease counter if needed */
			if (CustomTimers.Timers[i]->CNT) {
 80039e4:	79fb      	ldrb	r3, [r7, #7]
 80039e6:	4a2d      	ldr	r2, [pc, #180]	; (8003a9c <HAL_IncTick+0x104>)
 80039e8:	009b      	lsls	r3, r3, #2
 80039ea:	4413      	add	r3, r2
 80039ec:	685b      	ldr	r3, [r3, #4]
 80039ee:	689b      	ldr	r3, [r3, #8]
 80039f0:	2b00      	cmp	r3, #0
 80039f2:	d007      	beq.n	8003a04 <HAL_IncTick+0x6c>
				CustomTimers.Timers[i]->CNT--;
 80039f4:	79fb      	ldrb	r3, [r7, #7]
 80039f6:	4a29      	ldr	r2, [pc, #164]	; (8003a9c <HAL_IncTick+0x104>)
 80039f8:	009b      	lsls	r3, r3, #2
 80039fa:	4413      	add	r3, r2
 80039fc:	685b      	ldr	r3, [r3, #4]
 80039fe:	689a      	ldr	r2, [r3, #8]
 8003a00:	3a01      	subs	r2, #1
 8003a02:	609a      	str	r2, [r3, #8]
			}

			/* Check if count is zero */
			if (CustomTimers.Timers[i]->CNT == 0) {
 8003a04:	79fb      	ldrb	r3, [r7, #7]
 8003a06:	4a25      	ldr	r2, [pc, #148]	; (8003a9c <HAL_IncTick+0x104>)
 8003a08:	009b      	lsls	r3, r3, #2
 8003a0a:	4413      	add	r3, r2
 8003a0c:	685b      	ldr	r3, [r3, #4]
 8003a0e:	689b      	ldr	r3, [r3, #8]
 8003a10:	2b00      	cmp	r3, #0
 8003a12:	d132      	bne.n	8003a7a <HAL_IncTick+0xe2>
				/* Call user callback function */
				CustomTimers.Timers[i]->Callback(CustomTimers.Timers[i], CustomTimers.Timers[i]->UserParameters);
 8003a14:	79fb      	ldrb	r3, [r7, #7]
 8003a16:	4a21      	ldr	r2, [pc, #132]	; (8003a9c <HAL_IncTick+0x104>)
 8003a18:	009b      	lsls	r3, r3, #2
 8003a1a:	4413      	add	r3, r2
 8003a1c:	685b      	ldr	r3, [r3, #4]
 8003a1e:	68da      	ldr	r2, [r3, #12]
 8003a20:	79fb      	ldrb	r3, [r7, #7]
 8003a22:	491e      	ldr	r1, [pc, #120]	; (8003a9c <HAL_IncTick+0x104>)
 8003a24:	009b      	lsls	r3, r3, #2
 8003a26:	440b      	add	r3, r1
 8003a28:	6858      	ldr	r0, [r3, #4]
 8003a2a:	79fb      	ldrb	r3, [r7, #7]
 8003a2c:	491b      	ldr	r1, [pc, #108]	; (8003a9c <HAL_IncTick+0x104>)
 8003a2e:	009b      	lsls	r3, r3, #2
 8003a30:	440b      	add	r3, r1
 8003a32:	685b      	ldr	r3, [r3, #4]
 8003a34:	691b      	ldr	r3, [r3, #16]
 8003a36:	4619      	mov	r1, r3
 8003a38:	4790      	blx	r2

				/* Set new counter value */
				CustomTimers.Timers[i]->CNT = CustomTimers.Timers[i]->ARR;
 8003a3a:	79fb      	ldrb	r3, [r7, #7]
 8003a3c:	4a17      	ldr	r2, [pc, #92]	; (8003a9c <HAL_IncTick+0x104>)
 8003a3e:	009b      	lsls	r3, r3, #2
 8003a40:	4413      	add	r3, r2
 8003a42:	685a      	ldr	r2, [r3, #4]
 8003a44:	79fb      	ldrb	r3, [r7, #7]
 8003a46:	4915      	ldr	r1, [pc, #84]	; (8003a9c <HAL_IncTick+0x104>)
 8003a48:	009b      	lsls	r3, r3, #2
 8003a4a:	440b      	add	r3, r1
 8003a4c:	685b      	ldr	r3, [r3, #4]
 8003a4e:	685b      	ldr	r3, [r3, #4]
 8003a50:	6093      	str	r3, [r2, #8]

				/* Disable timer if auto reload feature is not used */
				if (!CustomTimers.Timers[i]->Flags.F.AREN) {
 8003a52:	79fb      	ldrb	r3, [r7, #7]
 8003a54:	4a11      	ldr	r2, [pc, #68]	; (8003a9c <HAL_IncTick+0x104>)
 8003a56:	009b      	lsls	r3, r3, #2
 8003a58:	4413      	add	r3, r2
 8003a5a:	685b      	ldr	r3, [r3, #4]
 8003a5c:	781b      	ldrb	r3, [r3, #0]
 8003a5e:	f003 0301 	and.w	r3, r3, #1
 8003a62:	b2db      	uxtb	r3, r3
 8003a64:	2b00      	cmp	r3, #0
 8003a66:	d108      	bne.n	8003a7a <HAL_IncTick+0xe2>
					/* Disable counter */
					CustomTimers.Timers[i]->Flags.F.CNTEN = 0;
 8003a68:	79fb      	ldrb	r3, [r7, #7]
 8003a6a:	4a0c      	ldr	r2, [pc, #48]	; (8003a9c <HAL_IncTick+0x104>)
 8003a6c:	009b      	lsls	r3, r3, #2
 8003a6e:	4413      	add	r3, r2
 8003a70:	685a      	ldr	r2, [r3, #4]
 8003a72:	7813      	ldrb	r3, [r2, #0]
 8003a74:	f36f 0341 	bfc	r3, #1, #1
 8003a78:	7013      	strb	r3, [r2, #0]
		TM_Time2--;
	}

	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
 8003a7a:	79fb      	ldrb	r3, [r7, #7]
 8003a7c:	3301      	adds	r3, #1
 8003a7e:	71fb      	strb	r3, [r7, #7]
 8003a80:	4b06      	ldr	r3, [pc, #24]	; (8003a9c <HAL_IncTick+0x104>)
 8003a82:	781b      	ldrb	r3, [r3, #0]
 8003a84:	79fa      	ldrb	r2, [r7, #7]
 8003a86:	429a      	cmp	r2, r3
 8003a88:	d39a      	bcc.n	80039c0 <HAL_IncTick+0x28>
		}
	}

	/* Call 1ms interrupt handler function */
	//TM_DELAY_1msHandler();
}
 8003a8a:	bf00      	nop
 8003a8c:	3708      	adds	r7, #8
 8003a8e:	46bd      	mov	sp, r7
 8003a90:	bd80      	pop	{r7, pc}
 8003a92:	bf00      	nop
 8003a94:	200001b0 	.word	0x200001b0
 8003a98:	200001ac 	.word	0x200001ac
 8003a9c:	200001b4 	.word	0x200001b4

08003aa0 <NVIC_PriorityGroupConfig>:
  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority
  *                                0 bits for subpriority
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 8003aa0:	b480      	push	{r7}
 8003aa2:	b083      	sub	sp, #12
 8003aa4:	af00      	add	r7, sp, #0
 8003aa6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003aa8:	4a05      	ldr	r2, [pc, #20]	; (8003ac0 <NVIC_PriorityGroupConfig+0x20>)
 8003aaa:	687b      	ldr	r3, [r7, #4]
 8003aac:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8003ab0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003ab4:	60d3      	str	r3, [r2, #12]
}
 8003ab6:	bf00      	nop
 8003ab8:	370c      	adds	r7, #12
 8003aba:	46bd      	mov	sp, r7
 8003abc:	bc80      	pop	{r7}
 8003abe:	4770      	bx	lr
 8003ac0:	e000ed00 	.word	0xe000ed00

08003ac4 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003ac4:	b480      	push	{r7}
 8003ac6:	b087      	sub	sp, #28
 8003ac8:	af00      	add	r7, sp, #0
 8003aca:	6078      	str	r0, [r7, #4]
  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8003acc:	2300      	movs	r3, #0
 8003ace:	617b      	str	r3, [r7, #20]
 8003ad0:	2300      	movs	r3, #0
 8003ad2:	613b      	str	r3, [r7, #16]
 8003ad4:	230f      	movs	r3, #15
 8003ad6:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003ad8:	687b      	ldr	r3, [r7, #4]
 8003ada:	78db      	ldrb	r3, [r3, #3]
 8003adc:	2b00      	cmp	r3, #0
 8003ade:	d03a      	beq.n	8003b56 <NVIC_Init+0x92>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003ae0:	4b27      	ldr	r3, [pc, #156]	; (8003b80 <NVIC_Init+0xbc>)
 8003ae2:	68db      	ldr	r3, [r3, #12]
 8003ae4:	43db      	mvns	r3, r3
 8003ae6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8003aea:	0a1b      	lsrs	r3, r3, #8
 8003aec:	617b      	str	r3, [r7, #20]
    tmppre = (0x4 - tmppriority);
 8003aee:	697b      	ldr	r3, [r7, #20]
 8003af0:	f1c3 0304 	rsb	r3, r3, #4
 8003af4:	613b      	str	r3, [r7, #16]
    tmpsub = tmpsub >> tmppriority;
 8003af6:	68fa      	ldr	r2, [r7, #12]
 8003af8:	697b      	ldr	r3, [r7, #20]
 8003afa:	fa22 f303 	lsr.w	r3, r2, r3
 8003afe:	60fb      	str	r3, [r7, #12]

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003b00:	687b      	ldr	r3, [r7, #4]
 8003b02:	785b      	ldrb	r3, [r3, #1]
 8003b04:	461a      	mov	r2, r3
 8003b06:	693b      	ldr	r3, [r7, #16]
 8003b08:	fa02 f303 	lsl.w	r3, r2, r3
 8003b0c:	617b      	str	r3, [r7, #20]
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003b0e:	687b      	ldr	r3, [r7, #4]
 8003b10:	789b      	ldrb	r3, [r3, #2]
 8003b12:	461a      	mov	r2, r3
 8003b14:	68fb      	ldr	r3, [r7, #12]
 8003b16:	4013      	ands	r3, r2
 8003b18:	697a      	ldr	r2, [r7, #20]
 8003b1a:	4313      	orrs	r3, r2
 8003b1c:	617b      	str	r3, [r7, #20]
    tmppriority = tmppriority << 0x04;
 8003b1e:	697b      	ldr	r3, [r7, #20]
 8003b20:	011b      	lsls	r3, r3, #4
 8003b22:	617b      	str	r3, [r7, #20]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003b24:	4a17      	ldr	r2, [pc, #92]	; (8003b84 <NVIC_Init+0xc0>)
 8003b26:	687b      	ldr	r3, [r7, #4]
 8003b28:	781b      	ldrb	r3, [r3, #0]
 8003b2a:	6979      	ldr	r1, [r7, #20]
 8003b2c:	b2c9      	uxtb	r1, r1
 8003b2e:	4413      	add	r3, r2
 8003b30:	460a      	mov	r2, r1
 8003b32:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003b36:	4a13      	ldr	r2, [pc, #76]	; (8003b84 <NVIC_Init+0xc0>)
 8003b38:	687b      	ldr	r3, [r7, #4]
 8003b3a:	781b      	ldrb	r3, [r3, #0]
 8003b3c:	095b      	lsrs	r3, r3, #5
 8003b3e:	b2db      	uxtb	r3, r3
 8003b40:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003b42:	687b      	ldr	r3, [r7, #4]
 8003b44:	781b      	ldrb	r3, [r3, #0]
 8003b46:	f003 031f 	and.w	r3, r3, #31
 8003b4a:	2101      	movs	r1, #1
 8003b4c:	fa01 f303 	lsl.w	r3, r1, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003b50:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8003b54:	e00f      	b.n	8003b76 <NVIC_Init+0xb2>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003b56:	490b      	ldr	r1, [pc, #44]	; (8003b84 <NVIC_Init+0xc0>)
 8003b58:	687b      	ldr	r3, [r7, #4]
 8003b5a:	781b      	ldrb	r3, [r3, #0]
 8003b5c:	095b      	lsrs	r3, r3, #5
 8003b5e:	b2db      	uxtb	r3, r3
 8003b60:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003b62:	687b      	ldr	r3, [r7, #4]
 8003b64:	781b      	ldrb	r3, [r3, #0]
 8003b66:	f003 031f 	and.w	r3, r3, #31
 8003b6a:	2201      	movs	r2, #1
 8003b6c:	409a      	lsls	r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003b6e:	f100 0320 	add.w	r3, r0, #32
 8003b72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8003b76:	bf00      	nop
 8003b78:	371c      	adds	r7, #28
 8003b7a:	46bd      	mov	sp, r7
 8003b7c:	bc80      	pop	{r7}
 8003b7e:	4770      	bx	lr
 8003b80:	e000ed00 	.word	0xe000ed00
 8003b84:	e000e100 	.word	0xe000e100

08003b88 <BKP_DeInit>:
  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
 8003b88:	b580      	push	{r7, lr}
 8003b8a:	af00      	add	r7, sp, #0
  RCC_BackupResetCmd(ENABLE);
 8003b8c:	2001      	movs	r0, #1
 8003b8e:	f001 f8a7 	bl	8004ce0 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 8003b92:	2000      	movs	r0, #0
 8003b94:	f001 f8a4 	bl	8004ce0 <RCC_BackupResetCmd>
}
 8003b98:	bf00      	nop
 8003b9a:	bd80      	pop	{r7, pc}

08003b9c <BKP_RTCOutputConfig>:
  *     @arg BKP_RTCOutputSource_Second: output the RTC Second pulse signal on
  *                                      the Tamper pin.  
  * @retval None
  */
void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource)
{
 8003b9c:	b480      	push	{r7}
 8003b9e:	b085      	sub	sp, #20
 8003ba0:	af00      	add	r7, sp, #0
 8003ba2:	4603      	mov	r3, r0
 8003ba4:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpreg = 0;
 8003ba6:	2300      	movs	r3, #0
 8003ba8:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
  tmpreg = BKP->RTCCR;
 8003baa:	4b09      	ldr	r3, [pc, #36]	; (8003bd0 <BKP_RTCOutputConfig+0x34>)
 8003bac:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8003bae:	81fb      	strh	r3, [r7, #14]
  /* Clear CCO, ASOE and ASOS bits */
  tmpreg &= RTCCR_MASK;
 8003bb0:	89fb      	ldrh	r3, [r7, #14]
 8003bb2:	f423 7360 	bic.w	r3, r3, #896	; 0x380
 8003bb6:	81fb      	strh	r3, [r7, #14]
  
  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
  tmpreg |= BKP_RTCOutputSource;
 8003bb8:	89fa      	ldrh	r2, [r7, #14]
 8003bba:	88fb      	ldrh	r3, [r7, #6]
 8003bbc:	4313      	orrs	r3, r2
 8003bbe:	81fb      	strh	r3, [r7, #14]
  /* Store the new value */
  BKP->RTCCR = tmpreg;
 8003bc0:	4a03      	ldr	r2, [pc, #12]	; (8003bd0 <BKP_RTCOutputConfig+0x34>)
 8003bc2:	89fb      	ldrh	r3, [r7, #14]
 8003bc4:	8593      	strh	r3, [r2, #44]	; 0x2c
}
 8003bc6:	bf00      	nop
 8003bc8:	3714      	adds	r7, #20
 8003bca:	46bd      	mov	sp, r7
 8003bcc:	bc80      	pop	{r7}
 8003bce:	4770      	bx	lr
 8003bd0:	40006c00 	.word	0x40006c00

08003bd4 <BKP_WriteBackupRegister>:
  *   This parameter can be BKP_DRx where x:[1, 42]
  * @param  Data: data to write
  * @retval None
  */
void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)
{
 8003bd4:	b480      	push	{r7}
 8003bd6:	b085      	sub	sp, #20
 8003bd8:	af00      	add	r7, sp, #0
 8003bda:	4603      	mov	r3, r0
 8003bdc:	460a      	mov	r2, r1
 8003bde:	80fb      	strh	r3, [r7, #6]
 8003be0:	4613      	mov	r3, r2
 8003be2:	80bb      	strh	r3, [r7, #4]
  __IO uint32_t tmp = 0;
 8003be4:	2300      	movs	r3, #0
 8003be6:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_BKP_DR(BKP_DR));

  tmp = (uint32_t)BKP_BASE; 
 8003be8:	4b07      	ldr	r3, [pc, #28]	; (8003c08 <BKP_WriteBackupRegister+0x34>)
 8003bea:	60fb      	str	r3, [r7, #12]
  tmp += BKP_DR;
 8003bec:	88fa      	ldrh	r2, [r7, #6]
 8003bee:	68fb      	ldr	r3, [r7, #12]
 8003bf0:	4413      	add	r3, r2
 8003bf2:	60fb      	str	r3, [r7, #12]

  *(__IO uint32_t *) tmp = Data;
 8003bf4:	68fb      	ldr	r3, [r7, #12]
 8003bf6:	461a      	mov	r2, r3
 8003bf8:	88bb      	ldrh	r3, [r7, #4]
 8003bfa:	6013      	str	r3, [r2, #0]
}
 8003bfc:	bf00      	nop
 8003bfe:	3714      	adds	r7, #20
 8003c00:	46bd      	mov	sp, r7
 8003c02:	bc80      	pop	{r7}
 8003c04:	4770      	bx	lr
 8003c06:	bf00      	nop
 8003c08:	40006c00 	.word	0x40006c00

08003c0c <BKP_ReadBackupRegister>:
  * @param  BKP_DR: specifies the Data Backup Register.
  *   This parameter can be BKP_DRx where x:[1, 42]
  * @retval The content of the specified Data Backup Register
  */
uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)
{
 8003c0c:	b480      	push	{r7}
 8003c0e:	b085      	sub	sp, #20
 8003c10:	af00      	add	r7, sp, #0
 8003c12:	4603      	mov	r3, r0
 8003c14:	80fb      	strh	r3, [r7, #6]
  __IO uint32_t tmp = 0;
 8003c16:	2300      	movs	r3, #0
 8003c18:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_BKP_DR(BKP_DR));

  tmp = (uint32_t)BKP_BASE; 
 8003c1a:	4b07      	ldr	r3, [pc, #28]	; (8003c38 <BKP_ReadBackupRegister+0x2c>)
 8003c1c:	60fb      	str	r3, [r7, #12]
  tmp += BKP_DR;
 8003c1e:	88fa      	ldrh	r2, [r7, #6]
 8003c20:	68fb      	ldr	r3, [r7, #12]
 8003c22:	4413      	add	r3, r2
 8003c24:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint16_t *) tmp);
 8003c26:	68fb      	ldr	r3, [r7, #12]
 8003c28:	881b      	ldrh	r3, [r3, #0]
 8003c2a:	b29b      	uxth	r3, r3
}
 8003c2c:	4618      	mov	r0, r3
 8003c2e:	3714      	adds	r7, #20
 8003c30:	46bd      	mov	sp, r7
 8003c32:	bc80      	pop	{r7}
 8003c34:	4770      	bx	lr
 8003c36:	bf00      	nop
 8003c38:	40006c00 	.word	0x40006c00

08003c3c <DMA_DeInit>:
  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
  * @retval None
  */
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
 8003c3c:	b480      	push	{r7}
 8003c3e:	b083      	sub	sp, #12
 8003c40:	af00      	add	r7, sp, #0
 8003c42:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8003c44:	687b      	ldr	r3, [r7, #4]
 8003c46:	681a      	ldr	r2, [r3, #0]
 8003c48:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8003c4c:	4013      	ands	r3, r2
 8003c4e:	687a      	ldr	r2, [r7, #4]
 8003c50:	6013      	str	r3, [r2, #0]
  
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8003c52:	687b      	ldr	r3, [r7, #4]
 8003c54:	2200      	movs	r2, #0
 8003c56:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8003c58:	687b      	ldr	r3, [r7, #4]
 8003c5a:	2200      	movs	r2, #0
 8003c5c:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8003c5e:	687b      	ldr	r3, [r7, #4]
 8003c60:	2200      	movs	r2, #0
 8003c62:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8003c64:	687b      	ldr	r3, [r7, #4]
 8003c66:	2200      	movs	r2, #0
 8003c68:	60da      	str	r2, [r3, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8003c6a:	687b      	ldr	r3, [r7, #4]
 8003c6c:	4a43      	ldr	r2, [pc, #268]	; (8003d7c <DMA_DeInit+0x140>)
 8003c6e:	4293      	cmp	r3, r2
 8003c70:	d106      	bne.n	8003c80 <DMA_DeInit+0x44>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
 8003c72:	4a43      	ldr	r2, [pc, #268]	; (8003d80 <DMA_DeInit+0x144>)
 8003c74:	4b42      	ldr	r3, [pc, #264]	; (8003d80 <DMA_DeInit+0x144>)
 8003c76:	685b      	ldr	r3, [r3, #4]
 8003c78:	f043 030f 	orr.w	r3, r3, #15
 8003c7c:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003c7e:	e077      	b.n	8003d70 <DMA_DeInit+0x134>
  if (DMAy_Channelx == DMA1_Channel1)
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8003c80:	687b      	ldr	r3, [r7, #4]
 8003c82:	4a40      	ldr	r2, [pc, #256]	; (8003d84 <DMA_DeInit+0x148>)
 8003c84:	4293      	cmp	r3, r2
 8003c86:	d106      	bne.n	8003c96 <DMA_DeInit+0x5a>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
 8003c88:	4a3d      	ldr	r2, [pc, #244]	; (8003d80 <DMA_DeInit+0x144>)
 8003c8a:	4b3d      	ldr	r3, [pc, #244]	; (8003d80 <DMA_DeInit+0x144>)
 8003c8c:	685b      	ldr	r3, [r3, #4]
 8003c8e:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8003c92:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003c94:	e06c      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA1_Channel2)
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8003c96:	687b      	ldr	r3, [r7, #4]
 8003c98:	4a3b      	ldr	r2, [pc, #236]	; (8003d88 <DMA_DeInit+0x14c>)
 8003c9a:	4293      	cmp	r3, r2
 8003c9c:	d106      	bne.n	8003cac <DMA_DeInit+0x70>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
 8003c9e:	4a38      	ldr	r2, [pc, #224]	; (8003d80 <DMA_DeInit+0x144>)
 8003ca0:	4b37      	ldr	r3, [pc, #220]	; (8003d80 <DMA_DeInit+0x144>)
 8003ca2:	685b      	ldr	r3, [r3, #4]
 8003ca4:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
 8003ca8:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003caa:	e061      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA1_Channel3)
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8003cac:	687b      	ldr	r3, [r7, #4]
 8003cae:	4a37      	ldr	r2, [pc, #220]	; (8003d8c <DMA_DeInit+0x150>)
 8003cb0:	4293      	cmp	r3, r2
 8003cb2:	d106      	bne.n	8003cc2 <DMA_DeInit+0x86>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
 8003cb4:	4a32      	ldr	r2, [pc, #200]	; (8003d80 <DMA_DeInit+0x144>)
 8003cb6:	4b32      	ldr	r3, [pc, #200]	; (8003d80 <DMA_DeInit+0x144>)
 8003cb8:	685b      	ldr	r3, [r3, #4]
 8003cba:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8003cbe:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003cc0:	e056      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA1_Channel4)
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8003cc2:	687b      	ldr	r3, [r7, #4]
 8003cc4:	4a32      	ldr	r2, [pc, #200]	; (8003d90 <DMA_DeInit+0x154>)
 8003cc6:	4293      	cmp	r3, r2
 8003cc8:	d106      	bne.n	8003cd8 <DMA_DeInit+0x9c>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
 8003cca:	4a2d      	ldr	r2, [pc, #180]	; (8003d80 <DMA_DeInit+0x144>)
 8003ccc:	4b2c      	ldr	r3, [pc, #176]	; (8003d80 <DMA_DeInit+0x144>)
 8003cce:	685b      	ldr	r3, [r3, #4]
 8003cd0:	f443 2370 	orr.w	r3, r3, #983040	; 0xf0000
 8003cd4:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003cd6:	e04b      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA1_Channel5)
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8003cd8:	687b      	ldr	r3, [r7, #4]
 8003cda:	4a2e      	ldr	r2, [pc, #184]	; (8003d94 <DMA_DeInit+0x158>)
 8003cdc:	4293      	cmp	r3, r2
 8003cde:	d106      	bne.n	8003cee <DMA_DeInit+0xb2>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 8003ce0:	4a27      	ldr	r2, [pc, #156]	; (8003d80 <DMA_DeInit+0x144>)
 8003ce2:	4b27      	ldr	r3, [pc, #156]	; (8003d80 <DMA_DeInit+0x144>)
 8003ce4:	685b      	ldr	r3, [r3, #4]
 8003ce6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003cea:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003cec:	e040      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA1_Channel6)
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8003cee:	687b      	ldr	r3, [r7, #4]
 8003cf0:	4a29      	ldr	r2, [pc, #164]	; (8003d98 <DMA_DeInit+0x15c>)
 8003cf2:	4293      	cmp	r3, r2
 8003cf4:	d106      	bne.n	8003d04 <DMA_DeInit+0xc8>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8003cf6:	4a22      	ldr	r2, [pc, #136]	; (8003d80 <DMA_DeInit+0x144>)
 8003cf8:	4b21      	ldr	r3, [pc, #132]	; (8003d80 <DMA_DeInit+0x144>)
 8003cfa:	685b      	ldr	r3, [r3, #4]
 8003cfc:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 8003d00:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003d02:	e035      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA1_Channel7)
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8003d04:	687b      	ldr	r3, [r7, #4]
 8003d06:	4a25      	ldr	r2, [pc, #148]	; (8003d9c <DMA_DeInit+0x160>)
 8003d08:	4293      	cmp	r3, r2
 8003d0a:	d106      	bne.n	8003d1a <DMA_DeInit+0xde>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8003d0c:	4a24      	ldr	r2, [pc, #144]	; (8003da0 <DMA_DeInit+0x164>)
 8003d0e:	4b24      	ldr	r3, [pc, #144]	; (8003da0 <DMA_DeInit+0x164>)
 8003d10:	685b      	ldr	r3, [r3, #4]
 8003d12:	f043 030f 	orr.w	r3, r3, #15
 8003d16:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003d18:	e02a      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA2_Channel1)
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8003d1a:	687b      	ldr	r3, [r7, #4]
 8003d1c:	4a21      	ldr	r2, [pc, #132]	; (8003da4 <DMA_DeInit+0x168>)
 8003d1e:	4293      	cmp	r3, r2
 8003d20:	d106      	bne.n	8003d30 <DMA_DeInit+0xf4>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 8003d22:	4a1f      	ldr	r2, [pc, #124]	; (8003da0 <DMA_DeInit+0x164>)
 8003d24:	4b1e      	ldr	r3, [pc, #120]	; (8003da0 <DMA_DeInit+0x164>)
 8003d26:	685b      	ldr	r3, [r3, #4]
 8003d28:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8003d2c:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003d2e:	e01f      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA2_Channel2)
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 8003d30:	687b      	ldr	r3, [r7, #4]
 8003d32:	4a1d      	ldr	r2, [pc, #116]	; (8003da8 <DMA_DeInit+0x16c>)
 8003d34:	4293      	cmp	r3, r2
 8003d36:	d106      	bne.n	8003d46 <DMA_DeInit+0x10a>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8003d38:	4a19      	ldr	r2, [pc, #100]	; (8003da0 <DMA_DeInit+0x164>)
 8003d3a:	4b19      	ldr	r3, [pc, #100]	; (8003da0 <DMA_DeInit+0x164>)
 8003d3c:	685b      	ldr	r3, [r3, #4]
 8003d3e:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
 8003d42:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003d44:	e014      	b.n	8003d70 <DMA_DeInit+0x134>
  else if (DMAy_Channelx == DMA2_Channel3)
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8003d46:	687b      	ldr	r3, [r7, #4]
 8003d48:	4a18      	ldr	r2, [pc, #96]	; (8003dac <DMA_DeInit+0x170>)
 8003d4a:	4293      	cmp	r3, r2
 8003d4c:	d106      	bne.n	8003d5c <DMA_DeInit+0x120>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8003d4e:	4a14      	ldr	r2, [pc, #80]	; (8003da0 <DMA_DeInit+0x164>)
 8003d50:	4b13      	ldr	r3, [pc, #76]	; (8003da0 <DMA_DeInit+0x164>)
 8003d52:	685b      	ldr	r3, [r3, #4]
 8003d54:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8003d58:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003d5a:	e009      	b.n	8003d70 <DMA_DeInit+0x134>
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8003d5c:	687b      	ldr	r3, [r7, #4]
 8003d5e:	4a14      	ldr	r2, [pc, #80]	; (8003db0 <DMA_DeInit+0x174>)
 8003d60:	4293      	cmp	r3, r2
 8003d62:	d105      	bne.n	8003d70 <DMA_DeInit+0x134>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 8003d64:	4a0e      	ldr	r2, [pc, #56]	; (8003da0 <DMA_DeInit+0x164>)
 8003d66:	4b0e      	ldr	r3, [pc, #56]	; (8003da0 <DMA_DeInit+0x164>)
 8003d68:	685b      	ldr	r3, [r3, #4]
 8003d6a:	f443 2370 	orr.w	r3, r3, #983040	; 0xf0000
 8003d6e:	6053      	str	r3, [r2, #4]
    }
  }
}
 8003d70:	bf00      	nop
 8003d72:	370c      	adds	r7, #12
 8003d74:	46bd      	mov	sp, r7
 8003d76:	bc80      	pop	{r7}
 8003d78:	4770      	bx	lr
 8003d7a:	bf00      	nop
 8003d7c:	40020008 	.word	0x40020008
 8003d80:	40020000 	.word	0x40020000
 8003d84:	4002001c 	.word	0x4002001c
 8003d88:	40020030 	.word	0x40020030
 8003d8c:	40020044 	.word	0x40020044
 8003d90:	40020058 	.word	0x40020058
 8003d94:	4002006c 	.word	0x4002006c
 8003d98:	40020080 	.word	0x40020080
 8003d9c:	40020408 	.word	0x40020408
 8003da0:	40020400 	.word	0x40020400
 8003da4:	4002041c 	.word	0x4002041c
 8003da8:	40020430 	.word	0x40020430
 8003dac:	40020444 	.word	0x40020444
 8003db0:	40020458 	.word	0x40020458

08003db4 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *         contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 8003db4:	b480      	push	{r7}
 8003db6:	b085      	sub	sp, #20
 8003db8:	af00      	add	r7, sp, #0
 8003dba:	6078      	str	r0, [r7, #4]
 8003dbc:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8003dbe:	2300      	movs	r3, #0
 8003dc0:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	681b      	ldr	r3, [r3, #0]
 8003dc6:	60fb      	str	r3, [r7, #12]
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8003dc8:	68fb      	ldr	r3, [r7, #12]
 8003dca:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 8003dce:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003dd2:	60fb      	str	r3, [r7, #12]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003dd4:	683b      	ldr	r3, [r7, #0]
 8003dd6:	689a      	ldr	r2, [r3, #8]
 8003dd8:	683b      	ldr	r3, [r7, #0]
 8003dda:	6a1b      	ldr	r3, [r3, #32]
 8003ddc:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003dde:	683b      	ldr	r3, [r7, #0]
 8003de0:	691b      	ldr	r3, [r3, #16]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003de2:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003de4:	683b      	ldr	r3, [r7, #0]
 8003de6:	695b      	ldr	r3, [r3, #20]
 8003de8:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003dea:	683b      	ldr	r3, [r7, #0]
 8003dec:	699b      	ldr	r3, [r3, #24]
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003dee:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003df0:	683b      	ldr	r3, [r7, #0]
 8003df2:	69db      	ldr	r3, [r3, #28]
 8003df4:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003df6:	683b      	ldr	r3, [r7, #0]
 8003df8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003dfa:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003dfc:	683b      	ldr	r3, [r7, #0]
 8003dfe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003e00:	4313      	orrs	r3, r2
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003e02:	68fa      	ldr	r2, [r7, #12]
 8003e04:	4313      	orrs	r3, r2
 8003e06:	60fb      	str	r3, [r7, #12]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8003e08:	687b      	ldr	r3, [r7, #4]
 8003e0a:	68fa      	ldr	r2, [r7, #12]
 8003e0c:	601a      	str	r2, [r3, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8003e0e:	683b      	ldr	r3, [r7, #0]
 8003e10:	68da      	ldr	r2, [r3, #12]
 8003e12:	687b      	ldr	r3, [r7, #4]
 8003e14:	605a      	str	r2, [r3, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8003e16:	683b      	ldr	r3, [r7, #0]
 8003e18:	681a      	ldr	r2, [r3, #0]
 8003e1a:	687b      	ldr	r3, [r7, #4]
 8003e1c:	609a      	str	r2, [r3, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8003e1e:	683b      	ldr	r3, [r7, #0]
 8003e20:	685a      	ldr	r2, [r3, #4]
 8003e22:	687b      	ldr	r3, [r7, #4]
 8003e24:	60da      	str	r2, [r3, #12]
}
 8003e26:	bf00      	nop
 8003e28:	3714      	adds	r7, #20
 8003e2a:	46bd      	mov	sp, r7
 8003e2c:	bc80      	pop	{r7}
 8003e2e:	4770      	bx	lr

08003e30 <DMA_Cmd>:
  * @param  NewState: new state of the DMAy Channelx. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
{
 8003e30:	b480      	push	{r7}
 8003e32:	b083      	sub	sp, #12
 8003e34:	af00      	add	r7, sp, #0
 8003e36:	6078      	str	r0, [r7, #4]
 8003e38:	460b      	mov	r3, r1
 8003e3a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003e3c:	78fb      	ldrb	r3, [r7, #3]
 8003e3e:	2b00      	cmp	r3, #0
 8003e40:	d006      	beq.n	8003e50 <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR1_EN;
 8003e42:	687b      	ldr	r3, [r7, #4]
 8003e44:	681b      	ldr	r3, [r3, #0]
 8003e46:	f043 0201 	orr.w	r2, r3, #1
 8003e4a:	687b      	ldr	r3, [r7, #4]
 8003e4c:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
  }
}
 8003e4e:	e006      	b.n	8003e5e <DMA_Cmd+0x2e>
    DMAy_Channelx->CCR |= DMA_CCR1_EN;
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8003e50:	687b      	ldr	r3, [r7, #4]
 8003e52:	681a      	ldr	r2, [r3, #0]
 8003e54:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8003e58:	4013      	ands	r3, r2
 8003e5a:	687a      	ldr	r2, [r7, #4]
 8003e5c:	6013      	str	r3, [r2, #0]
  }
}
 8003e5e:	bf00      	nop
 8003e60:	370c      	adds	r7, #12
 8003e62:	46bd      	mov	sp, r7
 8003e64:	bc80      	pop	{r7}
 8003e66:	4770      	bx	lr

08003e68 <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
{
 8003e68:	b480      	push	{r7}
 8003e6a:	b085      	sub	sp, #20
 8003e6c:	af00      	add	r7, sp, #0
 8003e6e:	60f8      	str	r0, [r7, #12]
 8003e70:	60b9      	str	r1, [r7, #8]
 8003e72:	4613      	mov	r3, r2
 8003e74:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003e76:	79fb      	ldrb	r3, [r7, #7]
 8003e78:	2b00      	cmp	r3, #0
 8003e7a:	d006      	beq.n	8003e8a <DMA_ITConfig+0x22>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003e7c:	68fb      	ldr	r3, [r7, #12]
 8003e7e:	681a      	ldr	r2, [r3, #0]
 8003e80:	68bb      	ldr	r3, [r7, #8]
 8003e82:	431a      	orrs	r2, r3
 8003e84:	68fb      	ldr	r3, [r7, #12]
 8003e86:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
  }
}
 8003e88:	e006      	b.n	8003e98 <DMA_ITConfig+0x30>
    DMAy_Channelx->CCR |= DMA_IT;
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 8003e8a:	68fb      	ldr	r3, [r7, #12]
 8003e8c:	681a      	ldr	r2, [r3, #0]
 8003e8e:	68bb      	ldr	r3, [r7, #8]
 8003e90:	43db      	mvns	r3, r3
 8003e92:	401a      	ands	r2, r3
 8003e94:	68fb      	ldr	r3, [r7, #12]
 8003e96:	601a      	str	r2, [r3, #0]
  }
}
 8003e98:	bf00      	nop
 8003e9a:	3714      	adds	r7, #20
 8003e9c:	46bd      	mov	sp, r7
 8003e9e:	bc80      	pop	{r7}
 8003ea0:	4770      	bx	lr
 8003ea2:	bf00      	nop

08003ea4 <DMA_GetFlagStatus>:
  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
  * @retval The new state of DMAy_FLAG (SET or RESET).
  */
FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG)
{
 8003ea4:	b480      	push	{r7}
 8003ea6:	b085      	sub	sp, #20
 8003ea8:	af00      	add	r7, sp, #0
 8003eaa:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8003eac:	2300      	movs	r3, #0
 8003eae:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 8003eb0:	2300      	movs	r3, #0
 8003eb2:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8003eb4:	687b      	ldr	r3, [r7, #4]
 8003eb6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003eba:	2b00      	cmp	r3, #0
 8003ebc:	d003      	beq.n	8003ec6 <DMA_GetFlagStatus+0x22>
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8003ebe:	4b0b      	ldr	r3, [pc, #44]	; (8003eec <DMA_GetFlagStatus+0x48>)
 8003ec0:	681b      	ldr	r3, [r3, #0]
 8003ec2:	60bb      	str	r3, [r7, #8]
 8003ec4:	e002      	b.n	8003ecc <DMA_GetFlagStatus+0x28>
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 8003ec6:	4b0a      	ldr	r3, [pc, #40]	; (8003ef0 <DMA_GetFlagStatus+0x4c>)
 8003ec8:	681b      	ldr	r3, [r3, #0]
 8003eca:	60bb      	str	r3, [r7, #8]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 8003ecc:	68ba      	ldr	r2, [r7, #8]
 8003ece:	687b      	ldr	r3, [r7, #4]
 8003ed0:	4013      	ands	r3, r2
 8003ed2:	2b00      	cmp	r3, #0
 8003ed4:	d002      	beq.n	8003edc <DMA_GetFlagStatus+0x38>
  {
    /* DMAy_FLAG is set */
    bitstatus = SET;
 8003ed6:	2301      	movs	r3, #1
 8003ed8:	73fb      	strb	r3, [r7, #15]
 8003eda:	e001      	b.n	8003ee0 <DMA_GetFlagStatus+0x3c>
  }
  else
  {
    /* DMAy_FLAG is reset */
    bitstatus = RESET;
 8003edc:	2300      	movs	r3, #0
 8003ede:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
 8003ee0:	7bfb      	ldrb	r3, [r7, #15]
}
 8003ee2:	4618      	mov	r0, r3
 8003ee4:	3714      	adds	r7, #20
 8003ee6:	46bd      	mov	sp, r7
 8003ee8:	bc80      	pop	{r7}
 8003eea:	4770      	bx	lr
 8003eec:	40020400 	.word	0x40020400
 8003ef0:	40020000 	.word	0x40020000

08003ef4 <DMA_ClearFlag>:
  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
  * @retval None
  */
void DMA_ClearFlag(uint32_t DMAy_FLAG)
{
 8003ef4:	b480      	push	{r7}
 8003ef6:	b083      	sub	sp, #12
 8003ef8:	af00      	add	r7, sp, #0
 8003efa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8003efc:	687b      	ldr	r3, [r7, #4]
 8003efe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003f02:	2b00      	cmp	r3, #0
 8003f04:	d003      	beq.n	8003f0e <DMA_ClearFlag+0x1a>
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 8003f06:	4a06      	ldr	r2, [pc, #24]	; (8003f20 <DMA_ClearFlag+0x2c>)
 8003f08:	687b      	ldr	r3, [r7, #4]
 8003f0a:	6053      	str	r3, [r2, #4]
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
  }
}
 8003f0c:	e002      	b.n	8003f14 <DMA_ClearFlag+0x20>
    DMA2->IFCR = DMAy_FLAG;
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8003f0e:	4a05      	ldr	r2, [pc, #20]	; (8003f24 <DMA_ClearFlag+0x30>)
 8003f10:	687b      	ldr	r3, [r7, #4]
 8003f12:	6053      	str	r3, [r2, #4]
  }
}
 8003f14:	bf00      	nop
 8003f16:	370c      	adds	r7, #12
 8003f18:	46bd      	mov	sp, r7
 8003f1a:	bc80      	pop	{r7}
 8003f1c:	4770      	bx	lr
 8003f1e:	bf00      	nop
 8003f20:	40020400 	.word	0x40020400
 8003f24:	40020000 	.word	0x40020000

08003f28 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8003f28:	b480      	push	{r7}
 8003f2a:	b085      	sub	sp, #20
 8003f2c:	af00      	add	r7, sp, #0
 8003f2e:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8003f30:	2300      	movs	r3, #0
 8003f32:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 8003f34:	4b34      	ldr	r3, [pc, #208]	; (8004008 <EXTI_Init+0xe0>)
 8003f36:	60fb      	str	r3, [r7, #12]
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003f38:	687b      	ldr	r3, [r7, #4]
 8003f3a:	799b      	ldrb	r3, [r3, #6]
 8003f3c:	2b00      	cmp	r3, #0
 8003f3e:	d04f      	beq.n	8003fe0 <EXTI_Init+0xb8>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8003f40:	4931      	ldr	r1, [pc, #196]	; (8004008 <EXTI_Init+0xe0>)
 8003f42:	4b31      	ldr	r3, [pc, #196]	; (8004008 <EXTI_Init+0xe0>)
 8003f44:	681a      	ldr	r2, [r3, #0]
 8003f46:	687b      	ldr	r3, [r7, #4]
 8003f48:	681b      	ldr	r3, [r3, #0]
 8003f4a:	43db      	mvns	r3, r3
 8003f4c:	4013      	ands	r3, r2
 8003f4e:	600b      	str	r3, [r1, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8003f50:	492d      	ldr	r1, [pc, #180]	; (8004008 <EXTI_Init+0xe0>)
 8003f52:	4b2d      	ldr	r3, [pc, #180]	; (8004008 <EXTI_Init+0xe0>)
 8003f54:	685a      	ldr	r2, [r3, #4]
 8003f56:	687b      	ldr	r3, [r7, #4]
 8003f58:	681b      	ldr	r3, [r3, #0]
 8003f5a:	43db      	mvns	r3, r3
 8003f5c:	4013      	ands	r3, r2
 8003f5e:	604b      	str	r3, [r1, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8003f60:	687b      	ldr	r3, [r7, #4]
 8003f62:	791b      	ldrb	r3, [r3, #4]
 8003f64:	461a      	mov	r2, r3
 8003f66:	68fb      	ldr	r3, [r7, #12]
 8003f68:	4413      	add	r3, r2
 8003f6a:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8003f6c:	68fb      	ldr	r3, [r7, #12]
 8003f6e:	68fa      	ldr	r2, [r7, #12]
 8003f70:	6811      	ldr	r1, [r2, #0]
 8003f72:	687a      	ldr	r2, [r7, #4]
 8003f74:	6812      	ldr	r2, [r2, #0]
 8003f76:	430a      	orrs	r2, r1
 8003f78:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8003f7a:	4923      	ldr	r1, [pc, #140]	; (8004008 <EXTI_Init+0xe0>)
 8003f7c:	4b22      	ldr	r3, [pc, #136]	; (8004008 <EXTI_Init+0xe0>)
 8003f7e:	689a      	ldr	r2, [r3, #8]
 8003f80:	687b      	ldr	r3, [r7, #4]
 8003f82:	681b      	ldr	r3, [r3, #0]
 8003f84:	43db      	mvns	r3, r3
 8003f86:	4013      	ands	r3, r2
 8003f88:	608b      	str	r3, [r1, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8003f8a:	491f      	ldr	r1, [pc, #124]	; (8004008 <EXTI_Init+0xe0>)
 8003f8c:	4b1e      	ldr	r3, [pc, #120]	; (8004008 <EXTI_Init+0xe0>)
 8003f8e:	68da      	ldr	r2, [r3, #12]
 8003f90:	687b      	ldr	r3, [r7, #4]
 8003f92:	681b      	ldr	r3, [r3, #0]
 8003f94:	43db      	mvns	r3, r3
 8003f96:	4013      	ands	r3, r2
 8003f98:	60cb      	str	r3, [r1, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8003f9a:	687b      	ldr	r3, [r7, #4]
 8003f9c:	795b      	ldrb	r3, [r3, #5]
 8003f9e:	2b10      	cmp	r3, #16
 8003fa0:	d10e      	bne.n	8003fc0 <EXTI_Init+0x98>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8003fa2:	4919      	ldr	r1, [pc, #100]	; (8004008 <EXTI_Init+0xe0>)
 8003fa4:	4b18      	ldr	r3, [pc, #96]	; (8004008 <EXTI_Init+0xe0>)
 8003fa6:	689a      	ldr	r2, [r3, #8]
 8003fa8:	687b      	ldr	r3, [r7, #4]
 8003faa:	681b      	ldr	r3, [r3, #0]
 8003fac:	4313      	orrs	r3, r2
 8003fae:	608b      	str	r3, [r1, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8003fb0:	4915      	ldr	r1, [pc, #84]	; (8004008 <EXTI_Init+0xe0>)
 8003fb2:	4b15      	ldr	r3, [pc, #84]	; (8004008 <EXTI_Init+0xe0>)
 8003fb4:	68da      	ldr	r2, [r3, #12]
 8003fb6:	687b      	ldr	r3, [r7, #4]
 8003fb8:	681b      	ldr	r3, [r3, #0]
 8003fba:	4313      	orrs	r3, r2
 8003fbc:	60cb      	str	r3, [r1, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8003fbe:	e01d      	b.n	8003ffc <EXTI_Init+0xd4>
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
 8003fc0:	4b11      	ldr	r3, [pc, #68]	; (8004008 <EXTI_Init+0xe0>)
 8003fc2:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8003fc4:	687b      	ldr	r3, [r7, #4]
 8003fc6:	795b      	ldrb	r3, [r3, #5]
 8003fc8:	461a      	mov	r2, r3
 8003fca:	68fb      	ldr	r3, [r7, #12]
 8003fcc:	4413      	add	r3, r2
 8003fce:	60fb      	str	r3, [r7, #12]

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8003fd0:	68fb      	ldr	r3, [r7, #12]
 8003fd2:	68fa      	ldr	r2, [r7, #12]
 8003fd4:	6811      	ldr	r1, [r2, #0]
 8003fd6:	687a      	ldr	r2, [r7, #4]
 8003fd8:	6812      	ldr	r2, [r2, #0]
 8003fda:	430a      	orrs	r2, r1
 8003fdc:	601a      	str	r2, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8003fde:	e00d      	b.n	8003ffc <EXTI_Init+0xd4>
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8003fe0:	687b      	ldr	r3, [r7, #4]
 8003fe2:	791b      	ldrb	r3, [r3, #4]
 8003fe4:	461a      	mov	r2, r3
 8003fe6:	68fb      	ldr	r3, [r7, #12]
 8003fe8:	4413      	add	r3, r2
 8003fea:	60fb      	str	r3, [r7, #12]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8003fec:	68fb      	ldr	r3, [r7, #12]
 8003fee:	68fa      	ldr	r2, [r7, #12]
 8003ff0:	6811      	ldr	r1, [r2, #0]
 8003ff2:	687a      	ldr	r2, [r7, #4]
 8003ff4:	6812      	ldr	r2, [r2, #0]
 8003ff6:	43d2      	mvns	r2, r2
 8003ff8:	400a      	ands	r2, r1
 8003ffa:	601a      	str	r2, [r3, #0]
  }
}
 8003ffc:	bf00      	nop
 8003ffe:	3714      	adds	r7, #20
 8004000:	46bd      	mov	sp, r7
 8004002:	bc80      	pop	{r7}
 8004004:	4770      	bx	lr
 8004006:	bf00      	nop
 8004008:	40010400 	.word	0x40010400

0800400c <EXTI_GetITStatus>:
  *   This parameter can be:
  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 800400c:	b480      	push	{r7}
 800400e:	b085      	sub	sp, #20
 8004010:	af00      	add	r7, sp, #0
 8004012:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 8004014:	2300      	movs	r3, #0
 8004016:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 8004018:	2300      	movs	r3, #0
 800401a:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 800401c:	4b0c      	ldr	r3, [pc, #48]	; (8004050 <EXTI_GetITStatus+0x44>)
 800401e:	681a      	ldr	r2, [r3, #0]
 8004020:	687b      	ldr	r3, [r7, #4]
 8004022:	4013      	ands	r3, r2
 8004024:	60bb      	str	r3, [r7, #8]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8004026:	4b0a      	ldr	r3, [pc, #40]	; (8004050 <EXTI_GetITStatus+0x44>)
 8004028:	695a      	ldr	r2, [r3, #20]
 800402a:	687b      	ldr	r3, [r7, #4]
 800402c:	4013      	ands	r3, r2
 800402e:	2b00      	cmp	r3, #0
 8004030:	d005      	beq.n	800403e <EXTI_GetITStatus+0x32>
 8004032:	68bb      	ldr	r3, [r7, #8]
 8004034:	2b00      	cmp	r3, #0
 8004036:	d002      	beq.n	800403e <EXTI_GetITStatus+0x32>
  {
    bitstatus = SET;
 8004038:	2301      	movs	r3, #1
 800403a:	73fb      	strb	r3, [r7, #15]
 800403c:	e001      	b.n	8004042 <EXTI_GetITStatus+0x36>
  }
  else
  {
    bitstatus = RESET;
 800403e:	2300      	movs	r3, #0
 8004040:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8004042:	7bfb      	ldrb	r3, [r7, #15]
}
 8004044:	4618      	mov	r0, r3
 8004046:	3714      	adds	r7, #20
 8004048:	46bd      	mov	sp, r7
 800404a:	bc80      	pop	{r7}
 800404c:	4770      	bx	lr
 800404e:	bf00      	nop
 8004050:	40010400 	.word	0x40010400

08004054 <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 8004054:	b480      	push	{r7}
 8004056:	b083      	sub	sp, #12
 8004058:	af00      	add	r7, sp, #0
 800405a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 800405c:	4a03      	ldr	r2, [pc, #12]	; (800406c <EXTI_ClearITPendingBit+0x18>)
 800405e:	687b      	ldr	r3, [r7, #4]
 8004060:	6153      	str	r3, [r2, #20]
}
 8004062:	bf00      	nop
 8004064:	370c      	adds	r7, #12
 8004066:	46bd      	mov	sp, r7
 8004068:	bc80      	pop	{r7}
 800406a:	4770      	bx	lr
 800406c:	40010400 	.word	0x40010400

08004070 <FLASH_SetLatency>:
  *     @arg FLASH_Latency_1: FLASH One Latency cycle
  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 8004070:	b480      	push	{r7}
 8004072:	b085      	sub	sp, #20
 8004074:	af00      	add	r7, sp, #0
 8004076:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8004078:	2300      	movs	r3, #0
 800407a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 800407c:	4b09      	ldr	r3, [pc, #36]	; (80040a4 <FLASH_SetLatency+0x34>)
 800407e:	681b      	ldr	r3, [r3, #0]
 8004080:	60fb      	str	r3, [r7, #12]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8004082:	68fb      	ldr	r3, [r7, #12]
 8004084:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8004088:	60fb      	str	r3, [r7, #12]
  tmpreg |= FLASH_Latency;
 800408a:	68fa      	ldr	r2, [r7, #12]
 800408c:	687b      	ldr	r3, [r7, #4]
 800408e:	4313      	orrs	r3, r2
 8004090:	60fb      	str	r3, [r7, #12]
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8004092:	4a04      	ldr	r2, [pc, #16]	; (80040a4 <FLASH_SetLatency+0x34>)
 8004094:	68fb      	ldr	r3, [r7, #12]
 8004096:	6013      	str	r3, [r2, #0]
}
 8004098:	bf00      	nop
 800409a:	3714      	adds	r7, #20
 800409c:	46bd      	mov	sp, r7
 800409e:	bc80      	pop	{r7}
 80040a0:	4770      	bx	lr
 80040a2:	bf00      	nop
 80040a4:	40022000 	.word	0x40022000

080040a8 <FLASH_PrefetchBufferCmd>:
  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
  * @retval None
  */
void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
{
 80040a8:	b480      	push	{r7}
 80040aa:	b083      	sub	sp, #12
 80040ac:	af00      	add	r7, sp, #0
 80040ae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 80040b0:	4a08      	ldr	r2, [pc, #32]	; (80040d4 <FLASH_PrefetchBufferCmd+0x2c>)
 80040b2:	4b08      	ldr	r3, [pc, #32]	; (80040d4 <FLASH_PrefetchBufferCmd+0x2c>)
 80040b4:	681b      	ldr	r3, [r3, #0]
 80040b6:	f023 0310 	bic.w	r3, r3, #16
 80040ba:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 80040bc:	4905      	ldr	r1, [pc, #20]	; (80040d4 <FLASH_PrefetchBufferCmd+0x2c>)
 80040be:	4b05      	ldr	r3, [pc, #20]	; (80040d4 <FLASH_PrefetchBufferCmd+0x2c>)
 80040c0:	681a      	ldr	r2, [r3, #0]
 80040c2:	687b      	ldr	r3, [r7, #4]
 80040c4:	4313      	orrs	r3, r2
 80040c6:	600b      	str	r3, [r1, #0]
}
 80040c8:	bf00      	nop
 80040ca:	370c      	adds	r7, #12
 80040cc:	46bd      	mov	sp, r7
 80040ce:	bc80      	pop	{r7}
 80040d0:	4770      	bx	lr
 80040d2:	bf00      	nop
 80040d4:	40022000 	.word	0x40022000

080040d8 <FLASH_Unlock>:
  *           to FLASH_UnlockBank1 function.. 
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 80040d8:	b480      	push	{r7}
 80040da:	af00      	add	r7, sp, #0
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
 80040dc:	4b04      	ldr	r3, [pc, #16]	; (80040f0 <FLASH_Unlock+0x18>)
 80040de:	4a05      	ldr	r2, [pc, #20]	; (80040f4 <FLASH_Unlock+0x1c>)
 80040e0:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 80040e2:	4b03      	ldr	r3, [pc, #12]	; (80040f0 <FLASH_Unlock+0x18>)
 80040e4:	4a04      	ldr	r2, [pc, #16]	; (80040f8 <FLASH_Unlock+0x20>)
 80040e6:	605a      	str	r2, [r3, #4]
#ifdef STM32F10X_XL
  /* Authorize the FPEC of Bank2 Access */
  FLASH->KEYR2 = FLASH_KEY1;
  FLASH->KEYR2 = FLASH_KEY2;
#endif /* STM32F10X_XL */
}
 80040e8:	bf00      	nop
 80040ea:	46bd      	mov	sp, r7
 80040ec:	bc80      	pop	{r7}
 80040ee:	4770      	bx	lr
 80040f0:	40022000 	.word	0x40022000
 80040f4:	45670123 	.word	0x45670123
 80040f8:	cdef89ab 	.word	0xcdef89ab

080040fc <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80040fc:	b480      	push	{r7}
 80040fe:	b089      	sub	sp, #36	; 0x24
 8004100:	af00      	add	r7, sp, #0
 8004102:	6078      	str	r0, [r7, #4]
 8004104:	6039      	str	r1, [r7, #0]
  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
 8004106:	2300      	movs	r3, #0
 8004108:	61fb      	str	r3, [r7, #28]
 800410a:	2300      	movs	r3, #0
 800410c:	613b      	str	r3, [r7, #16]
 800410e:	2300      	movs	r3, #0
 8004110:	61bb      	str	r3, [r7, #24]
 8004112:	2300      	movs	r3, #0
 8004114:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg = 0x00, pinmask = 0x00;
 8004116:	2300      	movs	r3, #0
 8004118:	617b      	str	r3, [r7, #20]
 800411a:	2300      	movs	r3, #0
 800411c:	60bb      	str	r3, [r7, #8]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 800411e:	683b      	ldr	r3, [r7, #0]
 8004120:	78db      	ldrb	r3, [r3, #3]
 8004122:	f003 030f 	and.w	r3, r3, #15
 8004126:	61fb      	str	r3, [r7, #28]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8004128:	683b      	ldr	r3, [r7, #0]
 800412a:	78db      	ldrb	r3, [r3, #3]
 800412c:	f003 0310 	and.w	r3, r3, #16
 8004130:	2b00      	cmp	r3, #0
 8004132:	d005      	beq.n	8004140 <GPIO_Init+0x44>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8004134:	683b      	ldr	r3, [r7, #0]
 8004136:	789b      	ldrb	r3, [r3, #2]
 8004138:	461a      	mov	r2, r3
 800413a:	69fb      	ldr	r3, [r7, #28]
 800413c:	4313      	orrs	r3, r2
 800413e:	61fb      	str	r3, [r7, #28]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8004140:	683b      	ldr	r3, [r7, #0]
 8004142:	881b      	ldrh	r3, [r3, #0]
 8004144:	b2db      	uxtb	r3, r3
 8004146:	2b00      	cmp	r3, #0
 8004148:	d044      	beq.n	80041d4 <GPIO_Init+0xd8>
  {
    tmpreg = GPIOx->CRL;
 800414a:	687b      	ldr	r3, [r7, #4]
 800414c:	681b      	ldr	r3, [r3, #0]
 800414e:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8004150:	2300      	movs	r3, #0
 8004152:	61bb      	str	r3, [r7, #24]
 8004154:	e038      	b.n	80041c8 <GPIO_Init+0xcc>
    {
      pos = ((uint32_t)0x01) << pinpos;
 8004156:	2201      	movs	r2, #1
 8004158:	69bb      	ldr	r3, [r7, #24]
 800415a:	fa02 f303 	lsl.w	r3, r2, r3
 800415e:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8004160:	683b      	ldr	r3, [r7, #0]
 8004162:	881b      	ldrh	r3, [r3, #0]
 8004164:	461a      	mov	r2, r3
 8004166:	68fb      	ldr	r3, [r7, #12]
 8004168:	4013      	ands	r3, r2
 800416a:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 800416c:	693a      	ldr	r2, [r7, #16]
 800416e:	68fb      	ldr	r3, [r7, #12]
 8004170:	429a      	cmp	r2, r3
 8004172:	d126      	bne.n	80041c2 <GPIO_Init+0xc6>
      {
        pos = pinpos << 2;
 8004174:	69bb      	ldr	r3, [r7, #24]
 8004176:	009b      	lsls	r3, r3, #2
 8004178:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800417a:	220f      	movs	r2, #15
 800417c:	68fb      	ldr	r3, [r7, #12]
 800417e:	fa02 f303 	lsl.w	r3, r2, r3
 8004182:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 8004184:	68bb      	ldr	r3, [r7, #8]
 8004186:	43db      	mvns	r3, r3
 8004188:	697a      	ldr	r2, [r7, #20]
 800418a:	4013      	ands	r3, r2
 800418c:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800418e:	69fa      	ldr	r2, [r7, #28]
 8004190:	68fb      	ldr	r3, [r7, #12]
 8004192:	fa02 f303 	lsl.w	r3, r2, r3
 8004196:	697a      	ldr	r2, [r7, #20]
 8004198:	4313      	orrs	r3, r2
 800419a:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800419c:	683b      	ldr	r3, [r7, #0]
 800419e:	78db      	ldrb	r3, [r3, #3]
 80041a0:	2b28      	cmp	r3, #40	; 0x28
 80041a2:	d105      	bne.n	80041b0 <GPIO_Init+0xb4>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80041a4:	2201      	movs	r2, #1
 80041a6:	69bb      	ldr	r3, [r7, #24]
 80041a8:	409a      	lsls	r2, r3
 80041aa:	687b      	ldr	r3, [r7, #4]
 80041ac:	615a      	str	r2, [r3, #20]
 80041ae:	e008      	b.n	80041c2 <GPIO_Init+0xc6>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80041b0:	683b      	ldr	r3, [r7, #0]
 80041b2:	78db      	ldrb	r3, [r3, #3]
 80041b4:	2b48      	cmp	r3, #72	; 0x48
 80041b6:	d104      	bne.n	80041c2 <GPIO_Init+0xc6>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 80041b8:	2201      	movs	r2, #1
 80041ba:	69bb      	ldr	r3, [r7, #24]
 80041bc:	409a      	lsls	r2, r3
 80041be:	687b      	ldr	r3, [r7, #4]
 80041c0:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80041c2:	69bb      	ldr	r3, [r7, #24]
 80041c4:	3301      	adds	r3, #1
 80041c6:	61bb      	str	r3, [r7, #24]
 80041c8:	69bb      	ldr	r3, [r7, #24]
 80041ca:	2b07      	cmp	r3, #7
 80041cc:	d9c3      	bls.n	8004156 <GPIO_Init+0x5a>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 80041ce:	687b      	ldr	r3, [r7, #4]
 80041d0:	697a      	ldr	r2, [r7, #20]
 80041d2:	601a      	str	r2, [r3, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 80041d4:	683b      	ldr	r3, [r7, #0]
 80041d6:	881b      	ldrh	r3, [r3, #0]
 80041d8:	2bff      	cmp	r3, #255	; 0xff
 80041da:	d946      	bls.n	800426a <GPIO_Init+0x16e>
  {
    tmpreg = GPIOx->CRH;
 80041dc:	687b      	ldr	r3, [r7, #4]
 80041de:	685b      	ldr	r3, [r3, #4]
 80041e0:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80041e2:	2300      	movs	r3, #0
 80041e4:	61bb      	str	r3, [r7, #24]
 80041e6:	e03a      	b.n	800425e <GPIO_Init+0x162>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80041e8:	69bb      	ldr	r3, [r7, #24]
 80041ea:	3308      	adds	r3, #8
 80041ec:	2201      	movs	r2, #1
 80041ee:	fa02 f303 	lsl.w	r3, r2, r3
 80041f2:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 80041f4:	683b      	ldr	r3, [r7, #0]
 80041f6:	881b      	ldrh	r3, [r3, #0]
 80041f8:	461a      	mov	r2, r3
 80041fa:	68fb      	ldr	r3, [r7, #12]
 80041fc:	4013      	ands	r3, r2
 80041fe:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 8004200:	693a      	ldr	r2, [r7, #16]
 8004202:	68fb      	ldr	r3, [r7, #12]
 8004204:	429a      	cmp	r2, r3
 8004206:	d127      	bne.n	8004258 <GPIO_Init+0x15c>
      {
        pos = pinpos << 2;
 8004208:	69bb      	ldr	r3, [r7, #24]
 800420a:	009b      	lsls	r3, r3, #2
 800420c:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800420e:	220f      	movs	r2, #15
 8004210:	68fb      	ldr	r3, [r7, #12]
 8004212:	fa02 f303 	lsl.w	r3, r2, r3
 8004216:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 8004218:	68bb      	ldr	r3, [r7, #8]
 800421a:	43db      	mvns	r3, r3
 800421c:	697a      	ldr	r2, [r7, #20]
 800421e:	4013      	ands	r3, r2
 8004220:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8004222:	69fa      	ldr	r2, [r7, #28]
 8004224:	68fb      	ldr	r3, [r7, #12]
 8004226:	fa02 f303 	lsl.w	r3, r2, r3
 800422a:	697a      	ldr	r2, [r7, #20]
 800422c:	4313      	orrs	r3, r2
 800422e:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8004230:	683b      	ldr	r3, [r7, #0]
 8004232:	78db      	ldrb	r3, [r3, #3]
 8004234:	2b28      	cmp	r3, #40	; 0x28
 8004236:	d105      	bne.n	8004244 <GPIO_Init+0x148>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8004238:	69bb      	ldr	r3, [r7, #24]
 800423a:	3308      	adds	r3, #8
 800423c:	2201      	movs	r2, #1
 800423e:	409a      	lsls	r2, r3
 8004240:	687b      	ldr	r3, [r7, #4]
 8004242:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8004244:	683b      	ldr	r3, [r7, #0]
 8004246:	78db      	ldrb	r3, [r3, #3]
 8004248:	2b48      	cmp	r3, #72	; 0x48
 800424a:	d105      	bne.n	8004258 <GPIO_Init+0x15c>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800424c:	69bb      	ldr	r3, [r7, #24]
 800424e:	3308      	adds	r3, #8
 8004250:	2201      	movs	r2, #1
 8004252:	409a      	lsls	r2, r3
 8004254:	687b      	ldr	r3, [r7, #4]
 8004256:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8004258:	69bb      	ldr	r3, [r7, #24]
 800425a:	3301      	adds	r3, #1
 800425c:	61bb      	str	r3, [r7, #24]
 800425e:	69bb      	ldr	r3, [r7, #24]
 8004260:	2b07      	cmp	r3, #7
 8004262:	d9c1      	bls.n	80041e8 <GPIO_Init+0xec>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8004264:	687b      	ldr	r3, [r7, #4]
 8004266:	697a      	ldr	r2, [r7, #20]
 8004268:	605a      	str	r2, [r3, #4]
  }
}
 800426a:	bf00      	nop
 800426c:	3724      	adds	r7, #36	; 0x24
 800426e:	46bd      	mov	sp, r7
 8004270:	bc80      	pop	{r7}
 8004272:	4770      	bx	lr

08004274 <GPIO_StructInit>:
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
 8004274:	b480      	push	{r7}
 8004276:	b083      	sub	sp, #12
 8004278:	af00      	add	r7, sp, #0
 800427a:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800427c:	687b      	ldr	r3, [r7, #4]
 800427e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004282:	801a      	strh	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8004284:	687b      	ldr	r3, [r7, #4]
 8004286:	2202      	movs	r2, #2
 8004288:	709a      	strb	r2, [r3, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 800428a:	687b      	ldr	r3, [r7, #4]
 800428c:	2204      	movs	r2, #4
 800428e:	70da      	strb	r2, [r3, #3]
}
 8004290:	bf00      	nop
 8004292:	370c      	adds	r7, #12
 8004294:	46bd      	mov	sp, r7
 8004296:	bc80      	pop	{r7}
 8004298:	4770      	bx	lr
 800429a:	bf00      	nop

0800429c <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin:  specifies the port bit to read.
  *   This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800429c:	b480      	push	{r7}
 800429e:	b085      	sub	sp, #20
 80042a0:	af00      	add	r7, sp, #0
 80042a2:	6078      	str	r0, [r7, #4]
 80042a4:	460b      	mov	r3, r1
 80042a6:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 80042a8:	2300      	movs	r3, #0
 80042aa:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80042ac:	687b      	ldr	r3, [r7, #4]
 80042ae:	689a      	ldr	r2, [r3, #8]
 80042b0:	887b      	ldrh	r3, [r7, #2]
 80042b2:	4013      	ands	r3, r2
 80042b4:	2b00      	cmp	r3, #0
 80042b6:	d002      	beq.n	80042be <GPIO_ReadInputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
 80042b8:	2301      	movs	r3, #1
 80042ba:	73fb      	strb	r3, [r7, #15]
 80042bc:	e001      	b.n	80042c2 <GPIO_ReadInputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 80042be:	2300      	movs	r3, #0
 80042c0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80042c2:	7bfb      	ldrb	r3, [r7, #15]
}
 80042c4:	4618      	mov	r0, r3
 80042c6:	3714      	adds	r7, #20
 80042c8:	46bd      	mov	sp, r7
 80042ca:	bc80      	pop	{r7}
 80042cc:	4770      	bx	lr
 80042ce:	bf00      	nop

080042d0 <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80042d0:	b480      	push	{r7}
 80042d2:	b083      	sub	sp, #12
 80042d4:	af00      	add	r7, sp, #0
 80042d6:	6078      	str	r0, [r7, #4]
 80042d8:	460b      	mov	r3, r1
 80042da:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 80042dc:	887a      	ldrh	r2, [r7, #2]
 80042de:	687b      	ldr	r3, [r7, #4]
 80042e0:	611a      	str	r2, [r3, #16]
}
 80042e2:	bf00      	nop
 80042e4:	370c      	adds	r7, #12
 80042e6:	46bd      	mov	sp, r7
 80042e8:	bc80      	pop	{r7}
 80042ea:	4770      	bx	lr

080042ec <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80042ec:	b480      	push	{r7}
 80042ee:	b083      	sub	sp, #12
 80042f0:	af00      	add	r7, sp, #0
 80042f2:	6078      	str	r0, [r7, #4]
 80042f4:	460b      	mov	r3, r1
 80042f6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 80042f8:	887a      	ldrh	r2, [r7, #2]
 80042fa:	687b      	ldr	r3, [r7, #4]
 80042fc:	615a      	str	r2, [r3, #20]
}
 80042fe:	bf00      	nop
 8004300:	370c      	adds	r7, #12
 8004302:	46bd      	mov	sp, r7
 8004304:	bc80      	pop	{r7}
 8004306:	4770      	bx	lr

08004308 <GPIO_WriteBit>:
  *     @arg Bit_RESET: to clear the port pin
  *     @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8004308:	b480      	push	{r7}
 800430a:	b083      	sub	sp, #12
 800430c:	af00      	add	r7, sp, #0
 800430e:	6078      	str	r0, [r7, #4]
 8004310:	460b      	mov	r3, r1
 8004312:	807b      	strh	r3, [r7, #2]
 8004314:	4613      	mov	r3, r2
 8004316:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8004318:	787b      	ldrb	r3, [r7, #1]
 800431a:	2b00      	cmp	r3, #0
 800431c:	d003      	beq.n	8004326 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800431e:	887a      	ldrh	r2, [r7, #2]
 8004320:	687b      	ldr	r3, [r7, #4]
 8004322:	611a      	str	r2, [r3, #16]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
  }
}
 8004324:	e002      	b.n	800432c <GPIO_WriteBit+0x24>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8004326:	887a      	ldrh	r2, [r7, #2]
 8004328:	687b      	ldr	r3, [r7, #4]
 800432a:	615a      	str	r2, [r3, #20]
  }
}
 800432c:	bf00      	nop
 800432e:	370c      	adds	r7, #12
 8004330:	46bd      	mov	sp, r7
 8004332:	bc80      	pop	{r7}
 8004334:	4770      	bx	lr
 8004336:	bf00      	nop

08004338 <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8004338:	b490      	push	{r4, r7}
 800433a:	b084      	sub	sp, #16
 800433c:	af00      	add	r7, sp, #0
 800433e:	4603      	mov	r3, r0
 8004340:	460a      	mov	r2, r1
 8004342:	71fb      	strb	r3, [r7, #7]
 8004344:	4613      	mov	r3, r2
 8004346:	71bb      	strb	r3, [r7, #6]
  uint32_t tmp = 0x00;
 8004348:	2300      	movs	r3, #0
 800434a:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800434c:	79bb      	ldrb	r3, [r7, #6]
 800434e:	f003 0303 	and.w	r3, r3, #3
 8004352:	009b      	lsls	r3, r3, #2
 8004354:	220f      	movs	r2, #15
 8004356:	fa02 f303 	lsl.w	r3, r2, r3
 800435a:	60fb      	str	r3, [r7, #12]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 800435c:	4916      	ldr	r1, [pc, #88]	; (80043b8 <GPIO_EXTILineConfig+0x80>)
 800435e:	79bb      	ldrb	r3, [r7, #6]
 8004360:	089b      	lsrs	r3, r3, #2
 8004362:	b2db      	uxtb	r3, r3
 8004364:	4618      	mov	r0, r3
 8004366:	4a14      	ldr	r2, [pc, #80]	; (80043b8 <GPIO_EXTILineConfig+0x80>)
 8004368:	79bb      	ldrb	r3, [r7, #6]
 800436a:	089b      	lsrs	r3, r3, #2
 800436c:	b2db      	uxtb	r3, r3
 800436e:	3302      	adds	r3, #2
 8004370:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004374:	68fb      	ldr	r3, [r7, #12]
 8004376:	43db      	mvns	r3, r3
 8004378:	401a      	ands	r2, r3
 800437a:	1c83      	adds	r3, r0, #2
 800437c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8004380:	480d      	ldr	r0, [pc, #52]	; (80043b8 <GPIO_EXTILineConfig+0x80>)
 8004382:	79bb      	ldrb	r3, [r7, #6]
 8004384:	089b      	lsrs	r3, r3, #2
 8004386:	b2db      	uxtb	r3, r3
 8004388:	461c      	mov	r4, r3
 800438a:	4a0b      	ldr	r2, [pc, #44]	; (80043b8 <GPIO_EXTILineConfig+0x80>)
 800438c:	79bb      	ldrb	r3, [r7, #6]
 800438e:	089b      	lsrs	r3, r3, #2
 8004390:	b2db      	uxtb	r3, r3
 8004392:	3302      	adds	r3, #2
 8004394:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004398:	79f9      	ldrb	r1, [r7, #7]
 800439a:	79bb      	ldrb	r3, [r7, #6]
 800439c:	f003 0303 	and.w	r3, r3, #3
 80043a0:	009b      	lsls	r3, r3, #2
 80043a2:	fa01 f303 	lsl.w	r3, r1, r3
 80043a6:	431a      	orrs	r2, r3
 80043a8:	1ca3      	adds	r3, r4, #2
 80043aa:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
 80043ae:	bf00      	nop
 80043b0:	3710      	adds	r7, #16
 80043b2:	46bd      	mov	sp, r7
 80043b4:	bc90      	pop	{r4, r7}
 80043b6:	4770      	bx	lr
 80043b8:	40010000 	.word	0x40010000

080043bc <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
  *   contains the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 80043bc:	b580      	push	{r7, lr}
 80043be:	b08a      	sub	sp, #40	; 0x28
 80043c0:	af00      	add	r7, sp, #0
 80043c2:	6078      	str	r0, [r7, #4]
 80043c4:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, freqrange = 0;
 80043c6:	2300      	movs	r3, #0
 80043c8:	84fb      	strh	r3, [r7, #38]	; 0x26
 80043ca:	2300      	movs	r3, #0
 80043cc:	847b      	strh	r3, [r7, #34]	; 0x22
  uint16_t result = 0x04;
 80043ce:	2304      	movs	r3, #4
 80043d0:	84bb      	strh	r3, [r7, #36]	; 0x24
  uint32_t pclk1 = 8000000;
 80043d2:	4b57      	ldr	r3, [pc, #348]	; (8004530 <I2C_Init+0x174>)
 80043d4:	61fb      	str	r3, [r7, #28]
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 80043d6:	687b      	ldr	r3, [r7, #4]
 80043d8:	889b      	ldrh	r3, [r3, #4]
 80043da:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
 80043dc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80043de:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80043e2:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 80043e4:	f107 0308 	add.w	r3, r7, #8
 80043e8:	4618      	mov	r0, r3
 80043ea:	f000 fb6f 	bl	8004acc <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 80043ee:	693b      	ldr	r3, [r7, #16]
 80043f0:	61fb      	str	r3, [r7, #28]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 80043f2:	69fb      	ldr	r3, [r7, #28]
 80043f4:	4a4f      	ldr	r2, [pc, #316]	; (8004534 <I2C_Init+0x178>)
 80043f6:	fba2 2303 	umull	r2, r3, r2, r3
 80043fa:	0c9b      	lsrs	r3, r3, #18
 80043fc:	847b      	strh	r3, [r7, #34]	; 0x22
  tmpreg |= freqrange;
 80043fe:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8004400:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8004402:	4313      	orrs	r3, r2
 8004404:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800440a:	809a      	strh	r2, [r3, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= CR1_PE_Reset;
 800440c:	687b      	ldr	r3, [r7, #4]
 800440e:	881b      	ldrh	r3, [r3, #0]
 8004410:	b29b      	uxth	r3, r3
 8004412:	f023 0301 	bic.w	r3, r3, #1
 8004416:	b29a      	uxth	r2, r3
 8004418:	687b      	ldr	r3, [r7, #4]
 800441a:	801a      	strh	r2, [r3, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;
 800441c:	2300      	movs	r3, #0
 800441e:	84fb      	strh	r3, [r7, #38]	; 0x26

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8004420:	683b      	ldr	r3, [r7, #0]
 8004422:	681b      	ldr	r3, [r3, #0]
 8004424:	4a44      	ldr	r2, [pc, #272]	; (8004538 <I2C_Init+0x17c>)
 8004426:	4293      	cmp	r3, r2
 8004428:	d815      	bhi.n	8004456 <I2C_Init+0x9a>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 800442a:	683b      	ldr	r3, [r7, #0]
 800442c:	681b      	ldr	r3, [r3, #0]
 800442e:	005b      	lsls	r3, r3, #1
 8004430:	69fa      	ldr	r2, [r7, #28]
 8004432:	fbb2 f3f3 	udiv	r3, r2, r3
 8004436:	84bb      	strh	r3, [r7, #36]	; 0x24
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 8004438:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800443a:	2b03      	cmp	r3, #3
 800443c:	d801      	bhi.n	8004442 <I2C_Init+0x86>
    {
      /* Set minimum allowed value */
      result = 0x04;  
 800443e:	2304      	movs	r3, #4
 8004440:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
 8004442:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8004444:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8004446:	4313      	orrs	r3, r2
 8004448:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 800444a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800444c:	3301      	adds	r3, #1
 800444e:	b29a      	uxth	r2, r3
 8004450:	687b      	ldr	r3, [r7, #4]
 8004452:	841a      	strh	r2, [r3, #32]
 8004454:	e040      	b.n	80044d8 <I2C_Init+0x11c>
  }
  /* Configure speed in fast mode */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 8004456:	683b      	ldr	r3, [r7, #0]
 8004458:	88db      	ldrh	r3, [r3, #6]
 800445a:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 800445e:	4293      	cmp	r3, r2
 8004460:	d109      	bne.n	8004476 <I2C_Init+0xba>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 8004462:	683b      	ldr	r3, [r7, #0]
 8004464:	681a      	ldr	r2, [r3, #0]
 8004466:	4613      	mov	r3, r2
 8004468:	005b      	lsls	r3, r3, #1
 800446a:	4413      	add	r3, r2
 800446c:	69fa      	ldr	r2, [r7, #28]
 800446e:	fbb2 f3f3 	udiv	r3, r2, r3
 8004472:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004474:	e00e      	b.n	8004494 <I2C_Init+0xd8>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 8004476:	683b      	ldr	r3, [r7, #0]
 8004478:	681a      	ldr	r2, [r3, #0]
 800447a:	4613      	mov	r3, r2
 800447c:	009b      	lsls	r3, r3, #2
 800447e:	4413      	add	r3, r2
 8004480:	009a      	lsls	r2, r3, #2
 8004482:	4413      	add	r3, r2
 8004484:	69fa      	ldr	r2, [r7, #28]
 8004486:	fbb2 f3f3 	udiv	r3, r2, r3
 800448a:	84bb      	strh	r3, [r7, #36]	; 0x24
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 800448c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800448e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004492:	84bb      	strh	r3, [r7, #36]	; 0x24
    }

    /* Test if CCR value is under 0x1*/
    if ((result & CCR_CCR_Set) == 0)
 8004494:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8004496:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800449a:	2b00      	cmp	r3, #0
 800449c:	d103      	bne.n	80044a6 <I2C_Init+0xea>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 800449e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80044a0:	f043 0301 	orr.w	r3, r3, #1
 80044a4:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | CCR_FS_Set);
 80044a6:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 80044a8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80044aa:	4313      	orrs	r3, r2
 80044ac:	b29b      	uxth	r3, r3
 80044ae:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80044b2:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80044b6:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 80044b8:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80044ba:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80044be:	fb02 f303 	mul.w	r3, r2, r3
 80044c2:	4a1e      	ldr	r2, [pc, #120]	; (800453c <I2C_Init+0x180>)
 80044c4:	fb82 1203 	smull	r1, r2, r2, r3
 80044c8:	1192      	asrs	r2, r2, #6
 80044ca:	17db      	asrs	r3, r3, #31
 80044cc:	1ad3      	subs	r3, r2, r3
 80044ce:	b29b      	uxth	r3, r3
 80044d0:	3301      	adds	r3, #1
 80044d2:	b29a      	uxth	r2, r3
 80044d4:	687b      	ldr	r3, [r7, #4]
 80044d6:	841a      	strh	r2, [r3, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 80044d8:	687b      	ldr	r3, [r7, #4]
 80044da:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80044dc:	839a      	strh	r2, [r3, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= CR1_PE_Set;
 80044de:	687b      	ldr	r3, [r7, #4]
 80044e0:	881b      	ldrh	r3, [r3, #0]
 80044e2:	b29b      	uxth	r3, r3
 80044e4:	f043 0301 	orr.w	r3, r3, #1
 80044e8:	b29a      	uxth	r2, r3
 80044ea:	687b      	ldr	r3, [r7, #4]
 80044ec:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 80044ee:	687b      	ldr	r3, [r7, #4]
 80044f0:	881b      	ldrh	r3, [r3, #0]
 80044f2:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
 80044f4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80044f6:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 80044fa:	f023 0302 	bic.w	r3, r3, #2
 80044fe:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8004500:	683b      	ldr	r3, [r7, #0]
 8004502:	889a      	ldrh	r2, [r3, #4]
 8004504:	683b      	ldr	r3, [r7, #0]
 8004506:	895b      	ldrh	r3, [r3, #10]
 8004508:	4313      	orrs	r3, r2
 800450a:	b29a      	uxth	r2, r3
 800450c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800450e:	4313      	orrs	r3, r2
 8004510:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8004512:	687b      	ldr	r3, [r7, #4]
 8004514:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8004516:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8004518:	683b      	ldr	r3, [r7, #0]
 800451a:	899a      	ldrh	r2, [r3, #12]
 800451c:	683b      	ldr	r3, [r7, #0]
 800451e:	891b      	ldrh	r3, [r3, #8]
 8004520:	4313      	orrs	r3, r2
 8004522:	b29a      	uxth	r2, r3
 8004524:	687b      	ldr	r3, [r7, #4]
 8004526:	811a      	strh	r2, [r3, #8]
}
 8004528:	bf00      	nop
 800452a:	3728      	adds	r7, #40	; 0x28
 800452c:	46bd      	mov	sp, r7
 800452e:	bd80      	pop	{r7, pc}
 8004530:	007a1200 	.word	0x007a1200
 8004534:	431bde83 	.word	0x431bde83
 8004538:	000186a0 	.word	0x000186a0
 800453c:	10624dd3 	.word	0x10624dd3

08004540 <I2C_Cmd>:
  * @param  NewState: new state of the I2Cx peripheral. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8004540:	b480      	push	{r7}
 8004542:	b083      	sub	sp, #12
 8004544:	af00      	add	r7, sp, #0
 8004546:	6078      	str	r0, [r7, #4]
 8004548:	460b      	mov	r3, r1
 800454a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800454c:	78fb      	ldrb	r3, [r7, #3]
 800454e:	2b00      	cmp	r3, #0
 8004550:	d008      	beq.n	8004564 <I2C_Cmd+0x24>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= CR1_PE_Set;
 8004552:	687b      	ldr	r3, [r7, #4]
 8004554:	881b      	ldrh	r3, [r3, #0]
 8004556:	b29b      	uxth	r3, r3
 8004558:	f043 0301 	orr.w	r3, r3, #1
 800455c:	b29a      	uxth	r2, r3
 800455e:	687b      	ldr	r3, [r7, #4]
 8004560:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= CR1_PE_Reset;
  }
}
 8004562:	e007      	b.n	8004574 <I2C_Cmd+0x34>
    I2Cx->CR1 |= CR1_PE_Set;
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= CR1_PE_Reset;
 8004564:	687b      	ldr	r3, [r7, #4]
 8004566:	881b      	ldrh	r3, [r3, #0]
 8004568:	b29b      	uxth	r3, r3
 800456a:	f023 0301 	bic.w	r3, r3, #1
 800456e:	b29a      	uxth	r2, r3
 8004570:	687b      	ldr	r3, [r7, #4]
 8004572:	801a      	strh	r2, [r3, #0]
  }
}
 8004574:	bf00      	nop
 8004576:	370c      	adds	r7, #12
 8004578:	46bd      	mov	sp, r7
 800457a:	bc80      	pop	{r7}
 800457c:	4770      	bx	lr
 800457e:	bf00      	nop

08004580 <I2C_DMACmd>:
  * @param  NewState: new state of the I2C DMA transfer.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8004580:	b480      	push	{r7}
 8004582:	b083      	sub	sp, #12
 8004584:	af00      	add	r7, sp, #0
 8004586:	6078      	str	r0, [r7, #4]
 8004588:	460b      	mov	r3, r1
 800458a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800458c:	78fb      	ldrb	r3, [r7, #3]
 800458e:	2b00      	cmp	r3, #0
 8004590:	d008      	beq.n	80045a4 <I2C_DMACmd+0x24>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= CR2_DMAEN_Set;
 8004592:	687b      	ldr	r3, [r7, #4]
 8004594:	889b      	ldrh	r3, [r3, #4]
 8004596:	b29b      	uxth	r3, r3
 8004598:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800459c:	b29a      	uxth	r2, r3
 800459e:	687b      	ldr	r3, [r7, #4]
 80045a0:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= CR2_DMAEN_Reset;
  }
}
 80045a2:	e007      	b.n	80045b4 <I2C_DMACmd+0x34>
    I2Cx->CR2 |= CR2_DMAEN_Set;
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= CR2_DMAEN_Reset;
 80045a4:	687b      	ldr	r3, [r7, #4]
 80045a6:	889b      	ldrh	r3, [r3, #4]
 80045a8:	b29b      	uxth	r3, r3
 80045aa:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80045ae:	b29a      	uxth	r2, r3
 80045b0:	687b      	ldr	r3, [r7, #4]
 80045b2:	809a      	strh	r2, [r3, #4]
  }
}
 80045b4:	bf00      	nop
 80045b6:	370c      	adds	r7, #12
 80045b8:	46bd      	mov	sp, r7
 80045ba:	bc80      	pop	{r7}
 80045bc:	4770      	bx	lr
 80045be:	bf00      	nop

080045c0 <I2C_DMALastTransferCmd>:
  * @param  NewState: new state of the I2C DMA last transfer.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 80045c0:	b480      	push	{r7}
 80045c2:	b083      	sub	sp, #12
 80045c4:	af00      	add	r7, sp, #0
 80045c6:	6078      	str	r0, [r7, #4]
 80045c8:	460b      	mov	r3, r1
 80045ca:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80045cc:	78fb      	ldrb	r3, [r7, #3]
 80045ce:	2b00      	cmp	r3, #0
 80045d0:	d008      	beq.n	80045e4 <I2C_DMALastTransferCmd+0x24>
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= CR2_LAST_Set;
 80045d2:	687b      	ldr	r3, [r7, #4]
 80045d4:	889b      	ldrh	r3, [r3, #4]
 80045d6:	b29b      	uxth	r3, r3
 80045d8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80045dc:	b29a      	uxth	r2, r3
 80045de:	687b      	ldr	r3, [r7, #4]
 80045e0:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= CR2_LAST_Reset;
  }
}
 80045e2:	e007      	b.n	80045f4 <I2C_DMALastTransferCmd+0x34>
    I2Cx->CR2 |= CR2_LAST_Set;
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= CR2_LAST_Reset;
 80045e4:	687b      	ldr	r3, [r7, #4]
 80045e6:	889b      	ldrh	r3, [r3, #4]
 80045e8:	b29b      	uxth	r3, r3
 80045ea:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80045ee:	b29a      	uxth	r2, r3
 80045f0:	687b      	ldr	r3, [r7, #4]
 80045f2:	809a      	strh	r2, [r3, #4]
  }
}
 80045f4:	bf00      	nop
 80045f6:	370c      	adds	r7, #12
 80045f8:	46bd      	mov	sp, r7
 80045fa:	bc80      	pop	{r7}
 80045fc:	4770      	bx	lr
 80045fe:	bf00      	nop

08004600 <I2C_GenerateSTART>:
  * @param  NewState: new state of the I2C START condition generation.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8004600:	b480      	push	{r7}
 8004602:	b083      	sub	sp, #12
 8004604:	af00      	add	r7, sp, #0
 8004606:	6078      	str	r0, [r7, #4]
 8004608:	460b      	mov	r3, r1
 800460a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800460c:	78fb      	ldrb	r3, [r7, #3]
 800460e:	2b00      	cmp	r3, #0
 8004610:	d008      	beq.n	8004624 <I2C_GenerateSTART+0x24>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8004612:	687b      	ldr	r3, [r7, #4]
 8004614:	881b      	ldrh	r3, [r3, #0]
 8004616:	b29b      	uxth	r3, r3
 8004618:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800461c:	b29a      	uxth	r2, r3
 800461e:	687b      	ldr	r3, [r7, #4]
 8004620:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
  }
}
 8004622:	e007      	b.n	8004634 <I2C_GenerateSTART+0x34>
    I2Cx->CR1 |= CR1_START_Set;
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 8004624:	687b      	ldr	r3, [r7, #4]
 8004626:	881b      	ldrh	r3, [r3, #0]
 8004628:	b29b      	uxth	r3, r3
 800462a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800462e:	b29a      	uxth	r2, r3
 8004630:	687b      	ldr	r3, [r7, #4]
 8004632:	801a      	strh	r2, [r3, #0]
  }
}
 8004634:	bf00      	nop
 8004636:	370c      	adds	r7, #12
 8004638:	46bd      	mov	sp, r7
 800463a:	bc80      	pop	{r7}
 800463c:	4770      	bx	lr
 800463e:	bf00      	nop

08004640 <I2C_GenerateSTOP>:
  * @param  NewState: new state of the I2C STOP condition generation.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8004640:	b480      	push	{r7}
 8004642:	b083      	sub	sp, #12
 8004644:	af00      	add	r7, sp, #0
 8004646:	6078      	str	r0, [r7, #4]
 8004648:	460b      	mov	r3, r1
 800464a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800464c:	78fb      	ldrb	r3, [r7, #3]
 800464e:	2b00      	cmp	r3, #0
 8004650:	d008      	beq.n	8004664 <I2C_GenerateSTOP+0x24>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8004652:	687b      	ldr	r3, [r7, #4]
 8004654:	881b      	ldrh	r3, [r3, #0]
 8004656:	b29b      	uxth	r3, r3
 8004658:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800465c:	b29a      	uxth	r2, r3
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
  }
}
 8004662:	e007      	b.n	8004674 <I2C_GenerateSTOP+0x34>
    I2Cx->CR1 |= CR1_STOP_Set;
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 8004664:	687b      	ldr	r3, [r7, #4]
 8004666:	881b      	ldrh	r3, [r3, #0]
 8004668:	b29b      	uxth	r3, r3
 800466a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800466e:	b29a      	uxth	r2, r3
 8004670:	687b      	ldr	r3, [r7, #4]
 8004672:	801a      	strh	r2, [r3, #0]
  }
}
 8004674:	bf00      	nop
 8004676:	370c      	adds	r7, #12
 8004678:	46bd      	mov	sp, r7
 800467a:	bc80      	pop	{r7}
 800467c:	4770      	bx	lr
 800467e:	bf00      	nop

08004680 <I2C_AcknowledgeConfig>:
  * @param  NewState: new state of the I2C Acknowledgement.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8004680:	b480      	push	{r7}
 8004682:	b083      	sub	sp, #12
 8004684:	af00      	add	r7, sp, #0
 8004686:	6078      	str	r0, [r7, #4]
 8004688:	460b      	mov	r3, r1
 800468a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800468c:	78fb      	ldrb	r3, [r7, #3]
 800468e:	2b00      	cmp	r3, #0
 8004690:	d008      	beq.n	80046a4 <I2C_AcknowledgeConfig+0x24>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8004692:	687b      	ldr	r3, [r7, #4]
 8004694:	881b      	ldrh	r3, [r3, #0]
 8004696:	b29b      	uxth	r3, r3
 8004698:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800469c:	b29a      	uxth	r2, r3
 800469e:	687b      	ldr	r3, [r7, #4]
 80046a0:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
  }
}
 80046a2:	e007      	b.n	80046b4 <I2C_AcknowledgeConfig+0x34>
    I2Cx->CR1 |= CR1_ACK_Set;
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 80046a4:	687b      	ldr	r3, [r7, #4]
 80046a6:	881b      	ldrh	r3, [r3, #0]
 80046a8:	b29b      	uxth	r3, r3
 80046aa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80046ae:	b29a      	uxth	r2, r3
 80046b0:	687b      	ldr	r3, [r7, #4]
 80046b2:	801a      	strh	r2, [r3, #0]
  }
}
 80046b4:	bf00      	nop
 80046b6:	370c      	adds	r7, #12
 80046b8:	46bd      	mov	sp, r7
 80046ba:	bc80      	pop	{r7}
 80046bc:	4770      	bx	lr
 80046be:	bf00      	nop

080046c0 <I2C_SendData>:
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @param  Data: Byte to be transmitted..
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
 80046c0:	b480      	push	{r7}
 80046c2:	b083      	sub	sp, #12
 80046c4:	af00      	add	r7, sp, #0
 80046c6:	6078      	str	r0, [r7, #4]
 80046c8:	460b      	mov	r3, r1
 80046ca:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 80046cc:	78fb      	ldrb	r3, [r7, #3]
 80046ce:	b29a      	uxth	r2, r3
 80046d0:	687b      	ldr	r3, [r7, #4]
 80046d2:	821a      	strh	r2, [r3, #16]
}
 80046d4:	bf00      	nop
 80046d6:	370c      	adds	r7, #12
 80046d8:	46bd      	mov	sp, r7
 80046da:	bc80      	pop	{r7}
 80046dc:	4770      	bx	lr
 80046de:	bf00      	nop

080046e0 <I2C_ReceiveData>:
  * @brief  Returns the most recent received data by the I2Cx peripheral.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
 80046e0:	b480      	push	{r7}
 80046e2:	b083      	sub	sp, #12
 80046e4:	af00      	add	r7, sp, #0
 80046e6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 80046e8:	687b      	ldr	r3, [r7, #4]
 80046ea:	8a1b      	ldrh	r3, [r3, #16]
 80046ec:	b29b      	uxth	r3, r3
 80046ee:	b2db      	uxtb	r3, r3
}
 80046f0:	4618      	mov	r0, r3
 80046f2:	370c      	adds	r7, #12
 80046f4:	46bd      	mov	sp, r7
 80046f6:	bc80      	pop	{r7}
 80046f8:	4770      	bx	lr
 80046fa:	bf00      	nop

080046fc <I2C_Send7bitAddress>:
  *     @arg I2C_Direction_Transmitter: Transmitter mode
  *     @arg I2C_Direction_Receiver: Receiver mode
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
 80046fc:	b480      	push	{r7}
 80046fe:	b083      	sub	sp, #12
 8004700:	af00      	add	r7, sp, #0
 8004702:	6078      	str	r0, [r7, #4]
 8004704:	460b      	mov	r3, r1
 8004706:	70fb      	strb	r3, [r7, #3]
 8004708:	4613      	mov	r3, r2
 800470a:	70bb      	strb	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 800470c:	78bb      	ldrb	r3, [r7, #2]
 800470e:	2b00      	cmp	r3, #0
 8004710:	d004      	beq.n	800471c <I2C_Send7bitAddress+0x20>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 8004712:	78fb      	ldrb	r3, [r7, #3]
 8004714:	f043 0301 	orr.w	r3, r3, #1
 8004718:	70fb      	strb	r3, [r7, #3]
 800471a:	e003      	b.n	8004724 <I2C_Send7bitAddress+0x28>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 800471c:	78fb      	ldrb	r3, [r7, #3]
 800471e:	f023 0301 	bic.w	r3, r3, #1
 8004722:	70fb      	strb	r3, [r7, #3]
  }
  /* Send the address */
  I2Cx->DR = Address;
 8004724:	78fb      	ldrb	r3, [r7, #3]
 8004726:	b29a      	uxth	r2, r3
 8004728:	687b      	ldr	r3, [r7, #4]
 800472a:	821a      	strh	r2, [r3, #16]
}
 800472c:	bf00      	nop
 800472e:	370c      	adds	r7, #12
 8004730:	46bd      	mov	sp, r7
 8004732:	bc80      	pop	{r7}
 8004734:	4770      	bx	lr
 8004736:	bf00      	nop

08004738 <I2C_CheckEvent>:
  * @retval An ErrorStatus enumeration value:
  * - SUCCESS: Last event is equal to the I2C_EVENT
  * - ERROR: Last event is different from the I2C_EVENT
  */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
 8004738:	b480      	push	{r7}
 800473a:	b087      	sub	sp, #28
 800473c:	af00      	add	r7, sp, #0
 800473e:	6078      	str	r0, [r7, #4]
 8004740:	6039      	str	r1, [r7, #0]
  uint32_t lastevent = 0;
 8004742:	2300      	movs	r3, #0
 8004744:	613b      	str	r3, [r7, #16]
  uint32_t flag1 = 0, flag2 = 0;
 8004746:	2300      	movs	r3, #0
 8004748:	60fb      	str	r3, [r7, #12]
 800474a:	2300      	movs	r3, #0
 800474c:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 800474e:	2300      	movs	r3, #0
 8004750:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8004752:	687b      	ldr	r3, [r7, #4]
 8004754:	8a9b      	ldrh	r3, [r3, #20]
 8004756:	b29b      	uxth	r3, r3
 8004758:	60fb      	str	r3, [r7, #12]
  flag2 = I2Cx->SR2;
 800475a:	687b      	ldr	r3, [r7, #4]
 800475c:	8b1b      	ldrh	r3, [r3, #24]
 800475e:	b29b      	uxth	r3, r3
 8004760:	60bb      	str	r3, [r7, #8]
  flag2 = flag2 << 16;
 8004762:	68bb      	ldr	r3, [r7, #8]
 8004764:	041b      	lsls	r3, r3, #16
 8004766:	60bb      	str	r3, [r7, #8]

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8004768:	68fa      	ldr	r2, [r7, #12]
 800476a:	68bb      	ldr	r3, [r7, #8]
 800476c:	4313      	orrs	r3, r2
 800476e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004772:	613b      	str	r3, [r7, #16]

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 8004774:	693a      	ldr	r2, [r7, #16]
 8004776:	683b      	ldr	r3, [r7, #0]
 8004778:	401a      	ands	r2, r3
 800477a:	683b      	ldr	r3, [r7, #0]
 800477c:	429a      	cmp	r2, r3
 800477e:	d102      	bne.n	8004786 <I2C_CheckEvent+0x4e>
  {
    /* SUCCESS: last event is equal to I2C_EVENT */
    status = SUCCESS;
 8004780:	2301      	movs	r3, #1
 8004782:	75fb      	strb	r3, [r7, #23]
 8004784:	e001      	b.n	800478a <I2C_CheckEvent+0x52>
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
 8004786:	2300      	movs	r3, #0
 8004788:	75fb      	strb	r3, [r7, #23]
  }
  /* Return status */
  return status;
 800478a:	7dfb      	ldrb	r3, [r7, #23]
}
 800478c:	4618      	mov	r0, r3
 800478e:	371c      	adds	r7, #28
 8004790:	46bd      	mov	sp, r7
 8004792:	bc80      	pop	{r7}
 8004794:	4770      	bx	lr
 8004796:	bf00      	nop

08004798 <I2C_GetFlagStatus>:
  *   Address matched flag (Slave mode)"ENDA"
  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 8004798:	b480      	push	{r7}
 800479a:	b087      	sub	sp, #28
 800479c:	af00      	add	r7, sp, #0
 800479e:	6078      	str	r0, [r7, #4]
 80047a0:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 80047a2:	2300      	movs	r3, #0
 80047a4:	75fb      	strb	r3, [r7, #23]
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 80047a6:	2300      	movs	r3, #0
 80047a8:	613b      	str	r3, [r7, #16]
 80047aa:	2300      	movs	r3, #0
 80047ac:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 80047ae:	687b      	ldr	r3, [r7, #4]
 80047b0:	60fb      	str	r3, [r7, #12]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 80047b2:	683b      	ldr	r3, [r7, #0]
 80047b4:	0f1b      	lsrs	r3, r3, #28
 80047b6:	613b      	str	r3, [r7, #16]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_Mask;
 80047b8:	683b      	ldr	r3, [r7, #0]
 80047ba:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80047be:	603b      	str	r3, [r7, #0]
  
  if(i2creg != 0)
 80047c0:	693b      	ldr	r3, [r7, #16]
 80047c2:	2b00      	cmp	r3, #0
 80047c4:	d003      	beq.n	80047ce <I2C_GetFlagStatus+0x36>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 80047c6:	68fb      	ldr	r3, [r7, #12]
 80047c8:	3314      	adds	r3, #20
 80047ca:	60fb      	str	r3, [r7, #12]
 80047cc:	e005      	b.n	80047da <I2C_GetFlagStatus+0x42>
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 80047ce:	683b      	ldr	r3, [r7, #0]
 80047d0:	0c1b      	lsrs	r3, r3, #16
 80047d2:	603b      	str	r3, [r7, #0]
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 80047d4:	68fb      	ldr	r3, [r7, #12]
 80047d6:	3318      	adds	r3, #24
 80047d8:	60fb      	str	r3, [r7, #12]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 80047da:	68fb      	ldr	r3, [r7, #12]
 80047dc:	681a      	ldr	r2, [r3, #0]
 80047de:	683b      	ldr	r3, [r7, #0]
 80047e0:	4013      	ands	r3, r2
 80047e2:	2b00      	cmp	r3, #0
 80047e4:	d002      	beq.n	80047ec <I2C_GetFlagStatus+0x54>
  {
    /* I2C_FLAG is set */
    bitstatus = SET;
 80047e6:	2301      	movs	r3, #1
 80047e8:	75fb      	strb	r3, [r7, #23]
 80047ea:	e001      	b.n	80047f0 <I2C_GetFlagStatus+0x58>
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
 80047ec:	2300      	movs	r3, #0
 80047ee:	75fb      	strb	r3, [r7, #23]
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
 80047f0:	7dfb      	ldrb	r3, [r7, #23]
}
 80047f2:	4618      	mov	r0, r3
 80047f4:	371c      	adds	r7, #28
 80047f6:	46bd      	mov	sp, r7
 80047f8:	bc80      	pop	{r7}
 80047fa:	4770      	bx	lr

080047fc <I2C_ClearFlag>:
  *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
  *     register  (I2C_SendData()).
  * @retval None
  */
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 80047fc:	b480      	push	{r7}
 80047fe:	b085      	sub	sp, #20
 8004800:	af00      	add	r7, sp, #0
 8004802:	6078      	str	r0, [r7, #4]
 8004804:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 8004806:	2300      	movs	r3, #0
 8004808:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_Mask;
 800480a:	683b      	ldr	r3, [r7, #0]
 800480c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004810:	60fb      	str	r3, [r7, #12]
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8004812:	68fb      	ldr	r3, [r7, #12]
 8004814:	b29b      	uxth	r3, r3
 8004816:	43db      	mvns	r3, r3
 8004818:	b29a      	uxth	r2, r3
 800481a:	687b      	ldr	r3, [r7, #4]
 800481c:	829a      	strh	r2, [r3, #20]
}
 800481e:	bf00      	nop
 8004820:	3714      	adds	r7, #20
 8004822:	46bd      	mov	sp, r7
 8004824:	bc80      	pop	{r7}
 8004826:	4770      	bx	lr

08004828 <PWR_BackupAccessCmd>:
  * @param  NewState: new state of the access to the RTC and backup registers.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
 8004828:	b480      	push	{r7}
 800482a:	b083      	sub	sp, #12
 800482c:	af00      	add	r7, sp, #0
 800482e:	4603      	mov	r3, r0
 8004830:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8004832:	4a04      	ldr	r2, [pc, #16]	; (8004844 <PWR_BackupAccessCmd+0x1c>)
 8004834:	79fb      	ldrb	r3, [r7, #7]
 8004836:	6013      	str	r3, [r2, #0]
}
 8004838:	bf00      	nop
 800483a:	370c      	adds	r7, #12
 800483c:	46bd      	mov	sp, r7
 800483e:	bc80      	pop	{r7}
 8004840:	4770      	bx	lr
 8004842:	bf00      	nop
 8004844:	420e0020 	.word	0x420e0020

08004848 <PWR_PVDCmd>:
  * @param  NewState: new state of the PVD.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_PVDCmd(FunctionalState NewState)
{
 8004848:	b480      	push	{r7}
 800484a:	b083      	sub	sp, #12
 800484c:	af00      	add	r7, sp, #0
 800484e:	4603      	mov	r3, r0
 8004850:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 8004852:	4a04      	ldr	r2, [pc, #16]	; (8004864 <PWR_PVDCmd+0x1c>)
 8004854:	79fb      	ldrb	r3, [r7, #7]
 8004856:	6013      	str	r3, [r2, #0]
}
 8004858:	bf00      	nop
 800485a:	370c      	adds	r7, #12
 800485c:	46bd      	mov	sp, r7
 800485e:	bc80      	pop	{r7}
 8004860:	4770      	bx	lr
 8004862:	bf00      	nop
 8004864:	420e0010 	.word	0x420e0010

08004868 <PWR_PVDLevelConfig>:
  *     @arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V
  *     @arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V
  * @retval None
  */
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
{
 8004868:	b480      	push	{r7}
 800486a:	b085      	sub	sp, #20
 800486c:	af00      	add	r7, sp, #0
 800486e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8004870:	2300      	movs	r3, #0
 8004872:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  tmpreg = PWR->CR;
 8004874:	4b09      	ldr	r3, [pc, #36]	; (800489c <PWR_PVDLevelConfig+0x34>)
 8004876:	681b      	ldr	r3, [r3, #0]
 8004878:	60fb      	str	r3, [r7, #12]
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 800487a:	68fb      	ldr	r3, [r7, #12]
 800487c:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 8004880:	60fb      	str	r3, [r7, #12]
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 8004882:	68fa      	ldr	r2, [r7, #12]
 8004884:	687b      	ldr	r3, [r7, #4]
 8004886:	4313      	orrs	r3, r2
 8004888:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  PWR->CR = tmpreg;
 800488a:	4a04      	ldr	r2, [pc, #16]	; (800489c <PWR_PVDLevelConfig+0x34>)
 800488c:	68fb      	ldr	r3, [r7, #12]
 800488e:	6013      	str	r3, [r2, #0]
}
 8004890:	bf00      	nop
 8004892:	3714      	adds	r7, #20
 8004894:	46bd      	mov	sp, r7
 8004896:	bc80      	pop	{r7}
 8004898:	4770      	bx	lr
 800489a:	bf00      	nop
 800489c:	40007000 	.word	0x40007000

080048a0 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80048a0:	b580      	push	{r7, lr}
 80048a2:	b082      	sub	sp, #8
 80048a4:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0;
 80048a6:	2300      	movs	r3, #0
 80048a8:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 80048aa:	2300      	movs	r3, #0
 80048ac:	71fb      	strb	r3, [r7, #7]
  FlagStatus HSEStatus = RESET;
 80048ae:	2300      	movs	r3, #0
 80048b0:	71bb      	strb	r3, [r7, #6]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80048b2:	2031      	movs	r0, #49	; 0x31
 80048b4:	f000 fa24 	bl	8004d00 <RCC_GetFlagStatus>
 80048b8:	4603      	mov	r3, r0
 80048ba:	71bb      	strb	r3, [r7, #6]
    StartUpCounter++;  
 80048bc:	683b      	ldr	r3, [r7, #0]
 80048be:	3301      	adds	r3, #1
 80048c0:	603b      	str	r3, [r7, #0]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80048c2:	683b      	ldr	r3, [r7, #0]
 80048c4:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80048c8:	d002      	beq.n	80048d0 <RCC_WaitForHSEStartUp+0x30>
 80048ca:	79bb      	ldrb	r3, [r7, #6]
 80048cc:	2b00      	cmp	r3, #0
 80048ce:	d0f0      	beq.n	80048b2 <RCC_WaitForHSEStartUp+0x12>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 80048d0:	2031      	movs	r0, #49	; 0x31
 80048d2:	f000 fa15 	bl	8004d00 <RCC_GetFlagStatus>
 80048d6:	4603      	mov	r3, r0
 80048d8:	2b00      	cmp	r3, #0
 80048da:	d002      	beq.n	80048e2 <RCC_WaitForHSEStartUp+0x42>
  {
    status = SUCCESS;
 80048dc:	2301      	movs	r3, #1
 80048de:	71fb      	strb	r3, [r7, #7]
 80048e0:	e001      	b.n	80048e6 <RCC_WaitForHSEStartUp+0x46>
  }
  else
  {
    status = ERROR;
 80048e2:	2300      	movs	r3, #0
 80048e4:	71fb      	strb	r3, [r7, #7]
  }  
  return (status);
 80048e6:	79fb      	ldrb	r3, [r7, #7]
}
 80048e8:	4618      	mov	r0, r3
 80048ea:	3708      	adds	r7, #8
 80048ec:	46bd      	mov	sp, r7
 80048ee:	bd80      	pop	{r7, pc}

080048f0 <RCC_PLLConfig>:
  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 80048f0:	b480      	push	{r7}
 80048f2:	b085      	sub	sp, #20
 80048f4:	af00      	add	r7, sp, #0
 80048f6:	6078      	str	r0, [r7, #4]
 80048f8:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 80048fa:	2300      	movs	r3, #0
 80048fc:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 80048fe:	4b0a      	ldr	r3, [pc, #40]	; (8004928 <RCC_PLLConfig+0x38>)
 8004900:	685b      	ldr	r3, [r3, #4]
 8004902:	60fb      	str	r3, [r7, #12]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8004904:	68fb      	ldr	r3, [r7, #12]
 8004906:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 800490a:	60fb      	str	r3, [r7, #12]
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 800490c:	687a      	ldr	r2, [r7, #4]
 800490e:	683b      	ldr	r3, [r7, #0]
 8004910:	4313      	orrs	r3, r2
 8004912:	68fa      	ldr	r2, [r7, #12]
 8004914:	4313      	orrs	r3, r2
 8004916:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8004918:	4a03      	ldr	r2, [pc, #12]	; (8004928 <RCC_PLLConfig+0x38>)
 800491a:	68fb      	ldr	r3, [r7, #12]
 800491c:	6053      	str	r3, [r2, #4]
}
 800491e:	bf00      	nop
 8004920:	3714      	adds	r7, #20
 8004922:	46bd      	mov	sp, r7
 8004924:	bc80      	pop	{r7}
 8004926:	4770      	bx	lr
 8004928:	40021000 	.word	0x40021000

0800492c <RCC_PLLCmd>:
  * @note   The PLL can not be disabled if it is used as system clock.
  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 800492c:	b480      	push	{r7}
 800492e:	b083      	sub	sp, #12
 8004930:	af00      	add	r7, sp, #0
 8004932:	4603      	mov	r3, r0
 8004934:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8004936:	4a04      	ldr	r2, [pc, #16]	; (8004948 <RCC_PLLCmd+0x1c>)
 8004938:	79fb      	ldrb	r3, [r7, #7]
 800493a:	6013      	str	r3, [r2, #0]
}
 800493c:	bf00      	nop
 800493e:	370c      	adds	r7, #12
 8004940:	46bd      	mov	sp, r7
 8004942:	bc80      	pop	{r7}
 8004944:	4770      	bx	lr
 8004946:	bf00      	nop
 8004948:	42420060 	.word	0x42420060

0800494c <RCC_SYSCLKConfig>:
  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 800494c:	b480      	push	{r7}
 800494e:	b085      	sub	sp, #20
 8004950:	af00      	add	r7, sp, #0
 8004952:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8004954:	2300      	movs	r3, #0
 8004956:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8004958:	4b09      	ldr	r3, [pc, #36]	; (8004980 <RCC_SYSCLKConfig+0x34>)
 800495a:	685b      	ldr	r3, [r3, #4]
 800495c:	60fb      	str	r3, [r7, #12]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 800495e:	68fb      	ldr	r3, [r7, #12]
 8004960:	f023 0303 	bic.w	r3, r3, #3
 8004964:	60fb      	str	r3, [r7, #12]
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8004966:	68fa      	ldr	r2, [r7, #12]
 8004968:	687b      	ldr	r3, [r7, #4]
 800496a:	4313      	orrs	r3, r2
 800496c:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800496e:	4a04      	ldr	r2, [pc, #16]	; (8004980 <RCC_SYSCLKConfig+0x34>)
 8004970:	68fb      	ldr	r3, [r7, #12]
 8004972:	6053      	str	r3, [r2, #4]
}
 8004974:	bf00      	nop
 8004976:	3714      	adds	r7, #20
 8004978:	46bd      	mov	sp, r7
 800497a:	bc80      	pop	{r7}
 800497c:	4770      	bx	lr
 800497e:	bf00      	nop
 8004980:	40021000 	.word	0x40021000

08004984 <RCC_GetSYSCLKSource>:
  *     - 0x00: HSI used as system clock
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 8004984:	b480      	push	{r7}
 8004986:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8004988:	4b04      	ldr	r3, [pc, #16]	; (800499c <RCC_GetSYSCLKSource+0x18>)
 800498a:	685b      	ldr	r3, [r3, #4]
 800498c:	b2db      	uxtb	r3, r3
 800498e:	f003 030c 	and.w	r3, r3, #12
 8004992:	b2db      	uxtb	r3, r3
}
 8004994:	4618      	mov	r0, r3
 8004996:	46bd      	mov	sp, r7
 8004998:	bc80      	pop	{r7}
 800499a:	4770      	bx	lr
 800499c:	40021000 	.word	0x40021000

080049a0 <RCC_HCLKConfig>:
  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 80049a0:	b480      	push	{r7}
 80049a2:	b085      	sub	sp, #20
 80049a4:	af00      	add	r7, sp, #0
 80049a6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80049a8:	2300      	movs	r3, #0
 80049aa:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 80049ac:	4b09      	ldr	r3, [pc, #36]	; (80049d4 <RCC_HCLKConfig+0x34>)
 80049ae:	685b      	ldr	r3, [r3, #4]
 80049b0:	60fb      	str	r3, [r7, #12]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 80049b2:	68fb      	ldr	r3, [r7, #12]
 80049b4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80049b8:	60fb      	str	r3, [r7, #12]
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80049ba:	68fa      	ldr	r2, [r7, #12]
 80049bc:	687b      	ldr	r3, [r7, #4]
 80049be:	4313      	orrs	r3, r2
 80049c0:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80049c2:	4a04      	ldr	r2, [pc, #16]	; (80049d4 <RCC_HCLKConfig+0x34>)
 80049c4:	68fb      	ldr	r3, [r7, #12]
 80049c6:	6053      	str	r3, [r2, #4]
}
 80049c8:	bf00      	nop
 80049ca:	3714      	adds	r7, #20
 80049cc:	46bd      	mov	sp, r7
 80049ce:	bc80      	pop	{r7}
 80049d0:	4770      	bx	lr
 80049d2:	bf00      	nop
 80049d4:	40021000 	.word	0x40021000

080049d8 <RCC_PCLK1Config>:
  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 80049d8:	b480      	push	{r7}
 80049da:	b085      	sub	sp, #20
 80049dc:	af00      	add	r7, sp, #0
 80049de:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80049e0:	2300      	movs	r3, #0
 80049e2:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80049e4:	4b09      	ldr	r3, [pc, #36]	; (8004a0c <RCC_PCLK1Config+0x34>)
 80049e6:	685b      	ldr	r3, [r3, #4]
 80049e8:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 80049ea:	68fb      	ldr	r3, [r7, #12]
 80049ec:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80049f0:	60fb      	str	r3, [r7, #12]
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80049f2:	68fa      	ldr	r2, [r7, #12]
 80049f4:	687b      	ldr	r3, [r7, #4]
 80049f6:	4313      	orrs	r3, r2
 80049f8:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80049fa:	4a04      	ldr	r2, [pc, #16]	; (8004a0c <RCC_PCLK1Config+0x34>)
 80049fc:	68fb      	ldr	r3, [r7, #12]
 80049fe:	6053      	str	r3, [r2, #4]
}
 8004a00:	bf00      	nop
 8004a02:	3714      	adds	r7, #20
 8004a04:	46bd      	mov	sp, r7
 8004a06:	bc80      	pop	{r7}
 8004a08:	4770      	bx	lr
 8004a0a:	bf00      	nop
 8004a0c:	40021000 	.word	0x40021000

08004a10 <RCC_PCLK2Config>:
  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 8004a10:	b480      	push	{r7}
 8004a12:	b085      	sub	sp, #20
 8004a14:	af00      	add	r7, sp, #0
 8004a16:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8004a18:	2300      	movs	r3, #0
 8004a1a:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8004a1c:	4b09      	ldr	r3, [pc, #36]	; (8004a44 <RCC_PCLK2Config+0x34>)
 8004a1e:	685b      	ldr	r3, [r3, #4]
 8004a20:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 8004a22:	68fb      	ldr	r3, [r7, #12]
 8004a24:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8004a28:	60fb      	str	r3, [r7, #12]
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8004a2a:	687b      	ldr	r3, [r7, #4]
 8004a2c:	00db      	lsls	r3, r3, #3
 8004a2e:	68fa      	ldr	r2, [r7, #12]
 8004a30:	4313      	orrs	r3, r2
 8004a32:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8004a34:	4a03      	ldr	r2, [pc, #12]	; (8004a44 <RCC_PCLK2Config+0x34>)
 8004a36:	68fb      	ldr	r3, [r7, #12]
 8004a38:	6053      	str	r3, [r2, #4]
}
 8004a3a:	bf00      	nop
 8004a3c:	3714      	adds	r7, #20
 8004a3e:	46bd      	mov	sp, r7
 8004a40:	bc80      	pop	{r7}
 8004a42:	4770      	bx	lr
 8004a44:	40021000 	.word	0x40021000

08004a48 <RCC_LSEConfig>:
  *     @arg RCC_LSE_ON: LSE oscillator ON
  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
 8004a48:	b480      	push	{r7}
 8004a4a:	b083      	sub	sp, #12
 8004a4c:	af00      	add	r7, sp, #0
 8004a4e:	4603      	mov	r3, r0
 8004a50:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8004a52:	4b0c      	ldr	r3, [pc, #48]	; (8004a84 <RCC_LSEConfig+0x3c>)
 8004a54:	2200      	movs	r2, #0
 8004a56:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8004a58:	4b0a      	ldr	r3, [pc, #40]	; (8004a84 <RCC_LSEConfig+0x3c>)
 8004a5a:	2200      	movs	r2, #0
 8004a5c:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8004a5e:	79fb      	ldrb	r3, [r7, #7]
 8004a60:	2b01      	cmp	r3, #1
 8004a62:	d002      	beq.n	8004a6a <RCC_LSEConfig+0x22>
 8004a64:	2b04      	cmp	r3, #4
 8004a66:	d004      	beq.n	8004a72 <RCC_LSEConfig+0x2a>
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
      break;            
      
    default:
      break;      
 8004a68:	e007      	b.n	8004a7a <RCC_LSEConfig+0x32>
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8004a6a:	4b06      	ldr	r3, [pc, #24]	; (8004a84 <RCC_LSEConfig+0x3c>)
 8004a6c:	2201      	movs	r2, #1
 8004a6e:	701a      	strb	r2, [r3, #0]
      break;
 8004a70:	e003      	b.n	8004a7a <RCC_LSEConfig+0x32>
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8004a72:	4b04      	ldr	r3, [pc, #16]	; (8004a84 <RCC_LSEConfig+0x3c>)
 8004a74:	2205      	movs	r2, #5
 8004a76:	701a      	strb	r2, [r3, #0]
      break;            
 8004a78:	bf00      	nop
      
    default:
      break;      
  }
}
 8004a7a:	bf00      	nop
 8004a7c:	370c      	adds	r7, #12
 8004a7e:	46bd      	mov	sp, r7
 8004a80:	bc80      	pop	{r7}
 8004a82:	4770      	bx	lr
 8004a84:	40021020 	.word	0x40021020

08004a88 <RCC_RTCCLKConfig>:
  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
 8004a88:	b480      	push	{r7}
 8004a8a:	b083      	sub	sp, #12
 8004a8c:	af00      	add	r7, sp, #0
 8004a8e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8004a90:	4905      	ldr	r1, [pc, #20]	; (8004aa8 <RCC_RTCCLKConfig+0x20>)
 8004a92:	4b05      	ldr	r3, [pc, #20]	; (8004aa8 <RCC_RTCCLKConfig+0x20>)
 8004a94:	6a1a      	ldr	r2, [r3, #32]
 8004a96:	687b      	ldr	r3, [r7, #4]
 8004a98:	4313      	orrs	r3, r2
 8004a9a:	620b      	str	r3, [r1, #32]
}
 8004a9c:	bf00      	nop
 8004a9e:	370c      	adds	r7, #12
 8004aa0:	46bd      	mov	sp, r7
 8004aa2:	bc80      	pop	{r7}
 8004aa4:	4770      	bx	lr
 8004aa6:	bf00      	nop
 8004aa8:	40021000 	.word	0x40021000

08004aac <RCC_RTCCLKCmd>:
  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
 8004aac:	b480      	push	{r7}
 8004aae:	b083      	sub	sp, #12
 8004ab0:	af00      	add	r7, sp, #0
 8004ab2:	4603      	mov	r3, r0
 8004ab4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8004ab6:	4a04      	ldr	r2, [pc, #16]	; (8004ac8 <RCC_RTCCLKCmd+0x1c>)
 8004ab8:	79fb      	ldrb	r3, [r7, #7]
 8004aba:	6013      	str	r3, [r2, #0]
}
 8004abc:	bf00      	nop
 8004abe:	370c      	adds	r7, #12
 8004ac0:	46bd      	mov	sp, r7
 8004ac2:	bc80      	pop	{r7}
 8004ac4:	4770      	bx	lr
 8004ac6:	bf00      	nop
 8004ac8:	4242043c 	.word	0x4242043c

08004acc <RCC_GetClocksFreq>:
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8004acc:	b480      	push	{r7}
 8004ace:	b087      	sub	sp, #28
 8004ad0:	af00      	add	r7, sp, #0
 8004ad2:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
 8004ad4:	2300      	movs	r3, #0
 8004ad6:	617b      	str	r3, [r7, #20]
 8004ad8:	2300      	movs	r3, #0
 8004ada:	613b      	str	r3, [r7, #16]
 8004adc:	2300      	movs	r3, #0
 8004ade:	60fb      	str	r3, [r7, #12]
 8004ae0:	2300      	movs	r3, #0
 8004ae2:	60bb      	str	r3, [r7, #8]
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8004ae4:	4b4c      	ldr	r3, [pc, #304]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004ae6:	685b      	ldr	r3, [r3, #4]
 8004ae8:	f003 030c 	and.w	r3, r3, #12
 8004aec:	617b      	str	r3, [r7, #20]
  
  switch (tmp)
 8004aee:	697b      	ldr	r3, [r7, #20]
 8004af0:	2b04      	cmp	r3, #4
 8004af2:	d007      	beq.n	8004b04 <RCC_GetClocksFreq+0x38>
 8004af4:	2b08      	cmp	r3, #8
 8004af6:	d009      	beq.n	8004b0c <RCC_GetClocksFreq+0x40>
 8004af8:	2b00      	cmp	r3, #0
 8004afa:	d133      	bne.n	8004b64 <RCC_GetClocksFreq+0x98>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8004afc:	687b      	ldr	r3, [r7, #4]
 8004afe:	4a47      	ldr	r2, [pc, #284]	; (8004c1c <RCC_GetClocksFreq+0x150>)
 8004b00:	601a      	str	r2, [r3, #0]
      break;
 8004b02:	e033      	b.n	8004b6c <RCC_GetClocksFreq+0xa0>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8004b04:	687b      	ldr	r3, [r7, #4]
 8004b06:	4a45      	ldr	r2, [pc, #276]	; (8004c1c <RCC_GetClocksFreq+0x150>)
 8004b08:	601a      	str	r2, [r3, #0]
      break;
 8004b0a:	e02f      	b.n	8004b6c <RCC_GetClocksFreq+0xa0>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8004b0c:	4b42      	ldr	r3, [pc, #264]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004b0e:	685b      	ldr	r3, [r3, #4]
 8004b10:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8004b14:	613b      	str	r3, [r7, #16]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8004b16:	4b40      	ldr	r3, [pc, #256]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004b18:	685b      	ldr	r3, [r3, #4]
 8004b1a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004b1e:	60fb      	str	r3, [r7, #12]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8004b20:	693b      	ldr	r3, [r7, #16]
 8004b22:	0c9b      	lsrs	r3, r3, #18
 8004b24:	3302      	adds	r3, #2
 8004b26:	613b      	str	r3, [r7, #16]
      
      if (pllsource == 0x00)
 8004b28:	68fb      	ldr	r3, [r7, #12]
 8004b2a:	2b00      	cmp	r3, #0
 8004b2c:	d106      	bne.n	8004b3c <RCC_GetClocksFreq+0x70>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
 8004b2e:	693b      	ldr	r3, [r7, #16]
 8004b30:	4a3b      	ldr	r2, [pc, #236]	; (8004c20 <RCC_GetClocksFreq+0x154>)
 8004b32:	fb02 f203 	mul.w	r2, r2, r3
 8004b36:	687b      	ldr	r3, [r7, #4]
 8004b38:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8004b3a:	e017      	b.n	8004b6c <RCC_GetClocksFreq+0xa0>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8004b3c:	4b36      	ldr	r3, [pc, #216]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004b3e:	685b      	ldr	r3, [r3, #4]
 8004b40:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004b44:	2b00      	cmp	r3, #0
 8004b46:	d006      	beq.n	8004b56 <RCC_GetClocksFreq+0x8a>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 8004b48:	693b      	ldr	r3, [r7, #16]
 8004b4a:	4a35      	ldr	r2, [pc, #212]	; (8004c20 <RCC_GetClocksFreq+0x154>)
 8004b4c:	fb02 f203 	mul.w	r2, r2, r3
 8004b50:	687b      	ldr	r3, [r7, #4]
 8004b52:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8004b54:	e00a      	b.n	8004b6c <RCC_GetClocksFreq+0xa0>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 8004b56:	693b      	ldr	r3, [r7, #16]
 8004b58:	4a30      	ldr	r2, [pc, #192]	; (8004c1c <RCC_GetClocksFreq+0x150>)
 8004b5a:	fb02 f203 	mul.w	r2, r2, r3
 8004b5e:	687b      	ldr	r3, [r7, #4]
 8004b60:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8004b62:	e003      	b.n	8004b6c <RCC_GetClocksFreq+0xa0>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8004b64:	687b      	ldr	r3, [r7, #4]
 8004b66:	4a2d      	ldr	r2, [pc, #180]	; (8004c1c <RCC_GetClocksFreq+0x150>)
 8004b68:	601a      	str	r2, [r3, #0]
      break;
 8004b6a:	bf00      	nop
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8004b6c:	4b2a      	ldr	r3, [pc, #168]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004b6e:	685b      	ldr	r3, [r3, #4]
 8004b70:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004b74:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 4;
 8004b76:	697b      	ldr	r3, [r7, #20]
 8004b78:	091b      	lsrs	r3, r3, #4
 8004b7a:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 8004b7c:	4a29      	ldr	r2, [pc, #164]	; (8004c24 <RCC_GetClocksFreq+0x158>)
 8004b7e:	697b      	ldr	r3, [r7, #20]
 8004b80:	4413      	add	r3, r2
 8004b82:	781b      	ldrb	r3, [r3, #0]
 8004b84:	b2db      	uxtb	r3, r3
 8004b86:	60bb      	str	r3, [r7, #8]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8004b88:	687b      	ldr	r3, [r7, #4]
 8004b8a:	681a      	ldr	r2, [r3, #0]
 8004b8c:	68bb      	ldr	r3, [r7, #8]
 8004b8e:	40da      	lsrs	r2, r3
 8004b90:	687b      	ldr	r3, [r7, #4]
 8004b92:	605a      	str	r2, [r3, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8004b94:	4b20      	ldr	r3, [pc, #128]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004b96:	685b      	ldr	r3, [r3, #4]
 8004b98:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004b9c:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 8;
 8004b9e:	697b      	ldr	r3, [r7, #20]
 8004ba0:	0a1b      	lsrs	r3, r3, #8
 8004ba2:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 8004ba4:	4a1f      	ldr	r2, [pc, #124]	; (8004c24 <RCC_GetClocksFreq+0x158>)
 8004ba6:	697b      	ldr	r3, [r7, #20]
 8004ba8:	4413      	add	r3, r2
 8004baa:	781b      	ldrb	r3, [r3, #0]
 8004bac:	b2db      	uxtb	r3, r3
 8004bae:	60bb      	str	r3, [r7, #8]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8004bb0:	687b      	ldr	r3, [r7, #4]
 8004bb2:	685a      	ldr	r2, [r3, #4]
 8004bb4:	68bb      	ldr	r3, [r7, #8]
 8004bb6:	40da      	lsrs	r2, r3
 8004bb8:	687b      	ldr	r3, [r7, #4]
 8004bba:	609a      	str	r2, [r3, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8004bbc:	4b16      	ldr	r3, [pc, #88]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004bbe:	685b      	ldr	r3, [r3, #4]
 8004bc0:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8004bc4:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 11;
 8004bc6:	697b      	ldr	r3, [r7, #20]
 8004bc8:	0adb      	lsrs	r3, r3, #11
 8004bca:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 8004bcc:	4a15      	ldr	r2, [pc, #84]	; (8004c24 <RCC_GetClocksFreq+0x158>)
 8004bce:	697b      	ldr	r3, [r7, #20]
 8004bd0:	4413      	add	r3, r2
 8004bd2:	781b      	ldrb	r3, [r3, #0]
 8004bd4:	b2db      	uxtb	r3, r3
 8004bd6:	60bb      	str	r3, [r7, #8]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8004bd8:	687b      	ldr	r3, [r7, #4]
 8004bda:	685a      	ldr	r2, [r3, #4]
 8004bdc:	68bb      	ldr	r3, [r7, #8]
 8004bde:	40da      	lsrs	r2, r3
 8004be0:	687b      	ldr	r3, [r7, #4]
 8004be2:	60da      	str	r2, [r3, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8004be4:	4b0c      	ldr	r3, [pc, #48]	; (8004c18 <RCC_GetClocksFreq+0x14c>)
 8004be6:	685b      	ldr	r3, [r3, #4]
 8004be8:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8004bec:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 14;
 8004bee:	697b      	ldr	r3, [r7, #20]
 8004bf0:	0b9b      	lsrs	r3, r3, #14
 8004bf2:	617b      	str	r3, [r7, #20]
  presc = ADCPrescTable[tmp];
 8004bf4:	4a0c      	ldr	r2, [pc, #48]	; (8004c28 <RCC_GetClocksFreq+0x15c>)
 8004bf6:	697b      	ldr	r3, [r7, #20]
 8004bf8:	4413      	add	r3, r2
 8004bfa:	781b      	ldrb	r3, [r3, #0]
 8004bfc:	b2db      	uxtb	r3, r3
 8004bfe:	60bb      	str	r3, [r7, #8]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8004c00:	687b      	ldr	r3, [r7, #4]
 8004c02:	68da      	ldr	r2, [r3, #12]
 8004c04:	68bb      	ldr	r3, [r7, #8]
 8004c06:	fbb2 f2f3 	udiv	r2, r2, r3
 8004c0a:	687b      	ldr	r3, [r7, #4]
 8004c0c:	611a      	str	r2, [r3, #16]
}
 8004c0e:	bf00      	nop
 8004c10:	371c      	adds	r7, #28
 8004c12:	46bd      	mov	sp, r7
 8004c14:	bc80      	pop	{r7}
 8004c16:	4770      	bx	lr
 8004c18:	40021000 	.word	0x40021000
 8004c1c:	007a1200 	.word	0x007a1200
 8004c20:	003d0900 	.word	0x003d0900
 8004c24:	20000008 	.word	0x20000008
 8004c28:	20000018 	.word	0x20000018

08004c2c <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8004c2c:	b480      	push	{r7}
 8004c2e:	b083      	sub	sp, #12
 8004c30:	af00      	add	r7, sp, #0
 8004c32:	6078      	str	r0, [r7, #4]
 8004c34:	460b      	mov	r3, r1
 8004c36:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c38:	78fb      	ldrb	r3, [r7, #3]
 8004c3a:	2b00      	cmp	r3, #0
 8004c3c:	d006      	beq.n	8004c4c <RCC_AHBPeriphClockCmd+0x20>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8004c3e:	4909      	ldr	r1, [pc, #36]	; (8004c64 <RCC_AHBPeriphClockCmd+0x38>)
 8004c40:	4b08      	ldr	r3, [pc, #32]	; (8004c64 <RCC_AHBPeriphClockCmd+0x38>)
 8004c42:	695a      	ldr	r2, [r3, #20]
 8004c44:	687b      	ldr	r3, [r7, #4]
 8004c46:	4313      	orrs	r3, r2
 8004c48:	614b      	str	r3, [r1, #20]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
 8004c4a:	e006      	b.n	8004c5a <RCC_AHBPeriphClockCmd+0x2e>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8004c4c:	4905      	ldr	r1, [pc, #20]	; (8004c64 <RCC_AHBPeriphClockCmd+0x38>)
 8004c4e:	4b05      	ldr	r3, [pc, #20]	; (8004c64 <RCC_AHBPeriphClockCmd+0x38>)
 8004c50:	695a      	ldr	r2, [r3, #20]
 8004c52:	687b      	ldr	r3, [r7, #4]
 8004c54:	43db      	mvns	r3, r3
 8004c56:	4013      	ands	r3, r2
 8004c58:	614b      	str	r3, [r1, #20]
  }
}
 8004c5a:	bf00      	nop
 8004c5c:	370c      	adds	r7, #12
 8004c5e:	46bd      	mov	sp, r7
 8004c60:	bc80      	pop	{r7}
 8004c62:	4770      	bx	lr
 8004c64:	40021000 	.word	0x40021000

08004c68 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8004c68:	b480      	push	{r7}
 8004c6a:	b083      	sub	sp, #12
 8004c6c:	af00      	add	r7, sp, #0
 8004c6e:	6078      	str	r0, [r7, #4]
 8004c70:	460b      	mov	r3, r1
 8004c72:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004c74:	78fb      	ldrb	r3, [r7, #3]
 8004c76:	2b00      	cmp	r3, #0
 8004c78:	d006      	beq.n	8004c88 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8004c7a:	4909      	ldr	r1, [pc, #36]	; (8004ca0 <RCC_APB2PeriphClockCmd+0x38>)
 8004c7c:	4b08      	ldr	r3, [pc, #32]	; (8004ca0 <RCC_APB2PeriphClockCmd+0x38>)
 8004c7e:	699a      	ldr	r2, [r3, #24]
 8004c80:	687b      	ldr	r3, [r7, #4]
 8004c82:	4313      	orrs	r3, r2
 8004c84:	618b      	str	r3, [r1, #24]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 8004c86:	e006      	b.n	8004c96 <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8004c88:	4905      	ldr	r1, [pc, #20]	; (8004ca0 <RCC_APB2PeriphClockCmd+0x38>)
 8004c8a:	4b05      	ldr	r3, [pc, #20]	; (8004ca0 <RCC_APB2PeriphClockCmd+0x38>)
 8004c8c:	699a      	ldr	r2, [r3, #24]
 8004c8e:	687b      	ldr	r3, [r7, #4]
 8004c90:	43db      	mvns	r3, r3
 8004c92:	4013      	ands	r3, r2
 8004c94:	618b      	str	r3, [r1, #24]
  }
}
 8004c96:	bf00      	nop
 8004c98:	370c      	adds	r7, #12
 8004c9a:	46bd      	mov	sp, r7
 8004c9c:	bc80      	pop	{r7}
 8004c9e:	4770      	bx	lr
 8004ca0:	40021000 	.word	0x40021000

08004ca4 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8004ca4:	b480      	push	{r7}
 8004ca6:	b083      	sub	sp, #12
 8004ca8:	af00      	add	r7, sp, #0
 8004caa:	6078      	str	r0, [r7, #4]
 8004cac:	460b      	mov	r3, r1
 8004cae:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004cb0:	78fb      	ldrb	r3, [r7, #3]
 8004cb2:	2b00      	cmp	r3, #0
 8004cb4:	d006      	beq.n	8004cc4 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8004cb6:	4909      	ldr	r1, [pc, #36]	; (8004cdc <RCC_APB1PeriphClockCmd+0x38>)
 8004cb8:	4b08      	ldr	r3, [pc, #32]	; (8004cdc <RCC_APB1PeriphClockCmd+0x38>)
 8004cba:	69da      	ldr	r2, [r3, #28]
 8004cbc:	687b      	ldr	r3, [r7, #4]
 8004cbe:	4313      	orrs	r3, r2
 8004cc0:	61cb      	str	r3, [r1, #28]
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
 8004cc2:	e006      	b.n	8004cd2 <RCC_APB1PeriphClockCmd+0x2e>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8004cc4:	4905      	ldr	r1, [pc, #20]	; (8004cdc <RCC_APB1PeriphClockCmd+0x38>)
 8004cc6:	4b05      	ldr	r3, [pc, #20]	; (8004cdc <RCC_APB1PeriphClockCmd+0x38>)
 8004cc8:	69da      	ldr	r2, [r3, #28]
 8004cca:	687b      	ldr	r3, [r7, #4]
 8004ccc:	43db      	mvns	r3, r3
 8004cce:	4013      	ands	r3, r2
 8004cd0:	61cb      	str	r3, [r1, #28]
  }
}
 8004cd2:	bf00      	nop
 8004cd4:	370c      	adds	r7, #12
 8004cd6:	46bd      	mov	sp, r7
 8004cd8:	bc80      	pop	{r7}
 8004cda:	4770      	bx	lr
 8004cdc:	40021000 	.word	0x40021000

08004ce0 <RCC_BackupResetCmd>:
  * @param  NewState: new state of the Backup domain reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
 8004ce0:	b480      	push	{r7}
 8004ce2:	b083      	sub	sp, #12
 8004ce4:	af00      	add	r7, sp, #0
 8004ce6:	4603      	mov	r3, r0
 8004ce8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8004cea:	4a04      	ldr	r2, [pc, #16]	; (8004cfc <RCC_BackupResetCmd+0x1c>)
 8004cec:	79fb      	ldrb	r3, [r7, #7]
 8004cee:	6013      	str	r3, [r2, #0]
}
 8004cf0:	bf00      	nop
 8004cf2:	370c      	adds	r7, #12
 8004cf4:	46bd      	mov	sp, r7
 8004cf6:	bc80      	pop	{r7}
 8004cf8:	4770      	bx	lr
 8004cfa:	bf00      	nop
 8004cfc:	42420440 	.word	0x42420440

08004d00 <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  *   
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 8004d00:	b480      	push	{r7}
 8004d02:	b087      	sub	sp, #28
 8004d04:	af00      	add	r7, sp, #0
 8004d06:	4603      	mov	r3, r0
 8004d08:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 8004d0a:	2300      	movs	r3, #0
 8004d0c:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 8004d0e:	2300      	movs	r3, #0
 8004d10:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 8004d12:	2300      	movs	r3, #0
 8004d14:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8004d16:	79fb      	ldrb	r3, [r7, #7]
 8004d18:	095b      	lsrs	r3, r3, #5
 8004d1a:	b2db      	uxtb	r3, r3
 8004d1c:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 8004d1e:	68fb      	ldr	r3, [r7, #12]
 8004d20:	2b01      	cmp	r3, #1
 8004d22:	d103      	bne.n	8004d2c <RCC_GetFlagStatus+0x2c>
  {
    statusreg = RCC->CR;
 8004d24:	4b12      	ldr	r3, [pc, #72]	; (8004d70 <RCC_GetFlagStatus+0x70>)
 8004d26:	681b      	ldr	r3, [r3, #0]
 8004d28:	617b      	str	r3, [r7, #20]
 8004d2a:	e009      	b.n	8004d40 <RCC_GetFlagStatus+0x40>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8004d2c:	68fb      	ldr	r3, [r7, #12]
 8004d2e:	2b02      	cmp	r3, #2
 8004d30:	d103      	bne.n	8004d3a <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->BDCR;
 8004d32:	4b0f      	ldr	r3, [pc, #60]	; (8004d70 <RCC_GetFlagStatus+0x70>)
 8004d34:	6a1b      	ldr	r3, [r3, #32]
 8004d36:	617b      	str	r3, [r7, #20]
 8004d38:	e002      	b.n	8004d40 <RCC_GetFlagStatus+0x40>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8004d3a:	4b0d      	ldr	r3, [pc, #52]	; (8004d70 <RCC_GetFlagStatus+0x70>)
 8004d3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004d3e:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 8004d40:	79fb      	ldrb	r3, [r7, #7]
 8004d42:	f003 031f 	and.w	r3, r3, #31
 8004d46:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8004d48:	697a      	ldr	r2, [r7, #20]
 8004d4a:	68fb      	ldr	r3, [r7, #12]
 8004d4c:	fa22 f303 	lsr.w	r3, r2, r3
 8004d50:	f003 0301 	and.w	r3, r3, #1
 8004d54:	2b00      	cmp	r3, #0
 8004d56:	d002      	beq.n	8004d5e <RCC_GetFlagStatus+0x5e>
  {
    bitstatus = SET;
 8004d58:	2301      	movs	r3, #1
 8004d5a:	74fb      	strb	r3, [r7, #19]
 8004d5c:	e001      	b.n	8004d62 <RCC_GetFlagStatus+0x62>
  }
  else
  {
    bitstatus = RESET;
 8004d5e:	2300      	movs	r3, #0
 8004d60:	74fb      	strb	r3, [r7, #19]
  }

  /* Return the flag status */
  return bitstatus;
 8004d62:	7cfb      	ldrb	r3, [r7, #19]
}
 8004d64:	4618      	mov	r0, r3
 8004d66:	371c      	adds	r7, #28
 8004d68:	46bd      	mov	sp, r7
 8004d6a:	bc80      	pop	{r7}
 8004d6c:	4770      	bx	lr
 8004d6e:	bf00      	nop
 8004d70:	40021000 	.word	0x40021000

08004d74 <RTC_ITConfig>:
  * @param  NewState: new state of the specified RTC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
{
 8004d74:	b480      	push	{r7}
 8004d76:	b083      	sub	sp, #12
 8004d78:	af00      	add	r7, sp, #0
 8004d7a:	4603      	mov	r3, r0
 8004d7c:	460a      	mov	r2, r1
 8004d7e:	80fb      	strh	r3, [r7, #6]
 8004d80:	4613      	mov	r3, r2
 8004d82:	717b      	strb	r3, [r7, #5]
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004d84:	797b      	ldrb	r3, [r7, #5]
 8004d86:	2b00      	cmp	r3, #0
 8004d88:	d008      	beq.n	8004d9c <RTC_ITConfig+0x28>
  {
    RTC->CRH |= RTC_IT;
 8004d8a:	490c      	ldr	r1, [pc, #48]	; (8004dbc <RTC_ITConfig+0x48>)
 8004d8c:	4b0b      	ldr	r3, [pc, #44]	; (8004dbc <RTC_ITConfig+0x48>)
 8004d8e:	881b      	ldrh	r3, [r3, #0]
 8004d90:	b29a      	uxth	r2, r3
 8004d92:	88fb      	ldrh	r3, [r7, #6]
 8004d94:	4313      	orrs	r3, r2
 8004d96:	b29b      	uxth	r3, r3
 8004d98:	800b      	strh	r3, [r1, #0]
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
  }
}
 8004d9a:	e009      	b.n	8004db0 <RTC_ITConfig+0x3c>
  {
    RTC->CRH |= RTC_IT;
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 8004d9c:	4907      	ldr	r1, [pc, #28]	; (8004dbc <RTC_ITConfig+0x48>)
 8004d9e:	4b07      	ldr	r3, [pc, #28]	; (8004dbc <RTC_ITConfig+0x48>)
 8004da0:	881b      	ldrh	r3, [r3, #0]
 8004da2:	b29a      	uxth	r2, r3
 8004da4:	88fb      	ldrh	r3, [r7, #6]
 8004da6:	43db      	mvns	r3, r3
 8004da8:	b29b      	uxth	r3, r3
 8004daa:	4013      	ands	r3, r2
 8004dac:	b29b      	uxth	r3, r3
 8004dae:	800b      	strh	r3, [r1, #0]
  }
}
 8004db0:	bf00      	nop
 8004db2:	370c      	adds	r7, #12
 8004db4:	46bd      	mov	sp, r7
 8004db6:	bc80      	pop	{r7}
 8004db8:	4770      	bx	lr
 8004dba:	bf00      	nop
 8004dbc:	40002800 	.word	0x40002800

08004dc0 <RTC_EnterConfigMode>:
  * @brief  Enters the RTC configuration mode.
  * @param  None
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
 8004dc0:	b480      	push	{r7}
 8004dc2:	af00      	add	r7, sp, #0
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= RTC_CRL_CNF;
 8004dc4:	4a05      	ldr	r2, [pc, #20]	; (8004ddc <RTC_EnterConfigMode+0x1c>)
 8004dc6:	4b05      	ldr	r3, [pc, #20]	; (8004ddc <RTC_EnterConfigMode+0x1c>)
 8004dc8:	889b      	ldrh	r3, [r3, #4]
 8004dca:	b29b      	uxth	r3, r3
 8004dcc:	f043 0310 	orr.w	r3, r3, #16
 8004dd0:	b29b      	uxth	r3, r3
 8004dd2:	8093      	strh	r3, [r2, #4]
}
 8004dd4:	bf00      	nop
 8004dd6:	46bd      	mov	sp, r7
 8004dd8:	bc80      	pop	{r7}
 8004dda:	4770      	bx	lr
 8004ddc:	40002800 	.word	0x40002800

08004de0 <RTC_ExitConfigMode>:
  * @brief  Exits from the RTC configuration mode.
  * @param  None
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
 8004de0:	b480      	push	{r7}
 8004de2:	af00      	add	r7, sp, #0
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
 8004de4:	4a05      	ldr	r2, [pc, #20]	; (8004dfc <RTC_ExitConfigMode+0x1c>)
 8004de6:	4b05      	ldr	r3, [pc, #20]	; (8004dfc <RTC_ExitConfigMode+0x1c>)
 8004de8:	889b      	ldrh	r3, [r3, #4]
 8004dea:	b29b      	uxth	r3, r3
 8004dec:	f023 0310 	bic.w	r3, r3, #16
 8004df0:	b29b      	uxth	r3, r3
 8004df2:	8093      	strh	r3, [r2, #4]
}
 8004df4:	bf00      	nop
 8004df6:	46bd      	mov	sp, r7
 8004df8:	bc80      	pop	{r7}
 8004dfa:	4770      	bx	lr
 8004dfc:	40002800 	.word	0x40002800

08004e00 <RTC_GetCounter>:
  * @brief  Gets the RTC counter value.
  * @param  None
  * @retval RTC counter value.
  */
uint32_t RTC_GetCounter(void)
{
 8004e00:	b480      	push	{r7}
 8004e02:	b083      	sub	sp, #12
 8004e04:	af00      	add	r7, sp, #0
  uint16_t high1 = 0, high2 = 0, low = 0;
 8004e06:	2300      	movs	r3, #0
 8004e08:	80fb      	strh	r3, [r7, #6]
 8004e0a:	2300      	movs	r3, #0
 8004e0c:	80bb      	strh	r3, [r7, #4]
 8004e0e:	2300      	movs	r3, #0
 8004e10:	807b      	strh	r3, [r7, #2]

  high1 = RTC->CNTH;
 8004e12:	4b0e      	ldr	r3, [pc, #56]	; (8004e4c <RTC_GetCounter+0x4c>)
 8004e14:	8b1b      	ldrh	r3, [r3, #24]
 8004e16:	80fb      	strh	r3, [r7, #6]
  low   = RTC->CNTL;
 8004e18:	4b0c      	ldr	r3, [pc, #48]	; (8004e4c <RTC_GetCounter+0x4c>)
 8004e1a:	8b9b      	ldrh	r3, [r3, #28]
 8004e1c:	807b      	strh	r3, [r7, #2]
  high2 = RTC->CNTH;
 8004e1e:	4b0b      	ldr	r3, [pc, #44]	; (8004e4c <RTC_GetCounter+0x4c>)
 8004e20:	8b1b      	ldrh	r3, [r3, #24]
 8004e22:	80bb      	strh	r3, [r7, #4]

  if (high1 != high2)
 8004e24:	88fa      	ldrh	r2, [r7, #6]
 8004e26:	88bb      	ldrh	r3, [r7, #4]
 8004e28:	429a      	cmp	r2, r3
 8004e2a:	d006      	beq.n	8004e3a <RTC_GetCounter+0x3a>
  { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
       read again CNTL register then return the counter value */
    return (((uint32_t) high2 << 16 ) | RTC->CNTL);
 8004e2c:	88bb      	ldrh	r3, [r7, #4]
 8004e2e:	041b      	lsls	r3, r3, #16
 8004e30:	4a06      	ldr	r2, [pc, #24]	; (8004e4c <RTC_GetCounter+0x4c>)
 8004e32:	8b92      	ldrh	r2, [r2, #28]
 8004e34:	b292      	uxth	r2, r2
 8004e36:	4313      	orrs	r3, r2
 8004e38:	e003      	b.n	8004e42 <RTC_GetCounter+0x42>
  }
  else
  { /* No counter roll over during reading of CNTL and CNTH registers, counter 
       value is equal to first value of CNTL and CNTH */
    return (((uint32_t) high1 << 16 ) | low);
 8004e3a:	88fb      	ldrh	r3, [r7, #6]
 8004e3c:	041a      	lsls	r2, r3, #16
 8004e3e:	887b      	ldrh	r3, [r7, #2]
 8004e40:	4313      	orrs	r3, r2
  }
}
 8004e42:	4618      	mov	r0, r3
 8004e44:	370c      	adds	r7, #12
 8004e46:	46bd      	mov	sp, r7
 8004e48:	bc80      	pop	{r7}
 8004e4a:	4770      	bx	lr
 8004e4c:	40002800 	.word	0x40002800

08004e50 <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 8004e50:	b580      	push	{r7, lr}
 8004e52:	b082      	sub	sp, #8
 8004e54:	af00      	add	r7, sp, #0
 8004e56:	6078      	str	r0, [r7, #4]
  RTC_EnterConfigMode();
 8004e58:	f7ff ffb2 	bl	8004dc0 <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 8004e5c:	4a07      	ldr	r2, [pc, #28]	; (8004e7c <RTC_SetCounter+0x2c>)
 8004e5e:	687b      	ldr	r3, [r7, #4]
 8004e60:	0c1b      	lsrs	r3, r3, #16
 8004e62:	b29b      	uxth	r3, r3
 8004e64:	8313      	strh	r3, [r2, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
 8004e66:	4b05      	ldr	r3, [pc, #20]	; (8004e7c <RTC_SetCounter+0x2c>)
 8004e68:	687a      	ldr	r2, [r7, #4]
 8004e6a:	b292      	uxth	r2, r2
 8004e6c:	839a      	strh	r2, [r3, #28]
  RTC_ExitConfigMode();
 8004e6e:	f7ff ffb7 	bl	8004de0 <RTC_ExitConfigMode>
}
 8004e72:	bf00      	nop
 8004e74:	3708      	adds	r7, #8
 8004e76:	46bd      	mov	sp, r7
 8004e78:	bd80      	pop	{r7, pc}
 8004e7a:	bf00      	nop
 8004e7c:	40002800 	.word	0x40002800

08004e80 <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 8004e80:	b580      	push	{r7, lr}
 8004e82:	b082      	sub	sp, #8
 8004e84:	af00      	add	r7, sp, #0
 8004e86:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 8004e88:	f7ff ff9a 	bl	8004dc0 <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
 8004e8c:	4a08      	ldr	r2, [pc, #32]	; (8004eb0 <RTC_SetPrescaler+0x30>)
 8004e8e:	687b      	ldr	r3, [r7, #4]
 8004e90:	0c1b      	lsrs	r3, r3, #16
 8004e92:	b29b      	uxth	r3, r3
 8004e94:	f003 030f 	and.w	r3, r3, #15
 8004e98:	b29b      	uxth	r3, r3
 8004e9a:	8113      	strh	r3, [r2, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
 8004e9c:	4b04      	ldr	r3, [pc, #16]	; (8004eb0 <RTC_SetPrescaler+0x30>)
 8004e9e:	687a      	ldr	r2, [r7, #4]
 8004ea0:	b292      	uxth	r2, r2
 8004ea2:	819a      	strh	r2, [r3, #12]
  RTC_ExitConfigMode();
 8004ea4:	f7ff ff9c 	bl	8004de0 <RTC_ExitConfigMode>
}
 8004ea8:	bf00      	nop
 8004eaa:	3708      	adds	r7, #8
 8004eac:	46bd      	mov	sp, r7
 8004eae:	bd80      	pop	{r7, pc}
 8004eb0:	40002800 	.word	0x40002800

08004eb4 <RTC_WaitForLastTask>:
  * @note   This function must be called before any write to RTC registers.
  * @param  None
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
 8004eb4:	b480      	push	{r7}
 8004eb6:	af00      	add	r7, sp, #0
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 8004eb8:	bf00      	nop
 8004eba:	4b05      	ldr	r3, [pc, #20]	; (8004ed0 <RTC_WaitForLastTask+0x1c>)
 8004ebc:	889b      	ldrh	r3, [r3, #4]
 8004ebe:	b29b      	uxth	r3, r3
 8004ec0:	f003 0320 	and.w	r3, r3, #32
 8004ec4:	2b00      	cmp	r3, #0
 8004ec6:	d0f8      	beq.n	8004eba <RTC_WaitForLastTask+0x6>
  {
  }
}
 8004ec8:	bf00      	nop
 8004eca:	46bd      	mov	sp, r7
 8004ecc:	bc80      	pop	{r7}
 8004ece:	4770      	bx	lr
 8004ed0:	40002800 	.word	0x40002800

08004ed4 <RTC_GetITStatus>:
  *     @arg RTC_IT_ALR: Alarm interrupt
  *     @arg RTC_IT_SEC: Second interrupt
  * @retval The new state of the RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint16_t RTC_IT)
{
 8004ed4:	b480      	push	{r7}
 8004ed6:	b085      	sub	sp, #20
 8004ed8:	af00      	add	r7, sp, #0
 8004eda:	4603      	mov	r3, r0
 8004edc:	80fb      	strh	r3, [r7, #6]
  ITStatus bitstatus = RESET;
 8004ede:	2300      	movs	r3, #0
 8004ee0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT)); 
  
  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
 8004ee2:	4b0f      	ldr	r3, [pc, #60]	; (8004f20 <RTC_GetITStatus+0x4c>)
 8004ee4:	889b      	ldrh	r3, [r3, #4]
 8004ee6:	b29b      	uxth	r3, r3
 8004ee8:	b2da      	uxtb	r2, r3
 8004eea:	88fb      	ldrh	r3, [r7, #6]
 8004eec:	b2db      	uxtb	r3, r3
 8004eee:	4013      	ands	r3, r2
 8004ef0:	73fb      	strb	r3, [r7, #15]
  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
 8004ef2:	4b0b      	ldr	r3, [pc, #44]	; (8004f20 <RTC_GetITStatus+0x4c>)
 8004ef4:	881b      	ldrh	r3, [r3, #0]
 8004ef6:	b29a      	uxth	r2, r3
 8004ef8:	88fb      	ldrh	r3, [r7, #6]
 8004efa:	4013      	ands	r3, r2
 8004efc:	b29b      	uxth	r3, r3
 8004efe:	2b00      	cmp	r3, #0
 8004f00:	d005      	beq.n	8004f0e <RTC_GetITStatus+0x3a>
 8004f02:	7bfb      	ldrb	r3, [r7, #15]
 8004f04:	2b00      	cmp	r3, #0
 8004f06:	d002      	beq.n	8004f0e <RTC_GetITStatus+0x3a>
  {
    bitstatus = SET;
 8004f08:	2301      	movs	r3, #1
 8004f0a:	73fb      	strb	r3, [r7, #15]
 8004f0c:	e001      	b.n	8004f12 <RTC_GetITStatus+0x3e>
  }
  else
  {
    bitstatus = RESET;
 8004f0e:	2300      	movs	r3, #0
 8004f10:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8004f12:	7bfb      	ldrb	r3, [r7, #15]
}
 8004f14:	4618      	mov	r0, r3
 8004f16:	3714      	adds	r7, #20
 8004f18:	46bd      	mov	sp, r7
 8004f1a:	bc80      	pop	{r7}
 8004f1c:	4770      	bx	lr
 8004f1e:	bf00      	nop
 8004f20:	40002800 	.word	0x40002800

08004f24 <RTC_ClearITPendingBit>:
  *     @arg RTC_IT_ALR: Alarm interrupt
  *     @arg RTC_IT_SEC: Second interrupt
  * @retval None
  */
void RTC_ClearITPendingBit(uint16_t RTC_IT)
{
 8004f24:	b480      	push	{r7}
 8004f26:	b083      	sub	sp, #12
 8004f28:	af00      	add	r7, sp, #0
 8004f2a:	4603      	mov	r3, r0
 8004f2c:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  
  /* Clear the corresponding RTC pending bit */
  RTC->CRL &= (uint16_t)~RTC_IT;
 8004f2e:	4907      	ldr	r1, [pc, #28]	; (8004f4c <RTC_ClearITPendingBit+0x28>)
 8004f30:	4b06      	ldr	r3, [pc, #24]	; (8004f4c <RTC_ClearITPendingBit+0x28>)
 8004f32:	889b      	ldrh	r3, [r3, #4]
 8004f34:	b29a      	uxth	r2, r3
 8004f36:	88fb      	ldrh	r3, [r7, #6]
 8004f38:	43db      	mvns	r3, r3
 8004f3a:	b29b      	uxth	r3, r3
 8004f3c:	4013      	ands	r3, r2
 8004f3e:	b29b      	uxth	r3, r3
 8004f40:	808b      	strh	r3, [r1, #4]
}
 8004f42:	bf00      	nop
 8004f44:	370c      	adds	r7, #12
 8004f46:	46bd      	mov	sp, r7
 8004f48:	bc80      	pop	{r7}
 8004f4a:	4770      	bx	lr
 8004f4c:	40002800 	.word	0x40002800

08004f50 <TIM_GetITStatus>:
  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.  
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8004f50:	b480      	push	{r7}
 8004f52:	b085      	sub	sp, #20
 8004f54:	af00      	add	r7, sp, #0
 8004f56:	6078      	str	r0, [r7, #4]
 8004f58:	460b      	mov	r3, r1
 8004f5a:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 8004f5c:	2300      	movs	r3, #0
 8004f5e:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
 8004f60:	2300      	movs	r3, #0
 8004f62:	81bb      	strh	r3, [r7, #12]
 8004f64:	2300      	movs	r3, #0
 8004f66:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8004f68:	687b      	ldr	r3, [r7, #4]
 8004f6a:	8a1b      	ldrh	r3, [r3, #16]
 8004f6c:	b29a      	uxth	r2, r3
 8004f6e:	887b      	ldrh	r3, [r7, #2]
 8004f70:	4013      	ands	r3, r2
 8004f72:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 8004f74:	687b      	ldr	r3, [r7, #4]
 8004f76:	899b      	ldrh	r3, [r3, #12]
 8004f78:	b29a      	uxth	r2, r3
 8004f7a:	887b      	ldrh	r3, [r7, #2]
 8004f7c:	4013      	ands	r3, r2
 8004f7e:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8004f80:	89bb      	ldrh	r3, [r7, #12]
 8004f82:	2b00      	cmp	r3, #0
 8004f84:	d005      	beq.n	8004f92 <TIM_GetITStatus+0x42>
 8004f86:	897b      	ldrh	r3, [r7, #10]
 8004f88:	2b00      	cmp	r3, #0
 8004f8a:	d002      	beq.n	8004f92 <TIM_GetITStatus+0x42>
  {
    bitstatus = SET;
 8004f8c:	2301      	movs	r3, #1
 8004f8e:	73fb      	strb	r3, [r7, #15]
 8004f90:	e001      	b.n	8004f96 <TIM_GetITStatus+0x46>
  }
  else
  {
    bitstatus = RESET;
 8004f92:	2300      	movs	r3, #0
 8004f94:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8004f96:	7bfb      	ldrb	r3, [r7, #15]
}
 8004f98:	4618      	mov	r0, r3
 8004f9a:	3714      	adds	r7, #20
 8004f9c:	46bd      	mov	sp, r7
 8004f9e:	bc80      	pop	{r7}
 8004fa0:	4770      	bx	lr
 8004fa2:	bf00      	nop

08004fa4 <TIM_ClearITPendingBit>:
  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8004fa4:	b480      	push	{r7}
 8004fa6:	b083      	sub	sp, #12
 8004fa8:	af00      	add	r7, sp, #0
 8004faa:	6078      	str	r0, [r7, #4]
 8004fac:	460b      	mov	r3, r1
 8004fae:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8004fb0:	887b      	ldrh	r3, [r7, #2]
 8004fb2:	43db      	mvns	r3, r3
 8004fb4:	b29a      	uxth	r2, r3
 8004fb6:	687b      	ldr	r3, [r7, #4]
 8004fb8:	821a      	strh	r2, [r3, #16]
}
 8004fba:	bf00      	nop
 8004fbc:	370c      	adds	r7, #12
 8004fbe:	46bd      	mov	sp, r7
 8004fc0:	bc80      	pop	{r7}
 8004fc2:	4770      	bx	lr

08004fc4 <USART_GetITStatus>:
  *     @arg USART_IT_FE:   Framing Error interrupt
  *     @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8004fc4:	b480      	push	{r7}
 8004fc6:	b087      	sub	sp, #28
 8004fc8:	af00      	add	r7, sp, #0
 8004fca:	6078      	str	r0, [r7, #4]
 8004fcc:	460b      	mov	r3, r1
 8004fce:	807b      	strh	r3, [r7, #2]
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 8004fd0:	2300      	movs	r3, #0
 8004fd2:	60fb      	str	r3, [r7, #12]
 8004fd4:	2300      	movs	r3, #0
 8004fd6:	617b      	str	r3, [r7, #20]
 8004fd8:	2300      	movs	r3, #0
 8004fda:	60bb      	str	r3, [r7, #8]
  ITStatus bitstatus = RESET;
 8004fdc:	2300      	movs	r3, #0
 8004fde:	74fb      	strb	r3, [r7, #19]
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8004fe0:	887b      	ldrh	r3, [r7, #2]
 8004fe2:	b2db      	uxtb	r3, r3
 8004fe4:	095b      	lsrs	r3, r3, #5
 8004fe6:	b2db      	uxtb	r3, r3
 8004fe8:	60bb      	str	r3, [r7, #8]
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
 8004fea:	887b      	ldrh	r3, [r7, #2]
 8004fec:	f003 031f 	and.w	r3, r3, #31
 8004ff0:	617b      	str	r3, [r7, #20]
  itmask = (uint32_t)0x01 << itmask;
 8004ff2:	2201      	movs	r2, #1
 8004ff4:	697b      	ldr	r3, [r7, #20]
 8004ff6:	fa02 f303 	lsl.w	r3, r2, r3
 8004ffa:	617b      	str	r3, [r7, #20]
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8004ffc:	68bb      	ldr	r3, [r7, #8]
 8004ffe:	2b01      	cmp	r3, #1
 8005000:	d107      	bne.n	8005012 <USART_GetITStatus+0x4e>
  {
    itmask &= USARTx->CR1;
 8005002:	687b      	ldr	r3, [r7, #4]
 8005004:	899b      	ldrh	r3, [r3, #12]
 8005006:	b29b      	uxth	r3, r3
 8005008:	461a      	mov	r2, r3
 800500a:	697b      	ldr	r3, [r7, #20]
 800500c:	4013      	ands	r3, r2
 800500e:	617b      	str	r3, [r7, #20]
 8005010:	e011      	b.n	8005036 <USART_GetITStatus+0x72>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8005012:	68bb      	ldr	r3, [r7, #8]
 8005014:	2b02      	cmp	r3, #2
 8005016:	d107      	bne.n	8005028 <USART_GetITStatus+0x64>
  {
    itmask &= USARTx->CR2;
 8005018:	687b      	ldr	r3, [r7, #4]
 800501a:	8a1b      	ldrh	r3, [r3, #16]
 800501c:	b29b      	uxth	r3, r3
 800501e:	461a      	mov	r2, r3
 8005020:	697b      	ldr	r3, [r7, #20]
 8005022:	4013      	ands	r3, r2
 8005024:	617b      	str	r3, [r7, #20]
 8005026:	e006      	b.n	8005036 <USART_GetITStatus+0x72>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8005028:	687b      	ldr	r3, [r7, #4]
 800502a:	8a9b      	ldrh	r3, [r3, #20]
 800502c:	b29b      	uxth	r3, r3
 800502e:	461a      	mov	r2, r3
 8005030:	697b      	ldr	r3, [r7, #20]
 8005032:	4013      	ands	r3, r2
 8005034:	617b      	str	r3, [r7, #20]
  }
  
  bitpos = USART_IT >> 0x08;
 8005036:	887b      	ldrh	r3, [r7, #2]
 8005038:	0a1b      	lsrs	r3, r3, #8
 800503a:	b29b      	uxth	r3, r3
 800503c:	60fb      	str	r3, [r7, #12]
  bitpos = (uint32_t)0x01 << bitpos;
 800503e:	2201      	movs	r2, #1
 8005040:	68fb      	ldr	r3, [r7, #12]
 8005042:	fa02 f303 	lsl.w	r3, r2, r3
 8005046:	60fb      	str	r3, [r7, #12]
  bitpos &= USARTx->SR;
 8005048:	687b      	ldr	r3, [r7, #4]
 800504a:	881b      	ldrh	r3, [r3, #0]
 800504c:	b29b      	uxth	r3, r3
 800504e:	461a      	mov	r2, r3
 8005050:	68fb      	ldr	r3, [r7, #12]
 8005052:	4013      	ands	r3, r2
 8005054:	60fb      	str	r3, [r7, #12]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005056:	697b      	ldr	r3, [r7, #20]
 8005058:	2b00      	cmp	r3, #0
 800505a:	d005      	beq.n	8005068 <USART_GetITStatus+0xa4>
 800505c:	68fb      	ldr	r3, [r7, #12]
 800505e:	2b00      	cmp	r3, #0
 8005060:	d002      	beq.n	8005068 <USART_GetITStatus+0xa4>
  {
    bitstatus = SET;
 8005062:	2301      	movs	r3, #1
 8005064:	74fb      	strb	r3, [r7, #19]
 8005066:	e001      	b.n	800506c <USART_GetITStatus+0xa8>
  }
  else
  {
    bitstatus = RESET;
 8005068:	2300      	movs	r3, #0
 800506a:	74fb      	strb	r3, [r7, #19]
  }
  
  return bitstatus;  
 800506c:	7cfb      	ldrb	r3, [r7, #19]
}
 800506e:	4618      	mov	r0, r3
 8005070:	371c      	adds	r7, #28
 8005072:	46bd      	mov	sp, r7
 8005074:	bc80      	pop	{r7}
 8005076:	4770      	bx	lr

08005078 <USART_ClearITPendingBit>:
  *   - TXE pending bit is cleared only by a write to the USART_DR register 
  *     (USART_SendData()).
  * @retval None
  */
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8005078:	b480      	push	{r7}
 800507a:	b085      	sub	sp, #20
 800507c:	af00      	add	r7, sp, #0
 800507e:	6078      	str	r0, [r7, #4]
 8005080:	460b      	mov	r3, r1
 8005082:	807b      	strh	r3, [r7, #2]
  uint16_t bitpos = 0x00, itmask = 0x00;
 8005084:	2300      	movs	r3, #0
 8005086:	81fb      	strh	r3, [r7, #14]
 8005088:	2300      	movs	r3, #0
 800508a:	81bb      	strh	r3, [r7, #12]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  bitpos = USART_IT >> 0x08;
 800508c:	887b      	ldrh	r3, [r7, #2]
 800508e:	0a1b      	lsrs	r3, r3, #8
 8005090:	81fb      	strh	r3, [r7, #14]
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8005092:	89fb      	ldrh	r3, [r7, #14]
 8005094:	2201      	movs	r2, #1
 8005096:	fa02 f303 	lsl.w	r3, r2, r3
 800509a:	81bb      	strh	r3, [r7, #12]
  USARTx->SR = (uint16_t)~itmask;
 800509c:	89bb      	ldrh	r3, [r7, #12]
 800509e:	43db      	mvns	r3, r3
 80050a0:	b29a      	uxth	r2, r3
 80050a2:	687b      	ldr	r3, [r7, #4]
 80050a4:	801a      	strh	r2, [r3, #0]
}
 80050a6:	bf00      	nop
 80050a8:	3714      	adds	r7, #20
 80050aa:	46bd      	mov	sp, r7
 80050ac:	bc80      	pop	{r7}
 80050ae:	4770      	bx	lr

080050b0 <main>:
 **===========================================================================
 */
void ADCT_BGS_Initialize_system(void);
void ADCT_BGS_Factory_Reset(void);
int main(void)
{
 80050b0:	b580      	push	{r7, lr}
 80050b2:	b084      	sub	sp, #16
 80050b4:	af02      	add	r7, sp, #8
	GPIO_InitTypeDef   GPIO_InitStructure;
	RCC_APB2PeriphClockCmd( LED1_GPIO_CLK|LED2_GPIO_CLK|LED3_GPIO_CLK|LED4_GPIO_CLK, ENABLE );
 80050b6:	2101      	movs	r1, #1
 80050b8:	2038      	movs	r0, #56	; 0x38
 80050ba:	f7ff fdd5 	bl	8004c68 <RCC_APB2PeriphClockCmd>

	GPIO_StructInit( &GPIO_InitStructure );
 80050be:	1d3b      	adds	r3, r7, #4
 80050c0:	4618      	mov	r0, r3
 80050c2:	f7ff f8d7 	bl	8004274 <GPIO_StructInit>

	GPIO_InitStructure.GPIO_Pin = LED1_PIN | LED2_PIN | LED3_PIN | LED4_PIN;
 80050c6:	f641 0324 	movw	r3, #6180	; 0x1824
 80050ca:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80050cc:	2310      	movs	r3, #16
 80050ce:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80050d0:	2303      	movs	r3, #3
 80050d2:	71bb      	strb	r3, [r7, #6]
	GPIO_Init( LED1_GPIO_PORT, &GPIO_InitStructure );
 80050d4:	1d3b      	adds	r3, r7, #4
 80050d6:	4619      	mov	r1, r3
 80050d8:	4828      	ldr	r0, [pc, #160]	; (800517c <main+0xcc>)
 80050da:	f7ff f80f 	bl	80040fc <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin =  LED2_PIN ;
 80050de:	2304      	movs	r3, #4
 80050e0:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80050e2:	2310      	movs	r3, #16
 80050e4:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80050e6:	2303      	movs	r3, #3
 80050e8:	71bb      	strb	r3, [r7, #6]
	GPIO_Init( LED2_GPIO_PORT, &GPIO_InitStructure );
 80050ea:	1d3b      	adds	r3, r7, #4
 80050ec:	4619      	mov	r1, r3
 80050ee:	4824      	ldr	r0, [pc, #144]	; (8005180 <main+0xd0>)
 80050f0:	f7ff f804 	bl	80040fc <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin =   LED3_PIN ;
 80050f4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80050f8:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80050fa:	2310      	movs	r3, #16
 80050fc:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80050fe:	2303      	movs	r3, #3
 8005100:	71bb      	strb	r3, [r7, #6]
	GPIO_Init( LED3_GPIO_PORT, &GPIO_InitStructure );
 8005102:	1d3b      	adds	r3, r7, #4
 8005104:	4619      	mov	r1, r3
 8005106:	481f      	ldr	r0, [pc, #124]	; (8005184 <main+0xd4>)
 8005108:	f7fe fff8 	bl	80040fc <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin =  LED4_PIN;
 800510c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8005110:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005112:	2310      	movs	r3, #16
 8005114:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005116:	2303      	movs	r3, #3
 8005118:	71bb      	strb	r3, [r7, #6]
	GPIO_Init( LED4_GPIO_PORT, &GPIO_InitStructure );
 800511a:	1d3b      	adds	r3, r7, #4
 800511c:	4619      	mov	r1, r3
 800511e:	4819      	ldr	r0, [pc, #100]	; (8005184 <main+0xd4>)
 8005120:	f7fe ffec 	bl	80040fc <GPIO_Init>
	DHT22_Module_Init_Hardware();
 8005124:	f7fc faba 	bl	800169c <DHT22_Module_Init_Hardware>
	ADCT_BGS_Systick_Init();
 8005128:	f7fe fb68 	bl	80037fc <ADCT_BGS_Systick_Init>
	/* TODO - Add your application code here */
	ADCT_BGS_ASW_100ms_Init();
 800512c:	f7fb f81c 	bl	8000168 <ADCT_BGS_ASW_100ms_Init>
	ADCT_BGS_ASW_10ms_Init();
 8005130:	f7fb f84a 	bl	80001c8 <ADCT_BGS_ASW_10ms_Init>
	ADCT_BGS_ASW_1s_Init();
 8005134:	f7fb f85e 	bl	80001f4 <ADCT_BGS_ASW_1s_Init>
	//ADCT_BGS_ASW_1ms_Init();
	ADCT_BGS_Button_Init();
 8005138:	f7fd fcd6 	bl	8002ae8 <ADCT_BGS_Button_Init>
	ADCT_BGS_RTC_Init();
 800513c:	f7fe f820 	bl	8003180 <ADCT_BGS_RTC_Init>
	EEPROM_Init();
 8005140:	f7fc ffbc 	bl	80020bc <EEPROM_Init>
	ADCT_Relay_Init();
 8005144:	f7fd fed0 	bl	8002ee8 <ADCT_Relay_Init>
	ADCT_BGS_Sensor_Input_Init();
 8005148:	f7fe fae6 	bl	8003718 <ADCT_BGS_Sensor_Input_Init>
	TestTimer = TM_DELAY_TimerCreate(1000, 0, 1, TempTimer_Task, NULL);
 800514c:	2300      	movs	r3, #0
 800514e:	9300      	str	r3, [sp, #0]
 8005150:	4b0d      	ldr	r3, [pc, #52]	; (8005188 <main+0xd8>)
 8005152:	2201      	movs	r2, #1
 8005154:	2100      	movs	r1, #0
 8005156:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800515a:	f7fe fb95 	bl	8003888 <TM_DELAY_TimerCreate>
 800515e:	4602      	mov	r2, r0
 8005160:	4b0a      	ldr	r3, [pc, #40]	; (800518c <main+0xdc>)
 8005162:	601a      	str	r2, [r3, #0]
	ADCT_BGS_Factory_Reset();
 8005164:	f000 fa42 	bl	80055ec <ADCT_BGS_Factory_Reset>
	ADCT_BGS_Initialize_system();
 8005168:	f000 f8c0 	bl	80052ec <ADCT_BGS_Initialize_system>
		//		GPIO_WriteBit(LED2_GPIO_PORT, LED2_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED2_GPIO_PORT, LED2_PIN)));
		//		GPIO_WriteBit(LED3_GPIO_PORT, LED3_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED3_GPIO_PORT, LED3_PIN)));
		//		GPIO_WriteBit(LED4_GPIO_PORT, LED4_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED4_GPIO_PORT, LED4_PIN)));
		//ADCT_BGS_DHT22_GetData(DHT22_Device_1);
		//ADCT_BGS_DHT22_GetData(DHT22_Device_2);
		TM_BUTTON_Update();
 800516c:	f7fd fdbe 	bl	8002cec <TM_BUTTON_Update>
		ADCT_BGS_StateManger();
 8005170:	f7fb f856 	bl	8000220 <ADCT_BGS_StateManger>
		ADCT_SystemFPT_RunOutput();
 8005174:	f7fb fdd6 	bl	8000d24 <ADCT_SystemFPT_RunOutput>
		//  Delay(1000000);
	}
 8005178:	e7f8      	b.n	800516c <main+0xbc>
 800517a:	bf00      	nop
 800517c:	40010c00 	.word	0x40010c00
 8005180:	40011400 	.word	0x40011400
 8005184:	40011000 	.word	0x40011000
 8005188:	08005191 	.word	0x08005191
 800518c:	200002f0 	.word	0x200002f0

08005190 <TempTimer_Task>:
volatile uint8_t test_state = TEMP_TIMER_START;
void BlinkLed1();
void BlinkLed2();
void BlinkLed3();
void TempTimer_Task(TM_DELAY_Timer_t* timer, void * parameter)
{
 8005190:	b580      	push	{r7, lr}
 8005192:	b082      	sub	sp, #8
 8005194:	af00      	add	r7, sp, #0
 8005196:	6078      	str	r0, [r7, #4]
 8005198:	6039      	str	r1, [r7, #0]
	switch(test_state)
 800519a:	4b0b      	ldr	r3, [pc, #44]	; (80051c8 <TempTimer_Task+0x38>)
 800519c:	781b      	ldrb	r3, [r3, #0]
 800519e:	b2db      	uxtb	r3, r3
 80051a0:	2b01      	cmp	r3, #1
 80051a2:	d007      	beq.n	80051b4 <TempTimer_Task+0x24>
 80051a4:	2b02      	cmp	r3, #2
 80051a6:	d008      	beq.n	80051ba <TempTimer_Task+0x2a>
 80051a8:	2b00      	cmp	r3, #0
 80051aa:	d000      	beq.n	80051ae <TempTimer_Task+0x1e>
	case TEMP_TIMER_STAYOFF:
		/* Action */
		BlinkLed1();
		break;
	default:
		break;
 80051ac:	e008      	b.n	80051c0 <TempTimer_Task+0x30>
{
	switch(test_state)
	{
	case TEMP_TIMER_START:
		/* Action */
		BlinkLed2();
 80051ae:	f000 f83d 	bl	800522c <BlinkLed2>
		break;
 80051b2:	e005      	b.n	80051c0 <TempTimer_Task+0x30>
	case TEMP_TIMER_MINSWITCH:
		/* Action */
		BlinkLed3();
 80051b4:	f000 f86a 	bl	800528c <BlinkLed3>
		break;
 80051b8:	e002      	b.n	80051c0 <TempTimer_Task+0x30>
	case TEMP_TIMER_STAYOFF:
		/* Action */
		BlinkLed1();
 80051ba:	f000 f807 	bl	80051cc <BlinkLed1>
		break;
 80051be:	bf00      	nop
	default:
		break;
	}
}
 80051c0:	bf00      	nop
 80051c2:	3708      	adds	r7, #8
 80051c4:	46bd      	mov	sp, r7
 80051c6:	bd80      	pop	{r7, pc}
 80051c8:	200001cc 	.word	0x200001cc

080051cc <BlinkLed1>:
void BlinkLed1()
{
 80051cc:	b580      	push	{r7, lr}
 80051ce:	af00      	add	r7, sp, #0
	GPIO_SetBits(LED1_GPIO_PORT,LED1_PIN);
 80051d0:	2120      	movs	r1, #32
 80051d2:	4811      	ldr	r0, [pc, #68]	; (8005218 <BlinkLed1+0x4c>)
 80051d4:	f7ff f87c 	bl	80042d0 <GPIO_SetBits>
	GPIO_ResetBits(LED2_GPIO_PORT,LED2_PIN);
 80051d8:	2104      	movs	r1, #4
 80051da:	4810      	ldr	r0, [pc, #64]	; (800521c <BlinkLed1+0x50>)
 80051dc:	f7ff f886 	bl	80042ec <GPIO_ResetBits>
	GPIO_ResetBits(LED4_GPIO_PORT,LED4_PIN);
 80051e0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80051e4:	480e      	ldr	r0, [pc, #56]	; (8005220 <BlinkLed1+0x54>)
 80051e6:	f7ff f881 	bl	80042ec <GPIO_ResetBits>
	//GPIO_WriteBit(LED1_GPIO_PORT, LED1_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED1_GPIO_PORT, LED1_PIN)));
    test_state = TEMP_TIMER_MINSWITCH;
 80051ea:	4b0e      	ldr	r3, [pc, #56]	; (8005224 <BlinkLed1+0x58>)
 80051ec:	2201      	movs	r2, #1
 80051ee:	701a      	strb	r2, [r3, #0]
    TM_DELAY_TimerStop(TestTimer);
 80051f0:	4b0d      	ldr	r3, [pc, #52]	; (8005228 <BlinkLed1+0x5c>)
 80051f2:	681b      	ldr	r3, [r3, #0]
 80051f4:	4618      	mov	r0, r3
 80051f6:	f7fe fb91 	bl	800391c <TM_DELAY_TimerStop>
	TM_DELAY_TimerAutoReloadValue(TestTimer, (2000));
 80051fa:	4b0b      	ldr	r3, [pc, #44]	; (8005228 <BlinkLed1+0x5c>)
 80051fc:	681b      	ldr	r3, [r3, #0]
 80051fe:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8005202:	4618      	mov	r0, r3
 8005204:	f7fe fbaa 	bl	800395c <TM_DELAY_TimerAutoReloadValue>
    TM_DELAY_TimerStart(TestTimer);
 8005208:	4b07      	ldr	r3, [pc, #28]	; (8005228 <BlinkLed1+0x5c>)
 800520a:	681b      	ldr	r3, [r3, #0]
 800520c:	4618      	mov	r0, r3
 800520e:	f7fe fb95 	bl	800393c <TM_DELAY_TimerStart>

}
 8005212:	bf00      	nop
 8005214:	bd80      	pop	{r7, pc}
 8005216:	bf00      	nop
 8005218:	40010c00 	.word	0x40010c00
 800521c:	40011400 	.word	0x40011400
 8005220:	40011000 	.word	0x40011000
 8005224:	200001cc 	.word	0x200001cc
 8005228:	200002f0 	.word	0x200002f0

0800522c <BlinkLed2>:

void BlinkLed2()
{
 800522c:	b580      	push	{r7, lr}
 800522e:	af00      	add	r7, sp, #0
	GPIO_SetBits(LED2_GPIO_PORT,LED2_PIN);
 8005230:	2104      	movs	r1, #4
 8005232:	4811      	ldr	r0, [pc, #68]	; (8005278 <BlinkLed2+0x4c>)
 8005234:	f7ff f84c 	bl	80042d0 <GPIO_SetBits>
	GPIO_ResetBits(LED1_GPIO_PORT,LED1_PIN);
 8005238:	2120      	movs	r1, #32
 800523a:	4810      	ldr	r0, [pc, #64]	; (800527c <BlinkLed2+0x50>)
 800523c:	f7ff f856 	bl	80042ec <GPIO_ResetBits>
	GPIO_ResetBits(LED4_GPIO_PORT,LED4_PIN);
 8005240:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8005244:	480e      	ldr	r0, [pc, #56]	; (8005280 <BlinkLed2+0x54>)
 8005246:	f7ff f851 	bl	80042ec <GPIO_ResetBits>

    test_state = TEMP_TIMER_STAYOFF;
 800524a:	4b0e      	ldr	r3, [pc, #56]	; (8005284 <BlinkLed2+0x58>)
 800524c:	2202      	movs	r2, #2
 800524e:	701a      	strb	r2, [r3, #0]
	TM_DELAY_TimerStop(TestTimer);
 8005250:	4b0d      	ldr	r3, [pc, #52]	; (8005288 <BlinkLed2+0x5c>)
 8005252:	681b      	ldr	r3, [r3, #0]
 8005254:	4618      	mov	r0, r3
 8005256:	f7fe fb61 	bl	800391c <TM_DELAY_TimerStop>
    TM_DELAY_TimerAutoReloadValue(TestTimer, (4000));
 800525a:	4b0b      	ldr	r3, [pc, #44]	; (8005288 <BlinkLed2+0x5c>)
 800525c:	681b      	ldr	r3, [r3, #0]
 800525e:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 8005262:	4618      	mov	r0, r3
 8005264:	f7fe fb7a 	bl	800395c <TM_DELAY_TimerAutoReloadValue>
    TM_DELAY_TimerStart(TestTimer);
 8005268:	4b07      	ldr	r3, [pc, #28]	; (8005288 <BlinkLed2+0x5c>)
 800526a:	681b      	ldr	r3, [r3, #0]
 800526c:	4618      	mov	r0, r3
 800526e:	f7fe fb65 	bl	800393c <TM_DELAY_TimerStart>
	//GPIO_WriteBit(LED2_GPIO_PORT, LED2_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED2_GPIO_PORT, LED2PIN)));
}
 8005272:	bf00      	nop
 8005274:	bd80      	pop	{r7, pc}
 8005276:	bf00      	nop
 8005278:	40011400 	.word	0x40011400
 800527c:	40010c00 	.word	0x40010c00
 8005280:	40011000 	.word	0x40011000
 8005284:	200001cc 	.word	0x200001cc
 8005288:	200002f0 	.word	0x200002f0

0800528c <BlinkLed3>:

void BlinkLed3()
{
 800528c:	b580      	push	{r7, lr}
 800528e:	af00      	add	r7, sp, #0
	GPIO_SetBits(LED4_GPIO_PORT,LED4_PIN);
 8005290:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8005294:	4810      	ldr	r0, [pc, #64]	; (80052d8 <BlinkLed3+0x4c>)
 8005296:	f7ff f81b 	bl	80042d0 <GPIO_SetBits>
	GPIO_ResetBits(LED1_GPIO_PORT,LED1_PIN);
 800529a:	2120      	movs	r1, #32
 800529c:	480f      	ldr	r0, [pc, #60]	; (80052dc <BlinkLed3+0x50>)
 800529e:	f7ff f825 	bl	80042ec <GPIO_ResetBits>
	GPIO_ResetBits(LED2_GPIO_PORT,LED2_PIN);
 80052a2:	2104      	movs	r1, #4
 80052a4:	480e      	ldr	r0, [pc, #56]	; (80052e0 <BlinkLed3+0x54>)
 80052a6:	f7ff f821 	bl	80042ec <GPIO_ResetBits>

    test_state = TEMP_TIMER_START;
 80052aa:	4b0e      	ldr	r3, [pc, #56]	; (80052e4 <BlinkLed3+0x58>)
 80052ac:	2200      	movs	r2, #0
 80052ae:	701a      	strb	r2, [r3, #0]
    TM_DELAY_TimerStop(TestTimer);
 80052b0:	4b0d      	ldr	r3, [pc, #52]	; (80052e8 <BlinkLed3+0x5c>)
 80052b2:	681b      	ldr	r3, [r3, #0]
 80052b4:	4618      	mov	r0, r3
 80052b6:	f7fe fb31 	bl	800391c <TM_DELAY_TimerStop>
    TM_DELAY_TimerAutoReloadValue(TestTimer, (6000));
 80052ba:	4b0b      	ldr	r3, [pc, #44]	; (80052e8 <BlinkLed3+0x5c>)
 80052bc:	681b      	ldr	r3, [r3, #0]
 80052be:	f241 7170 	movw	r1, #6000	; 0x1770
 80052c2:	4618      	mov	r0, r3
 80052c4:	f7fe fb4a 	bl	800395c <TM_DELAY_TimerAutoReloadValue>
    TM_DELAY_TimerStart(TestTimer);
 80052c8:	4b07      	ldr	r3, [pc, #28]	; (80052e8 <BlinkLed3+0x5c>)
 80052ca:	681b      	ldr	r3, [r3, #0]
 80052cc:	4618      	mov	r0, r3
 80052ce:	f7fe fb35 	bl	800393c <TM_DELAY_TimerStart>
	//GPIO_WriteBit(LED3_GPIO_PORT, LED3_PIN, (BitAction)(1 - GPIO_ReadOutputDataBit(LED3_GPIO_PORT, LED3_PIN)));
}
 80052d2:	bf00      	nop
 80052d4:	bd80      	pop	{r7, pc}
 80052d6:	bf00      	nop
 80052d8:	40011000 	.word	0x40011000
 80052dc:	40010c00 	.word	0x40010c00
 80052e0:	40011400 	.word	0x40011400
 80052e4:	200001cc 	.word	0x200001cc
 80052e8:	200002f0 	.word	0x200002f0

080052ec <ADCT_BGS_Initialize_system>:
void ADCT_BGS_Initialize_system(void)
{
 80052ec:	b580      	push	{r7, lr}
 80052ee:	b082      	sub	sp, #8
 80052f0:	af00      	add	r7, sp, #0
	uint16_t HighByte =0, LowByte =0;
 80052f2:	2300      	movs	r3, #0
 80052f4:	80fb      	strh	r3, [r7, #6]
 80052f6:	2300      	movs	r3, #0
 80052f8:	80bb      	strh	r3, [r7, #4]
	ADCT_BGS_AIR_1_2_OFF();
 80052fa:	2140      	movs	r1, #64	; 0x40
 80052fc:	48b7      	ldr	r0, [pc, #732]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 80052fe:	f7fe fff5 	bl	80042ec <GPIO_ResetBits>
 8005302:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8005306:	48b6      	ldr	r0, [pc, #728]	; (80055e0 <ADCT_BGS_Initialize_system+0x2f4>)
 8005308:	f7fe fff0 	bl	80042ec <GPIO_ResetBits>
	ADCT_BGS_AIR_3_4_OFF();
 800530c:	2180      	movs	r1, #128	; 0x80
 800530e:	48b3      	ldr	r0, [pc, #716]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 8005310:	f7fe ffec 	bl	80042ec <GPIO_ResetBits>
 8005314:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8005318:	48b0      	ldr	r0, [pc, #704]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 800531a:	f7fe ffe7 	bl	80042ec <GPIO_ResetBits>
	ADCT_BGS_FAN_OFF();
 800531e:	2104      	movs	r1, #4
 8005320:	48ae      	ldr	r0, [pc, #696]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 8005322:	f7fe ffe3 	bl	80042ec <GPIO_ResetBits>
 8005326:	2108      	movs	r1, #8
 8005328:	48ac      	ldr	r0, [pc, #688]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 800532a:	f7fe ffdf 	bl	80042ec <GPIO_ResetBits>
 800532e:	2110      	movs	r1, #16
 8005330:	48aa      	ldr	r0, [pc, #680]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 8005332:	f7fe ffdb 	bl	80042ec <GPIO_ResetBits>
 8005336:	2120      	movs	r1, #32
 8005338:	48a8      	ldr	r0, [pc, #672]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 800533a:	f7fe ffd7 	bl	80042ec <GPIO_ResetBits>
	ADCT_BGS_RELAY_LAMP_OFF();
 800533e:	2200      	movs	r2, #0
 8005340:	2101      	movs	r1, #1
 8005342:	48a6      	ldr	r0, [pc, #664]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 8005344:	f7fe ffe0 	bl	8004308 <GPIO_WriteBit>
	ADCT_BGS_RELAY_BUZZER_OFF();
 8005348:	2200      	movs	r2, #0
 800534a:	2102      	movs	r1, #2
 800534c:	48a3      	ldr	r0, [pc, #652]	; (80055dc <ADCT_BGS_Initialize_system+0x2f0>)
 800534e:	f7fe ffdb 	bl	8004308 <GPIO_WriteBit>
	// Read parameters saved in EEPROM
	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_TEMPERATURE_T1_LOW );
 8005352:	2001      	movs	r0, #1
 8005354:	f7fd fb9c 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005358:	4603      	mov	r3, r0
 800535a:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_TEMPERATURE_T1_HIGH );
 800535c:	2002      	movs	r0, #2
 800535e:	f7fd fb97 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005362:	4603      	mov	r3, r0
 8005364:	80fb      	strh	r3, [r7, #6]

	GstSystemSetting.usLowTemperatureT1 = HighByte*256 + LowByte;
 8005366:	88fb      	ldrh	r3, [r7, #6]
 8005368:	021b      	lsls	r3, r3, #8
 800536a:	b29a      	uxth	r2, r3
 800536c:	88bb      	ldrh	r3, [r7, #4]
 800536e:	4413      	add	r3, r2
 8005370:	b29a      	uxth	r2, r3
 8005372:	4b9c      	ldr	r3, [pc, #624]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005374:	801a      	strh	r2, [r3, #0]
	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_TEMPERATURE_T2_LOW );
 8005376:	2003      	movs	r0, #3
 8005378:	f7fd fb8a 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800537c:	4603      	mov	r3, r0
 800537e:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_TEMPERATURE_T2_HIGH );
 8005380:	2004      	movs	r0, #4
 8005382:	f7fd fb85 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005386:	4603      	mov	r3, r0
 8005388:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usHighTemperatureT2 = (uint16_t)(HighByte*256 + LowByte);
 800538a:	88fb      	ldrh	r3, [r7, #6]
 800538c:	021b      	lsls	r3, r3, #8
 800538e:	b29a      	uxth	r2, r3
 8005390:	88bb      	ldrh	r3, [r7, #4]
 8005392:	4413      	add	r3, r2
 8005394:	b29a      	uxth	r2, r3
 8005396:	4b93      	ldr	r3, [pc, #588]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005398:	805a      	strh	r2, [r3, #2]

	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_HUMIDITY_H1_LOW );
 800539a:	2007      	movs	r0, #7
 800539c:	f7fd fb78 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80053a0:	4603      	mov	r3, r0
 80053a2:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_HUMIDITY_H1_HIGH);
 80053a4:	2008      	movs	r0, #8
 80053a6:	f7fd fb73 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80053aa:	4603      	mov	r3, r0
 80053ac:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usLowHumidityH1 = HighByte*256 + LowByte;
 80053ae:	88fb      	ldrh	r3, [r7, #6]
 80053b0:	021b      	lsls	r3, r3, #8
 80053b2:	b29a      	uxth	r2, r3
 80053b4:	88bb      	ldrh	r3, [r7, #4]
 80053b6:	4413      	add	r3, r2
 80053b8:	b29a      	uxth	r2, r3
 80053ba:	4b8a      	ldr	r3, [pc, #552]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 80053bc:	80da      	strh	r2, [r3, #6]

	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_HUMIDITY_H2_LOW);
 80053be:	2009      	movs	r0, #9
 80053c0:	f7fd fb66 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80053c4:	4603      	mov	r3, r0
 80053c6:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_HUMIDITY_H2_HIGH);
 80053c8:	200a      	movs	r0, #10
 80053ca:	f7fd fb61 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80053ce:	4603      	mov	r3, r0
 80053d0:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usHighHumidityH2 = HighByte*256 + LowByte;
 80053d2:	88fb      	ldrh	r3, [r7, #6]
 80053d4:	021b      	lsls	r3, r3, #8
 80053d6:	b29a      	uxth	r2, r3
 80053d8:	88bb      	ldrh	r3, [r7, #4]
 80053da:	4413      	add	r3, r2
 80053dc:	b29a      	uxth	r2, r3
 80053de:	4b81      	ldr	r3, [pc, #516]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 80053e0:	811a      	strh	r2, [r3, #8]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_MINSWITCHINGTIME_HOUR);
 80053e2:	201f      	movs	r0, #31
 80053e4:	f7fd fb54 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80053e8:	4603      	mov	r3, r0
 80053ea:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_MINSWITCHINGTIME_MINUTE);
 80053ec:	2020      	movs	r0, #32
 80053ee:	f7fd fb4f 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80053f2:	4603      	mov	r3, r0
 80053f4:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.ulMinSwitchingTime = LowByte*3600 + HighByte*60;
 80053f6:	88bb      	ldrh	r3, [r7, #4]
 80053f8:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80053fc:	fb02 f103 	mul.w	r1, r2, r3
 8005400:	88fa      	ldrh	r2, [r7, #6]
 8005402:	4613      	mov	r3, r2
 8005404:	011b      	lsls	r3, r3, #4
 8005406:	1a9b      	subs	r3, r3, r2
 8005408:	009b      	lsls	r3, r3, #2
 800540a:	440b      	add	r3, r1
 800540c:	461a      	mov	r2, r3
 800540e:	4b75      	ldr	r3, [pc, #468]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005410:	621a      	str	r2, [r3, #32]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_HOUR);
 8005412:	200b      	movs	r0, #11
 8005414:	f7fd fb3c 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005418:	4603      	mov	r3, r0
 800541a:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_MINUTE);
 800541c:	200c      	movs	r0, #12
 800541e:	f7fd fb37 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005422:	4603      	mov	r3, r0
 8005424:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.ulSwitchingTime = LowByte*3600 + HighByte*60;
 8005426:	88bb      	ldrh	r3, [r7, #4]
 8005428:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800542c:	fb02 f103 	mul.w	r1, r2, r3
 8005430:	88fa      	ldrh	r2, [r7, #6]
 8005432:	4613      	mov	r3, r2
 8005434:	011b      	lsls	r3, r3, #4
 8005436:	1a9b      	subs	r3, r3, r2
 8005438:	009b      	lsls	r3, r3, #2
 800543a:	440b      	add	r3, r1
 800543c:	461a      	mov	r2, r3
 800543e:	4b69      	ldr	r3, [pc, #420]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005440:	61da      	str	r2, [r3, #28]
	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_FAN_TEMPERATURE_T3_LOW);
 8005442:	2005      	movs	r0, #5
 8005444:	f7fd fb24 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005448:	4603      	mov	r3, r0
 800544a:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_FAN_TEMPERATURE_T3_HIGH);
 800544c:	2006      	movs	r0, #6
 800544e:	f7fd fb1f 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005452:	4603      	mov	r3, r0
 8005454:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usFanTemperatureT3 = HighByte*256 + LowByte;
 8005456:	88fb      	ldrh	r3, [r7, #6]
 8005458:	021b      	lsls	r3, r3, #8
 800545a:	b29a      	uxth	r2, r3
 800545c:	88bb      	ldrh	r3, [r7, #4]
 800545e:	4413      	add	r3, r2
 8005460:	b29a      	uxth	r2, r3
 8005462:	4b60      	ldr	r3, [pc, #384]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005464:	809a      	strh	r2, [r3, #4]
	GstSystemSetting.ucDoorBurglarEnableAlarm = ADCT_AT24C64_ReadOneByte(EPPROM_DOORBURGLAR_ENABLEALARM);
 8005466:	200d      	movs	r0, #13
 8005468:	f7fd fb12 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800546c:	4603      	mov	r3, r0
 800546e:	461a      	mov	r2, r3
 8005470:	4b5c      	ldr	r3, [pc, #368]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005472:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
	GstSystemSetting.ucEnableAlarm = ADCT_AT24C64_ReadOneByte(EPPROM_ENABLE_ALARM);;
 8005476:	200e      	movs	r0, #14
 8005478:	f7fd fb0a 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800547c:	4603      	mov	r3, r0
 800547e:	461a      	mov	r2, r3
 8005480:	4b58      	ldr	r3, [pc, #352]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005482:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_LOW);
 8005486:	200f      	movs	r0, #15
 8005488:	f7fd fb02 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800548c:	4603      	mov	r3, r0
 800548e:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH);
 8005490:	2010      	movs	r0, #16
 8005492:	f7fd fafd 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005496:	4603      	mov	r3, r0
 8005498:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.ulAlarmDuration = LowByte*3600+ HighByte*60;
 800549a:	88bb      	ldrh	r3, [r7, #4]
 800549c:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80054a0:	fb02 f103 	mul.w	r1, r2, r3
 80054a4:	88fa      	ldrh	r2, [r7, #6]
 80054a6:	4613      	mov	r3, r2
 80054a8:	011b      	lsls	r3, r3, #4
 80054aa:	1a9b      	subs	r3, r3, r2
 80054ac:	009b      	lsls	r3, r3, #2
 80054ae:	440b      	add	r3, r1
 80054b0:	461a      	mov	r2, r3
 80054b2:	4b4c      	ldr	r3, [pc, #304]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 80054b4:	62da      	str	r2, [r3, #44]	; 0x2c
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENBATTERYVOLTAGEALARMVALUE_LOW);
 80054b6:	2011      	movs	r0, #17
 80054b8:	f7fd faea 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80054bc:	4603      	mov	r3, r0
 80054be:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENBATTERYVOLTAGEALARMVALUE_HIGH);
 80054c0:	2012      	movs	r0, #18
 80054c2:	f7fd fae5 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80054c6:	4603      	mov	r3, r0
 80054c8:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usGenBatteryVoltageAlarmValue = HighByte*256 + LowByte;
 80054ca:	88fb      	ldrh	r3, [r7, #6]
 80054cc:	021b      	lsls	r3, r3, #8
 80054ce:	b29a      	uxth	r2, r3
 80054d0:	88bb      	ldrh	r3, [r7, #4]
 80054d2:	4413      	add	r3, r2
 80054d4:	b29a      	uxth	r2, r3
 80054d6:	4b43      	ldr	r3, [pc, #268]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 80054d8:	825a      	strh	r2, [r3, #18]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENCOOLANTTEMPALARMVALUE_LOW);
 80054da:	2013      	movs	r0, #19
 80054dc:	f7fd fad8 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80054e0:	4603      	mov	r3, r0
 80054e2:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENCOOLANTTEMPALARMVALUE_HIGH);
 80054e4:	2014      	movs	r0, #20
 80054e6:	f7fd fad3 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80054ea:	4603      	mov	r3, r0
 80054ec:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usGenCoolantTempAlarmValue = HighByte*256 + LowByte;
 80054ee:	88fb      	ldrh	r3, [r7, #6]
 80054f0:	021b      	lsls	r3, r3, #8
 80054f2:	b29a      	uxth	r2, r3
 80054f4:	88bb      	ldrh	r3, [r7, #4]
 80054f6:	4413      	add	r3, r2
 80054f8:	b29a      	uxth	r2, r3
 80054fa:	4b3a      	ldr	r3, [pc, #232]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 80054fc:	829a      	strh	r2, [r3, #20]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENENGINESPEEDALARMVALUE_LOW);
 80054fe:	2015      	movs	r0, #21
 8005500:	f7fd fac6 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005504:	4603      	mov	r3, r0
 8005506:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENENGINESPEEDALARMVALUE_HIGH);
 8005508:	2016      	movs	r0, #22
 800550a:	f7fd fac1 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800550e:	4603      	mov	r3, r0
 8005510:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usGenEngineSpeedAlarmValue =  HighByte*256 + LowByte;
 8005512:	88fb      	ldrh	r3, [r7, #6]
 8005514:	021b      	lsls	r3, r3, #8
 8005516:	b29a      	uxth	r2, r3
 8005518:	88bb      	ldrh	r3, [r7, #4]
 800551a:	4413      	add	r3, r2
 800551c:	b29a      	uxth	r2, r3
 800551e:	4b31      	ldr	r3, [pc, #196]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005520:	82da      	strh	r2, [r3, #22]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENFUELLOWVALUE_LOW);
 8005522:	2017      	movs	r0, #23
 8005524:	f7fd fab4 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005528:	4603      	mov	r3, r0
 800552a:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENFUELLOWVALUE_HIGH);
 800552c:	2018      	movs	r0, #24
 800552e:	f7fd faaf 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005532:	4603      	mov	r3, r0
 8005534:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usGenFuelLowValue = HighByte*256 + LowByte;
 8005536:	88fb      	ldrh	r3, [r7, #6]
 8005538:	021b      	lsls	r3, r3, #8
 800553a:	b29a      	uxth	r2, r3
 800553c:	88bb      	ldrh	r3, [r7, #4]
 800553e:	4413      	add	r3, r2
 8005540:	b29a      	uxth	r2, r3
 8005542:	4b28      	ldr	r3, [pc, #160]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005544:	81da      	strh	r2, [r3, #14]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENOILPRESSUREALARMVALUE_LOW);
 8005546:	2019      	movs	r0, #25
 8005548:	f7fd faa2 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800554c:	4603      	mov	r3, r0
 800554e:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENOILPRESSUREALARMVALUE_HIGH);
 8005550:	201a      	movs	r0, #26
 8005552:	f7fd fa9d 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005556:	4603      	mov	r3, r0
 8005558:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usGenOilPressureAlarmValue = HighByte*256 + LowByte;
 800555a:	88fb      	ldrh	r3, [r7, #6]
 800555c:	021b      	lsls	r3, r3, #8
 800555e:	b29a      	uxth	r2, r3
 8005560:	88bb      	ldrh	r3, [r7, #4]
 8005562:	4413      	add	r3, r2
 8005564:	b29a      	uxth	r2, r3
 8005566:	4b1f      	ldr	r3, [pc, #124]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 8005568:	831a      	strh	r2, [r3, #24]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENVOLTAGEALARMVALUE_LOW);
 800556a:	201b      	movs	r0, #27
 800556c:	f7fd fa90 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005570:	4603      	mov	r3, r0
 8005572:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENVOLTAGEALARMVALUE_HIGH);
 8005574:	201c      	movs	r0, #28
 8005576:	f7fd fa8b 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800557a:	4603      	mov	r3, r0
 800557c:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usGenVoltageAlarmValue = HighByte*256 + LowByte;
 800557e:	88fb      	ldrh	r3, [r7, #6]
 8005580:	021b      	lsls	r3, r3, #8
 8005582:	b29a      	uxth	r2, r3
 8005584:	88bb      	ldrh	r3, [r7, #4]
 8005586:	4413      	add	r3, r2
 8005588:	b29a      	uxth	r2, r3
 800558a:	4b16      	ldr	r3, [pc, #88]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 800558c:	821a      	strh	r2, [r3, #16]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_LOWMAINVOLTAGE_LOW);
 800558e:	201d      	movs	r0, #29
 8005590:	f7fd fa7e 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 8005594:	4603      	mov	r3, r0
 8005596:	80bb      	strh	r3, [r7, #4]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_LOWMAINVOLTAGE_HIGH);
 8005598:	201e      	movs	r0, #30
 800559a:	f7fd fa79 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 800559e:	4603      	mov	r3, r0
 80055a0:	80fb      	strh	r3, [r7, #6]
	GstSystemSetting.usLowMainVoltage = HighByte*256 + LowByte;
 80055a2:	88fb      	ldrh	r3, [r7, #6]
 80055a4:	021b      	lsls	r3, r3, #8
 80055a6:	b29a      	uxth	r2, r3
 80055a8:	88bb      	ldrh	r3, [r7, #4]
 80055aa:	4413      	add	r3, r2
 80055ac:	b29a      	uxth	r2, r3
 80055ae:	4b0d      	ldr	r3, [pc, #52]	; (80055e4 <ADCT_BGS_Initialize_system+0x2f8>)
 80055b0:	815a      	strh	r2, [r3, #10]

	g_ADCT_BGS_TimerManager.SWitchingTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_HOUR);
 80055b2:	200b      	movs	r0, #11
 80055b4:	f7fd fa6c 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80055b8:	4603      	mov	r3, r0
 80055ba:	461a      	mov	r2, r3
 80055bc:	4b0a      	ldr	r3, [pc, #40]	; (80055e8 <ADCT_BGS_Initialize_system+0x2fc>)
 80055be:	701a      	strb	r2, [r3, #0]
	g_ADCT_BGS_TimerManager.SWitchingTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_MINUTE);;
 80055c0:	200c      	movs	r0, #12
 80055c2:	f7fd fa65 	bl	8002a90 <ADCT_AT24C64_ReadOneByte>
 80055c6:	4603      	mov	r3, r0
 80055c8:	461a      	mov	r2, r3
 80055ca:	4b07      	ldr	r3, [pc, #28]	; (80055e8 <ADCT_BGS_Initialize_system+0x2fc>)
 80055cc:	705a      	strb	r2, [r3, #1]
	g_ADCT_BGS_TimerManager.SWitchingTimer.second = 0;
 80055ce:	4b06      	ldr	r3, [pc, #24]	; (80055e8 <ADCT_BGS_Initialize_system+0x2fc>)
 80055d0:	2200      	movs	r2, #0
 80055d2:	709a      	strb	r2, [r3, #2]

}
 80055d4:	bf00      	nop
 80055d6:	3708      	adds	r7, #8
 80055d8:	46bd      	mov	sp, r7
 80055da:	bd80      	pop	{r7, pc}
 80055dc:	40010800 	.word	0x40010800
 80055e0:	40011000 	.word	0x40011000
 80055e4:	20000204 	.word	0x20000204
 80055e8:	200001e0 	.word	0x200001e0

080055ec <ADCT_BGS_Factory_Reset>:

void ADCT_BGS_Factory_Reset(void)
{
 80055ec:	b580      	push	{r7, lr}
 80055ee:	af00      	add	r7, sp, #0
	// Load default parameter
	ADCT_AT24C64_WriteOneBytes(EEPROM_LOW_TEMPERATURE_T1_LOW,(uint8_t)(DEFAULT_LOW_TEMPERATURE_T1%256));
 80055f0:	21a0      	movs	r1, #160	; 0xa0
 80055f2:	2001      	movs	r0, #1
 80055f4:	f7fd fa66 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_LOW_TEMPERATURE_T1_HIGH, (uint8_t)(DEFAULT_LOW_TEMPERATURE_T1/256));
 80055f8:	2100      	movs	r1, #0
 80055fa:	2002      	movs	r0, #2
 80055fc:	f7fd fa62 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_HIGH_TEMPERATURE_T2_LOW	,(uint8_t)(DEFAULT_HIGH_TEMPERATURE_T2%256));
 8005600:	2172      	movs	r1, #114	; 0x72
 8005602:	2003      	movs	r0, #3
 8005604:	f7fd fa5e 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_HIGH_TEMPERATURE_T2_HIGH	, (uint8_t)(DEFAULT_HIGH_TEMPERATURE_T2/256));
 8005608:	2101      	movs	r1, #1
 800560a:	2004      	movs	r0, #4
 800560c:	f7fd fa5a 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_FAN_TEMPERATURE_T3_LOW, (uint8_t)(DEFAULT_FANTEMPERATURET3%256));
 8005610:	214a      	movs	r1, #74	; 0x4a
 8005612:	2005      	movs	r0, #5
 8005614:	f7fd fa56 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_FAN_TEMPERATURE_T3_HIGH,(uint8_t)(DEFAULT_FANTEMPERATURET3/256));
 8005618:	2101      	movs	r1, #1
 800561a:	2006      	movs	r0, #6
 800561c:	f7fd fa52 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_LOW_HUMIDITY_H1_LOW, (uint8_t)(DEFAULT_LOW_HUMIDITY_H1%256));
 8005620:	2190      	movs	r1, #144	; 0x90
 8005622:	2007      	movs	r0, #7
 8005624:	f7fd fa4e 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_LOW_HUMIDITY_H1_HIGH, (uint8_t)(DEFAULT_LOW_HUMIDITY_H1/256));
 8005628:	2101      	movs	r1, #1
 800562a:	2008      	movs	r0, #8
 800562c:	f7fd fa4a 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_HIGH_HUMIDITY_H2_LOW, (uint8_t)(DEFAULT_HIGH_HUMIDITY_H2%256));
 8005630:	2184      	movs	r1, #132	; 0x84
 8005632:	2009      	movs	r0, #9
 8005634:	f7fd fa46 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_HIGH_HUMIDITY_H2_HIGH, (uint8_t)(DEFAULT_HIGH_HUMIDITY_H2/256));
 8005638:	2103      	movs	r1, #3
 800563a:	200a      	movs	r0, #10
 800563c:	f7fd fa42 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_HOUR, (uint8_t)(DEFAULT_TIME_CHANGE_HOUR));
 8005640:	2118      	movs	r1, #24
 8005642:	200b      	movs	r0, #11
 8005644:	f7fd fa3e 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_MINUTE, (uint8_t)(DEFAULT_TIME_CHANGE_MINUTE));
 8005648:	2100      	movs	r1, #0
 800564a:	200c      	movs	r0, #12
 800564c:	f7fd fa3a 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_DOORBURGLAR_ENABLEALARM, (uint8_t)(DEFAULT_DOORBURGLARENABLEALARM));
 8005650:	2101      	movs	r1, #1
 8005652:	200d      	movs	r0, #13
 8005654:	f7fd fa36 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_ENABLE_ALARM, (uint8_t)(DEFAULT_ENABLEALARM));
 8005658:	2101      	movs	r1, #1
 800565a:	200e      	movs	r0, #14
 800565c:	f7fd fa32 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_ALARMDURATION_LOW, (uint8_t)(DEFAULT_ALARMDURATION%256));
 8005660:	2132      	movs	r1, #50	; 0x32
 8005662:	200f      	movs	r0, #15
 8005664:	f7fd fa2e 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_ALARMDURATION_HIGH, (uint8_t)(DEFAULT_ALARMDURATION/256));
 8005668:	2100      	movs	r1, #0
 800566a:	2010      	movs	r0, #16
 800566c:	f7fd fa2a 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENBATTERYVOLTAGEALARMVALUE_LOW, (uint8_t)(DEFAULT_GENBATTERYVOLTAGEALARMVALUE%256));
 8005670:	210c      	movs	r1, #12
 8005672:	2011      	movs	r0, #17
 8005674:	f7fd fa26 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENBATTERYVOLTAGEALARMVALUE_HIGH, (uint8_t)(DEFAULT_GENBATTERYVOLTAGEALARMVALUE/256));
 8005678:	2100      	movs	r1, #0
 800567a:	2012      	movs	r0, #18
 800567c:	f7fd fa22 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENCOOLANTTEMPALARMVALUE_LOW, (uint8_t)(DEFAULT_GENCOOLANTTEMPALARMVALUE%256));
 8005680:	2162      	movs	r1, #98	; 0x62
 8005682:	2013      	movs	r0, #19
 8005684:	f7fd fa1e 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENCOOLANTTEMPALARMVALUE_HIGH, (uint8_t)(DEFAULT_GENCOOLANTTEMPALARMVALUE/256));
 8005688:	2100      	movs	r1, #0
 800568a:	2014      	movs	r0, #20
 800568c:	f7fd fa1a 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENENGINESPEEDALARMVALUE_LOW,(uint8_t)(DEFAULT_GENENGINESPEEDALARMVALUE%256));
 8005690:	2154      	movs	r1, #84	; 0x54
 8005692:	2015      	movs	r0, #21
 8005694:	f7fd fa16 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENENGINESPEEDALARMVALUE_HIGH	,(uint8_t)(DEFAULT_GENENGINESPEEDALARMVALUE/256));
 8005698:	210b      	movs	r1, #11
 800569a:	2016      	movs	r0, #22
 800569c:	f7fd fa12 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENFUELLOWVALUE_LOW	,(uint8_t)(DEFAULT_GENFUELLOWVALUE%256));
 80056a0:	2132      	movs	r1, #50	; 0x32
 80056a2:	2017      	movs	r0, #23
 80056a4:	f7fd fa0e 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENFUELLOWVALUE_HIGH, (uint8_t)(DEFAULT_GENFUELLOWVALUE/256));
 80056a8:	2100      	movs	r1, #0
 80056aa:	2018      	movs	r0, #24
 80056ac:	f7fd fa0a 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENOILPRESSUREALARMVALUE_LOW, (uint8_t)(DEFAULT_GENOILPRESSUREALARMVALUE%256));
 80056b0:	2100      	movs	r1, #0
 80056b2:	2019      	movs	r0, #25
 80056b4:	f7fd fa06 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENOILPRESSUREALARMVALUE_HIGH,(uint8_t)(DEFAULT_GENOILPRESSUREALARMVALUE/256));
 80056b8:	2100      	movs	r1, #0
 80056ba:	201a      	movs	r0, #26
 80056bc:	f7fd fa02 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENVOLTAGEALARMVALUE_LOW, (uint8_t)(DEFAULT_GENVOLTAGEALARMVALUE%256));
 80056c0:	21c8      	movs	r1, #200	; 0xc8
 80056c2:	201b      	movs	r0, #27
 80056c4:	f7fd f9fe 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_GENVOLTAGEALARMVALUE_HIGH	,(uint8_t)(DEFAULT_GENVOLTAGEALARMVALUE/256));
 80056c8:	2100      	movs	r1, #0
 80056ca:	201c      	movs	r0, #28
 80056cc:	f7fd f9fa 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_LOWMAINVOLTAGE_LOW, (uint8_t)(DEFAULT_LOWMAINVOLTAGE%256));
 80056d0:	21be      	movs	r1, #190	; 0xbe
 80056d2:	201d      	movs	r0, #29
 80056d4:	f7fd f9f6 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_LOWMAINVOLTAGE_HIGH, (uint8_t)(DEFAULT_LOWMAINVOLTAGE/256));
 80056d8:	2100      	movs	r1, #0
 80056da:	201e      	movs	r0, #30
 80056dc:	f7fd f9f2 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_HOUR	, (uint8_t)(DEFAULT_MINSWITCHINGTIME_HOUR));
 80056e0:	2100      	movs	r1, #0
 80056e2:	201f      	movs	r0, #31
 80056e4:	f7fd f9ee 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_MINUTE, (uint8_t)(DEFAULT_MINSWITCHINGTIME_MINUTE));
 80056e8:	210a      	movs	r1, #10
 80056ea:	2020      	movs	r0, #32
 80056ec:	f7fd f9ea 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_HIGHMAINVOLTAGE_LOW, (uint8_t)(DEFAULT_HIGHMAINVOLTAGE%256)				);
 80056f0:	21f0      	movs	r1, #240	; 0xf0
 80056f2:	2021      	movs	r0, #33	; 0x21
 80056f4:	f7fd f9e6 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_HIGHMAINVOLTAGE_HIGH,(uint8_t)(DEFAULT_HIGHMAINVOLTAGE/256)				);
 80056f8:	2100      	movs	r1, #0
 80056fa:	2022      	movs	r0, #34	; 0x22
 80056fc:	f7fd f9e2 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_HOUR	, (uint8_t)(DEFAULT_STAYOFFTIME_HOUR)				);
 8005700:	2100      	movs	r1, #0
 8005702:	2023      	movs	r0, #35	; 0x23
 8005704:	f7fd f9de 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_MINUTE, (uint8_t)(DEFAULT_STAYOFFTIME_MINUTE));
 8005708:	2105      	movs	r1, #5
 800570a:	2024      	movs	r0, #36	; 0x24
 800570c:	f7fd f9da 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_DEFAULT_DATE	,DEFAULT_BGS_DATE);
 8005710:	211e      	movs	r1, #30
 8005712:	2025      	movs	r0, #37	; 0x25
 8005714:	f7fd f9d6 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_DEFAULT_MONTH	,DEFAULT_BGS_MONTH);
 8005718:	2103      	movs	r1, #3
 800571a:	2026      	movs	r0, #38	; 0x26
 800571c:	f7fd f9d2 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_DEFAULT_YEAR	,DEFAULT_BGS_YEAR);
 8005720:	2111      	movs	r1, #17
 8005722:	2027      	movs	r0, #39	; 0x27
 8005724:	f7fd f9ce 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_DEFAULT_HOUR	,DEFAULT_BGS_HOUR)	;
 8005728:	2114      	movs	r1, #20
 800572a:	2028      	movs	r0, #40	; 0x28
 800572c:	f7fd f9ca 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_DEFAULT_MINUTE,DEFAULT_BGS_MINUTE);
 8005730:	2128      	movs	r1, #40	; 0x28
 8005732:	2029      	movs	r0, #41	; 0x29
 8005734:	f7fd f9c6 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_DEFAULT_SECOND,DEFAULT_BGS_SECOND);
 8005738:	2100      	movs	r1, #0
 800573a:	202a      	movs	r0, #42	; 0x2a
 800573c:	f7fd f9c2 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_ALARM_ID_LOW	, (uint8_t)(DEFAULT_ALARM_ID%256));
 8005740:	2108      	movs	r1, #8
 8005742:	202b      	movs	r0, #43	; 0x2b
 8005744:	f7fd f9be 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
	ADCT_AT24C64_WriteOneBytes(EEPROM_ALARM_ID_HIGH	,(uint8_t)(DEFAULT_ALARM_ID/256));
 8005748:	2100      	movs	r1, #0
 800574a:	202c      	movs	r0, #44	; 0x2c
 800574c:	f7fd f9ba 	bl	8002ac4 <ADCT_AT24C64_WriteOneBytes>
}
 8005750:	bf00      	nop
 8005752:	bd80      	pop	{r7, pc}

08005754 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8005754:	f8df d034 	ldr.w	sp, [pc, #52]	; 800578c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8005758:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 800575a:	e003      	b.n	8005764 <LoopCopyDataInit>

0800575c <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 800575c:	4b0c      	ldr	r3, [pc, #48]	; (8005790 <LoopFillZerobss+0x18>)
	ldr	r3, [r3, r1]
 800575e:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8005760:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8005762:	3104      	adds	r1, #4

08005764 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8005764:	480b      	ldr	r0, [pc, #44]	; (8005794 <LoopFillZerobss+0x1c>)
	ldr	r3, =_edata
 8005766:	4b0c      	ldr	r3, [pc, #48]	; (8005798 <LoopFillZerobss+0x20>)
	adds	r2, r0, r1
 8005768:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 800576a:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 800576c:	d3f6      	bcc.n	800575c <CopyDataInit>
	ldr	r2, =_sbss
 800576e:	4a0b      	ldr	r2, [pc, #44]	; (800579c <LoopFillZerobss+0x24>)
	b	LoopFillZerobss
 8005770:	e002      	b.n	8005778 <LoopFillZerobss>

08005772 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8005772:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8005774:	f842 3b04 	str.w	r3, [r2], #4

08005778 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8005778:	4b09      	ldr	r3, [pc, #36]	; (80057a0 <LoopFillZerobss+0x28>)
	cmp	r2, r3
 800577a:	429a      	cmp	r2, r3
	bcc	FillZerobss
 800577c:	d3f9      	bcc.n	8005772 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800577e:	f000 f841 	bl	8005804 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8005782:	f000 f8f9 	bl	8005978 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8005786:	f7ff fc93 	bl	80050b0 <main>
	bx	lr
 800578a:	4770      	bx	lr

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800578c:	20005000 	.word	0x20005000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8005790:	08005b04 	.word	0x08005b04
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8005794:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8005798:	20000084 	.word	0x20000084
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 800579c:	20000084 	.word	0x20000084
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 80057a0:	200002f8 	.word	0x200002f8

080057a4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80057a4:	e7fe      	b.n	80057a4 <ADC1_2_IRQHandler>
	...

080057a8 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 80057a8:	b480      	push	{r7}
 80057aa:	af00      	add	r7, sp, #0
}
 80057ac:	bf00      	nop
 80057ae:	46bd      	mov	sp, r7
 80057b0:	bc80      	pop	{r7}
 80057b2:	4770      	bx	lr

080057b4 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 80057b4:	b480      	push	{r7}
 80057b6:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 80057b8:	e7fe      	b.n	80057b8 <HardFault_Handler+0x4>
 80057ba:	bf00      	nop

080057bc <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 80057bc:	b480      	push	{r7}
 80057be:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 80057c0:	e7fe      	b.n	80057c0 <MemManage_Handler+0x4>
 80057c2:	bf00      	nop

080057c4 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 80057c4:	b480      	push	{r7}
 80057c6:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 80057c8:	e7fe      	b.n	80057c8 <BusFault_Handler+0x4>
 80057ca:	bf00      	nop

080057cc <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 80057cc:	b480      	push	{r7}
 80057ce:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 80057d0:	e7fe      	b.n	80057d0 <UsageFault_Handler+0x4>
 80057d2:	bf00      	nop

080057d4 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 80057d4:	b480      	push	{r7}
 80057d6:	af00      	add	r7, sp, #0
}
 80057d8:	bf00      	nop
 80057da:	46bd      	mov	sp, r7
 80057dc:	bc80      	pop	{r7}
 80057de:	4770      	bx	lr

080057e0 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 80057e0:	b480      	push	{r7}
 80057e2:	af00      	add	r7, sp, #0
}
 80057e4:	bf00      	nop
 80057e6:	46bd      	mov	sp, r7
 80057e8:	bc80      	pop	{r7}
 80057ea:	4770      	bx	lr

080057ec <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 80057ec:	b480      	push	{r7}
 80057ee:	af00      	add	r7, sp, #0
}
 80057f0:	bf00      	nop
 80057f2:	46bd      	mov	sp, r7
 80057f4:	bc80      	pop	{r7}
 80057f6:	4770      	bx	lr

080057f8 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 80057f8:	b580      	push	{r7, lr}
 80057fa:	af00      	add	r7, sp, #0
	HAL_IncTick();
 80057fc:	f7fe f8cc 	bl	8003998 <HAL_IncTick>
}
 8005800:	bf00      	nop
 8005802:	bd80      	pop	{r7, pc}

08005804 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8005804:	b580      	push	{r7, lr}
 8005806:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8005808:	4a15      	ldr	r2, [pc, #84]	; (8005860 <SystemInit+0x5c>)
 800580a:	4b15      	ldr	r3, [pc, #84]	; (8005860 <SystemInit+0x5c>)
 800580c:	681b      	ldr	r3, [r3, #0]
 800580e:	f043 0301 	orr.w	r3, r3, #1
 8005812:	6013      	str	r3, [r2, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8005814:	4912      	ldr	r1, [pc, #72]	; (8005860 <SystemInit+0x5c>)
 8005816:	4b12      	ldr	r3, [pc, #72]	; (8005860 <SystemInit+0x5c>)
 8005818:	685a      	ldr	r2, [r3, #4]
 800581a:	4b12      	ldr	r3, [pc, #72]	; (8005864 <SystemInit+0x60>)
 800581c:	4013      	ands	r3, r2
 800581e:	604b      	str	r3, [r1, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8005820:	4a0f      	ldr	r2, [pc, #60]	; (8005860 <SystemInit+0x5c>)
 8005822:	4b0f      	ldr	r3, [pc, #60]	; (8005860 <SystemInit+0x5c>)
 8005824:	681b      	ldr	r3, [r3, #0]
 8005826:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 800582a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800582e:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8005830:	4a0b      	ldr	r2, [pc, #44]	; (8005860 <SystemInit+0x5c>)
 8005832:	4b0b      	ldr	r3, [pc, #44]	; (8005860 <SystemInit+0x5c>)
 8005834:	681b      	ldr	r3, [r3, #0]
 8005836:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800583a:	6013      	str	r3, [r2, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800583c:	4a08      	ldr	r2, [pc, #32]	; (8005860 <SystemInit+0x5c>)
 800583e:	4b08      	ldr	r3, [pc, #32]	; (8005860 <SystemInit+0x5c>)
 8005840:	685b      	ldr	r3, [r3, #4]
 8005842:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 8005846:	6053      	str	r3, [r2, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8005848:	4b05      	ldr	r3, [pc, #20]	; (8005860 <SystemInit+0x5c>)
 800584a:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 800584e:	609a      	str	r2, [r3, #8]
  #endif /* DATA_IN_ExtSRAM */
#endif 

  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
  /* Configure the Flash Latency cycles and enable prefetch buffer */
  SetSysClock();
 8005850:	f000 f80c 	bl	800586c <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8005854:	4b04      	ldr	r3, [pc, #16]	; (8005868 <SystemInit+0x64>)
 8005856:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800585a:	609a      	str	r2, [r3, #8]
#endif 
}
 800585c:	bf00      	nop
 800585e:	bd80      	pop	{r7, pc}
 8005860:	40021000 	.word	0x40021000
 8005864:	f8ff0000 	.word	0xf8ff0000
 8005868:	e000ed00 	.word	0xe000ed00

0800586c <SetSysClock>:
  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 800586c:	b580      	push	{r7, lr}
 800586e:	af00      	add	r7, sp, #0
#elif defined SYSCLK_FREQ_48MHz
  SetSysClockTo48();
#elif defined SYSCLK_FREQ_56MHz
  SetSysClockTo56();  
#elif defined SYSCLK_FREQ_72MHz
  SetSysClockTo72();
 8005870:	f000 f802 	bl	8005878 <SetSysClockTo72>
#endif
 
 /* If none of the define above is enabled, the HSI is used as System clock
    source (default after reset) */ 
}
 8005874:	bf00      	nop
 8005876:	bd80      	pop	{r7, pc}

08005878 <SetSysClockTo72>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
 8005878:	b480      	push	{r7}
 800587a:	b083      	sub	sp, #12
 800587c:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800587e:	2300      	movs	r3, #0
 8005880:	607b      	str	r3, [r7, #4]
 8005882:	2300      	movs	r3, #0
 8005884:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8005886:	4a3a      	ldr	r2, [pc, #232]	; (8005970 <SetSysClockTo72+0xf8>)
 8005888:	4b39      	ldr	r3, [pc, #228]	; (8005970 <SetSysClockTo72+0xf8>)
 800588a:	681b      	ldr	r3, [r3, #0]
 800588c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005890:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8005892:	4b37      	ldr	r3, [pc, #220]	; (8005970 <SetSysClockTo72+0xf8>)
 8005894:	681b      	ldr	r3, [r3, #0]
 8005896:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800589a:	603b      	str	r3, [r7, #0]
    StartUpCounter++;  
 800589c:	687b      	ldr	r3, [r7, #4]
 800589e:	3301      	adds	r3, #1
 80058a0:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80058a2:	683b      	ldr	r3, [r7, #0]
 80058a4:	2b00      	cmp	r3, #0
 80058a6:	d103      	bne.n	80058b0 <SetSysClockTo72+0x38>
 80058a8:	687b      	ldr	r3, [r7, #4]
 80058aa:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80058ae:	d1f0      	bne.n	8005892 <SetSysClockTo72+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80058b0:	4b2f      	ldr	r3, [pc, #188]	; (8005970 <SetSysClockTo72+0xf8>)
 80058b2:	681b      	ldr	r3, [r3, #0]
 80058b4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80058b8:	2b00      	cmp	r3, #0
 80058ba:	d002      	beq.n	80058c2 <SetSysClockTo72+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
 80058bc:	2301      	movs	r3, #1
 80058be:	603b      	str	r3, [r7, #0]
 80058c0:	e001      	b.n	80058c6 <SetSysClockTo72+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80058c2:	2300      	movs	r3, #0
 80058c4:	603b      	str	r3, [r7, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
 80058c6:	683b      	ldr	r3, [r7, #0]
 80058c8:	2b01      	cmp	r3, #1
 80058ca:	d14b      	bne.n	8005964 <SetSysClockTo72+0xec>
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 80058cc:	4a29      	ldr	r2, [pc, #164]	; (8005974 <SetSysClockTo72+0xfc>)
 80058ce:	4b29      	ldr	r3, [pc, #164]	; (8005974 <SetSysClockTo72+0xfc>)
 80058d0:	681b      	ldr	r3, [r3, #0]
 80058d2:	f043 0310 	orr.w	r3, r3, #16
 80058d6:	6013      	str	r3, [r2, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 80058d8:	4a26      	ldr	r2, [pc, #152]	; (8005974 <SetSysClockTo72+0xfc>)
 80058da:	4b26      	ldr	r3, [pc, #152]	; (8005974 <SetSysClockTo72+0xfc>)
 80058dc:	681b      	ldr	r3, [r3, #0]
 80058de:	f023 0303 	bic.w	r3, r3, #3
 80058e2:	6013      	str	r3, [r2, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 80058e4:	4a23      	ldr	r2, [pc, #140]	; (8005974 <SetSysClockTo72+0xfc>)
 80058e6:	4b23      	ldr	r3, [pc, #140]	; (8005974 <SetSysClockTo72+0xfc>)
 80058e8:	681b      	ldr	r3, [r3, #0]
 80058ea:	f043 0302 	orr.w	r3, r3, #2
 80058ee:	6013      	str	r3, [r2, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 80058f0:	4a1f      	ldr	r2, [pc, #124]	; (8005970 <SetSysClockTo72+0xf8>)
 80058f2:	4b1f      	ldr	r3, [pc, #124]	; (8005970 <SetSysClockTo72+0xf8>)
 80058f4:	685b      	ldr	r3, [r3, #4]
 80058f6:	6053      	str	r3, [r2, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 80058f8:	4a1d      	ldr	r2, [pc, #116]	; (8005970 <SetSysClockTo72+0xf8>)
 80058fa:	4b1d      	ldr	r3, [pc, #116]	; (8005970 <SetSysClockTo72+0xf8>)
 80058fc:	685b      	ldr	r3, [r3, #4]
 80058fe:	6053      	str	r3, [r2, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8005900:	4a1b      	ldr	r2, [pc, #108]	; (8005970 <SetSysClockTo72+0xf8>)
 8005902:	4b1b      	ldr	r3, [pc, #108]	; (8005970 <SetSysClockTo72+0xf8>)
 8005904:	685b      	ldr	r3, [r3, #4]
 8005906:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800590a:	6053      	str	r3, [r2, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 800590c:	4a18      	ldr	r2, [pc, #96]	; (8005970 <SetSysClockTo72+0xf8>)
 800590e:	4b18      	ldr	r3, [pc, #96]	; (8005970 <SetSysClockTo72+0xf8>)
 8005910:	685b      	ldr	r3, [r3, #4]
 8005912:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8005916:	6053      	str	r3, [r2, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 8005918:	4a15      	ldr	r2, [pc, #84]	; (8005970 <SetSysClockTo72+0xf8>)
 800591a:	4b15      	ldr	r3, [pc, #84]	; (8005970 <SetSysClockTo72+0xf8>)
 800591c:	685b      	ldr	r3, [r3, #4]
 800591e:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 8005922:	6053      	str	r3, [r2, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8005924:	4a12      	ldr	r2, [pc, #72]	; (8005970 <SetSysClockTo72+0xf8>)
 8005926:	4b12      	ldr	r3, [pc, #72]	; (8005970 <SetSysClockTo72+0xf8>)
 8005928:	681b      	ldr	r3, [r3, #0]
 800592a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800592e:	6013      	str	r3, [r2, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8005930:	bf00      	nop
 8005932:	4b0f      	ldr	r3, [pc, #60]	; (8005970 <SetSysClockTo72+0xf8>)
 8005934:	681b      	ldr	r3, [r3, #0]
 8005936:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800593a:	2b00      	cmp	r3, #0
 800593c:	d0f9      	beq.n	8005932 <SetSysClockTo72+0xba>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800593e:	4a0c      	ldr	r2, [pc, #48]	; (8005970 <SetSysClockTo72+0xf8>)
 8005940:	4b0b      	ldr	r3, [pc, #44]	; (8005970 <SetSysClockTo72+0xf8>)
 8005942:	685b      	ldr	r3, [r3, #4]
 8005944:	f023 0303 	bic.w	r3, r3, #3
 8005948:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 800594a:	4a09      	ldr	r2, [pc, #36]	; (8005970 <SetSysClockTo72+0xf8>)
 800594c:	4b08      	ldr	r3, [pc, #32]	; (8005970 <SetSysClockTo72+0xf8>)
 800594e:	685b      	ldr	r3, [r3, #4]
 8005950:	f043 0302 	orr.w	r3, r3, #2
 8005954:	6053      	str	r3, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8005956:	bf00      	nop
 8005958:	4b05      	ldr	r3, [pc, #20]	; (8005970 <SetSysClockTo72+0xf8>)
 800595a:	685b      	ldr	r3, [r3, #4]
 800595c:	f003 030c 	and.w	r3, r3, #12
 8005960:	2b08      	cmp	r3, #8
 8005962:	d1f9      	bne.n	8005958 <SetSysClockTo72+0xe0>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
}
 8005964:	bf00      	nop
 8005966:	370c      	adds	r7, #12
 8005968:	46bd      	mov	sp, r7
 800596a:	bc80      	pop	{r7}
 800596c:	4770      	bx	lr
 800596e:	bf00      	nop
 8005970:	40021000 	.word	0x40021000
 8005974:	40022000 	.word	0x40022000

08005978 <__libc_init_array>:
 8005978:	4b0e      	ldr	r3, [pc, #56]	; (80059b4 <__libc_init_array+0x3c>)
 800597a:	b570      	push	{r4, r5, r6, lr}
 800597c:	461e      	mov	r6, r3
 800597e:	4c0e      	ldr	r4, [pc, #56]	; (80059b8 <__libc_init_array+0x40>)
 8005980:	2500      	movs	r5, #0
 8005982:	1ae4      	subs	r4, r4, r3
 8005984:	10a4      	asrs	r4, r4, #2
 8005986:	42a5      	cmp	r5, r4
 8005988:	d004      	beq.n	8005994 <__libc_init_array+0x1c>
 800598a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800598e:	4798      	blx	r3
 8005990:	3501      	adds	r5, #1
 8005992:	e7f8      	b.n	8005986 <__libc_init_array+0xe>
 8005994:	f000 f8a4 	bl	8005ae0 <_init>
 8005998:	4b08      	ldr	r3, [pc, #32]	; (80059bc <__libc_init_array+0x44>)
 800599a:	4c09      	ldr	r4, [pc, #36]	; (80059c0 <__libc_init_array+0x48>)
 800599c:	461e      	mov	r6, r3
 800599e:	1ae4      	subs	r4, r4, r3
 80059a0:	10a4      	asrs	r4, r4, #2
 80059a2:	2500      	movs	r5, #0
 80059a4:	42a5      	cmp	r5, r4
 80059a6:	d004      	beq.n	80059b2 <__libc_init_array+0x3a>
 80059a8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80059ac:	4798      	blx	r3
 80059ae:	3501      	adds	r5, #1
 80059b0:	e7f8      	b.n	80059a4 <__libc_init_array+0x2c>
 80059b2:	bd70      	pop	{r4, r5, r6, pc}
 80059b4:	08005afc 	.word	0x08005afc
 80059b8:	08005afc 	.word	0x08005afc
 80059bc:	08005afc 	.word	0x08005afc
 80059c0:	08005b00 	.word	0x08005b00

080059c4 <malloc>:
 80059c4:	4b02      	ldr	r3, [pc, #8]	; (80059d0 <malloc+0xc>)
 80059c6:	4601      	mov	r1, r0
 80059c8:	6818      	ldr	r0, [r3, #0]
 80059ca:	f000 b80b 	b.w	80059e4 <_malloc_r>
 80059ce:	bf00      	nop
 80059d0:	20000080 	.word	0x20000080

080059d4 <memset>:
 80059d4:	4603      	mov	r3, r0
 80059d6:	4402      	add	r2, r0
 80059d8:	4293      	cmp	r3, r2
 80059da:	d002      	beq.n	80059e2 <memset+0xe>
 80059dc:	f803 1b01 	strb.w	r1, [r3], #1
 80059e0:	e7fa      	b.n	80059d8 <memset+0x4>
 80059e2:	4770      	bx	lr

080059e4 <_malloc_r>:
 80059e4:	b570      	push	{r4, r5, r6, lr}
 80059e6:	1ccd      	adds	r5, r1, #3
 80059e8:	f025 0503 	bic.w	r5, r5, #3
 80059ec:	3508      	adds	r5, #8
 80059ee:	2d0c      	cmp	r5, #12
 80059f0:	bf38      	it	cc
 80059f2:	250c      	movcc	r5, #12
 80059f4:	2d00      	cmp	r5, #0
 80059f6:	4606      	mov	r6, r0
 80059f8:	db01      	blt.n	80059fe <_malloc_r+0x1a>
 80059fa:	42a9      	cmp	r1, r5
 80059fc:	d902      	bls.n	8005a04 <_malloc_r+0x20>
 80059fe:	230c      	movs	r3, #12
 8005a00:	6033      	str	r3, [r6, #0]
 8005a02:	e046      	b.n	8005a92 <_malloc_r+0xae>
 8005a04:	f000 f85c 	bl	8005ac0 <__malloc_lock>
 8005a08:	4b23      	ldr	r3, [pc, #140]	; (8005a98 <_malloc_r+0xb4>)
 8005a0a:	681c      	ldr	r4, [r3, #0]
 8005a0c:	461a      	mov	r2, r3
 8005a0e:	4621      	mov	r1, r4
 8005a10:	b1a1      	cbz	r1, 8005a3c <_malloc_r+0x58>
 8005a12:	680b      	ldr	r3, [r1, #0]
 8005a14:	1b5b      	subs	r3, r3, r5
 8005a16:	d40e      	bmi.n	8005a36 <_malloc_r+0x52>
 8005a18:	2b0b      	cmp	r3, #11
 8005a1a:	d903      	bls.n	8005a24 <_malloc_r+0x40>
 8005a1c:	600b      	str	r3, [r1, #0]
 8005a1e:	18cc      	adds	r4, r1, r3
 8005a20:	50cd      	str	r5, [r1, r3]
 8005a22:	e01e      	b.n	8005a62 <_malloc_r+0x7e>
 8005a24:	428c      	cmp	r4, r1
 8005a26:	bf0b      	itete	eq
 8005a28:	6863      	ldreq	r3, [r4, #4]
 8005a2a:	684b      	ldrne	r3, [r1, #4]
 8005a2c:	6013      	streq	r3, [r2, #0]
 8005a2e:	6063      	strne	r3, [r4, #4]
 8005a30:	bf18      	it	ne
 8005a32:	460c      	movne	r4, r1
 8005a34:	e015      	b.n	8005a62 <_malloc_r+0x7e>
 8005a36:	460c      	mov	r4, r1
 8005a38:	6849      	ldr	r1, [r1, #4]
 8005a3a:	e7e9      	b.n	8005a10 <_malloc_r+0x2c>
 8005a3c:	4c17      	ldr	r4, [pc, #92]	; (8005a9c <_malloc_r+0xb8>)
 8005a3e:	6823      	ldr	r3, [r4, #0]
 8005a40:	b91b      	cbnz	r3, 8005a4a <_malloc_r+0x66>
 8005a42:	4630      	mov	r0, r6
 8005a44:	f000 f82c 	bl	8005aa0 <_sbrk_r>
 8005a48:	6020      	str	r0, [r4, #0]
 8005a4a:	4629      	mov	r1, r5
 8005a4c:	4630      	mov	r0, r6
 8005a4e:	f000 f827 	bl	8005aa0 <_sbrk_r>
 8005a52:	1c43      	adds	r3, r0, #1
 8005a54:	d018      	beq.n	8005a88 <_malloc_r+0xa4>
 8005a56:	1cc4      	adds	r4, r0, #3
 8005a58:	f024 0403 	bic.w	r4, r4, #3
 8005a5c:	42a0      	cmp	r0, r4
 8005a5e:	d10d      	bne.n	8005a7c <_malloc_r+0x98>
 8005a60:	6025      	str	r5, [r4, #0]
 8005a62:	4630      	mov	r0, r6
 8005a64:	f000 f82d 	bl	8005ac2 <__malloc_unlock>
 8005a68:	f104 000b 	add.w	r0, r4, #11
 8005a6c:	1d23      	adds	r3, r4, #4
 8005a6e:	f020 0007 	bic.w	r0, r0, #7
 8005a72:	1ac3      	subs	r3, r0, r3
 8005a74:	d00e      	beq.n	8005a94 <_malloc_r+0xb0>
 8005a76:	425a      	negs	r2, r3
 8005a78:	50e2      	str	r2, [r4, r3]
 8005a7a:	bd70      	pop	{r4, r5, r6, pc}
 8005a7c:	1a21      	subs	r1, r4, r0
 8005a7e:	4630      	mov	r0, r6
 8005a80:	f000 f80e 	bl	8005aa0 <_sbrk_r>
 8005a84:	3001      	adds	r0, #1
 8005a86:	d1eb      	bne.n	8005a60 <_malloc_r+0x7c>
 8005a88:	230c      	movs	r3, #12
 8005a8a:	6033      	str	r3, [r6, #0]
 8005a8c:	4630      	mov	r0, r6
 8005a8e:	f000 f818 	bl	8005ac2 <__malloc_unlock>
 8005a92:	2000      	movs	r0, #0
 8005a94:	bd70      	pop	{r4, r5, r6, pc}
 8005a96:	bf00      	nop
 8005a98:	200001d4 	.word	0x200001d4
 8005a9c:	200001d0 	.word	0x200001d0

08005aa0 <_sbrk_r>:
 8005aa0:	b538      	push	{r3, r4, r5, lr}
 8005aa2:	4c06      	ldr	r4, [pc, #24]	; (8005abc <_sbrk_r+0x1c>)
 8005aa4:	2300      	movs	r3, #0
 8005aa6:	4605      	mov	r5, r0
 8005aa8:	4608      	mov	r0, r1
 8005aaa:	6023      	str	r3, [r4, #0]
 8005aac:	f000 f80a 	bl	8005ac4 <_sbrk>
 8005ab0:	1c43      	adds	r3, r0, #1
 8005ab2:	d102      	bne.n	8005aba <_sbrk_r+0x1a>
 8005ab4:	6823      	ldr	r3, [r4, #0]
 8005ab6:	b103      	cbz	r3, 8005aba <_sbrk_r+0x1a>
 8005ab8:	602b      	str	r3, [r5, #0]
 8005aba:	bd38      	pop	{r3, r4, r5, pc}
 8005abc:	200002f4 	.word	0x200002f4

08005ac0 <__malloc_lock>:
 8005ac0:	4770      	bx	lr

08005ac2 <__malloc_unlock>:
 8005ac2:	4770      	bx	lr

08005ac4 <_sbrk>:
 8005ac4:	4b04      	ldr	r3, [pc, #16]	; (8005ad8 <_sbrk+0x14>)
 8005ac6:	4602      	mov	r2, r0
 8005ac8:	6819      	ldr	r1, [r3, #0]
 8005aca:	b909      	cbnz	r1, 8005ad0 <_sbrk+0xc>
 8005acc:	4903      	ldr	r1, [pc, #12]	; (8005adc <_sbrk+0x18>)
 8005ace:	6019      	str	r1, [r3, #0]
 8005ad0:	6818      	ldr	r0, [r3, #0]
 8005ad2:	4402      	add	r2, r0
 8005ad4:	601a      	str	r2, [r3, #0]
 8005ad6:	4770      	bx	lr
 8005ad8:	200001d8 	.word	0x200001d8
 8005adc:	200002f8 	.word	0x200002f8

08005ae0 <_init>:
 8005ae0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ae2:	bf00      	nop
 8005ae4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005ae6:	bc08      	pop	{r3}
 8005ae8:	469e      	mov	lr, r3
 8005aea:	4770      	bx	lr

08005aec <_fini>:
 8005aec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005aee:	bf00      	nop
 8005af0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005af2:	bc08      	pop	{r3}
 8005af4:	469e      	mov	lr, r3
 8005af6:	4770      	bx	lr
