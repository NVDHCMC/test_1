
C:\Users\Administrator\git\adct_bgs_snmp_fpt\ADCT_BGS_FPT\Debug\ADCT_BGS_FPT.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00004f64  0800010c  0800010c  0001010c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000204  08005070  08005070  00015070  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08005274  08005274  00015274  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08005278  08005278  00015278  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000001f8  20000000  0800527c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000004c4  200001f8  08005474  000201f8  2**2
                  ALLOC
  7 ._user_heap_stack 00000100  200006bc  08005474  000206bc  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  000201f8  2**0
                  CONTENTS, READONLY
  9 .debug_info   0001518e  00000000  00000000  00020221  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000043fe  00000000  00000000  000353af  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007baa  00000000  00000000  000397ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000012b8  00000000  00000000  00041358  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001038  00000000  00000000  00042610  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000a78e  00000000  00000000  00043648  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00006046  00000000  00000000  0004ddd6  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007e  00000000  00000000  00053e1c  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00002a3c  00000000  00000000  00053e9c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800010c <__do_global_dtors_aux>:
 800010c:	b510      	push	{r4, lr}
 800010e:	4c05      	ldr	r4, [pc, #20]	; (8000124 <__do_global_dtors_aux+0x18>)
 8000110:	7823      	ldrb	r3, [r4, #0]
 8000112:	b933      	cbnz	r3, 8000122 <__do_global_dtors_aux+0x16>
 8000114:	4b04      	ldr	r3, [pc, #16]	; (8000128 <__do_global_dtors_aux+0x1c>)
 8000116:	b113      	cbz	r3, 800011e <__do_global_dtors_aux+0x12>
 8000118:	4804      	ldr	r0, [pc, #16]	; (800012c <__do_global_dtors_aux+0x20>)
 800011a:	f3af 8000 	nop.w
 800011e:	2301      	movs	r3, #1
 8000120:	7023      	strb	r3, [r4, #0]
 8000122:	bd10      	pop	{r4, pc}
 8000124:	200001f8 	.word	0x200001f8
 8000128:	00000000 	.word	0x00000000
 800012c:	08005058 	.word	0x08005058

08000130 <frame_dummy>:
 8000130:	b508      	push	{r3, lr}
 8000132:	4b03      	ldr	r3, [pc, #12]	; (8000140 <frame_dummy+0x10>)
 8000134:	b11b      	cbz	r3, 800013e <frame_dummy+0xe>
 8000136:	4903      	ldr	r1, [pc, #12]	; (8000144 <frame_dummy+0x14>)
 8000138:	4803      	ldr	r0, [pc, #12]	; (8000148 <frame_dummy+0x18>)
 800013a:	f3af 8000 	nop.w
 800013e:	bd08      	pop	{r3, pc}
 8000140:	00000000 	.word	0x00000000
 8000144:	200001fc 	.word	0x200001fc
 8000148:	08005058 	.word	0x08005058

0800014c <ADCT_BGS_ASW_10ms_TaskHandler>:

void ADCT_BGS_ASW_10ms_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
	(void)timer;
	(void)parameter;
	g_ASW_Task_flag.ASW_10ms_flag = ADCT_TRUE;
 800014c:	2201      	movs	r2, #1
 800014e:	4b01      	ldr	r3, [pc, #4]	; (8000154 <ADCT_BGS_ASW_10ms_TaskHandler+0x8>)
 8000150:	709a      	strb	r2, [r3, #2]
 8000152:	4770      	bx	lr
 8000154:	20000444 	.word	0x20000444

08000158 <ADCT_BGS_ASW_1ms_TaskHandler>:

void ADCT_BGS_ASW_1ms_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
	(void)timer;
	(void)parameter;
	g_ASW_Task_flag.ASW_1ms_flag = ADCT_TRUE;
 8000158:	2201      	movs	r2, #1
 800015a:	4b01      	ldr	r3, [pc, #4]	; (8000160 <ADCT_BGS_ASW_1ms_TaskHandler+0x8>)
 800015c:	70da      	strb	r2, [r3, #3]
 800015e:	4770      	bx	lr
 8000160:	20000444 	.word	0x20000444

08000164 <ADCT_BGS_ASW_1s_TaskHandler>:

void ADCT_BGS_ASW_1s_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
	(void)timer;
	(void)parameter;
	g_ASW_Task_flag.ASW_1s_flag = ADCT_TRUE;
 8000164:	2201      	movs	r2, #1
 8000166:	4b01      	ldr	r3, [pc, #4]	; (800016c <ADCT_BGS_ASW_1s_TaskHandler+0x8>)
 8000168:	701a      	strb	r2, [r3, #0]
 800016a:	4770      	bx	lr
 800016c:	20000444 	.word	0x20000444

08000170 <ADCT_BGS_ASW_100ms_TaskHandler>:
#include "HardwareCfg.h"
#include "ADCT_DHT22.h"
extern FPT_SystemStatus    GstSystemStatus;
ADCT_BGS_ASW_TaskDatatypes g_ASW_Task_flag;
void ADCT_BGS_ASW_100ms_TaskHandler(TM_DELAY_Timer_t* timer, void * parameter)
{
 8000170:	b508      	push	{r3, lr}
	(void)timer;
	(void)parameter;
	ADCT_DHT22_FPT_GetValue(&GstSystemStatus.dhtData);
 8000172:	4803      	ldr	r0, [pc, #12]	; (8000180 <ADCT_BGS_ASW_100ms_TaskHandler+0x10>)
 8000174:	f001 fd2a 	bl	8001bcc <ADCT_DHT22_FPT_GetValue>
	g_ASW_Task_flag.ASW_100ms_flag = TRUE;
 8000178:	2201      	movs	r2, #1
 800017a:	4b02      	ldr	r3, [pc, #8]	; (8000184 <ADCT_BGS_ASW_100ms_TaskHandler+0x14>)
 800017c:	705a      	strb	r2, [r3, #1]
 800017e:	bd08      	pop	{r3, pc}
 8000180:	20000522 	.word	0x20000522
 8000184:	20000444 	.word	0x20000444

08000188 <ADCT_BGS_ASW_100ms_Init>:
}
void ADCT_BGS_ASW_100ms_Init(void)
{
 8000188:	b500      	push	{lr}
 800018a:	b083      	sub	sp, #12
	TM_DELAY_TimerCreate(100, 1, 1, ADCT_BGS_ASW_100ms_TaskHandler, NULL);
 800018c:	2300      	movs	r3, #0
 800018e:	9300      	str	r3, [sp, #0]
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <ADCT_BGS_ASW_100ms_Init+0x1c>)
 8000192:	2201      	movs	r2, #1
 8000194:	4611      	mov	r1, r2
 8000196:	2064      	movs	r0, #100	; 0x64
 8000198:	f003 fd76 	bl	8003c88 <TM_DELAY_TimerCreate>
}
 800019c:	b003      	add	sp, #12
 800019e:	f85d fb04 	ldr.w	pc, [sp], #4
 80001a2:	bf00      	nop
 80001a4:	08000171 	.word	0x08000171

080001a8 <ADCT_BGS_ASW_10ms_Init>:
	(void)parameter;
	g_ASW_Task_flag.ASW_1s_flag = ADCT_TRUE;

}
void ADCT_BGS_ASW_10ms_Init(void)
{
 80001a8:	b500      	push	{lr}
 80001aa:	b083      	sub	sp, #12
	g_ASW_Task_flag.ASW_10ms_flag = ADCT_FALSE;
 80001ac:	2300      	movs	r3, #0
 80001ae:	4a06      	ldr	r2, [pc, #24]	; (80001c8 <ADCT_BGS_ASW_10ms_Init+0x20>)
 80001b0:	7093      	strb	r3, [r2, #2]
	TM_DELAY_TimerCreate(10, 1, 1, ADCT_BGS_ASW_10ms_TaskHandler, NULL);
 80001b2:	9300      	str	r3, [sp, #0]
 80001b4:	4b05      	ldr	r3, [pc, #20]	; (80001cc <ADCT_BGS_ASW_10ms_Init+0x24>)
 80001b6:	2201      	movs	r2, #1
 80001b8:	4611      	mov	r1, r2
 80001ba:	200a      	movs	r0, #10
 80001bc:	f003 fd64 	bl	8003c88 <TM_DELAY_TimerCreate>
}
 80001c0:	b003      	add	sp, #12
 80001c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80001c6:	bf00      	nop
 80001c8:	20000444 	.word	0x20000444
 80001cc:	0800014d 	.word	0x0800014d

080001d0 <ADCT_BGS_ASW_1ms_Init>:

void ADCT_BGS_ASW_1ms_Init(void)
{
 80001d0:	b500      	push	{lr}
 80001d2:	b083      	sub	sp, #12
	g_ASW_Task_flag.ASW_1ms_flag =ADCT_FALSE;
 80001d4:	2300      	movs	r3, #0
 80001d6:	4a06      	ldr	r2, [pc, #24]	; (80001f0 <ADCT_BGS_ASW_1ms_Init+0x20>)
 80001d8:	70d3      	strb	r3, [r2, #3]
	TM_DELAY_TimerCreate(1, 1, 1, ADCT_BGS_ASW_1ms_TaskHandler, NULL);
 80001da:	9300      	str	r3, [sp, #0]
 80001dc:	4b05      	ldr	r3, [pc, #20]	; (80001f4 <ADCT_BGS_ASW_1ms_Init+0x24>)
 80001de:	2201      	movs	r2, #1
 80001e0:	4611      	mov	r1, r2
 80001e2:	4610      	mov	r0, r2
 80001e4:	f003 fd50 	bl	8003c88 <TM_DELAY_TimerCreate>
}
 80001e8:	b003      	add	sp, #12
 80001ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80001ee:	bf00      	nop
 80001f0:	20000444 	.word	0x20000444
 80001f4:	08000159 	.word	0x08000159

080001f8 <ADCT_BGS_ASW_1s_Init>:

void ADCT_BGS_ASW_1s_Init(void)
{
 80001f8:	b500      	push	{lr}
 80001fa:	b083      	sub	sp, #12
	g_ASW_Task_flag.ASW_1s_flag =ADCT_FALSE;
 80001fc:	2300      	movs	r3, #0
 80001fe:	4a06      	ldr	r2, [pc, #24]	; (8000218 <ADCT_BGS_ASW_1s_Init+0x20>)
 8000200:	7013      	strb	r3, [r2, #0]
	TM_DELAY_TimerCreate(1000, 1, 1, ADCT_BGS_ASW_1s_TaskHandler, NULL);
 8000202:	9300      	str	r3, [sp, #0]
 8000204:	4b05      	ldr	r3, [pc, #20]	; (800021c <ADCT_BGS_ASW_1s_Init+0x24>)
 8000206:	2201      	movs	r2, #1
 8000208:	4611      	mov	r1, r2
 800020a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800020e:	f003 fd3b 	bl	8003c88 <TM_DELAY_TimerCreate>
}
 8000212:	b003      	add	sp, #12
 8000214:	f85d fb04 	ldr.w	pc, [sp], #4
 8000218:	20000444 	.word	0x20000444
 800021c:	08000165 	.word	0x08000165

08000220 <adct_bgs_choose_views>:
void adct_bgs_choose_datalog    (void);
void adct_bgs_runstate_idle     (void);
void adct_bgs_runstate_alarm    (void);
void adct_bgs_view_datalog		(void);
void adct_bgs_choose_views		(void)
{
 8000220:	4770      	bx	lr
 8000222:	bf00      	nop

08000224 <adct_bgs_enter_parameter>:
	sprintf(LCD_Buffer.lcd_line2, "UP-> XEM NHAT KY");
	(void)lcd_update(LCD_Buffer.lcd_line1, LCD_Buffer.lcd_line2);
#endif
}
void adct_bgs_enter_parameter(void)
{
 8000224:	4770      	bx	lr
 8000226:	bf00      	nop

08000228 <adct_bgs_choose_datalog>:

}
void adct_bgs_choose_datalog(void)
{
 8000228:	4770      	bx	lr
 800022a:	bf00      	nop

0800022c <adct_bgs_runstate_idle>:
	sprintf(LCD_Buffer.lcd_line2, "UP-> XEM NHAT KY");
	(void)lcd_update(LCD_Buffer.lcd_line1, LCD_Buffer.lcd_line2);
#endif
}
void adct_bgs_runstate_idle(void)
{
 800022c:	4770      	bx	lr
 800022e:	bf00      	nop

08000230 <adct_bgs_runstate_alarm>:
	(void)lcd_update(LCD_Buffer.lcd_line1, LCD_Buffer.lcd_line2);
#endif
}
void adct_bgs_runstate_alarm(void)

{
 8000230:	4770      	bx	lr
 8000232:	bf00      	nop

08000234 <adct_bgs_view_datalog>:
	sprintf(LCD_Buffer.lcd_line2, "                ");
	(void)lcd_update(LCD_Buffer.lcd_line1, LCD_Buffer.lcd_line2);
#endif
}
void adct_bgs_view_datalog(void)
{
 8000234:	4770      	bx	lr
 8000236:	bf00      	nop

08000238 <BUTTON_ENTER_Callback>:
		}
};


void BUTTON_ENTER_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
 {
 8000238:	b508      	push	{r3, lr}

	(void)(ButtonPtr);
	(void)(PressType);
	 if(adct_bgs_main_state_table[ActState][ENTER_BUTTON].ptrFunct != NULL)
 800023a:	4b09      	ldr	r3, [pc, #36]	; (8000260 <BUTTON_ENTER_Callback+0x28>)
 800023c:	781b      	ldrb	r3, [r3, #0]
 800023e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000242:	00da      	lsls	r2, r3, #3
 8000244:	4b07      	ldr	r3, [pc, #28]	; (8000264 <BUTTON_ENTER_Callback+0x2c>)
 8000246:	589b      	ldr	r3, [r3, r2]
 8000248:	b14b      	cbz	r3, 800025e <BUTTON_ENTER_Callback+0x26>
	 {
		 adct_bgs_main_state_table[ActState][ENTER_BUTTON].ptrFunct();
 800024a:	4798      	blx	r3
		 ActState =  adct_bgs_main_state_table[ActState][ENTER_BUTTON].NextState;
 800024c:	4904      	ldr	r1, [pc, #16]	; (8000260 <BUTTON_ENTER_Callback+0x28>)
 800024e:	780b      	ldrb	r3, [r1, #0]
 8000250:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000254:	00da      	lsls	r2, r3, #3
 8000256:	4b03      	ldr	r3, [pc, #12]	; (8000264 <BUTTON_ENTER_Callback+0x2c>)
 8000258:	441a      	add	r2, r3
 800025a:	7913      	ldrb	r3, [r2, #4]
 800025c:	700b      	strb	r3, [r1, #0]
 800025e:	bd08      	pop	{r3, pc}
 8000260:	20000214 	.word	0x20000214
 8000264:	20000000 	.word	0x20000000

08000268 <BUTTON_CANCEL_Callback>:
	 }
}
 void BUTTON_CANCEL_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 8000268:	b508      	push	{r3, lr}
		(void)(ButtonPtr);
		(void)(PressType);
	 if(adct_bgs_main_state_table[ActState][CANCEL_BUTTON_ALARM_OFF].ptrFunct != NULL)
 800026a:	4b0a      	ldr	r3, [pc, #40]	; (8000294 <BUTTON_CANCEL_Callback+0x2c>)
 800026c:	781b      	ldrb	r3, [r3, #0]
 800026e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000272:	00da      	lsls	r2, r3, #3
 8000274:	4b08      	ldr	r3, [pc, #32]	; (8000298 <BUTTON_CANCEL_Callback+0x30>)
 8000276:	441a      	add	r2, r3
 8000278:	6913      	ldr	r3, [r2, #16]
 800027a:	b14b      	cbz	r3, 8000290 <BUTTON_CANCEL_Callback+0x28>
	 {
		 adct_bgs_main_state_table[ActState][CANCEL_BUTTON_ALARM_OFF].ptrFunct();
 800027c:	4798      	blx	r3
		 ActState =  adct_bgs_main_state_table[ActState][CANCEL_BUTTON_ALARM_OFF].NextState;
 800027e:	4905      	ldr	r1, [pc, #20]	; (8000294 <BUTTON_CANCEL_Callback+0x2c>)
 8000280:	780b      	ldrb	r3, [r1, #0]
 8000282:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000286:	00da      	lsls	r2, r3, #3
 8000288:	4b03      	ldr	r3, [pc, #12]	; (8000298 <BUTTON_CANCEL_Callback+0x30>)
 800028a:	441a      	add	r2, r3
 800028c:	7d13      	ldrb	r3, [r2, #20]
 800028e:	700b      	strb	r3, [r1, #0]
 8000290:	bd08      	pop	{r3, pc}
 8000292:	bf00      	nop
 8000294:	20000214 	.word	0x20000214
 8000298:	20000000 	.word	0x20000000

0800029c <BUTTON_UP_Callback>:
	 }
}
 void BUTTON_UP_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 800029c:	b508      	push	{r3, lr}
		(void)(ButtonPtr);
		(void)(PressType);
	 if(adct_bgs_main_state_table[ActState][UP_BUTTON].ptrFunct != NULL)
 800029e:	4b0a      	ldr	r3, [pc, #40]	; (80002c8 <BUTTON_UP_Callback+0x2c>)
 80002a0:	781b      	ldrb	r3, [r3, #0]
 80002a2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80002a6:	00da      	lsls	r2, r3, #3
 80002a8:	4b08      	ldr	r3, [pc, #32]	; (80002cc <BUTTON_UP_Callback+0x30>)
 80002aa:	441a      	add	r2, r3
 80002ac:	6993      	ldr	r3, [r2, #24]
 80002ae:	b14b      	cbz	r3, 80002c4 <BUTTON_UP_Callback+0x28>
	 {
		 adct_bgs_main_state_table[ActState][UP_BUTTON].ptrFunct();
 80002b0:	4798      	blx	r3
		 ActState =  adct_bgs_main_state_table[ActState][UP_BUTTON].NextState;
 80002b2:	4905      	ldr	r1, [pc, #20]	; (80002c8 <BUTTON_UP_Callback+0x2c>)
 80002b4:	780b      	ldrb	r3, [r1, #0]
 80002b6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80002ba:	00da      	lsls	r2, r3, #3
 80002bc:	4b03      	ldr	r3, [pc, #12]	; (80002cc <BUTTON_UP_Callback+0x30>)
 80002be:	441a      	add	r2, r3
 80002c0:	7f13      	ldrb	r3, [r2, #28]
 80002c2:	700b      	strb	r3, [r1, #0]
 80002c4:	bd08      	pop	{r3, pc}
 80002c6:	bf00      	nop
 80002c8:	20000214 	.word	0x20000214
 80002cc:	20000000 	.word	0x20000000

080002d0 <BUTTON_DOWN_Callback>:
	 }
}
 void BUTTON_DOWN_Callback(TM_BUTTON_t* ButtonPtr, TM_BUTTON_PressType_t PressType)
{
 80002d0:	b508      	push	{r3, lr}
		(void)(ButtonPtr);
		(void)(PressType);
	 if(adct_bgs_main_state_table[ActState][DOWN_BUTTON].ptrFunct != NULL)
 80002d2:	4b0a      	ldr	r3, [pc, #40]	; (80002fc <BUTTON_DOWN_Callback+0x2c>)
 80002d4:	781b      	ldrb	r3, [r3, #0]
 80002d6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80002da:	00da      	lsls	r2, r3, #3
 80002dc:	4b08      	ldr	r3, [pc, #32]	; (8000300 <BUTTON_DOWN_Callback+0x30>)
 80002de:	441a      	add	r2, r3
 80002e0:	6a13      	ldr	r3, [r2, #32]
 80002e2:	b153      	cbz	r3, 80002fa <BUTTON_DOWN_Callback+0x2a>
	 {
		 adct_bgs_main_state_table[ActState][DOWN_BUTTON].ptrFunct();
 80002e4:	4798      	blx	r3
		 ActState =  adct_bgs_main_state_table[ActState][DOWN_BUTTON].NextState;
 80002e6:	4905      	ldr	r1, [pc, #20]	; (80002fc <BUTTON_DOWN_Callback+0x2c>)
 80002e8:	780b      	ldrb	r3, [r1, #0]
 80002ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80002ee:	00da      	lsls	r2, r3, #3
 80002f0:	4b03      	ldr	r3, [pc, #12]	; (8000300 <BUTTON_DOWN_Callback+0x30>)
 80002f2:	441a      	add	r2, r3
 80002f4:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 80002f8:	700b      	strb	r3, [r1, #0]
 80002fa:	bd08      	pop	{r3, pc}
 80002fc:	20000214 	.word	0x20000214
 8000300:	20000000 	.word	0x20000000

08000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>:
  return eStatus;
}

static void ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
    ADCT_RegHoldingAddressOffset_t offset, uint16_t data) {
  usRegHoldingBuf[(uint16_t) (offset)] = data;
 8000304:	4b01      	ldr	r3, [pc, #4]	; (800030c <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg+0x8>)
 8000306:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
 800030a:	4770      	bx	lr
 800030c:	20000218 	.word	0x20000218

08000310 <ADCT_BGS_MODBUS_RS485_Init>:
static volatile USHORT usRegHoldingBuf[REG_HOLDING_NREGS];
void ADCT_BGS_MODBUS_GetSetting(void);
static void ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
    ADCT_RegHoldingAddressOffset_t offset, uint16_t data);

eMBErrorCode ADCT_BGS_MODBUS_RS485_Init(void) {
 8000310:	b500      	push	{lr}
 8000312:	b083      	sub	sp, #12
  eMBErrorCode eStatus;
  eStatus = eMBInit(MB_RTU, ADCT_BGS_MODBUS_ADDR, 0, ADCT_BGS_BAULDRATE,
 8000314:	2000      	movs	r0, #0
 8000316:	9000      	str	r0, [sp, #0]
 8000318:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 800031c:	4602      	mov	r2, r0
 800031e:	2103      	movs	r1, #3
 8000320:	f002 fd36 	bl	8002d90 <eMBInit>
                    MB_PAR_NONE);
  eStatus = eMBEnable();
 8000324:	f002 fd90 	bl	8002e48 <eMBEnable>
  return eStatus;
}
 8000328:	b003      	add	sp, #12
 800032a:	f85d fb04 	ldr.w	pc, [sp], #4
 800032e:	bf00      	nop

08000330 <ADCT_BGS_MODBUS_RS485_UpdateData>:

static void ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
    ADCT_RegHoldingAddressOffset_t offset, uint16_t data) {
  usRegHoldingBuf[(uint16_t) (offset)] = data;
}
void ADCT_BGS_MODBUS_RS485_UpdateData(void) {
 8000330:	b538      	push	{r3, r4, r5, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8000332:	b672      	cpsid	i
  ENTER_CRITICAL_SECTION();
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USTEMP_MAIN,
 8000334:	4c8d      	ldr	r4, [pc, #564]	; (800056c <ADCT_BGS_MODBUS_RS485_UpdateData+0x23c>)
 8000336:	8ae1      	ldrh	r1, [r4, #22]
 8000338:	2000      	movs	r0, #0
 800033a:	f7ff ffe3 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.dhtData.usTemp_Main);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USHUMID_MAIN,
 800033e:	8b21      	ldrh	r1, [r4, #24]
 8000340:	2001      	movs	r0, #1
 8000342:	f7ff ffdf 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.dhtData.usHumid_Main);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USTEMP_SUB,
 8000346:	8b61      	ldrh	r1, [r4, #26]
 8000348:	2002      	movs	r0, #2
 800034a:	f7ff ffdb 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.dhtData.usTemp_Sub);

  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USHUMID_SUB,
 800034e:	8ba1      	ldrh	r1, [r4, #28]
 8000350:	2003      	movs	r0, #3
 8000352:	f7ff ffd7 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.dhtData.usHumid_Sub);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
      UCFIRE, ReadBit(GstSystemWarning.othWarn, WARN_FIRE));
 8000356:	4d86      	ldr	r5, [pc, #536]	; (8000570 <ADCT_BGS_MODBUS_RS485_UpdateData+0x240>)
 8000358:	6869      	ldr	r1, [r5, #4]
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USTEMP_SUB,
                                         GstSystemStatus.dhtData.usTemp_Sub);

  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USHUMID_SUB,
                                         GstSystemStatus.dhtData.usHumid_Sub);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
 800035a:	f3c1 1180 	ubfx	r1, r1, #6, #1
 800035e:	200a      	movs	r0, #10
 8000360:	f7ff ffd0 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
      UCFIRE, ReadBit(GstSystemWarning.othWarn, WARN_FIRE));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
      UCSMOKE, ReadBit(GstSystemWarning.othWarn, WARN_SMOKE));
 8000364:	6869      	ldr	r1, [r5, #4]

  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USHUMID_SUB,
                                         GstSystemStatus.dhtData.usHumid_Sub);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
      UCFIRE, ReadBit(GstSystemWarning.othWarn, WARN_FIRE));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
 8000366:	f3c1 11c0 	ubfx	r1, r1, #7, #1
 800036a:	200b      	movs	r0, #11
 800036c:	f7ff ffca 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
      UCSMOKE, ReadBit(GstSystemWarning.othWarn, WARN_SMOKE));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
      UCWATER, ReadBit(GstSystemWarning.othWarn, WARN_WATER));
 8000370:	6869      	ldr	r1, [r5, #4]
                                         GstSystemStatus.dhtData.usHumid_Sub);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
      UCFIRE, ReadBit(GstSystemWarning.othWarn, WARN_FIRE));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
      UCSMOKE, ReadBit(GstSystemWarning.othWarn, WARN_SMOKE));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(
 8000372:	f3c1 2180 	ubfx	r1, r1, #10, #1
 8000376:	200c      	movs	r0, #12
 8000378:	f7ff ffc4 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
      UCWATER, ReadBit(GstSystemWarning.othWarn, WARN_WATER));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(DOOR1,
 800037c:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 8000380:	200d      	movs	r0, #13
 8000382:	f7ff ffbf 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.ioData.ucDoor[0]);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(DOOR2,
 8000386:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 800038a:	200e      	movs	r0, #14
 800038c:	f7ff ffba 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.ioData.ucDoor[0]);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(DOOR3,
 8000390:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 8000394:	200f      	movs	r0, #15
 8000396:	f7ff ffb5 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                        GstSystemStatus.ioData.ucDoor[0]);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(DOOR4,
 800039a:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 800039e:	2010      	movs	r0, #16
 80003a0:	f7ff ffb0 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.ioData.ucDoor[0]);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(DOOR5,
 80003a4:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 80003a8:	2011      	movs	r0, #17
 80003aa:	f7ff ffab 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         GstSystemStatus.ioData.ucDoor[0]);
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg( BUGLAR, GstSystemStatus.ioData.ucBurglar);
 80003ae:	f894 1026 	ldrb.w	r1, [r4, #38]	; 0x26
 80003b2:	201c      	movs	r0, #28
 80003b4:	f7ff ffa6 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(AIR1, !ADCT_BGS_AIR_1_2_READ());
 80003b8:	4c6e      	ldr	r4, [pc, #440]	; (8000574 <ADCT_BGS_MODBUS_RS485_UpdateData+0x244>)
 80003ba:	2140      	movs	r1, #64	; 0x40
 80003bc:	4620      	mov	r0, r4
 80003be:	f003 ff07 	bl	80041d0 <GPIO_ReadOutputDataBit>
 80003c2:	fab0 f180 	clz	r1, r0
 80003c6:	0949      	lsrs	r1, r1, #5
 80003c8:	2012      	movs	r0, #18
 80003ca:	f7ff ff9b 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(AIR2, !ADCT_BGS_AIR_1_2_READ());
 80003ce:	2140      	movs	r1, #64	; 0x40
 80003d0:	4620      	mov	r0, r4
 80003d2:	f003 fefd 	bl	80041d0 <GPIO_ReadOutputDataBit>
 80003d6:	fab0 f180 	clz	r1, r0
 80003da:	0949      	lsrs	r1, r1, #5
 80003dc:	2013      	movs	r0, #19
 80003de:	f7ff ff91 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(AIR3, !ADCT_BGS_AIR_3_4_READ());
 80003e2:	2180      	movs	r1, #128	; 0x80
 80003e4:	4620      	mov	r0, r4
 80003e6:	f003 fef3 	bl	80041d0 <GPIO_ReadOutputDataBit>
 80003ea:	fab0 f180 	clz	r1, r0
 80003ee:	0949      	lsrs	r1, r1, #5
 80003f0:	2014      	movs	r0, #20
 80003f2:	f7ff ff87 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(AIR4, !ADCT_BGS_AIR_3_4_READ());
 80003f6:	2180      	movs	r1, #128	; 0x80
 80003f8:	4620      	mov	r0, r4
 80003fa:	f003 fee9 	bl	80041d0 <GPIO_ReadOutputDataBit>
 80003fe:	fab0 f180 	clz	r1, r0
 8000402:	0949      	lsrs	r1, r1, #5
 8000404:	2015      	movs	r0, #21
 8000406:	f7ff ff7d 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(FAN1, ADCT_BGS_FAN_READ());
 800040a:	2104      	movs	r1, #4
 800040c:	4620      	mov	r0, r4
 800040e:	f003 fedf 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000412:	b281      	uxth	r1, r0
 8000414:	2016      	movs	r0, #22
 8000416:	f7ff ff75 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(FAN2, ADCT_BGS_FAN_READ());
 800041a:	2104      	movs	r1, #4
 800041c:	4620      	mov	r0, r4
 800041e:	f003 fed7 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000422:	b281      	uxth	r1, r0
 8000424:	2017      	movs	r0, #23
 8000426:	f7ff ff6d 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(FAN3, ADCT_BGS_FAN_READ());
 800042a:	2104      	movs	r1, #4
 800042c:	4620      	mov	r0, r4
 800042e:	f003 fecf 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000432:	b281      	uxth	r1, r0
 8000434:	2018      	movs	r0, #24
 8000436:	f7ff ff65 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(FAN4, ADCT_BGS_FAN_READ());
 800043a:	2104      	movs	r1, #4
 800043c:	4620      	mov	r0, r4
 800043e:	f003 fec7 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000442:	b281      	uxth	r1, r0
 8000444:	2019      	movs	r0, #25
 8000446:	f7ff ff5d 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(BUZZER, ADCT_BGS_BUZZER_READ());
 800044a:	2102      	movs	r1, #2
 800044c:	4620      	mov	r0, r4
 800044e:	f003 febf 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000452:	b281      	uxth	r1, r0
 8000454:	201a      	movs	r0, #26
 8000456:	f7ff ff55 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(LED, ADCT_BGS_LAMP_READ());
 800045a:	2101      	movs	r1, #1
 800045c:	4620      	mov	r0, r4
 800045e:	f003 feb7 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000462:	b281      	uxth	r1, r0
 8000464:	201b      	movs	r0, #27
 8000466:	f7ff ff4d 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(ALARM_WARNING_HIGH,
 800046a:	88e9      	ldrh	r1, [r5, #6]
 800046c:	201e      	movs	r0, #30
 800046e:	f7ff ff49 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         (uint16_t)((GstSystemWarning.othWarn >> 16)&(0xFFFF)));
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(ALARM_WARNING_LOW,
 8000472:	88a9      	ldrh	r1, [r5, #4]
 8000474:	201f      	movs	r0, #31
 8000476:	f7ff ff45 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
                                         (uint16_t)(GstSystemWarning.othWarn &(0xFFFF)));

  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_RTC_SEC, g_ADCT_BGS_Current_RTC.RTC_Sec);
 800047a:	4c3f      	ldr	r4, [pc, #252]	; (8000578 <ADCT_BGS_MODBUS_RS485_UpdateData+0x248>)
 800047c:	7821      	ldrb	r1, [r4, #0]
 800047e:	2047      	movs	r0, #71	; 0x47
 8000480:	f7ff ff40 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_RTC_MIN, g_ADCT_BGS_Current_RTC.RTC_Min);
 8000484:	7861      	ldrb	r1, [r4, #1]
 8000486:	2048      	movs	r0, #72	; 0x48
 8000488:	f7ff ff3c 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_RTC_HOUR, g_ADCT_BGS_Current_RTC.RTC_Hour);
 800048c:	78a1      	ldrb	r1, [r4, #2]
 800048e:	2049      	movs	r0, #73	; 0x49
 8000490:	f7ff ff38 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_RTC_DAY, g_ADCT_BGS_Current_RTC.RTC_Mday);
 8000494:	78e1      	ldrb	r1, [r4, #3]
 8000496:	204a      	movs	r0, #74	; 0x4a
 8000498:	f7ff ff34 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_RTC_MONTH, g_ADCT_BGS_Current_RTC.RTC_Mon);
 800049c:	7921      	ldrb	r1, [r4, #4]
 800049e:	204b      	movs	r0, #75	; 0x4b
 80004a0:	f7ff ff30 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_RTC_YEAR, g_ADCT_BGS_Current_RTC.RTC_Year);
 80004a4:	88e1      	ldrh	r1, [r4, #6]
 80004a6:	204c      	movs	r0, #76	; 0x4c
 80004a8:	f7ff ff2c 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>

  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_SW_SEC, g_ADCT_BGS_TimerManager.SWitchingTimer.second);
 80004ac:	4c33      	ldr	r4, [pc, #204]	; (800057c <ADCT_BGS_MODBUS_RS485_UpdateData+0x24c>)
 80004ae:	78a1      	ldrb	r1, [r4, #2]
 80004b0:	204d      	movs	r0, #77	; 0x4d
 80004b2:	f7ff ff27 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_SW_MINUTE, g_ADCT_BGS_TimerManager.SWitchingTimer.minute);
 80004b6:	7861      	ldrb	r1, [r4, #1]
 80004b8:	204e      	movs	r0, #78	; 0x4e
 80004ba:	f7ff ff23 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>
  ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(US_SW_HOUR, g_ADCT_BGS_TimerManager.SWitchingTimer.hour);
 80004be:	7821      	ldrb	r1, [r4, #0]
 80004c0:	204f      	movs	r0, #79	; 0x4f
 80004c2:	f7ff ff1f 	bl	8000304 <ADCT_BGS_MODBUS_RS485_UpdateHoldingReg>

  GTempSetting.usLowTemperatureT1 = usRegHoldingBuf[USLOWTEMPERATURET1];
 80004c6:	4a2e      	ldr	r2, [pc, #184]	; (8000580 <ADCT_BGS_MODBUS_RS485_UpdateData+0x250>)
 80004c8:	f8b2 1064 	ldrh.w	r1, [r2, #100]	; 0x64
 80004cc:	b289      	uxth	r1, r1
 80004ce:	4b2d      	ldr	r3, [pc, #180]	; (8000584 <ADCT_BGS_MODBUS_RS485_UpdateData+0x254>)
 80004d0:	8019      	strh	r1, [r3, #0]
  GTempSetting.usHighTemperatureT2 = usRegHoldingBuf[USHIGHTEMPERATURET2];
 80004d2:	f8b2 1066 	ldrh.w	r1, [r2, #102]	; 0x66
 80004d6:	b289      	uxth	r1, r1
 80004d8:	8059      	strh	r1, [r3, #2]
  GTempSetting.usFanTemperatureT3 = usRegHoldingBuf[USFANTEMPERATURET3];
 80004da:	f8b2 1068 	ldrh.w	r1, [r2, #104]	; 0x68
 80004de:	b289      	uxth	r1, r1
 80004e0:	8099      	strh	r1, [r3, #4]
  GTempSetting.usLowHumidityH1 = usRegHoldingBuf[USLOWHUMIDITYH1];
 80004e2:	f8b2 106a 	ldrh.w	r1, [r2, #106]	; 0x6a
 80004e6:	b289      	uxth	r1, r1
 80004e8:	80d9      	strh	r1, [r3, #6]
  GTempSetting.usHighHumidityH2 = usRegHoldingBuf[USHIGHHUMIDITYH2];
 80004ea:	f8b2 106c 	ldrh.w	r1, [r2, #108]	; 0x6c
 80004ee:	b289      	uxth	r1, r1
 80004f0:	8119      	strh	r1, [r3, #8]
  GTempSetting.usLowMainVoltage = usRegHoldingBuf[USLOWMAINVOLTAGE];
 80004f2:	f8b2 106e 	ldrh.w	r1, [r2, #110]	; 0x6e
 80004f6:	b289      	uxth	r1, r1
 80004f8:	8159      	strh	r1, [r3, #10]
  GTempSetting.usHighMainVoltage = usRegHoldingBuf[USHIGHMAINVOLTAGE];
 80004fa:	f8b2 1070 	ldrh.w	r1, [r2, #112]	; 0x70
 80004fe:	b289      	uxth	r1, r1
 8000500:	8199      	strh	r1, [r3, #12]
  GTempSetting.usGenFuelLowValue = usRegHoldingBuf[USGENFUELLOWVALUE];
 8000502:	f8b2 1072 	ldrh.w	r1, [r2, #114]	; 0x72
 8000506:	b289      	uxth	r1, r1
 8000508:	81d9      	strh	r1, [r3, #14]
  GTempSetting.usGenVoltageAlarmValue = usRegHoldingBuf[USGENVOLTAGEALARMVALUE];
 800050a:	f8b2 1074 	ldrh.w	r1, [r2, #116]	; 0x74
 800050e:	b289      	uxth	r1, r1
 8000510:	8219      	strh	r1, [r3, #16]
  GTempSetting.usGenBatteryVoltageAlarmValue =
      usRegHoldingBuf[USGENBATTERYVOLTAGEALARMVALUE];
 8000512:	f8b2 1076 	ldrh.w	r1, [r2, #118]	; 0x76
 8000516:	b289      	uxth	r1, r1
  GTempSetting.usHighHumidityH2 = usRegHoldingBuf[USHIGHHUMIDITYH2];
  GTempSetting.usLowMainVoltage = usRegHoldingBuf[USLOWMAINVOLTAGE];
  GTempSetting.usHighMainVoltage = usRegHoldingBuf[USHIGHMAINVOLTAGE];
  GTempSetting.usGenFuelLowValue = usRegHoldingBuf[USGENFUELLOWVALUE];
  GTempSetting.usGenVoltageAlarmValue = usRegHoldingBuf[USGENVOLTAGEALARMVALUE];
  GTempSetting.usGenBatteryVoltageAlarmValue =
 8000518:	8259      	strh	r1, [r3, #18]
      usRegHoldingBuf[USGENBATTERYVOLTAGEALARMVALUE];
  GTempSetting.usGenCoolantTempAlarmValue =
      usRegHoldingBuf[USGENCOOLANTTEMPALARMVALUE];
 800051a:	f8b2 1078 	ldrh.w	r1, [r2, #120]	; 0x78
 800051e:	b289      	uxth	r1, r1
  GTempSetting.usHighMainVoltage = usRegHoldingBuf[USHIGHMAINVOLTAGE];
  GTempSetting.usGenFuelLowValue = usRegHoldingBuf[USGENFUELLOWVALUE];
  GTempSetting.usGenVoltageAlarmValue = usRegHoldingBuf[USGENVOLTAGEALARMVALUE];
  GTempSetting.usGenBatteryVoltageAlarmValue =
      usRegHoldingBuf[USGENBATTERYVOLTAGEALARMVALUE];
  GTempSetting.usGenCoolantTempAlarmValue =
 8000520:	8299      	strh	r1, [r3, #20]
      usRegHoldingBuf[USGENCOOLANTTEMPALARMVALUE];
  GTempSetting.usGenEngineSpeedAlarmValue =
      usRegHoldingBuf[USGENENGINESPEEDALARMVALUE];
 8000522:	f8b2 107a 	ldrh.w	r1, [r2, #122]	; 0x7a
 8000526:	b289      	uxth	r1, r1
  GTempSetting.usGenVoltageAlarmValue = usRegHoldingBuf[USGENVOLTAGEALARMVALUE];
  GTempSetting.usGenBatteryVoltageAlarmValue =
      usRegHoldingBuf[USGENBATTERYVOLTAGEALARMVALUE];
  GTempSetting.usGenCoolantTempAlarmValue =
      usRegHoldingBuf[USGENCOOLANTTEMPALARMVALUE];
  GTempSetting.usGenEngineSpeedAlarmValue =
 8000528:	82d9      	strh	r1, [r3, #22]
      usRegHoldingBuf[USGENENGINESPEEDALARMVALUE];
  GTempSetting.usGenOilPressureAlarmValue =
      usRegHoldingBuf[USGENOILPRESSUREALARMVALUE];
 800052a:	f8b2 107c 	ldrh.w	r1, [r2, #124]	; 0x7c
 800052e:	b289      	uxth	r1, r1
      usRegHoldingBuf[USGENBATTERYVOLTAGEALARMVALUE];
  GTempSetting.usGenCoolantTempAlarmValue =
      usRegHoldingBuf[USGENCOOLANTTEMPALARMVALUE];
  GTempSetting.usGenEngineSpeedAlarmValue =
      usRegHoldingBuf[USGENENGINESPEEDALARMVALUE];
  GTempSetting.usGenOilPressureAlarmValue =
 8000530:	8319      	strh	r1, [r3, #24]
      usRegHoldingBuf[USGENOILPRESSUREALARMVALUE];
  GTempSetting.ulSwitchingTime = usRegHoldingBuf[ULSWITCHINGTIME];
 8000532:	f8b2 107e 	ldrh.w	r1, [r2, #126]	; 0x7e
 8000536:	b289      	uxth	r1, r1
 8000538:	61d9      	str	r1, [r3, #28]
  GTempSetting.ulMinSwitchingTime = usRegHoldingBuf[ULMINSWITCHINGTIME];
 800053a:	f8b2 1080 	ldrh.w	r1, [r2, #128]	; 0x80
 800053e:	b289      	uxth	r1, r1
 8000540:	6219      	str	r1, [r3, #32]
  GTempSetting.ulStayOffTime = usRegHoldingBuf[ULSTAYOFFTIME];
 8000542:	f8b2 1082 	ldrh.w	r1, [r2, #130]	; 0x82
 8000546:	b289      	uxth	r1, r1
 8000548:	6259      	str	r1, [r3, #36]	; 0x24
  GTempSetting.ucEnableAlarm = usRegHoldingBuf[UCENABLEALARM];
 800054a:	f8b2 1084 	ldrh.w	r1, [r2, #132]	; 0x84
 800054e:	b2c9      	uxtb	r1, r1
 8000550:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
  GTempSetting.ucDoorBurglarEnableAlarm =
      usRegHoldingBuf[UCDOORBURGLARENABLEALARM];
 8000554:	f8b2 1086 	ldrh.w	r1, [r2, #134]	; 0x86
      usRegHoldingBuf[USGENOILPRESSUREALARMVALUE];
  GTempSetting.ulSwitchingTime = usRegHoldingBuf[ULSWITCHINGTIME];
  GTempSetting.ulMinSwitchingTime = usRegHoldingBuf[ULMINSWITCHINGTIME];
  GTempSetting.ulStayOffTime = usRegHoldingBuf[ULSTAYOFFTIME];
  GTempSetting.ucEnableAlarm = usRegHoldingBuf[UCENABLEALARM];
  GTempSetting.ucDoorBurglarEnableAlarm =
 8000558:	b2c9      	uxtb	r1, r1
 800055a:	f883 1029 	strb.w	r1, [r3, #41]	; 0x29
      usRegHoldingBuf[UCDOORBURGLARENABLEALARM];
  GTempSetting.ulAlarmDuration = usRegHoldingBuf[ULALARMDURATION];
 800055e:	f8b2 2088 	ldrh.w	r2, [r2, #136]	; 0x88
 8000562:	b292      	uxth	r2, r2
 8000564:	62da      	str	r2, [r3, #44]	; 0x2c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 8000566:	b662      	cpsie	i
 8000568:	bd38      	pop	{r3, r4, r5, pc}
 800056a:	bf00      	nop
 800056c:	2000050c 	.word	0x2000050c
 8000570:	20000504 	.word	0x20000504
 8000574:	40010800 	.word	0x40010800
 8000578:	200004a8 	.word	0x200004a8
 800057c:	20000490 	.word	0x20000490
 8000580:	20000218 	.word	0x20000218
 8000584:	2000044c 	.word	0x2000044c

08000588 <ADCT_BGS_MODBUS_Get_BE_DKG_Data>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8000588:	b672      	cpsid	i

void ADCT_BGS_MODBUS_Get_BE_DKG_Data(void) {
  ENTER_CRITICAL_SECTION();

  GstSystemStatus.mbData.usCurrentMainVoltage =
      usRegHoldingBuf[USCURRENTMAINVOLTAGE];
 800058a:	4b15      	ldr	r3, [pc, #84]	; (80005e0 <ADCT_BGS_MODBUS_Get_BE_DKG_Data+0x58>)
 800058c:	f8b3 1048 	ldrh.w	r1, [r3, #72]	; 0x48
}

void ADCT_BGS_MODBUS_Get_BE_DKG_Data(void) {
  ENTER_CRITICAL_SECTION();

  GstSystemStatus.mbData.usCurrentMainVoltage =
 8000590:	4a14      	ldr	r2, [pc, #80]	; (80005e4 <ADCT_BGS_MODBUS_Get_BE_DKG_Data+0x5c>)
 8000592:	8011      	strh	r1, [r2, #0]
      usRegHoldingBuf[USCURRENTMAINVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenFuel = usRegHoldingBuf[USCURRENTGENFUEL];
 8000594:	f8b3 104a 	ldrh.w	r1, [r3, #74]	; 0x4a
 8000598:	8051      	strh	r1, [r2, #2]
  GstSystemStatus.mbData.usCurrentGenVoltage =
      usRegHoldingBuf[USCURRENTGENVOLTAGE];
 800059a:	f8b3 104c 	ldrh.w	r1, [r3, #76]	; 0x4c
  ENTER_CRITICAL_SECTION();

  GstSystemStatus.mbData.usCurrentMainVoltage =
      usRegHoldingBuf[USCURRENTMAINVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenFuel = usRegHoldingBuf[USCURRENTGENFUEL];
  GstSystemStatus.mbData.usCurrentGenVoltage =
 800059e:	8091      	strh	r1, [r2, #4]
      usRegHoldingBuf[USCURRENTGENVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenBatteryVoltage =
      usRegHoldingBuf[USCURRENTGENBATTERYVOLTAGE];
 80005a0:	f8b3 104e 	ldrh.w	r1, [r3, #78]	; 0x4e
  GstSystemStatus.mbData.usCurrentMainVoltage =
      usRegHoldingBuf[USCURRENTMAINVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenFuel = usRegHoldingBuf[USCURRENTGENFUEL];
  GstSystemStatus.mbData.usCurrentGenVoltage =
      usRegHoldingBuf[USCURRENTGENVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenBatteryVoltage =
 80005a4:	80d1      	strh	r1, [r2, #6]
      usRegHoldingBuf[USCURRENTGENBATTERYVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenCoolantTemp =
      usRegHoldingBuf[USCURRENTGENCOOLANTTEMP];
 80005a6:	f8b3 1050 	ldrh.w	r1, [r3, #80]	; 0x50
  GstSystemStatus.mbData.usCurrentGenFuel = usRegHoldingBuf[USCURRENTGENFUEL];
  GstSystemStatus.mbData.usCurrentGenVoltage =
      usRegHoldingBuf[USCURRENTGENVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenBatteryVoltage =
      usRegHoldingBuf[USCURRENTGENBATTERYVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenCoolantTemp =
 80005aa:	8111      	strh	r1, [r2, #8]
      usRegHoldingBuf[USCURRENTGENCOOLANTTEMP];
  GstSystemStatus.mbData.usCurrentGenEngineSpeed =
      usRegHoldingBuf[USCURRENTGENENGINESPEED];
 80005ac:	f8b3 1052 	ldrh.w	r1, [r3, #82]	; 0x52
      usRegHoldingBuf[USCURRENTGENVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenBatteryVoltage =
      usRegHoldingBuf[USCURRENTGENBATTERYVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenCoolantTemp =
      usRegHoldingBuf[USCURRENTGENCOOLANTTEMP];
  GstSystemStatus.mbData.usCurrentGenEngineSpeed =
 80005b0:	8151      	strh	r1, [r2, #10]
      usRegHoldingBuf[USCURRENTGENENGINESPEED];
  GstSystemStatus.mbData.usCurrentGenOilPressure =
      usRegHoldingBuf[USCURRENTGENOILPRESSURE];
 80005b2:	f8b3 1054 	ldrh.w	r1, [r3, #84]	; 0x54
      usRegHoldingBuf[USCURRENTGENBATTERYVOLTAGE];
  GstSystemStatus.mbData.usCurrentGenCoolantTemp =
      usRegHoldingBuf[USCURRENTGENCOOLANTTEMP];
  GstSystemStatus.mbData.usCurrentGenEngineSpeed =
      usRegHoldingBuf[USCURRENTGENENGINESPEED];
  GstSystemStatus.mbData.usCurrentGenOilPressure =
 80005b6:	8191      	strh	r1, [r2, #12]
      usRegHoldingBuf[USCURRENTGENOILPRESSURE];
  GstSystemStatus.mbData.usCurrentGenCurVoltage =
      usRegHoldingBuf[USCURRENTGENCURVOLTAGE];
 80005b8:	f8b3 1056 	ldrh.w	r1, [r3, #86]	; 0x56
      usRegHoldingBuf[USCURRENTGENCOOLANTTEMP];
  GstSystemStatus.mbData.usCurrentGenEngineSpeed =
      usRegHoldingBuf[USCURRENTGENENGINESPEED];
  GstSystemStatus.mbData.usCurrentGenOilPressure =
      usRegHoldingBuf[USCURRENTGENOILPRESSURE];
  GstSystemStatus.mbData.usCurrentGenCurVoltage =
 80005bc:	81d1      	strh	r1, [r2, #14]
      usRegHoldingBuf[USCURRENTGENCURVOLTAGE];
  GstSystemStatus.mbData.usCurrentMainFreq = usRegHoldingBuf[USCURRENTMAINFREQ];
 80005be:	f8b3 1058 	ldrh.w	r1, [r3, #88]	; 0x58
 80005c2:	8211      	strh	r1, [r2, #16]
  GstSystemStatus.mbData.usCurrentGenFreq = usRegHoldingBuf[USCURRENTGENFREQ];
 80005c4:	f8b3 105a 	ldrh.w	r1, [r3, #90]	; 0x5a
 80005c8:	8251      	strh	r1, [r2, #18]
  GstSystemStatus.mbData.usCurrentGenMode = usRegHoldingBuf[USCURRENTGENMODE];
 80005ca:	f8b3 105c 	ldrh.w	r1, [r3, #92]	; 0x5c
 80005ce:	8291      	strh	r1, [r2, #20]

  ADCT_BGS_REBOOT_BOARD = usRegHoldingBuf[UC_REBOOT];
 80005d0:	f8b3 308a 	ldrh.w	r3, [r3, #138]	; 0x8a
 80005d4:	b2db      	uxtb	r3, r3
 80005d6:	4a04      	ldr	r2, [pc, #16]	; (80005e8 <ADCT_BGS_MODBUS_Get_BE_DKG_Data+0x60>)
 80005d8:	7013      	strb	r3, [r2, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80005da:	b662      	cpsie	i
 80005dc:	4770      	bx	lr
 80005de:	bf00      	nop
 80005e0:	20000218 	.word	0x20000218
 80005e4:	2000050c 	.word	0x2000050c
 80005e8:	2000044a 	.word	0x2000044a

080005ec <ADCT_BGS_MODBUS_GetSetting>:
  EXIT_CRITICAL_SECTION();
}
void ADCT_BGS_MODBUS_GetSetting(void) {
 80005ec:	b510      	push	{r4, lr}
  if (GstSystemSetting.usLowTemperatureT1
 80005ee:	4ba4      	ldr	r3, [pc, #656]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80005f0:	8819      	ldrh	r1, [r3, #0]
      != GTempSetting.usLowTemperatureT1 * 10) {
 80005f2:	4ba4      	ldr	r3, [pc, #656]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80005f4:	881b      	ldrh	r3, [r3, #0]
 80005f6:	b29b      	uxth	r3, r3
 80005f8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80005fc:	005a      	lsls	r2, r3, #1

  ADCT_BGS_REBOOT_BOARD = usRegHoldingBuf[UC_REBOOT];
  EXIT_CRITICAL_SECTION();
}
void ADCT_BGS_MODBUS_GetSetting(void) {
  if (GstSystemSetting.usLowTemperatureT1
 80005fe:	4291      	cmp	r1, r2
 8000600:	d00b      	beq.n	800061a <ADCT_BGS_MODBUS_GetSetting+0x2e>
      != GTempSetting.usLowTemperatureT1 * 10) {
    GstSystemSetting.usLowTemperatureT1 = GTempSetting.usLowTemperatureT1 * 10;
 8000602:	4ba0      	ldr	r3, [pc, #640]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000604:	881b      	ldrh	r3, [r3, #0]
 8000606:	b29b      	uxth	r3, r3
 8000608:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800060c:	0059      	lsls	r1, r3, #1
 800060e:	b289      	uxth	r1, r1
 8000610:	4b9b      	ldr	r3, [pc, #620]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000612:	8019      	strh	r1, [r3, #0]
    ADCT_AT24C64_WriteTwoBytes(EEPROM_LOW_TEMPERATURE_T1_LOW,
 8000614:	2001      	movs	r0, #1
 8000616:	f002 f8f5 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
  else
  {
   // ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USLOWTEMPERATURET1, GstSystemSetting.usLowTemperatureT1 /10);
  }

  if (GstSystemSetting.usHighTemperatureT2
 800061a:	4b99      	ldr	r3, [pc, #612]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800061c:	8859      	ldrh	r1, [r3, #2]
      != GTempSetting.usHighTemperatureT2 * 10) {
 800061e:	4b99      	ldr	r3, [pc, #612]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000620:	885b      	ldrh	r3, [r3, #2]
 8000622:	b29b      	uxth	r3, r3
 8000624:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000628:	005a      	lsls	r2, r3, #1
  else
  {
   // ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USLOWTEMPERATURET1, GstSystemSetting.usLowTemperatureT1 /10);
  }

  if (GstSystemSetting.usHighTemperatureT2
 800062a:	4291      	cmp	r1, r2
 800062c:	d00b      	beq.n	8000646 <ADCT_BGS_MODBUS_GetSetting+0x5a>
      != GTempSetting.usHighTemperatureT2 * 10) {
    GstSystemSetting.usHighTemperatureT2 = GTempSetting.usHighTemperatureT2 * 10;
 800062e:	4b95      	ldr	r3, [pc, #596]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000630:	885b      	ldrh	r3, [r3, #2]
 8000632:	b29b      	uxth	r3, r3
 8000634:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000638:	0059      	lsls	r1, r3, #1
 800063a:	b289      	uxth	r1, r1
 800063c:	4b90      	ldr	r3, [pc, #576]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800063e:	8059      	strh	r1, [r3, #2]
    ADCT_AT24C64_WriteTwoBytes(EEPROM_HIGH_TEMPERATURE_T2_LOW,
 8000640:	2003      	movs	r0, #3
 8000642:	f002 f8df 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
  }
  else
  {
   // ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(EEPROM_HIGH_TEMPERATURE_T2_LOW, GstSystemSetting.usLowTemperatureT1 /10);
  }
  if (GstSystemSetting.usHighHumidityH2 != GTempSetting.usHighHumidityH2 * 10) {
 8000646:	4b8e      	ldr	r3, [pc, #568]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000648:	8919      	ldrh	r1, [r3, #8]
 800064a:	4b8e      	ldr	r3, [pc, #568]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 800064c:	891b      	ldrh	r3, [r3, #8]
 800064e:	b29b      	uxth	r3, r3
 8000650:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000654:	005a      	lsls	r2, r3, #1
 8000656:	4291      	cmp	r1, r2
 8000658:	d00b      	beq.n	8000672 <ADCT_BGS_MODBUS_GetSetting+0x86>
    GstSystemSetting.usHighHumidityH2 = GTempSetting.usHighHumidityH2 * 10;
 800065a:	4b8a      	ldr	r3, [pc, #552]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 800065c:	891b      	ldrh	r3, [r3, #8]
 800065e:	b29b      	uxth	r3, r3
 8000660:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000664:	0059      	lsls	r1, r3, #1
 8000666:	b289      	uxth	r1, r1
 8000668:	4b85      	ldr	r3, [pc, #532]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800066a:	8119      	strh	r1, [r3, #8]
    ADCT_AT24C64_WriteTwoBytes(EEPROM_HIGH_HUMIDITY_H2_LOW,
 800066c:	2009      	movs	r0, #9
 800066e:	f002 f8c9 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
  else
  {
   // ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USHIGHHUMIDITYH2, GstSystemSetting.usHighHumidityH2 /10);
  }

  if (GstSystemSetting.usFanTemperatureT3
 8000672:	4b83      	ldr	r3, [pc, #524]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000674:	8899      	ldrh	r1, [r3, #4]
      != GTempSetting.usFanTemperatureT3 * 10) {
 8000676:	4b83      	ldr	r3, [pc, #524]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000678:	889b      	ldrh	r3, [r3, #4]
 800067a:	b29b      	uxth	r3, r3
 800067c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000680:	005a      	lsls	r2, r3, #1
  else
  {
   // ADCT_BGS_MODBUS_RS485_UpdateHoldingReg(USHIGHHUMIDITYH2, GstSystemSetting.usHighHumidityH2 /10);
  }

  if (GstSystemSetting.usFanTemperatureT3
 8000682:	4291      	cmp	r1, r2
 8000684:	d00b      	beq.n	800069e <ADCT_BGS_MODBUS_GetSetting+0xb2>
      != GTempSetting.usFanTemperatureT3 * 10) {
    GstSystemSetting.usFanTemperatureT3 = GTempSetting.usFanTemperatureT3 * 10;
 8000686:	4b7f      	ldr	r3, [pc, #508]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000688:	889b      	ldrh	r3, [r3, #4]
 800068a:	b29b      	uxth	r3, r3
 800068c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000690:	0059      	lsls	r1, r3, #1
 8000692:	b289      	uxth	r1, r1
 8000694:	4b7a      	ldr	r3, [pc, #488]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000696:	8099      	strh	r1, [r3, #4]
    ADCT_AT24C64_WriteTwoBytes(EEPROM_FAN_TEMPERATURE_T3_LOW,
 8000698:	2005      	movs	r0, #5
 800069a:	f002 f8b3 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usFanTemperatureT3);
  }
  if (GstSystemSetting.usLowMainVoltage != GTempSetting.usLowMainVoltage ) {
 800069e:	4b78      	ldr	r3, [pc, #480]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006a0:	895a      	ldrh	r2, [r3, #10]
 80006a2:	4b78      	ldr	r3, [pc, #480]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006a4:	895b      	ldrh	r3, [r3, #10]
 80006a6:	b29b      	uxth	r3, r3
 80006a8:	429a      	cmp	r2, r3
 80006aa:	d007      	beq.n	80006bc <ADCT_BGS_MODBUS_GetSetting+0xd0>
    GstSystemSetting.usLowMainVoltage = GTempSetting.usLowMainVoltage ;
 80006ac:	4b75      	ldr	r3, [pc, #468]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006ae:	8959      	ldrh	r1, [r3, #10]
 80006b0:	b289      	uxth	r1, r1
 80006b2:	4b73      	ldr	r3, [pc, #460]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006b4:	8159      	strh	r1, [r3, #10]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_LOWMAINVOLTAGE_LOW,
 80006b6:	201d      	movs	r0, #29
 80006b8:	f002 f8a4 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usLowMainVoltage);
  }

  if (GstSystemSetting.usHighMainVoltage
 80006bc:	4b70      	ldr	r3, [pc, #448]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006be:	899a      	ldrh	r2, [r3, #12]
      != GTempSetting.usHighMainVoltage ) {
 80006c0:	4b70      	ldr	r3, [pc, #448]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006c2:	899b      	ldrh	r3, [r3, #12]
 80006c4:	b29b      	uxth	r3, r3
    GstSystemSetting.usLowMainVoltage = GTempSetting.usLowMainVoltage ;
    ADCT_AT24C64_WriteTwoBytes(EPPROM_LOWMAINVOLTAGE_LOW,
                               GstSystemSetting.usLowMainVoltage);
  }

  if (GstSystemSetting.usHighMainVoltage
 80006c6:	429a      	cmp	r2, r3
 80006c8:	d007      	beq.n	80006da <ADCT_BGS_MODBUS_GetSetting+0xee>
      != GTempSetting.usHighMainVoltage ) {
    GstSystemSetting.usHighMainVoltage = GTempSetting.usHighMainVoltage;
 80006ca:	4b6e      	ldr	r3, [pc, #440]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006cc:	8999      	ldrh	r1, [r3, #12]
 80006ce:	b289      	uxth	r1, r1
 80006d0:	4b6b      	ldr	r3, [pc, #428]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006d2:	8199      	strh	r1, [r3, #12]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_HIGHMAINVOLTAGE_LOW,
 80006d4:	2021      	movs	r0, #33	; 0x21
 80006d6:	f002 f895 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usHighMainVoltage);
  }
  if (GstSystemSetting.usGenFuelLowValue != GTempSetting.usGenFuelLowValue ) {
 80006da:	4b69      	ldr	r3, [pc, #420]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006dc:	89da      	ldrh	r2, [r3, #14]
 80006de:	4b69      	ldr	r3, [pc, #420]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006e0:	89db      	ldrh	r3, [r3, #14]
 80006e2:	b29b      	uxth	r3, r3
 80006e4:	429a      	cmp	r2, r3
 80006e6:	d007      	beq.n	80006f8 <ADCT_BGS_MODBUS_GetSetting+0x10c>
    GstSystemSetting.usGenFuelLowValue = GTempSetting.usGenFuelLowValue ;
 80006e8:	4b66      	ldr	r3, [pc, #408]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006ea:	89d9      	ldrh	r1, [r3, #14]
 80006ec:	b289      	uxth	r1, r1
 80006ee:	4b64      	ldr	r3, [pc, #400]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006f0:	81d9      	strh	r1, [r3, #14]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENFUELLOWVALUE_LOW,
 80006f2:	2017      	movs	r0, #23
 80006f4:	f002 f886 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usGenFuelLowValue);
  }

  if (GstSystemSetting.usGenVoltageAlarmValue
 80006f8:	4b61      	ldr	r3, [pc, #388]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80006fa:	8a1a      	ldrh	r2, [r3, #16]
      != GTempSetting.usGenVoltageAlarmValue ) {
 80006fc:	4b61      	ldr	r3, [pc, #388]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80006fe:	8a1b      	ldrh	r3, [r3, #16]
 8000700:	b29b      	uxth	r3, r3
    GstSystemSetting.usGenFuelLowValue = GTempSetting.usGenFuelLowValue ;
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENFUELLOWVALUE_LOW,
                               GstSystemSetting.usGenFuelLowValue);
  }

  if (GstSystemSetting.usGenVoltageAlarmValue
 8000702:	429a      	cmp	r2, r3
 8000704:	d007      	beq.n	8000716 <ADCT_BGS_MODBUS_GetSetting+0x12a>
      != GTempSetting.usGenVoltageAlarmValue ) {
    GstSystemSetting.usGenVoltageAlarmValue = GTempSetting.usGenVoltageAlarmValue;
 8000706:	4b5f      	ldr	r3, [pc, #380]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000708:	8a19      	ldrh	r1, [r3, #16]
 800070a:	b289      	uxth	r1, r1
 800070c:	4b5c      	ldr	r3, [pc, #368]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800070e:	8219      	strh	r1, [r3, #16]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENVOLTAGEALARMVALUE_LOW,
 8000710:	201b      	movs	r0, #27
 8000712:	f002 f877 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usGenVoltageAlarmValue);
  }
  if (GstSystemSetting.usGenBatteryVoltageAlarmValue != GTempSetting.usGenBatteryVoltageAlarmValue ) {
 8000716:	4b5a      	ldr	r3, [pc, #360]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000718:	8a5a      	ldrh	r2, [r3, #18]
 800071a:	4b5a      	ldr	r3, [pc, #360]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 800071c:	8a5b      	ldrh	r3, [r3, #18]
 800071e:	b29b      	uxth	r3, r3
 8000720:	429a      	cmp	r2, r3
 8000722:	d007      	beq.n	8000734 <ADCT_BGS_MODBUS_GetSetting+0x148>
    GstSystemSetting.usGenBatteryVoltageAlarmValue = GTempSetting.usGenBatteryVoltageAlarmValue ;
 8000724:	4b57      	ldr	r3, [pc, #348]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000726:	8a59      	ldrh	r1, [r3, #18]
 8000728:	b289      	uxth	r1, r1
 800072a:	4b55      	ldr	r3, [pc, #340]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800072c:	8259      	strh	r1, [r3, #18]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENBATTERYVOLTAGEALARMVALUE_LOW,
 800072e:	2011      	movs	r0, #17
 8000730:	f002 f868 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usGenBatteryVoltageAlarmValue);
  }

  if (GstSystemSetting.usGenCoolantTempAlarmValue
 8000734:	4b52      	ldr	r3, [pc, #328]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000736:	8a9a      	ldrh	r2, [r3, #20]
      != GTempSetting.usGenCoolantTempAlarmValue ) {
 8000738:	4b52      	ldr	r3, [pc, #328]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 800073a:	8a9b      	ldrh	r3, [r3, #20]
 800073c:	b29b      	uxth	r3, r3
    GstSystemSetting.usGenBatteryVoltageAlarmValue = GTempSetting.usGenBatteryVoltageAlarmValue ;
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENBATTERYVOLTAGEALARMVALUE_LOW,
                               GstSystemSetting.usGenBatteryVoltageAlarmValue);
  }

  if (GstSystemSetting.usGenCoolantTempAlarmValue
 800073e:	429a      	cmp	r2, r3
 8000740:	d007      	beq.n	8000752 <ADCT_BGS_MODBUS_GetSetting+0x166>
      != GTempSetting.usGenCoolantTempAlarmValue ) {
    GstSystemSetting.usGenCoolantTempAlarmValue = GTempSetting.usGenCoolantTempAlarmValue;
 8000742:	4b50      	ldr	r3, [pc, #320]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000744:	8a99      	ldrh	r1, [r3, #20]
 8000746:	b289      	uxth	r1, r1
 8000748:	4b4d      	ldr	r3, [pc, #308]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800074a:	8299      	strh	r1, [r3, #20]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENCOOLANTTEMPALARMVALUE_LOW,
 800074c:	2013      	movs	r0, #19
 800074e:	f002 f859 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usGenCoolantTempAlarmValue);
  }
  if (GstSystemSetting.usGenEngineSpeedAlarmValue != GTempSetting.usGenEngineSpeedAlarmValue ) {
 8000752:	4b4b      	ldr	r3, [pc, #300]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000754:	8ada      	ldrh	r2, [r3, #22]
 8000756:	4b4b      	ldr	r3, [pc, #300]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000758:	8adb      	ldrh	r3, [r3, #22]
 800075a:	b29b      	uxth	r3, r3
 800075c:	429a      	cmp	r2, r3
 800075e:	d007      	beq.n	8000770 <ADCT_BGS_MODBUS_GetSetting+0x184>
    GstSystemSetting.usGenEngineSpeedAlarmValue = GTempSetting.usGenEngineSpeedAlarmValue ;
 8000760:	4b48      	ldr	r3, [pc, #288]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000762:	8ad9      	ldrh	r1, [r3, #22]
 8000764:	b289      	uxth	r1, r1
 8000766:	4b46      	ldr	r3, [pc, #280]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000768:	82d9      	strh	r1, [r3, #22]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENENGINESPEEDALARMVALUE_LOW,
 800076a:	2015      	movs	r0, #21
 800076c:	f002 f84a 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usGenEngineSpeedAlarmValue);
  }

  if (GstSystemSetting.usGenOilPressureAlarmValue
 8000770:	4b43      	ldr	r3, [pc, #268]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000772:	8b1a      	ldrh	r2, [r3, #24]
      != GTempSetting.usGenOilPressureAlarmValue ) {
 8000774:	4b43      	ldr	r3, [pc, #268]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000776:	8b1b      	ldrh	r3, [r3, #24]
 8000778:	b29b      	uxth	r3, r3
    GstSystemSetting.usGenEngineSpeedAlarmValue = GTempSetting.usGenEngineSpeedAlarmValue ;
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENENGINESPEEDALARMVALUE_LOW,
                               GstSystemSetting.usGenEngineSpeedAlarmValue);
  }

  if (GstSystemSetting.usGenOilPressureAlarmValue
 800077a:	429a      	cmp	r2, r3
 800077c:	d007      	beq.n	800078e <ADCT_BGS_MODBUS_GetSetting+0x1a2>
      != GTempSetting.usGenOilPressureAlarmValue ) {
    GstSystemSetting.usGenOilPressureAlarmValue = GTempSetting.usGenOilPressureAlarmValue;
 800077e:	4b41      	ldr	r3, [pc, #260]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000780:	8b19      	ldrh	r1, [r3, #24]
 8000782:	b289      	uxth	r1, r1
 8000784:	4b3e      	ldr	r3, [pc, #248]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000786:	8319      	strh	r1, [r3, #24]
    ADCT_AT24C64_WriteTwoBytes(EPPROM_GENOILPRESSUREALARMVALUE_LOW,
 8000788:	2019      	movs	r0, #25
 800078a:	f002 f83b 	bl	8002804 <ADCT_AT24C64_WriteTwoBytes>
                               GstSystemSetting.usGenOilPressureAlarmValue);
  }
  if (GstSystemSetting.ulSwitchingTime != GTempSetting.ulSwitchingTime ) {
 800078e:	4b3c      	ldr	r3, [pc, #240]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000790:	69da      	ldr	r2, [r3, #28]
 8000792:	4b3c      	ldr	r3, [pc, #240]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000794:	69db      	ldr	r3, [r3, #28]
 8000796:	429a      	cmp	r2, r3
 8000798:	d018      	beq.n	80007cc <ADCT_BGS_MODBUS_GetSetting+0x1e0>
    GstSystemSetting.ulSwitchingTime = GTempSetting.ulSwitchingTime ;
 800079a:	4b3a      	ldr	r3, [pc, #232]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 800079c:	69db      	ldr	r3, [r3, #28]
 800079e:	4a38      	ldr	r2, [pc, #224]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80007a0:	61d3      	str	r3, [r2, #28]
    uint32_t temp_ui32;
    temp_ui32 = GstSystemSetting.ulSwitchingTime %3600;
 80007a2:	4939      	ldr	r1, [pc, #228]	; (8000888 <ADCT_BGS_MODBUS_GetSetting+0x29c>)
 80007a4:	fba1 2103 	umull	r2, r1, r1, r3
 80007a8:	0acc      	lsrs	r4, r1, #11
 80007aa:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80007ae:	fb02 3414 	mls	r4, r2, r4, r3
    ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_HOUR, GstSystemSetting.ulSwitchingTime /3600);
 80007b2:	f3c1 21c7 	ubfx	r1, r1, #11, #8
 80007b6:	200b      	movs	r0, #11
 80007b8:	f002 f834 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>

    ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_MINUTE,
                               temp_ui32/60);
 80007bc:	4933      	ldr	r1, [pc, #204]	; (800088c <ADCT_BGS_MODBUS_GetSetting+0x2a0>)
 80007be:	fba1 3104 	umull	r3, r1, r1, r4
    GstSystemSetting.ulSwitchingTime = GTempSetting.ulSwitchingTime ;
    uint32_t temp_ui32;
    temp_ui32 = GstSystemSetting.ulSwitchingTime %3600;
    ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_HOUR, GstSystemSetting.ulSwitchingTime /3600);

    ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_MINUTE,
 80007c2:	f3c1 1147 	ubfx	r1, r1, #5, #8
 80007c6:	200c      	movs	r0, #12
 80007c8:	f002 f82c 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
                               temp_ui32/60);
  }

  if (GstSystemSetting.ulMinSwitchingTime
 80007cc:	4b2c      	ldr	r3, [pc, #176]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80007ce:	6a1a      	ldr	r2, [r3, #32]
      != GTempSetting.ulMinSwitchingTime ) {
 80007d0:	4b2c      	ldr	r3, [pc, #176]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80007d2:	6a1b      	ldr	r3, [r3, #32]

    ADCT_AT24C64_WriteOneBytes(EPPROM_SWITCHING_MINUTE,
                               temp_ui32/60);
  }

  if (GstSystemSetting.ulMinSwitchingTime
 80007d4:	429a      	cmp	r2, r3
 80007d6:	d018      	beq.n	800080a <ADCT_BGS_MODBUS_GetSetting+0x21e>
      != GTempSetting.ulMinSwitchingTime ) {
    GstSystemSetting.ulMinSwitchingTime = GTempSetting.ulMinSwitchingTime;
 80007d8:	4b2a      	ldr	r3, [pc, #168]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 80007da:	6a1b      	ldr	r3, [r3, #32]
 80007dc:	4a28      	ldr	r2, [pc, #160]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 80007de:	6213      	str	r3, [r2, #32]
    uint32_t temp_ui32;
    temp_ui32 = GstSystemSetting.ulMinSwitchingTime %3600;
 80007e0:	4929      	ldr	r1, [pc, #164]	; (8000888 <ADCT_BGS_MODBUS_GetSetting+0x29c>)
 80007e2:	fba1 2103 	umull	r2, r1, r1, r3
 80007e6:	0acc      	lsrs	r4, r1, #11
 80007e8:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80007ec:	fb02 3414 	mls	r4, r2, r4, r3
    ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_HOUR,
 80007f0:	f3c1 21c7 	ubfx	r1, r1, #11, #8
 80007f4:	201f      	movs	r0, #31
 80007f6:	f002 f815 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
                               GstSystemSetting.ulMinSwitchingTime /3600);

    ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_MINUTE,
                               temp_ui32/60);
 80007fa:	4924      	ldr	r1, [pc, #144]	; (800088c <ADCT_BGS_MODBUS_GetSetting+0x2a0>)
 80007fc:	fba1 3104 	umull	r3, r1, r1, r4
    uint32_t temp_ui32;
    temp_ui32 = GstSystemSetting.ulMinSwitchingTime %3600;
    ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_HOUR,
                               GstSystemSetting.ulMinSwitchingTime /3600);

    ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_MINUTE,
 8000800:	f3c1 1147 	ubfx	r1, r1, #5, #8
 8000804:	2020      	movs	r0, #32
 8000806:	f002 f80d 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
                               temp_ui32/60);
  }

  if (GstSystemSetting.ulStayOffTime
 800080a:	4b1d      	ldr	r3, [pc, #116]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800080c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
      != GTempSetting.ulStayOffTime ) {
 800080e:	4b1d      	ldr	r3, [pc, #116]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000810:	6a5b      	ldr	r3, [r3, #36]	; 0x24

    ADCT_AT24C64_WriteOneBytes(EPPROM_MINSWITCHINGTIME_MINUTE,
                               temp_ui32/60);
  }

  if (GstSystemSetting.ulStayOffTime
 8000812:	429a      	cmp	r2, r3
 8000814:	d018      	beq.n	8000848 <ADCT_BGS_MODBUS_GetSetting+0x25c>
      != GTempSetting.ulStayOffTime ) {
    GstSystemSetting.ulStayOffTime = GTempSetting.ulStayOffTime;
 8000816:	4b1b      	ldr	r3, [pc, #108]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000818:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800081a:	4a19      	ldr	r2, [pc, #100]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800081c:	6253      	str	r3, [r2, #36]	; 0x24

    uint32_t temp_ui32;
    temp_ui32 = GstSystemSetting.ulStayOffTime %3600;
 800081e:	491a      	ldr	r1, [pc, #104]	; (8000888 <ADCT_BGS_MODBUS_GetSetting+0x29c>)
 8000820:	fba1 2103 	umull	r2, r1, r1, r3
 8000824:	0acc      	lsrs	r4, r1, #11
 8000826:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800082a:	fb02 3414 	mls	r4, r2, r4, r3
    ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_HOUR,
 800082e:	f3c1 21c7 	ubfx	r1, r1, #11, #8
 8000832:	2023      	movs	r0, #35	; 0x23
 8000834:	f001 fff6 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
                               GstSystemSetting.ulStayOffTime /3600);

    ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_MINUTE,
                               temp_ui32/60);
 8000838:	4914      	ldr	r1, [pc, #80]	; (800088c <ADCT_BGS_MODBUS_GetSetting+0x2a0>)
 800083a:	fba1 3104 	umull	r3, r1, r1, r4
    uint32_t temp_ui32;
    temp_ui32 = GstSystemSetting.ulStayOffTime %3600;
    ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_HOUR,
                               GstSystemSetting.ulStayOffTime /3600);

    ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_MINUTE,
 800083e:	f3c1 1147 	ubfx	r1, r1, #5, #8
 8000842:	2024      	movs	r0, #36	; 0x24
 8000844:	f001 ffee 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
                               temp_ui32/60);
  }

  if (GstSystemSetting.ucEnableAlarm
 8000848:	4b0d      	ldr	r3, [pc, #52]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 800084a:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
      != GTempSetting.ucEnableAlarm ) {
 800084e:	4b0d      	ldr	r3, [pc, #52]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000850:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8000854:	b2db      	uxtb	r3, r3

    ADCT_AT24C64_WriteOneBytes(EPPROM_STAYOFFTIME_MINUTE,
                               temp_ui32/60);
  }

  if (GstSystemSetting.ucEnableAlarm
 8000856:	429a      	cmp	r2, r3
 8000858:	d009      	beq.n	800086e <ADCT_BGS_MODBUS_GetSetting+0x282>
      != GTempSetting.ucEnableAlarm ) {
    GstSystemSetting.ucEnableAlarm = GTempSetting.ucEnableAlarm;
 800085a:	4b0a      	ldr	r3, [pc, #40]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 800085c:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 8000860:	b2c9      	uxtb	r1, r1
 8000862:	4b07      	ldr	r3, [pc, #28]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000864:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
    ADCT_AT24C64_WriteOneBytes(EPPROM_ENABLE_ALARM,
 8000868:	200e      	movs	r0, #14
 800086a:	f001 ffdb 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
                               GstSystemSetting.ucEnableAlarm);
  }

  if (GstSystemSetting.ucDoorBurglarEnableAlarm
 800086e:	4b04      	ldr	r3, [pc, #16]	; (8000880 <ADCT_BGS_MODBUS_GetSetting+0x294>)
 8000870:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
      != GTempSetting.ucDoorBurglarEnableAlarm ) {
 8000874:	4b03      	ldr	r3, [pc, #12]	; (8000884 <ADCT_BGS_MODBUS_GetSetting+0x298>)
 8000876:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800087a:	b2db      	uxtb	r3, r3
    GstSystemSetting.ucEnableAlarm = GTempSetting.ucEnableAlarm;
    ADCT_AT24C64_WriteOneBytes(EPPROM_ENABLE_ALARM,
                               GstSystemSetting.ucEnableAlarm);
  }

  if (GstSystemSetting.ucDoorBurglarEnableAlarm
 800087c:	429a      	cmp	r2, r3
 800087e:	e007      	b.n	8000890 <ADCT_BGS_MODBUS_GetSetting+0x2a4>
 8000880:	200004c0 	.word	0x200004c0
 8000884:	2000044c 	.word	0x2000044c
 8000888:	91a2b3c5 	.word	0x91a2b3c5
 800088c:	88888889 	.word	0x88888889
 8000890:	d009      	beq.n	80008a6 <ADCT_BGS_MODBUS_GetSetting+0x2ba>
      != GTempSetting.ucDoorBurglarEnableAlarm ) {
    GstSystemSetting.ucDoorBurglarEnableAlarm = GTempSetting.ucDoorBurglarEnableAlarm;
 8000892:	4b05      	ldr	r3, [pc, #20]	; (80008a8 <ADCT_BGS_MODBUS_GetSetting+0x2bc>)
 8000894:	f893 1029 	ldrb.w	r1, [r3, #41]	; 0x29
 8000898:	b2c9      	uxtb	r1, r1
 800089a:	4b04      	ldr	r3, [pc, #16]	; (80008ac <ADCT_BGS_MODBUS_GetSetting+0x2c0>)
 800089c:	f883 1029 	strb.w	r1, [r3, #41]	; 0x29
    ADCT_AT24C64_WriteOneBytes(EPPROM_DOORBURGLAR_ENABLEALARM,
 80008a0:	200d      	movs	r0, #13
 80008a2:	f001 ffbf 	bl	8002824 <ADCT_AT24C64_WriteOneBytes>
 80008a6:	bd10      	pop	{r4, pc}
 80008a8:	2000044c 	.word	0x2000044c
 80008ac:	200004c0 	.word	0x200004c0

080008b0 <eMBRegInputCB>:
  }
}
eMBErrorCode eMBRegInputCB(UCHAR * pucRegBuffer, USHORT usAddress,
                           USHORT usNRegs) {
  return MB_ENOREG;
}
 80008b0:	2001      	movs	r0, #1
 80008b2:	4770      	bx	lr

080008b4 <eMBRegHoldingCB>:

eMBErrorCode eMBRegHoldingCB(UCHAR * pucRegBuffer, USHORT usAddress,
                             USHORT usNRegs, eMBRegisterMode eMode) {
 80008b4:	b430      	push	{r4, r5}
  eMBErrorCode eStatus = MB_ENOERR;
  int iRegIndex;

  if ((usAddress >= ADCT_REG_HOLDING_START)
 80008b6:	f649 4440 	movw	r4, #40000	; 0x9c40
 80008ba:	42a1      	cmp	r1, r4
 80008bc:	d934      	bls.n	8000928 <eMBRegHoldingCB+0x74>
      && (usAddress + usNRegs <= ADCT_REG_HOLDING_START + REG_HOLDING_NREGS)) {
 80008be:	1855      	adds	r5, r2, r1
 80008c0:	f649 4491 	movw	r4, #40081	; 0x9c91
 80008c4:	42a5      	cmp	r5, r4
 80008c6:	dc31      	bgt.n	800092c <eMBRegHoldingCB+0x78>
    iRegIndex = (int) (usAddress - usRegHoldingStart);
 80008c8:	f5a1 411c 	sub.w	r1, r1, #39936	; 0x9c00
 80008cc:	3941      	subs	r1, #65	; 0x41

    switch (eMode)
 80008ce:	b18b      	cbz	r3, 80008f4 <eMBRegHoldingCB+0x40>
 80008d0:	2b01      	cmp	r3, #1
 80008d2:	d025      	beq.n	8000920 <eMBRegHoldingCB+0x6c>
 80008d4:	e02c      	b.n	8000930 <eMBRegHoldingCB+0x7c>
    {
      case MB_REG_READ:
        while (usNRegs > 0) {
          *pucRegBuffer++ = (UCHAR) (usRegHoldingBuf[iRegIndex] >> 8);
 80008d6:	4d18      	ldr	r5, [pc, #96]	; (8000938 <eMBRegHoldingCB+0x84>)
 80008d8:	f835 4011 	ldrh.w	r4, [r5, r1, lsl #1]
 80008dc:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80008e0:	4603      	mov	r3, r0
 80008e2:	f803 4b02 	strb.w	r4, [r3], #2
          *pucRegBuffer++ = (UCHAR) (usRegHoldingBuf[iRegIndex] & 0xFF);
 80008e6:	f835 4011 	ldrh.w	r4, [r5, r1, lsl #1]
 80008ea:	7044      	strb	r4, [r0, #1]
          iRegIndex++;
 80008ec:	3101      	adds	r1, #1
          usNRegs--;
 80008ee:	3a01      	subs	r2, #1
 80008f0:	b292      	uxth	r2, r2
    switch (eMode)
    {
      case MB_REG_READ:
        while (usNRegs > 0) {
          *pucRegBuffer++ = (UCHAR) (usRegHoldingBuf[iRegIndex] >> 8);
          *pucRegBuffer++ = (UCHAR) (usRegHoldingBuf[iRegIndex] & 0xFF);
 80008f2:	4618      	mov	r0, r3
    iRegIndex = (int) (usAddress - usRegHoldingStart);

    switch (eMode)
    {
      case MB_REG_READ:
        while (usNRegs > 0) {
 80008f4:	2a00      	cmp	r2, #0
 80008f6:	d1ee      	bne.n	80008d6 <eMBRegHoldingCB+0x22>
  return MB_ENOREG;
}

eMBErrorCode eMBRegHoldingCB(UCHAR * pucRegBuffer, USHORT usAddress,
                             USHORT usNRegs, eMBRegisterMode eMode) {
  eMBErrorCode eStatus = MB_ENOERR;
 80008f8:	2000      	movs	r0, #0
 80008fa:	e01a      	b.n	8000932 <eMBRegHoldingCB+0x7e>
          usNRegs--;
        }
        break;
      case MB_REG_WRITE:
        while (usNRegs > 0) {
          usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
 80008fc:	4603      	mov	r3, r0
 80008fe:	f813 5b02 	ldrb.w	r5, [r3], #2
 8000902:	022d      	lsls	r5, r5, #8
 8000904:	4c0c      	ldr	r4, [pc, #48]	; (8000938 <eMBRegHoldingCB+0x84>)
 8000906:	f824 5011 	strh.w	r5, [r4, r1, lsl #1]
          usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
 800090a:	7845      	ldrb	r5, [r0, #1]
 800090c:	f834 0011 	ldrh.w	r0, [r4, r1, lsl #1]
 8000910:	b280      	uxth	r0, r0
 8000912:	4328      	orrs	r0, r5
 8000914:	f824 0011 	strh.w	r0, [r4, r1, lsl #1]
          iRegIndex++;
 8000918:	3101      	adds	r1, #1
          usNRegs--;
 800091a:	3a01      	subs	r2, #1
 800091c:	b292      	uxth	r2, r2
        }
        break;
      case MB_REG_WRITE:
        while (usNRegs > 0) {
          usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
          usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
 800091e:	4618      	mov	r0, r3
          iRegIndex++;
          usNRegs--;
        }
        break;
      case MB_REG_WRITE:
        while (usNRegs > 0) {
 8000920:	2a00      	cmp	r2, #0
 8000922:	d1eb      	bne.n	80008fc <eMBRegHoldingCB+0x48>
  return MB_ENOREG;
}

eMBErrorCode eMBRegHoldingCB(UCHAR * pucRegBuffer, USHORT usAddress,
                             USHORT usNRegs, eMBRegisterMode eMode) {
  eMBErrorCode eStatus = MB_ENOERR;
 8000924:	2000      	movs	r0, #0
 8000926:	e004      	b.n	8000932 <eMBRegHoldingCB+0x7e>
          usNRegs--;
        }
        break;
    }
  } else {
    eStatus = MB_ENOREG;
 8000928:	2001      	movs	r0, #1
 800092a:	e002      	b.n	8000932 <eMBRegHoldingCB+0x7e>
 800092c:	2001      	movs	r0, #1
 800092e:	e000      	b.n	8000932 <eMBRegHoldingCB+0x7e>
  return MB_ENOREG;
}

eMBErrorCode eMBRegHoldingCB(UCHAR * pucRegBuffer, USHORT usAddress,
                             USHORT usNRegs, eMBRegisterMode eMode) {
  eMBErrorCode eStatus = MB_ENOERR;
 8000930:	2000      	movs	r0, #0
    }
  } else {
    eStatus = MB_ENOREG;
  }
  return eStatus;
}
 8000932:	bc30      	pop	{r4, r5}
 8000934:	4770      	bx	lr
 8000936:	bf00      	nop
 8000938:	20000218 	.word	0x20000218

0800093c <eMBRegCoilsCB>:

eMBErrorCode eMBRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress,
                           USHORT usNCoils, eMBRegisterMode eMode) {
  return MB_ENOREG;
}
 800093c:	2001      	movs	r0, #1
 800093e:	4770      	bx	lr

08000940 <eMBRegDiscreteCB>:

eMBErrorCode eMBRegDiscreteCB(UCHAR * pucRegBuffer, USHORT usAddress,
                              USHORT usNDiscrete) {
  return MB_ENOREG;
}
 8000940:	2001      	movs	r0, #1
 8000942:	4770      	bx	lr

08000944 <ADCT_BGS_GetCurrentRTCData>:
		ADCT_BGS_AlarmBuzzer();
		g_ASW_Task_flag.ASW_1s_flag = ADCT_FALSE;
	}
}
void ADCT_BGS_GetCurrentRTCData(void )
{
 8000944:	b508      	push	{r3, lr}
	ADCT_BGS_Run_RTC(&g_ADCT_BGS_Current_RTC);
 8000946:	4802      	ldr	r0, [pc, #8]	; (8000950 <ADCT_BGS_GetCurrentRTCData+0xc>)
 8000948:	f002 fe60 	bl	800360c <ADCT_BGS_Run_RTC>
 800094c:	bd08      	pop	{r3, pc}
 800094e:	bf00      	nop
 8000950:	200004a8 	.word	0x200004a8

08000954 <ADCT_BGS_SwitchAIR_TimeCal>:
}
void ADCT_BGS_SwitchAIR_TimeCal(void)
{
	if(g_ADCT_BGS_TimerManager.SWitchingTimer.second  == 0)
 8000954:	4b17      	ldr	r3, [pc, #92]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 8000956:	789b      	ldrb	r3, [r3, #2]
 8000958:	bb43      	cbnz	r3, 80009ac <ADCT_BGS_SwitchAIR_TimeCal+0x58>
	{
		g_ADCT_BGS_TimerManager.SWitchingTimer.second = 59;
 800095a:	4b16      	ldr	r3, [pc, #88]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 800095c:	223b      	movs	r2, #59	; 0x3b
 800095e:	709a      	strb	r2, [r3, #2]
		if(g_ADCT_BGS_TimerManager.SWitchingTimer.minute == 0)
 8000960:	785b      	ldrb	r3, [r3, #1]
 8000962:	b9fb      	cbnz	r3, 80009a4 <ADCT_BGS_SwitchAIR_TimeCal+0x50>
		{
			g_ADCT_BGS_TimerManager.SWitchingTimer.minute = 59;
 8000964:	4b13      	ldr	r3, [pc, #76]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 8000966:	705a      	strb	r2, [r3, #1]
			if(g_ADCT_BGS_TimerManager.SWitchingTimer.hour == 0)
 8000968:	781b      	ldrb	r3, [r3, #0]
 800096a:	b9bb      	cbnz	r3, 800099c <ADCT_BGS_SwitchAIR_TimeCal+0x48>
void ADCT_BGS_GetCurrentRTCData(void )
{
	ADCT_BGS_Run_RTC(&g_ADCT_BGS_Current_RTC);
}
void ADCT_BGS_SwitchAIR_TimeCal(void)
{
 800096c:	b510      	push	{r4, lr}
		if(g_ADCT_BGS_TimerManager.SWitchingTimer.minute == 0)
		{
			g_ADCT_BGS_TimerManager.SWitchingTimer.minute = 59;
			if(g_ADCT_BGS_TimerManager.SWitchingTimer.hour == 0)
			{
				if(g_ADCT_BGS_StateOutput.WITCH_AIR == ADCT_TRUE)
 800096e:	4b12      	ldr	r3, [pc, #72]	; (80009b8 <ADCT_BGS_SwitchAIR_TimeCal+0x64>)
 8000970:	7a9b      	ldrb	r3, [r3, #10]
 8000972:	2b01      	cmp	r3, #1
 8000974:	d103      	bne.n	800097e <ADCT_BGS_SwitchAIR_TimeCal+0x2a>
				{
					g_ADCT_BGS_StateOutput.WITCH_AIR = ADCT_FALSE;
 8000976:	2200      	movs	r2, #0
 8000978:	4b0f      	ldr	r3, [pc, #60]	; (80009b8 <ADCT_BGS_SwitchAIR_TimeCal+0x64>)
 800097a:	729a      	strb	r2, [r3, #10]
 800097c:	e002      	b.n	8000984 <ADCT_BGS_SwitchAIR_TimeCal+0x30>
				}
				else
				{
					g_ADCT_BGS_StateOutput.WITCH_AIR = ADCT_TRUE;
 800097e:	2201      	movs	r2, #1
 8000980:	4b0d      	ldr	r3, [pc, #52]	; (80009b8 <ADCT_BGS_SwitchAIR_TimeCal+0x64>)
 8000982:	729a      	strb	r2, [r3, #10]
				}
				g_ADCT_BGS_TimerManager.SWitchingTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_HOUR);
 8000984:	200b      	movs	r0, #11
 8000986:	f001 ff27 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 800098a:	4c0a      	ldr	r4, [pc, #40]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 800098c:	7020      	strb	r0, [r4, #0]
				g_ADCT_BGS_TimerManager.SWitchingTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_MINUTE);
 800098e:	200c      	movs	r0, #12
 8000990:	f001 ff22 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8000994:	7060      	strb	r0, [r4, #1]
				g_ADCT_BGS_TimerManager.SWitchingTimer.second = 0;
 8000996:	2300      	movs	r3, #0
 8000998:	70a3      	strb	r3, [r4, #2]
 800099a:	bd10      	pop	{r4, pc}
			}
			else
			{
				g_ADCT_BGS_TimerManager.SWitchingTimer.hour -- ;
 800099c:	3b01      	subs	r3, #1
 800099e:	4a05      	ldr	r2, [pc, #20]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 80009a0:	7013      	strb	r3, [r2, #0]
 80009a2:	4770      	bx	lr
			}
		}else
		{
			g_ADCT_BGS_TimerManager.SWitchingTimer.minute --;
 80009a4:	3b01      	subs	r3, #1
 80009a6:	4a03      	ldr	r2, [pc, #12]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 80009a8:	7053      	strb	r3, [r2, #1]
 80009aa:	4770      	bx	lr
		}
	}
	else
	{
		g_ADCT_BGS_TimerManager.SWitchingTimer.second --;
 80009ac:	3b01      	subs	r3, #1
 80009ae:	4a01      	ldr	r2, [pc, #4]	; (80009b4 <ADCT_BGS_SwitchAIR_TimeCal+0x60>)
 80009b0:	7093      	strb	r3, [r2, #2]
	}
}
 80009b2:	4770      	bx	lr
 80009b4:	20000490 	.word	0x20000490
 80009b8:	200004b0 	.word	0x200004b0

080009bc <ADCT_BGS_CheckMinSwitchAIR1_2>:

// Timer to check if air_1 has run at least t_min (s)
void ADCT_BGS_CheckMinSwitchAIR1_2(void)
{
	if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == ADCT_TRUE)
 80009bc:	4b0c      	ldr	r3, [pc, #48]	; (80009f0 <ADCT_BGS_CheckMinSwitchAIR1_2+0x34>)
 80009be:	795b      	ldrb	r3, [r3, #5]
 80009c0:	2b01      	cmp	r3, #1
 80009c2:	d113      	bne.n	80009ec <ADCT_BGS_CheckMinSwitchAIR1_2+0x30>
	{
		if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second == 0)
 80009c4:	4b0b      	ldr	r3, [pc, #44]	; (80009f4 <ADCT_BGS_CheckMinSwitchAIR1_2+0x38>)
 80009c6:	795b      	ldrb	r3, [r3, #5]
 80009c8:	b96b      	cbnz	r3, 80009e6 <ADCT_BGS_CheckMinSwitchAIR1_2+0x2a>
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second = 59;
 80009ca:	4b0a      	ldr	r3, [pc, #40]	; (80009f4 <ADCT_BGS_CheckMinSwitchAIR1_2+0x38>)
 80009cc:	223b      	movs	r2, #59	; 0x3b
 80009ce:	715a      	strb	r2, [r3, #5]
			if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute == 0)
 80009d0:	791b      	ldrb	r3, [r3, #4]
 80009d2:	b923      	cbnz	r3, 80009de <ADCT_BGS_CheckMinSwitchAIR1_2+0x22>
			{
				g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = FALSE;
 80009d4:	4a06      	ldr	r2, [pc, #24]	; (80009f0 <ADCT_BGS_CheckMinSwitchAIR1_2+0x34>)
 80009d6:	7153      	strb	r3, [r2, #5]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second = 0;
 80009d8:	4a06      	ldr	r2, [pc, #24]	; (80009f4 <ADCT_BGS_CheckMinSwitchAIR1_2+0x38>)
 80009da:	7153      	strb	r3, [r2, #5]
 80009dc:	4770      	bx	lr
			}
			else
			{
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute --;
 80009de:	3b01      	subs	r3, #1
 80009e0:	4a04      	ldr	r2, [pc, #16]	; (80009f4 <ADCT_BGS_CheckMinSwitchAIR1_2+0x38>)
 80009e2:	7113      	strb	r3, [r2, #4]
 80009e4:	4770      	bx	lr
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second --;
 80009e6:	3b01      	subs	r3, #1
 80009e8:	4a02      	ldr	r2, [pc, #8]	; (80009f4 <ADCT_BGS_CheckMinSwitchAIR1_2+0x38>)
 80009ea:	7153      	strb	r3, [r2, #5]
 80009ec:	4770      	bx	lr
 80009ee:	bf00      	nop
 80009f0:	200004b0 	.word	0x200004b0
 80009f4:	20000490 	.word	0x20000490

080009f8 <ADCT_BGS_CheckMinSwitchAIR3_4>:
		}
	}
}
void ADCT_BGS_CheckMinSwitchAIR3_4(void)
{
	if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == ADCT_TRUE)
 80009f8:	4b0c      	ldr	r3, [pc, #48]	; (8000a2c <ADCT_BGS_CheckMinSwitchAIR3_4+0x34>)
 80009fa:	799b      	ldrb	r3, [r3, #6]
 80009fc:	2b01      	cmp	r3, #1
 80009fe:	d113      	bne.n	8000a28 <ADCT_BGS_CheckMinSwitchAIR3_4+0x30>
	{
		if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second == 0)
 8000a00:	4b0b      	ldr	r3, [pc, #44]	; (8000a30 <ADCT_BGS_CheckMinSwitchAIR3_4+0x38>)
 8000a02:	7a1b      	ldrb	r3, [r3, #8]
 8000a04:	b96b      	cbnz	r3, 8000a22 <ADCT_BGS_CheckMinSwitchAIR3_4+0x2a>
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second = 59;
 8000a06:	4b0a      	ldr	r3, [pc, #40]	; (8000a30 <ADCT_BGS_CheckMinSwitchAIR3_4+0x38>)
 8000a08:	223b      	movs	r2, #59	; 0x3b
 8000a0a:	721a      	strb	r2, [r3, #8]
			if(g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute == 0)
 8000a0c:	79db      	ldrb	r3, [r3, #7]
 8000a0e:	b923      	cbnz	r3, 8000a1a <ADCT_BGS_CheckMinSwitchAIR3_4+0x22>
			{
				g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = FALSE;
 8000a10:	4a06      	ldr	r2, [pc, #24]	; (8000a2c <ADCT_BGS_CheckMinSwitchAIR3_4+0x34>)
 8000a12:	7193      	strb	r3, [r2, #6]
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second = 0;
 8000a14:	4a06      	ldr	r2, [pc, #24]	; (8000a30 <ADCT_BGS_CheckMinSwitchAIR3_4+0x38>)
 8000a16:	7213      	strb	r3, [r2, #8]
 8000a18:	4770      	bx	lr
			}
			else
			{
				g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute --;
 8000a1a:	3b01      	subs	r3, #1
 8000a1c:	4a04      	ldr	r2, [pc, #16]	; (8000a30 <ADCT_BGS_CheckMinSwitchAIR3_4+0x38>)
 8000a1e:	71d3      	strb	r3, [r2, #7]
 8000a20:	4770      	bx	lr
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second --;
 8000a22:	3b01      	subs	r3, #1
 8000a24:	4a02      	ldr	r2, [pc, #8]	; (8000a30 <ADCT_BGS_CheckMinSwitchAIR3_4+0x38>)
 8000a26:	7213      	strb	r3, [r2, #8]
 8000a28:	4770      	bx	lr
 8000a2a:	bf00      	nop
 8000a2c:	200004b0 	.word	0x200004b0
 8000a30:	20000490 	.word	0x20000490

08000a34 <ADCT_BGS_CheckBuzzerTimerRun>:
		}
	}
}
void ADCT_BGS_CheckBuzzerTimerRun(void)
{
 8000a34:	b538      	push	{r3, r4, r5, lr}
	if(g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE == ADCT_TRUE)
 8000a36:	4b13      	ldr	r3, [pc, #76]	; (8000a84 <ADCT_BGS_CheckBuzzerTimerRun+0x50>)
 8000a38:	791b      	ldrb	r3, [r3, #4]
 8000a3a:	2b01      	cmp	r3, #1
 8000a3c:	d120      	bne.n	8000a80 <ADCT_BGS_CheckBuzzerTimerRun+0x4c>
	{
		if(g_ADCT_BGS_TimerManager.BuzzerTimer.second == 0)
 8000a3e:	4b12      	ldr	r3, [pc, #72]	; (8000a88 <ADCT_BGS_CheckBuzzerTimerRun+0x54>)
 8000a40:	7b9b      	ldrb	r3, [r3, #14]
 8000a42:	b9d3      	cbnz	r3, 8000a7a <ADCT_BGS_CheckBuzzerTimerRun+0x46>
		{
			g_ADCT_BGS_TimerManager.BuzzerTimer.second = 59;
 8000a44:	4b10      	ldr	r3, [pc, #64]	; (8000a88 <ADCT_BGS_CheckBuzzerTimerRun+0x54>)
 8000a46:	223b      	movs	r2, #59	; 0x3b
 8000a48:	739a      	strb	r2, [r3, #14]
			if(g_ADCT_BGS_TimerManager.BuzzerTimer.minute ==0)
 8000a4a:	7b5b      	ldrb	r3, [r3, #13]
 8000a4c:	b98b      	cbnz	r3, 8000a72 <ADCT_BGS_CheckBuzzerTimerRun+0x3e>
			{
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute = 59;
 8000a4e:	4b0e      	ldr	r3, [pc, #56]	; (8000a88 <ADCT_BGS_CheckBuzzerTimerRun+0x54>)
 8000a50:	735a      	strb	r2, [r3, #13]
				if(g_ADCT_BGS_TimerManager.BuzzerTimer.hour == 0)
 8000a52:	7b1b      	ldrb	r3, [r3, #12]
 8000a54:	b9a3      	cbnz	r3, 8000a80 <ADCT_BGS_CheckBuzzerTimerRun+0x4c>
				{
					g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE = ADCT_FALSE;
 8000a56:	2500      	movs	r5, #0
 8000a58:	4b0a      	ldr	r3, [pc, #40]	; (8000a84 <ADCT_BGS_CheckBuzzerTimerRun+0x50>)
 8000a5a:	711d      	strb	r5, [r3, #4]
					g_ADCT_BGS_TimerManager.BuzzerTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_LOW);
 8000a5c:	200f      	movs	r0, #15
 8000a5e:	f001 febb 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8000a62:	4c09      	ldr	r4, [pc, #36]	; (8000a88 <ADCT_BGS_CheckBuzzerTimerRun+0x54>)
 8000a64:	7320      	strb	r0, [r4, #12]
					g_ADCT_BGS_TimerManager.BuzzerTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH);
 8000a66:	2010      	movs	r0, #16
 8000a68:	f001 feb6 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8000a6c:	7360      	strb	r0, [r4, #13]
					g_ADCT_BGS_TimerManager.BuzzerTimer.second =0;
 8000a6e:	73a5      	strb	r5, [r4, #14]
 8000a70:	bd38      	pop	{r3, r4, r5, pc}
				}
			}
			else
			{
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute --;
 8000a72:	3b01      	subs	r3, #1
 8000a74:	4a04      	ldr	r2, [pc, #16]	; (8000a88 <ADCT_BGS_CheckBuzzerTimerRun+0x54>)
 8000a76:	7353      	strb	r3, [r2, #13]
 8000a78:	bd38      	pop	{r3, r4, r5, pc}
			}
		}else
		{
			g_ADCT_BGS_TimerManager.BuzzerTimer.second--;
 8000a7a:	3b01      	subs	r3, #1
 8000a7c:	4a02      	ldr	r2, [pc, #8]	; (8000a88 <ADCT_BGS_CheckBuzzerTimerRun+0x54>)
 8000a7e:	7393      	strb	r3, [r2, #14]
 8000a80:	bd38      	pop	{r3, r4, r5, pc}
 8000a82:	bf00      	nop
 8000a84:	200004b0 	.word	0x200004b0
 8000a88:	20000490 	.word	0x20000490

08000a8c <ADCT_BGS_CheckDelayOfftime>:
	}
}

void ADCT_BGS_CheckDelayOfftime(void)
{
	if(g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE == ADCT_TRUE)
 8000a8c:	4b0d      	ldr	r3, [pc, #52]	; (8000ac4 <ADCT_BGS_CheckDelayOfftime+0x38>)
 8000a8e:	7a1b      	ldrb	r3, [r3, #8]
 8000a90:	2b01      	cmp	r3, #1
 8000a92:	d116      	bne.n	8000ac2 <ADCT_BGS_CheckDelayOfftime+0x36>
	{
		if(g_ADCT_BGS_TimerManager.StayOffTimer.second ==0)
 8000a94:	4b0c      	ldr	r3, [pc, #48]	; (8000ac8 <ADCT_BGS_CheckDelayOfftime+0x3c>)
 8000a96:	7adb      	ldrb	r3, [r3, #11]
 8000a98:	b983      	cbnz	r3, 8000abc <ADCT_BGS_CheckDelayOfftime+0x30>
		{
			g_ADCT_BGS_TimerManager.StayOffTimer.second = 59;
 8000a9a:	4b0b      	ldr	r3, [pc, #44]	; (8000ac8 <ADCT_BGS_CheckDelayOfftime+0x3c>)
 8000a9c:	223b      	movs	r2, #59	; 0x3b
 8000a9e:	72da      	strb	r2, [r3, #11]
			if(g_ADCT_BGS_TimerManager.StayOffTimer.minute == 0)
 8000aa0:	7a9b      	ldrb	r3, [r3, #10]
 8000aa2:	b93b      	cbnz	r3, 8000ab4 <ADCT_BGS_CheckDelayOfftime+0x28>
			{
				g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_STATE = ADCT_FALSE;
 8000aa4:	4b07      	ldr	r3, [pc, #28]	; (8000ac4 <ADCT_BGS_CheckDelayOfftime+0x38>)
 8000aa6:	2200      	movs	r2, #0
 8000aa8:	721a      	strb	r2, [r3, #8]
				g_ADCT_BGS_TimerManager.StayOffTimer.second = 0;
 8000aaa:	4907      	ldr	r1, [pc, #28]	; (8000ac8 <ADCT_BGS_CheckDelayOfftime+0x3c>)
 8000aac:	72ca      	strb	r2, [r1, #11]
				g_ADCT_BGS_StateOutput.DELAY_OFFTIMER_ELAPSED = ADCT_TRUE;
 8000aae:	2201      	movs	r2, #1
 8000ab0:	725a      	strb	r2, [r3, #9]
 8000ab2:	4770      	bx	lr
			}
			else
			{
				g_ADCT_BGS_TimerManager.StayOffTimer.minute --;
 8000ab4:	3b01      	subs	r3, #1
 8000ab6:	4a04      	ldr	r2, [pc, #16]	; (8000ac8 <ADCT_BGS_CheckDelayOfftime+0x3c>)
 8000ab8:	7293      	strb	r3, [r2, #10]
 8000aba:	4770      	bx	lr
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.StayOffTimer.second -- ;
 8000abc:	3b01      	subs	r3, #1
 8000abe:	4a02      	ldr	r2, [pc, #8]	; (8000ac8 <ADCT_BGS_CheckDelayOfftime+0x3c>)
 8000ac0:	72d3      	strb	r3, [r2, #11]
 8000ac2:	4770      	bx	lr
 8000ac4:	200004b0 	.word	0x200004b0
 8000ac8:	20000490 	.word	0x20000490

08000acc <ADCT_BGS_CheckTminFan>:
		}
	}
}
void ADCT_BGS_CheckTminFan(void)
{
	if(g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == ADCT_TRUE)
 8000acc:	4b0c      	ldr	r3, [pc, #48]	; (8000b00 <ADCT_BGS_CheckTminFan+0x34>)
 8000ace:	789b      	ldrb	r3, [r3, #2]
 8000ad0:	2b01      	cmp	r3, #1
 8000ad2:	d113      	bne.n	8000afc <ADCT_BGS_CheckTminFan+0x30>
	{
		if(g_ADCT_BGS_TimerManager.MinRuningTimerFan.second == 0)
 8000ad4:	4b0b      	ldr	r3, [pc, #44]	; (8000b04 <ADCT_BGS_CheckTminFan+0x38>)
 8000ad6:	7d1b      	ldrb	r3, [r3, #20]
 8000ad8:	b96b      	cbnz	r3, 8000af6 <ADCT_BGS_CheckTminFan+0x2a>
		{
			g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = 59;
 8000ada:	4b0a      	ldr	r3, [pc, #40]	; (8000b04 <ADCT_BGS_CheckTminFan+0x38>)
 8000adc:	223b      	movs	r2, #59	; 0x3b
 8000ade:	751a      	strb	r2, [r3, #20]
			if(g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute == 0)
 8000ae0:	7cdb      	ldrb	r3, [r3, #19]
 8000ae2:	b923      	cbnz	r3, 8000aee <ADCT_BGS_CheckTminFan+0x22>
			{
				g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
 8000ae4:	4a06      	ldr	r2, [pc, #24]	; (8000b00 <ADCT_BGS_CheckTminFan+0x34>)
 8000ae6:	7093      	strb	r3, [r2, #2]
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = 0;
 8000ae8:	4a06      	ldr	r2, [pc, #24]	; (8000b04 <ADCT_BGS_CheckTminFan+0x38>)
 8000aea:	7513      	strb	r3, [r2, #20]
 8000aec:	4770      	bx	lr
			}
			else
			{
				g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute--;
 8000aee:	3b01      	subs	r3, #1
 8000af0:	4a04      	ldr	r2, [pc, #16]	; (8000b04 <ADCT_BGS_CheckTminFan+0x38>)
 8000af2:	74d3      	strb	r3, [r2, #19]
 8000af4:	4770      	bx	lr
			}
		}
		else
		{
			g_ADCT_BGS_TimerManager.MinRuningTimerFan.second -- ;
 8000af6:	3b01      	subs	r3, #1
 8000af8:	4a02      	ldr	r2, [pc, #8]	; (8000b04 <ADCT_BGS_CheckTminFan+0x38>)
 8000afa:	7513      	strb	r3, [r2, #20]
 8000afc:	4770      	bx	lr
 8000afe:	bf00      	nop
 8000b00:	200004b0 	.word	0x200004b0
 8000b04:	20000490 	.word	0x20000490

08000b08 <ADCT_BGS_AlarmBuzzer>:
	}
}

void ADCT_BGS_AlarmBuzzer(void)
{
	if(g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag == ADCT_TRUE)
 8000b08:	4b0f      	ldr	r3, [pc, #60]	; (8000b48 <ADCT_BGS_AlarmBuzzer+0x40>)
 8000b0a:	7adb      	ldrb	r3, [r3, #11]
 8000b0c:	2b01      	cmp	r3, #1
 8000b0e:	d11a      	bne.n	8000b46 <ADCT_BGS_AlarmBuzzer+0x3e>
	{
		if(g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt == 0)
 8000b10:	4b0d      	ldr	r3, [pc, #52]	; (8000b48 <ADCT_BGS_AlarmBuzzer+0x40>)
 8000b12:	7b1b      	ldrb	r3, [r3, #12]
 8000b14:	b99b      	cbnz	r3, 8000b3e <ADCT_BGS_AlarmBuzzer+0x36>
		{
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_FALSE;
 8000b16:	4b0c      	ldr	r3, [pc, #48]	; (8000b48 <ADCT_BGS_AlarmBuzzer+0x40>)
 8000b18:	2200      	movs	r2, #0
 8000b1a:	72da      	strb	r2, [r3, #11]
			g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE = ADCT_FALSE;
 8000b1c:	70da      	strb	r2, [r3, #3]
			if(g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE == ADCT_FALSE)
 8000b1e:	791b      	ldrb	r3, [r3, #4]
 8000b20:	b98b      	cbnz	r3, 8000b46 <ADCT_BGS_AlarmBuzzer+0x3e>
		}
	}
}

void ADCT_BGS_AlarmBuzzer(void)
{
 8000b22:	b510      	push	{r4, lr}
		{
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_FALSE;
			g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE = ADCT_FALSE;
			if(g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE == ADCT_FALSE)
			{
				g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE = ADCT_TRUE;
 8000b24:	2201      	movs	r2, #1
 8000b26:	4b08      	ldr	r3, [pc, #32]	; (8000b48 <ADCT_BGS_AlarmBuzzer+0x40>)
 8000b28:	711a      	strb	r2, [r3, #4]
				g_ADCT_BGS_TimerManager.BuzzerTimer.hour = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH );
 8000b2a:	2010      	movs	r0, #16
 8000b2c:	f001 fe54 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8000b30:	4c06      	ldr	r4, [pc, #24]	; (8000b4c <ADCT_BGS_AlarmBuzzer+0x44>)
 8000b32:	7320      	strb	r0, [r4, #12]
				g_ADCT_BGS_TimerManager.BuzzerTimer.minute = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_LOW );
 8000b34:	200f      	movs	r0, #15
 8000b36:	f001 fe4f 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8000b3a:	7360      	strb	r0, [r4, #13]
 8000b3c:	bd10      	pop	{r4, pc}
			}
		}
		else
		{
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt -- ;
 8000b3e:	3b01      	subs	r3, #1
 8000b40:	4a01      	ldr	r2, [pc, #4]	; (8000b48 <ADCT_BGS_AlarmBuzzer+0x40>)
 8000b42:	7313      	strb	r3, [r2, #12]
		}
	}
}
 8000b44:	4770      	bx	lr
 8000b46:	4770      	bx	lr
 8000b48:	200004b0 	.word	0x200004b0
 8000b4c:	20000490 	.word	0x20000490

08000b50 <ADCT_IO_FPT_GetValue>:
  * @brief Get value of I/Os.
  * @param pIOData        : data of I/Os
  * @retval None
  */
void ADCT_IO_FPT_GetValue(IO_MODULE_DATA *pIOData)
{
 8000b50:	b538      	push	{r3, r4, r5, lr}
 8000b52:	4604      	mov	r4, r0
	/*DOOR*/
	pIOData->ucDoor [0] = !ADCT_BGS_DOOR_READ ;
 8000b54:	4d26      	ldr	r5, [pc, #152]	; (8000bf0 <ADCT_IO_FPT_GetValue+0xa0>)
 8000b56:	2102      	movs	r1, #2
 8000b58:	4628      	mov	r0, r5
 8000b5a:	f003 fb31 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000b5e:	fab0 f080 	clz	r0, r0
 8000b62:	0940      	lsrs	r0, r0, #5
 8000b64:	70e0      	strb	r0, [r4, #3]
	pIOData->ucDoor [1] = !ADCT_BGS_DOOR_READ ;
 8000b66:	2102      	movs	r1, #2
 8000b68:	4628      	mov	r0, r5
 8000b6a:	f003 fb29 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000b6e:	fab0 f080 	clz	r0, r0
 8000b72:	0940      	lsrs	r0, r0, #5
 8000b74:	7120      	strb	r0, [r4, #4]
	pIOData->ucDoor [2] = !ADCT_BGS_DOOR_READ ;
 8000b76:	2102      	movs	r1, #2
 8000b78:	4628      	mov	r0, r5
 8000b7a:	f003 fb21 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000b7e:	fab0 f080 	clz	r0, r0
 8000b82:	0940      	lsrs	r0, r0, #5
 8000b84:	7160      	strb	r0, [r4, #5]
	pIOData->ucDoor [3] = !ADCT_BGS_DOOR_READ ;
 8000b86:	2102      	movs	r1, #2
 8000b88:	4628      	mov	r0, r5
 8000b8a:	f003 fb19 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000b8e:	fab0 f080 	clz	r0, r0
 8000b92:	0940      	lsrs	r0, r0, #5
 8000b94:	71a0      	strb	r0, [r4, #6]
	pIOData->ucDoor [4] = !ADCT_BGS_DOOR_READ ;
 8000b96:	2102      	movs	r1, #2
 8000b98:	4628      	mov	r0, r5
 8000b9a:	f003 fb11 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000b9e:	fab0 f080 	clz	r0, r0
 8000ba2:	0940      	lsrs	r0, r0, #5
 8000ba4:	71e0      	strb	r0, [r4, #7]
	/*FIRE*/
	pIOData->ucFire = ADCT_BGS_FIRE_READ;
 8000ba6:	2108      	movs	r1, #8
 8000ba8:	4628      	mov	r0, r5
 8000baa:	f003 fb09 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000bae:	7020      	strb	r0, [r4, #0]
	/*WATER*/
	pIOData->ucWater = ADCT_BGS_WATER_READ;
 8000bb0:	2110      	movs	r1, #16
 8000bb2:	4628      	mov	r0, r5
 8000bb4:	f003 fb04 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000bb8:	70a0      	strb	r0, [r4, #2]
	/*SMOKE*/
	pIOData->ucSmoke = ADCT_BGS_SMOKE_READ;
 8000bba:	2101      	movs	r1, #1
 8000bbc:	4628      	mov	r0, r5
 8000bbe:	f003 faff 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000bc2:	7060      	strb	r0, [r4, #1]

	/*BURGLAR*/
	pIOData->ucBurglar = !ADCT_BGS_BURGLAR_READ;
 8000bc4:	2104      	movs	r1, #4
 8000bc6:	4628      	mov	r0, r5
 8000bc8:	f003 fafa 	bl	80041c0 <GPIO_ReadInputDataBit>
 8000bcc:	fab0 f080 	clz	r0, r0
 8000bd0:	0940      	lsrs	r0, r0, #5
 8000bd2:	7220      	strb	r0, [r4, #8]
	/*BUZZER*/
	pIOData->ucBuzzer = ADCT_BGS_BUZZER_READ();
 8000bd4:	f5a5 6500 	sub.w	r5, r5, #2048	; 0x800
 8000bd8:	2102      	movs	r1, #2
 8000bda:	4628      	mov	r0, r5
 8000bdc:	f003 faf8 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000be0:	7460      	strb	r0, [r4, #17]
	/*LED*/
	pIOData->ucLed = ADCT_BGS_LAMP_READ();
 8000be2:	2101      	movs	r1, #1
 8000be4:	4628      	mov	r0, r5
 8000be6:	f003 faf3 	bl	80041d0 <GPIO_ReadOutputDataBit>
 8000bea:	74a0      	strb	r0, [r4, #18]
 8000bec:	bd38      	pop	{r3, r4, r5, pc}
 8000bee:	bf00      	nop
 8000bf0:	40011000 	.word	0x40011000

08000bf4 <ADCT_BGS_StateManger>:
void ADCT_BGS_CheckTminFan(void);
void ADCT_BGS_CheckDelayOfftime(void);
void ADCT_BGS_AlarmBuzzer(void);
void ADCT_BGS_GetCurrentRTCData(void );
void ADCT_BGS_StateManger(void)
{
 8000bf4:	b508      	push	{r3, lr}

	if(g_ASW_Task_flag.ASW_1s_flag == ADCT_TRUE)
 8000bf6:	4b19      	ldr	r3, [pc, #100]	; (8000c5c <ADCT_BGS_StateManger+0x68>)
 8000bf8:	781b      	ldrb	r3, [r3, #0]
 8000bfa:	2b01      	cmp	r3, #1
 8000bfc:	d12c      	bne.n	8000c58 <ADCT_BGS_StateManger+0x64>
	{
		if(count_dht22 >3)
 8000bfe:	4b18      	ldr	r3, [pc, #96]	; (8000c60 <ADCT_BGS_StateManger+0x6c>)
 8000c00:	781b      	ldrb	r3, [r3, #0]
 8000c02:	2b03      	cmp	r3, #3
 8000c04:	d909      	bls.n	8000c1a <ADCT_BGS_StateManger+0x26>
		{
		/* Call sequence start reading DHT 22 */
		/* DHT 22 main */
		ADCT_BGS_DHT22Start(DHT22_Device_1);
 8000c06:	2000      	movs	r0, #0
 8000c08:	f000 ff0e 	bl	8001a28 <ADCT_BGS_DHT22Start>
		/* DHT22 sub */
#ifdef SUB_DHT22
		ADCT_BGS_DHT22Start(DHT22_Device_2);
 8000c0c:	2001      	movs	r0, #1
 8000c0e:	f000 ff0b 	bl	8001a28 <ADCT_BGS_DHT22Start>
		count_dht22 =0;
 8000c12:	2200      	movs	r2, #0
 8000c14:	4b12      	ldr	r3, [pc, #72]	; (8000c60 <ADCT_BGS_StateManger+0x6c>)
 8000c16:	701a      	strb	r2, [r3, #0]
 8000c18:	e002      	b.n	8000c20 <ADCT_BGS_StateManger+0x2c>
#endif
		}
		else
		{
			count_dht22 ++;
 8000c1a:	3301      	adds	r3, #1
 8000c1c:	4a10      	ldr	r2, [pc, #64]	; (8000c60 <ADCT_BGS_StateManger+0x6c>)
 8000c1e:	7013      	strb	r3, [r2, #0]
		}
		/* Get the latest RTC value */
		ADCT_BGS_GetCurrentRTCData();
 8000c20:	f7ff fe90 	bl	8000944 <ADCT_BGS_GetCurrentRTCData>
		/* Get all input data */
		ADCT_IO_FPT_GetValue(&GstSystemStatus.ioData);
 8000c24:	480f      	ldr	r0, [pc, #60]	; (8000c64 <ADCT_BGS_StateManger+0x70>)
 8000c26:	f7ff ff93 	bl	8000b50 <ADCT_IO_FPT_GetValue>
		/* check state modbus */
		ADCT_SYSTEM_FPT_CheckState_MODBUS();
 8000c2a:	f000 f81d 	bl	8000c68 <ADCT_SYSTEM_FPT_CheckState_MODBUS>
		/* Check state IO */
		ADCT_SYSTEM_FPT_CheckState_IO();
 8000c2e:	f000 f8f7 	bl	8000e20 <ADCT_SYSTEM_FPT_CheckState_IO>
		/* Check buzzer timer */
		ADCT_BGS_CheckBuzzerTimerRun();
 8000c32:	f7ff feff 	bl	8000a34 <ADCT_BGS_CheckBuzzerTimerRun>
		/* Check switching time */
		ADCT_BGS_SwitchAIR_TimeCal();
 8000c36:	f7ff fe8d 	bl	8000954 <ADCT_BGS_SwitchAIR_TimeCal>
		/* Check time min swith for AIR 1_2*/
		ADCT_BGS_CheckMinSwitchAIR1_2();
 8000c3a:	f7ff febf 	bl	80009bc <ADCT_BGS_CheckMinSwitchAIR1_2>
		/* Check time min switch for AIR 3_4 */
		ADCT_BGS_CheckMinSwitchAIR3_4();
 8000c3e:	f7ff fedb 	bl	80009f8 <ADCT_BGS_CheckMinSwitchAIR3_4>
		/* Check state DHT22 */
		ADCT_SYSTEM_FPT_CheckState_DHT();
 8000c42:	f000 f9a5 	bl	8000f90 <ADCT_SYSTEM_FPT_CheckState_DHT>
		/* Check t min fan */
		ADCT_BGS_CheckTminFan();
 8000c46:	f7ff ff41 	bl	8000acc <ADCT_BGS_CheckTminFan>

		/* Check delay off time */
		ADCT_BGS_CheckDelayOfftime();
 8000c4a:	f7ff ff1f 	bl	8000a8c <ADCT_BGS_CheckDelayOfftime>
		ADCT_BGS_AlarmBuzzer();
 8000c4e:	f7ff ff5b 	bl	8000b08 <ADCT_BGS_AlarmBuzzer>
		g_ASW_Task_flag.ASW_1s_flag = ADCT_FALSE;
 8000c52:	2200      	movs	r2, #0
 8000c54:	4b01      	ldr	r3, [pc, #4]	; (8000c5c <ADCT_BGS_StateManger+0x68>)
 8000c56:	701a      	strb	r2, [r3, #0]
 8000c58:	bd08      	pop	{r3, pc}
 8000c5a:	bf00      	nop
 8000c5c:	20000444 	.word	0x20000444
 8000c60:	2000048c 	.word	0x2000048c
 8000c64:	2000052a 	.word	0x2000052a

08000c68 <ADCT_SYSTEM_FPT_CheckState_MODBUS>:
}
#ifdef ADCT_MODBUS_ENABLED
void ADCT_SYSTEM_FPT_CheckState_MODBUS(void )
{
	/* High Main voltage */
	if((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usHighMainVoltage)&&
 8000c68:	4b6a      	ldr	r3, [pc, #424]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000c6a:	881b      	ldrh	r3, [r3, #0]
 8000c6c:	4a6a      	ldr	r2, [pc, #424]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000c6e:	8992      	ldrh	r2, [r2, #12]
 8000c70:	4293      	cmp	r3, r2
 8000c72:	d909      	bls.n	8000c88 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x20>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_OFF))
 8000c74:	4969      	ldr	r1, [pc, #420]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000c76:	6849      	ldr	r1, [r1, #4]
}
#ifdef ADCT_MODBUS_ENABLED
void ADCT_SYSTEM_FPT_CheckState_MODBUS(void )
{
	/* High Main voltage */
	if((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usHighMainVoltage)&&
 8000c78:	f411 6f00 	tst.w	r1, #2048	; 0x800
 8000c7c:	d104      	bne.n	8000c88 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x20>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_OFF))
	{
		/*Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_ON);
 8000c7e:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8000c82:	4a66      	ldr	r2, [pc, #408]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000c84:	6051      	str	r1, [r2, #4]
 8000c86:	e00a      	b.n	8000c9e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x36>

		/* Store log into EPPRROM */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usHighMainVoltage) &&
 8000c88:	4293      	cmp	r3, r2
 8000c8a:	d208      	bcs.n	8000c9e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x36>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_ON))
 8000c8c:	4a63      	ldr	r2, [pc, #396]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000c8e:	6852      	ldr	r2, [r2, #4]
		/*Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_ON);

		/* Store log into EPPRROM */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usHighMainVoltage) &&
 8000c90:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8000c94:	d003      	beq.n	8000c9e <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x36>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE) == WARN_ON))
	{
		/* Set warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_OFF);
 8000c96:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8000c9a:	4960      	ldr	r1, [pc, #384]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000c9c:	604a      	str	r2, [r1, #4]
		/* Store log into Epprom */
	}
	/* Low Main Voltage (SNMP_SYT_013) */
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
 8000c9e:	4a5e      	ldr	r2, [pc, #376]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000ca0:	8952      	ldrh	r2, [r2, #10]
 8000ca2:	4293      	cmp	r3, r2
 8000ca4:	d209      	bcs.n	8000cba <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x52>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_OFF))
 8000ca6:	495d      	ldr	r1, [pc, #372]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000ca8:	6849      	ldr	r1, [r1, #4]
		/* Set warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHMAINVOLTAGE, WARN_OFF);
		/* Store log into Epprom */
	}
	/* Low Main Voltage (SNMP_SYT_013) */
	if((GstSystemStatus.mbData.usCurrentMainVoltage < GstSystemSetting.usLowMainVoltage) &&
 8000caa:	f411 5f80 	tst.w	r1, #4096	; 0x1000
 8000cae:	d104      	bne.n	8000cba <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x52>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_ON);
 8000cb0:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8000cb4:	4b59      	ldr	r3, [pc, #356]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000cb6:	6059      	str	r1, [r3, #4]
 8000cb8:	e00a      	b.n	8000cd0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x68>
		/* Set log */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usLowMainVoltage) &&
 8000cba:	4293      	cmp	r3, r2
 8000cbc:	d908      	bls.n	8000cd0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x68>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_ON))
 8000cbe:	4b57      	ldr	r3, [pc, #348]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000cc0:	685b      	ldr	r3, [r3, #4]
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_ON);
		/* Set log */
	}
	else if ((GstSystemStatus.mbData.usCurrentMainVoltage > GstSystemSetting.usLowMainVoltage) &&
 8000cc2:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8000cc6:	d003      	beq.n	8000cd0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x68>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_OFF);
 8000cc8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000ccc:	4a53      	ldr	r2, [pc, #332]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000cce:	6053      	str	r3, [r2, #4]
		/* Set Log */
	}

	/* Low Fuel (SNMP_SYT_015) */
	if((GstSystemStatus.mbData.usCurrentGenFuel < GstSystemSetting.usGenFuelLowValue) &&
 8000cd0:	4b50      	ldr	r3, [pc, #320]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000cd2:	885a      	ldrh	r2, [r3, #2]
 8000cd4:	4b50      	ldr	r3, [pc, #320]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000cd6:	89db      	ldrh	r3, [r3, #14]
 8000cd8:	429a      	cmp	r2, r3
 8000cda:	d209      	bcs.n	8000cf0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x88>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_OFF))
 8000cdc:	494f      	ldr	r1, [pc, #316]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000cde:	6849      	ldr	r1, [r1, #4]
		WriteBit(GstSystemWarning.othWarn, WARN_LOWMAINVOLTAGE, WARN_OFF);
		/* Set Log */
	}

	/* Low Fuel (SNMP_SYT_015) */
	if((GstSystemStatus.mbData.usCurrentGenFuel < GstSystemSetting.usGenFuelLowValue) &&
 8000ce0:	f411 4f80 	tst.w	r1, #16384	; 0x4000
 8000ce4:	d104      	bne.n	8000cf0 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x88>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_ON);
 8000ce6:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000cea:	4b4c      	ldr	r3, [pc, #304]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000cec:	6059      	str	r1, [r3, #4]
 8000cee:	e00a      	b.n	8000d06 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x9e>
		/* Set Log */
	}
	else if ((GstSystemStatus.mbData.usCurrentGenFuel > GstSystemSetting.usGenFuelLowValue) &&
 8000cf0:	429a      	cmp	r2, r3
 8000cf2:	d908      	bls.n	8000d06 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x9e>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON))
 8000cf4:	4b49      	ldr	r3, [pc, #292]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000cf6:	685b      	ldr	r3, [r3, #4]
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_ON);
		/* Set Log */
	}
	else if ((GstSystemStatus.mbData.usCurrentGenFuel > GstSystemSetting.usGenFuelLowValue) &&
 8000cf8:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8000cfc:	d003      	beq.n	8000d06 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x9e>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_OFF);
 8000cfe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000d02:	4a46      	ldr	r2, [pc, #280]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d04:	6053      	str	r3, [r2, #4]
		/* Set Log */
	}
	/* Low Oil Pressure (SNMP_SYT_016) */
	if((GstSystemStatus.mbData.usCurrentGenOilPressure < GstSystemSetting.usGenOilPressureAlarmValue) &&
 8000d06:	4b43      	ldr	r3, [pc, #268]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000d08:	899a      	ldrh	r2, [r3, #12]
 8000d0a:	4b43      	ldr	r3, [pc, #268]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000d0c:	8b1b      	ldrh	r3, [r3, #24]
 8000d0e:	429a      	cmp	r2, r3
 8000d10:	d209      	bcs.n	8000d26 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xbe>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_OFF))
 8000d12:	4942      	ldr	r1, [pc, #264]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d14:	6849      	ldr	r1, [r1, #4]
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWFUEL, WARN_OFF);
		/* Set Log */
	}
	/* Low Oil Pressure (SNMP_SYT_016) */
	if((GstSystemStatus.mbData.usCurrentGenOilPressure < GstSystemSetting.usGenOilPressureAlarmValue) &&
 8000d16:	f411 4f00 	tst.w	r1, #32768	; 0x8000
 8000d1a:	d104      	bne.n	8000d26 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xbe>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS, WARN_ON);
 8000d1c:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8000d20:	4b3e      	ldr	r3, [pc, #248]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d22:	6059      	str	r1, [r3, #4]
 8000d24:	e00a      	b.n	8000d3c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xd4>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenOilPressure > GstSystemSetting.usGenOilPressureAlarmValue) &&
 8000d26:	429a      	cmp	r2, r3
 8000d28:	d908      	bls.n	8000d3c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xd4>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_ON))
 8000d2a:	4b3c      	ldr	r3, [pc, #240]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d2c:	685b      	ldr	r3, [r3, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenOilPressure > GstSystemSetting.usGenOilPressureAlarmValue) &&
 8000d2e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8000d32:	d003      	beq.n	8000d3c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xd4>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWOILPRESS, WARN_OFF);
 8000d34:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8000d38:	4a38      	ldr	r2, [pc, #224]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d3a:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Generate Voltage (SNMP_SYT_017) */
	if((GstSystemStatus.mbData.usCurrentGenVoltage < GstSystemSetting.usGenVoltageAlarmValue) &&
 8000d3c:	4b35      	ldr	r3, [pc, #212]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000d3e:	889a      	ldrh	r2, [r3, #4]
 8000d40:	4b35      	ldr	r3, [pc, #212]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000d42:	8a1b      	ldrh	r3, [r3, #16]
 8000d44:	429a      	cmp	r2, r3
 8000d46:	d209      	bcs.n	8000d5c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xf4>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_OFF))
 8000d48:	4934      	ldr	r1, [pc, #208]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d4a:	6849      	ldr	r1, [r1, #4]
		/* Set Log */

	}

	/* Low Generate Voltage (SNMP_SYT_017) */
	if((GstSystemStatus.mbData.usCurrentGenVoltage < GstSystemSetting.usGenVoltageAlarmValue) &&
 8000d4c:	f411 3f80 	tst.w	r1, #65536	; 0x10000
 8000d50:	d104      	bne.n	8000d5c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0xf4>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE, WARN_ON);
 8000d52:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8000d56:	4b31      	ldr	r3, [pc, #196]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d58:	6059      	str	r1, [r3, #4]
 8000d5a:	e00a      	b.n	8000d72 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x10a>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenVoltage > GstSystemSetting.usGenVoltageAlarmValue) &&
 8000d5c:	429a      	cmp	r2, r3
 8000d5e:	d908      	bls.n	8000d72 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x10a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_ON))
 8000d60:	4b2e      	ldr	r3, [pc, #184]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d62:	685b      	ldr	r3, [r3, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenVoltage > GstSystemSetting.usGenVoltageAlarmValue) &&
 8000d64:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8000d68:	d003      	beq.n	8000d72 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x10a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENVOLTAGE, WARN_OFF);
 8000d6a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000d6e:	4a2b      	ldr	r2, [pc, #172]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d70:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Generate Battery (SNMP_SYT_018) */
	if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage < GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 8000d72:	4b28      	ldr	r3, [pc, #160]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000d74:	88da      	ldrh	r2, [r3, #6]
 8000d76:	4b28      	ldr	r3, [pc, #160]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000d78:	8a5b      	ldrh	r3, [r3, #18]
 8000d7a:	429a      	cmp	r2, r3
 8000d7c:	d209      	bcs.n	8000d92 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x12a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_OFF))
 8000d7e:	4927      	ldr	r1, [pc, #156]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d80:	6849      	ldr	r1, [r1, #4]
		/* Set Log */

	}

	/* Low Generate Battery (SNMP_SYT_018) */
	if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage < GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 8000d82:	f411 3f00 	tst.w	r1, #131072	; 0x20000
 8000d86:	d104      	bne.n	8000d92 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x12a>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENBAT, WARN_ON);
 8000d88:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 8000d8c:	4b23      	ldr	r3, [pc, #140]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d8e:	6059      	str	r1, [r3, #4]
 8000d90:	e00a      	b.n	8000da8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x140>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage > GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 8000d92:	429a      	cmp	r2, r3
 8000d94:	d908      	bls.n	8000da8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x140>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_ON))
 8000d96:	4b21      	ldr	r3, [pc, #132]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000d98:	685b      	ldr	r3, [r3, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENBAT, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenBatteryVoltage > GstSystemSetting.usGenBatteryVoltageAlarmValue) &&
 8000d9a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8000d9e:	d003      	beq.n	8000da8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x140>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWGENBAT) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWGENBAT, WARN_OFF);
 8000da0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8000da4:	4a1d      	ldr	r2, [pc, #116]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000da6:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Engine Speed (SNMP_SYT_019) */
	if((GstSystemStatus.mbData.usCurrentGenEngineSpeed < GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 8000da8:	4b1a      	ldr	r3, [pc, #104]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000daa:	895a      	ldrh	r2, [r3, #10]
 8000dac:	4b1a      	ldr	r3, [pc, #104]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000dae:	8adb      	ldrh	r3, [r3, #22]
 8000db0:	429a      	cmp	r2, r3
 8000db2:	d209      	bcs.n	8000dc8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x160>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_OFF))
 8000db4:	4919      	ldr	r1, [pc, #100]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000db6:	6849      	ldr	r1, [r1, #4]
		/* Set Log */

	}

	/* Low Engine Speed (SNMP_SYT_019) */
	if((GstSystemStatus.mbData.usCurrentGenEngineSpeed < GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 8000db8:	f411 2f80 	tst.w	r1, #262144	; 0x40000
 8000dbc:	d104      	bne.n	8000dc8 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x160>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWENSPEED, WARN_ON);
 8000dbe:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 8000dc2:	4b16      	ldr	r3, [pc, #88]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000dc4:	6059      	str	r1, [r3, #4]
 8000dc6:	e00a      	b.n	8000dde <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x176>
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenEngineSpeed > GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 8000dc8:	429a      	cmp	r2, r3
 8000dca:	d908      	bls.n	8000dde <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x176>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_ON))
 8000dcc:	4b13      	ldr	r3, [pc, #76]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000dce:	685b      	ldr	r3, [r3, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWENSPEED, WARN_ON);
		/* Set Log */

	}
	else if((GstSystemStatus.mbData.usCurrentGenEngineSpeed > GstSystemSetting.usGenEngineSpeedAlarmValue) &&
 8000dd0:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8000dd4:	d003      	beq.n	8000dde <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x176>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWENSPEED) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWENSPEED, WARN_OFF);
 8000dd6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000dda:	4a10      	ldr	r2, [pc, #64]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000ddc:	6053      	str	r3, [r2, #4]
		/* Set Log */

	}

	/* Low Coolant Temperature (SNMP_SYT_020) */
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp < GstSystemSetting.usGenCoolantTempAlarmValue) &&
 8000dde:	4b0d      	ldr	r3, [pc, #52]	; (8000e14 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1ac>)
 8000de0:	891a      	ldrh	r2, [r3, #8]
 8000de2:	4b0d      	ldr	r3, [pc, #52]	; (8000e18 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b0>)
 8000de4:	8a9b      	ldrh	r3, [r3, #20]
 8000de6:	429a      	cmp	r2, r3
 8000de8:	d208      	bcs.n	8000dfc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x194>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_OFF))
 8000dea:	490c      	ldr	r1, [pc, #48]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000dec:	6849      	ldr	r1, [r1, #4]
		/* Set Log */

	}

	/* Low Coolant Temperature (SNMP_SYT_020) */
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp < GstSystemSetting.usGenCoolantTempAlarmValue) &&
 8000dee:	f411 2f00 	tst.w	r1, #524288	; 0x80000
 8000df2:	d103      	bne.n	8000dfc <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x194>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP, WARN_ON);
 8000df4:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 8000df8:	4808      	ldr	r0, [pc, #32]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000dfa:	6041      	str	r1, [r0, #4]
		/* Set Log */

	}
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp > GstSystemSetting.usGenCoolantTempAlarmValue) &&
 8000dfc:	429a      	cmp	r2, r3
 8000dfe:	d908      	bls.n	8000e12 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1aa>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_ON))
 8000e00:	4b06      	ldr	r3, [pc, #24]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000e02:	685b      	ldr	r3, [r3, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP, WARN_ON);
		/* Set Log */

	}
	if((GstSystemStatus.mbData.usCurrentGenCoolantTemp > GstSystemSetting.usGenCoolantTempAlarmValue) &&
 8000e04:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8000e08:	d003      	beq.n	8000e12 <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1aa>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWCOOLTEMP, WARN_OFF);
 8000e0a:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8000e0e:	4a03      	ldr	r2, [pc, #12]	; (8000e1c <ADCT_SYSTEM_FPT_CheckState_MODBUS+0x1b4>)
 8000e10:	6053      	str	r3, [r2, #4]
 8000e12:	4770      	bx	lr
 8000e14:	2000050c 	.word	0x2000050c
 8000e18:	200004c0 	.word	0x200004c0
 8000e1c:	20000504 	.word	0x20000504

08000e20 <ADCT_SYSTEM_FPT_CheckState_IO>:
 * @retval None
 */
void ADCT_SYSTEM_FPT_CheckState_IO(void)
{
	/* Fire (SNMP_SYT_007) */
	if(GstSystemStatus.ioData.ucFire == (ReadBit(GstSystemWarning.othWarn, WARN_FIRE)))
 8000e20:	4b57      	ldr	r3, [pc, #348]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000e22:	7f9a      	ldrb	r2, [r3, #30]
 8000e24:	4b57      	ldr	r3, [pc, #348]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e26:	685b      	ldr	r3, [r3, #4]
 8000e28:	f3c3 1180 	ubfx	r1, r3, #6, #1
 8000e2c:	428a      	cmp	r2, r1
 8000e2e:	d117      	bne.n	8000e60 <ADCT_SYSTEM_FPT_CheckState_IO+0x40>
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_FIRE, !GstSystemStatus.ioData.ucFire);
 8000e30:	b922      	cbnz	r2, 8000e3c <ADCT_SYSTEM_FPT_CheckState_IO+0x1c>
 8000e32:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000e36:	4953      	ldr	r1, [pc, #332]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e38:	604b      	str	r3, [r1, #4]
 8000e3a:	e003      	b.n	8000e44 <ADCT_SYSTEM_FPT_CheckState_IO+0x24>
 8000e3c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000e40:	4950      	ldr	r1, [pc, #320]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e42:	604b      	str	r3, [r1, #4]
		if(!GstSystemStatus.ioData.ucFire)
 8000e44:	b94a      	cbnz	r2, 8000e5a <ADCT_SYSTEM_FPT_CheckState_IO+0x3a>
		{
			GstSystemWarning.State = MAINSTATE_ALARM;
 8000e46:	2206      	movs	r2, #6
 8000e48:	4b4e      	ldr	r3, [pc, #312]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e4a:	701a      	strb	r2, [r3, #0]
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000e4c:	4b4e      	ldr	r3, [pc, #312]	; (8000f88 <ADCT_SYSTEM_FPT_CheckState_IO+0x168>)
 8000e4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000e50:	4b4e      	ldr	r3, [pc, #312]	; (8000f8c <ADCT_SYSTEM_FPT_CheckState_IO+0x16c>)
 8000e52:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000e54:	2201      	movs	r2, #1
 8000e56:	72da      	strb	r2, [r3, #11]
 8000e58:	e002      	b.n	8000e60 <ADCT_SYSTEM_FPT_CheckState_IO+0x40>
		}
		else
		{
			/* Set Log */
			GstSystemWarning.State = MAINSTATE_IDLE;
 8000e5a:	2201      	movs	r2, #1
 8000e5c:	4b49      	ldr	r3, [pc, #292]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e5e:	701a      	strb	r2, [r3, #0]
		}
	}

	/* Smoke (SNMP_SYT_008) */
	if(GstSystemStatus.ioData.ucSmoke == (ReadBit(GstSystemWarning.othWarn, WARN_SMOKE)))
 8000e60:	4b47      	ldr	r3, [pc, #284]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000e62:	7fda      	ldrb	r2, [r3, #31]
 8000e64:	4b47      	ldr	r3, [pc, #284]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e66:	685b      	ldr	r3, [r3, #4]
 8000e68:	f3c3 11c0 	ubfx	r1, r3, #7, #1
 8000e6c:	428a      	cmp	r2, r1
 8000e6e:	d117      	bne.n	8000ea0 <ADCT_SYSTEM_FPT_CheckState_IO+0x80>
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_SMOKE, !GstSystemStatus.ioData.ucSmoke);
 8000e70:	b922      	cbnz	r2, 8000e7c <ADCT_SYSTEM_FPT_CheckState_IO+0x5c>
 8000e72:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000e76:	4943      	ldr	r1, [pc, #268]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e78:	604b      	str	r3, [r1, #4]
 8000e7a:	e003      	b.n	8000e84 <ADCT_SYSTEM_FPT_CheckState_IO+0x64>
 8000e7c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000e80:	4940      	ldr	r1, [pc, #256]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e82:	604b      	str	r3, [r1, #4]
		if(!GstSystemStatus.ioData.ucSmoke)
 8000e84:	b94a      	cbnz	r2, 8000e9a <ADCT_SYSTEM_FPT_CheckState_IO+0x7a>
		{
			GstSystemWarning.State = MAINSTATE_ALARM;
 8000e86:	2206      	movs	r2, #6
 8000e88:	4b3e      	ldr	r3, [pc, #248]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e8a:	701a      	strb	r2, [r3, #0]
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000e8c:	4b3e      	ldr	r3, [pc, #248]	; (8000f88 <ADCT_SYSTEM_FPT_CheckState_IO+0x168>)
 8000e8e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000e90:	4b3e      	ldr	r3, [pc, #248]	; (8000f8c <ADCT_SYSTEM_FPT_CheckState_IO+0x16c>)
 8000e92:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000e94:	2201      	movs	r2, #1
 8000e96:	72da      	strb	r2, [r3, #11]
 8000e98:	e002      	b.n	8000ea0 <ADCT_SYSTEM_FPT_CheckState_IO+0x80>
		}
		else
		{
			/* Set Log */
			GstSystemWarning.State = MAINSTATE_IDLE;
 8000e9a:	2201      	movs	r2, #1
 8000e9c:	4b39      	ldr	r3, [pc, #228]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000e9e:	701a      	strb	r2, [r3, #0]
		}
	}
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
 8000ea0:	4b37      	ldr	r3, [pc, #220]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000ea2:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 8000ea6:	b922      	cbnz	r2, 8000eb2 <ADCT_SYSTEM_FPT_CheckState_IO+0x92>
			GstSystemStatus.ioData.ucDoor[1] ||
 8000ea8:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8000eaa:	b913      	cbnz	r3, 8000eb2 <ADCT_SYSTEM_FPT_CheckState_IO+0x92>
			GstSystemStatus.ioData.ucDoor[2] ||
			GstSystemStatus.ioData.ucDoor[3] ||
 8000eac:	4b34      	ldr	r3, [pc, #208]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000eae:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000eb0:	b18b      	cbz	r3, 8000ed6 <ADCT_SYSTEM_FPT_CheckState_IO+0xb6>
			GstSystemStatus.ioData.ucDoor[4]) &&
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_OFF))
 8000eb2:	4b34      	ldr	r3, [pc, #208]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000eb4:	685b      	ldr	r3, [r3, #4]
	/* Door (SNMP_SYT_009) */
	if((GstSystemStatus.ioData.ucDoor[0] ||
			GstSystemStatus.ioData.ucDoor[1] ||
			GstSystemStatus.ioData.ucDoor[2] ||
			GstSystemStatus.ioData.ucDoor[3] ||
			GstSystemStatus.ioData.ucDoor[4]) &&
 8000eb6:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000eba:	d10c      	bne.n	8000ed6 <ADCT_SYSTEM_FPT_CheckState_IO+0xb6>
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_OFF))
	{
		GstSystemWarning.State = MAINSTATE_ALARM;
 8000ebc:	4a31      	ldr	r2, [pc, #196]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000ebe:	2106      	movs	r1, #6
 8000ec0:	7011      	strb	r1, [r2, #0]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_DOOR, WARN_ON);
 8000ec2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000ec6:	6053      	str	r3, [r2, #4]
		/* Set Log */
		g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000ec8:	4b2f      	ldr	r3, [pc, #188]	; (8000f88 <ADCT_SYSTEM_FPT_CheckState_IO+0x168>)
 8000eca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000ecc:	4b2f      	ldr	r3, [pc, #188]	; (8000f8c <ADCT_SYSTEM_FPT_CheckState_IO+0x16c>)
 8000ece:	731a      	strb	r2, [r3, #12]
		g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000ed0:	2201      	movs	r2, #1
 8000ed2:	72da      	strb	r2, [r3, #11]
 8000ed4:	e011      	b.n	8000efa <ADCT_SYSTEM_FPT_CheckState_IO+0xda>
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
 8000ed6:	b982      	cbnz	r2, 8000efa <ADCT_SYSTEM_FPT_CheckState_IO+0xda>
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
 8000ed8:	4b29      	ldr	r3, [pc, #164]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000eda:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8000edc:	b96b      	cbnz	r3, 8000efa <ADCT_SYSTEM_FPT_CheckState_IO+0xda>
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
			GstSystemStatus.ioData.ucDoor[3] == 0 &&
 8000ede:	4b28      	ldr	r3, [pc, #160]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000ee0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000ee2:	b953      	cbnz	r3, 8000efa <ADCT_SYSTEM_FPT_CheckState_IO+0xda>
			GstSystemStatus.ioData.ucDoor[4] == 0) &&
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON))
 8000ee4:	4b27      	ldr	r3, [pc, #156]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000ee6:	685b      	ldr	r3, [r3, #4]
	}
	else if((GstSystemStatus.ioData.ucDoor[0] == 0 &&
			GstSystemStatus.ioData.ucDoor[1] == 0 &&
			GstSystemStatus.ioData.ucDoor[2] == 0 &&
			GstSystemStatus.ioData.ucDoor[3] == 0 &&
			GstSystemStatus.ioData.ucDoor[4] == 0) &&
 8000ee8:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000eec:	d005      	beq.n	8000efa <ADCT_SYSTEM_FPT_CheckState_IO+0xda>
			(ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON))
	{
		/* Set Warning OFF */
		WriteBit(GstSystemWarning.othWarn, WARN_DOOR, WARN_OFF);
 8000eee:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000ef2:	4a24      	ldr	r2, [pc, #144]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000ef4:	6053      	str	r3, [r2, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_IDLE;
 8000ef6:	2301      	movs	r3, #1
 8000ef8:	7013      	strb	r3, [r2, #0]
	}
	/* Burglar (SNMP_SYT_010) */
	if(GstSystemStatus.ioData.ucBurglar != (ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR)))
 8000efa:	4b21      	ldr	r3, [pc, #132]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000efc:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 8000f00:	4b20      	ldr	r3, [pc, #128]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f02:	685b      	ldr	r3, [r3, #4]
 8000f04:	f3c3 2140 	ubfx	r1, r3, #9, #1
 8000f08:	428a      	cmp	r2, r1
 8000f0a:	d017      	beq.n	8000f3c <ADCT_SYSTEM_FPT_CheckState_IO+0x11c>
	{

		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_BURGLAR, GstSystemStatus.ioData.ucBurglar);
 8000f0c:	b122      	cbz	r2, 8000f18 <ADCT_SYSTEM_FPT_CheckState_IO+0xf8>
 8000f0e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000f12:	491c      	ldr	r1, [pc, #112]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f14:	604b      	str	r3, [r1, #4]
 8000f16:	e003      	b.n	8000f20 <ADCT_SYSTEM_FPT_CheckState_IO+0x100>
 8000f18:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000f1c:	4919      	ldr	r1, [pc, #100]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f1e:	604b      	str	r3, [r1, #4]
		if(GstSystemStatus.ioData.ucBurglar)
 8000f20:	b14a      	cbz	r2, 8000f36 <ADCT_SYSTEM_FPT_CheckState_IO+0x116>
		{
			GstSystemWarning.State = MAINSTATE_ALARM;
 8000f22:	2206      	movs	r2, #6
 8000f24:	4b17      	ldr	r3, [pc, #92]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f26:	701a      	strb	r2, [r3, #0]
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000f28:	4b17      	ldr	r3, [pc, #92]	; (8000f88 <ADCT_SYSTEM_FPT_CheckState_IO+0x168>)
 8000f2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000f2c:	4b17      	ldr	r3, [pc, #92]	; (8000f8c <ADCT_SYSTEM_FPT_CheckState_IO+0x16c>)
 8000f2e:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000f30:	2201      	movs	r2, #1
 8000f32:	72da      	strb	r2, [r3, #11]
 8000f34:	e002      	b.n	8000f3c <ADCT_SYSTEM_FPT_CheckState_IO+0x11c>
		}
		else
		{
			/* Set Log */
			GstSystemWarning.State = MAINSTATE_IDLE;
 8000f36:	2201      	movs	r2, #1
 8000f38:	4b12      	ldr	r3, [pc, #72]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f3a:	701a      	strb	r2, [r3, #0]
		}
	}

	/* Water (SNMP_SYT_011) */
	if(GstSystemStatus.ioData.ucWater != (ReadBit(GstSystemWarning.othWarn, WARN_WATER)))
 8000f3c:	4b10      	ldr	r3, [pc, #64]	; (8000f80 <ADCT_SYSTEM_FPT_CheckState_IO+0x160>)
 8000f3e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8000f42:	4b10      	ldr	r3, [pc, #64]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f44:	685b      	ldr	r3, [r3, #4]
 8000f46:	f3c3 2180 	ubfx	r1, r3, #10, #1
 8000f4a:	428a      	cmp	r2, r1
 8000f4c:	d017      	beq.n	8000f7e <ADCT_SYSTEM_FPT_CheckState_IO+0x15e>
	{

		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_WATER, GstSystemStatus.ioData.ucWater);
 8000f4e:	b122      	cbz	r2, 8000f5a <ADCT_SYSTEM_FPT_CheckState_IO+0x13a>
 8000f50:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000f54:	490b      	ldr	r1, [pc, #44]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f56:	604b      	str	r3, [r1, #4]
 8000f58:	e003      	b.n	8000f62 <ADCT_SYSTEM_FPT_CheckState_IO+0x142>
 8000f5a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000f5e:	4909      	ldr	r1, [pc, #36]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f60:	604b      	str	r3, [r1, #4]
		if(GstSystemStatus.ioData.ucWater)
 8000f62:	b14a      	cbz	r2, 8000f78 <ADCT_SYSTEM_FPT_CheckState_IO+0x158>
		{
			GstSystemWarning.State = MAINSTATE_ALARM;
 8000f64:	2206      	movs	r2, #6
 8000f66:	4b07      	ldr	r3, [pc, #28]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f68:	701a      	strb	r2, [r3, #0]
			/* Set Log */
			g_ADCT_BGS_StateOutput.ALARM_RUNNING_Timer_Cnt = GstSystemSetting.ulAlarmDuration;
 8000f6a:	4b07      	ldr	r3, [pc, #28]	; (8000f88 <ADCT_SYSTEM_FPT_CheckState_IO+0x168>)
 8000f6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000f6e:	4b07      	ldr	r3, [pc, #28]	; (8000f8c <ADCT_SYSTEM_FPT_CheckState_IO+0x16c>)
 8000f70:	731a      	strb	r2, [r3, #12]
			g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag = ADCT_TRUE;
 8000f72:	2201      	movs	r2, #1
 8000f74:	72da      	strb	r2, [r3, #11]
 8000f76:	4770      	bx	lr
		}
		else
		{
			/* Set Log */
			GstSystemWarning.State = MAINSTATE_IDLE;
 8000f78:	2201      	movs	r2, #1
 8000f7a:	4b02      	ldr	r3, [pc, #8]	; (8000f84 <ADCT_SYSTEM_FPT_CheckState_IO+0x164>)
 8000f7c:	701a      	strb	r2, [r3, #0]
 8000f7e:	4770      	bx	lr
 8000f80:	2000050c 	.word	0x2000050c
 8000f84:	20000504 	.word	0x20000504
 8000f88:	200004c0 	.word	0x200004c0
 8000f8c:	200004b0 	.word	0x200004b0

08000f90 <ADCT_SYSTEM_FPT_CheckState_DHT>:
 * @retval None
 */
void ADCT_SYSTEM_FPT_CheckState_DHT(void)
{
	/* Low Humidity (SNMP_SYT_005) */
	if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usLowHumidityH1) &&
 8000f90:	4b4a      	ldr	r3, [pc, #296]	; (80010bc <ADCT_SYSTEM_FPT_CheckState_DHT+0x12c>)
 8000f92:	8b1b      	ldrh	r3, [r3, #24]
 8000f94:	4a4a      	ldr	r2, [pc, #296]	; (80010c0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x130>)
 8000f96:	88d2      	ldrh	r2, [r2, #6]
 8000f98:	4293      	cmp	r3, r2
 8000f9a:	d20b      	bcs.n	8000fb4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x24>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_OFF))
 8000f9c:	4949      	ldr	r1, [pc, #292]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000f9e:	6849      	ldr	r1, [r1, #4]
 * @retval None
 */
void ADCT_SYSTEM_FPT_CheckState_DHT(void)
{
	/* Low Humidity (SNMP_SYT_005) */
	if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usLowHumidityH1) &&
 8000fa0:	f011 0f10 	tst.w	r1, #16
 8000fa4:	d106      	bne.n	8000fb4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x24>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_ON);
 8000fa6:	f041 0110 	orr.w	r1, r1, #16
 8000faa:	4b46      	ldr	r3, [pc, #280]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000fac:	6059      	str	r1, [r3, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_ALARM;
 8000fae:	2206      	movs	r2, #6
 8000fb0:	701a      	strb	r2, [r3, #0]
 8000fb2:	4770      	bx	lr
	}
	else if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usLowHumidityH1) &&
 8000fb4:	4293      	cmp	r3, r2
 8000fb6:	d90b      	bls.n	8000fd0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x40>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON))
 8000fb8:	4a42      	ldr	r2, [pc, #264]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000fba:	6852      	ldr	r2, [r2, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_ON);
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_ALARM;
	}
	else if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usLowHumidityH1) &&
 8000fbc:	f012 0f10 	tst.w	r2, #16
 8000fc0:	d006      	beq.n	8000fd0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x40>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON))
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWHUMID, WARN_OFF);
 8000fc2:	f022 0210 	bic.w	r2, r2, #16
 8000fc6:	4b3f      	ldr	r3, [pc, #252]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000fc8:	605a      	str	r2, [r3, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_IDLE;
 8000fca:	2201      	movs	r2, #1
 8000fcc:	701a      	strb	r2, [r3, #0]
 8000fce:	4770      	bx	lr
	}

	/* High Humidity (SNMP_SYT_006) */
	else if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usHighHumidityH2) &&
 8000fd0:	4a3b      	ldr	r2, [pc, #236]	; (80010c0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x130>)
 8000fd2:	8912      	ldrh	r2, [r2, #8]
 8000fd4:	4293      	cmp	r3, r2
 8000fd6:	d90b      	bls.n	8000ff0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x60>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_OFF))
 8000fd8:	493a      	ldr	r1, [pc, #232]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000fda:	6849      	ldr	r1, [r1, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_IDLE;
	}

	/* High Humidity (SNMP_SYT_006) */
	else if((GstSystemStatus.dhtData.usHumid_Main > GstSystemSetting.usHighHumidityH2) &&
 8000fdc:	f011 0f20 	tst.w	r1, #32
 8000fe0:	d106      	bne.n	8000ff0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x60>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHHUMID, WARN_ON);
 8000fe2:	f041 0120 	orr.w	r1, r1, #32
 8000fe6:	4b37      	ldr	r3, [pc, #220]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000fe8:	6059      	str	r1, [r3, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_ALARM;
 8000fea:	2206      	movs	r2, #6
 8000fec:	701a      	strb	r2, [r3, #0]
 8000fee:	4770      	bx	lr
	}
	else if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usHighHumidityH2) &&
 8000ff0:	4293      	cmp	r3, r2
 8000ff2:	d20b      	bcs.n	800100c <ADCT_SYSTEM_FPT_CheckState_DHT+0x7c>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON))
 8000ff4:	4b33      	ldr	r3, [pc, #204]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8000ff6:	685b      	ldr	r3, [r3, #4]
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHHUMID, WARN_ON);
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_ALARM;
	}
	else if((GstSystemStatus.dhtData.usHumid_Main < GstSystemSetting.usHighHumidityH2) &&
 8000ff8:	f013 0f20 	tst.w	r3, #32
 8000ffc:	d006      	beq.n	800100c <ADCT_SYSTEM_FPT_CheckState_DHT+0x7c>
			(ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON))
	{
		/* Set Warning */
		WriteBit(GstSystemWarning.othWarn, WARN_HIGHHUMID, WARN_OFF);
 8000ffe:	f023 0320 	bic.w	r3, r3, #32
 8001002:	4a30      	ldr	r2, [pc, #192]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8001004:	6053      	str	r3, [r2, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_IDLE;
 8001006:	2301      	movs	r3, #1
 8001008:	7013      	strb	r3, [r2, #0]
 800100a:	4770      	bx	lr
	}

	/* Low Temperature (SNMP_SYT_002) */
	else if((GstSystemStatus.dhtData.usTemp_Main < GstSystemSetting.usLowTemperatureT1)&&
 800100c:	4b2b      	ldr	r3, [pc, #172]	; (80010bc <ADCT_SYSTEM_FPT_CheckState_DHT+0x12c>)
 800100e:	8adb      	ldrh	r3, [r3, #22]
 8001010:	4a2b      	ldr	r2, [pc, #172]	; (80010c0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x130>)
 8001012:	8812      	ldrh	r2, [r2, #0]
 8001014:	4293      	cmp	r3, r2
 8001016:	d20b      	bcs.n	8001030 <ADCT_SYSTEM_FPT_CheckState_DHT+0xa0>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_OFF))
 8001018:	492a      	ldr	r1, [pc, #168]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 800101a:	6849      	ldr	r1, [r1, #4]
		/* Set Log */
		GstSystemWarning.State = MAINSTATE_IDLE;
	}

	/* Low Temperature (SNMP_SYT_002) */
	else if((GstSystemStatus.dhtData.usTemp_Main < GstSystemSetting.usLowTemperatureT1)&&
 800101c:	f011 0f04 	tst.w	r1, #4
 8001020:	d106      	bne.n	8001030 <ADCT_SYSTEM_FPT_CheckState_DHT+0xa0>
			(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_OFF))
	{
		/* Set Warning ON */
		WriteBit(GstSystemWarning.othWarn, WARN_LOWTEMP, WARN_ON);
 8001022:	f041 0104 	orr.w	r1, r1, #4
 8001026:	4b27      	ldr	r3, [pc, #156]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8001028:	6059      	str	r1, [r3, #4]
		/* Set next state is LOW */
		GstSystemWarning.State = MAINSTATE_ALARM;
 800102a:	2206      	movs	r2, #6
 800102c:	701a      	strb	r2, [r3, #0]
 800102e:	4770      	bx	lr
		/* Set Log */
		//ADCT_SDCARD_FPT_SetAlarmID(ALARM_LOW_TEMP_START);
	}
	else if((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1) &&
 8001030:	4293      	cmp	r3, r2
 8001032:	d31a      	bcc.n	800106a <ADCT_SYSTEM_FPT_CheckState_DHT+0xda>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
 8001034:	4a22      	ldr	r2, [pc, #136]	; (80010c0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x130>)
 8001036:	8852      	ldrh	r2, [r2, #2]
		/* Set next state is LOW */
		GstSystemWarning.State = MAINSTATE_ALARM;
		/* Set Log */
		//ADCT_SDCARD_FPT_SetAlarmID(ALARM_LOW_TEMP_START);
	}
	else if((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1) &&
 8001038:	4293      	cmp	r3, r2
 800103a:	d816      	bhi.n	800106a <ADCT_SYSTEM_FPT_CheckState_DHT+0xda>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
	{
		/* Set next state is NORMAL */
		if(ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON)
 800103c:	4b21      	ldr	r3, [pc, #132]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 800103e:	685b      	ldr	r3, [r3, #4]
 8001040:	f013 0f04 	tst.w	r3, #4
 8001044:	d005      	beq.n	8001052 <ADCT_SYSTEM_FPT_CheckState_DHT+0xc2>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_LOWTEMP, WARN_OFF);
 8001046:	f023 0304 	bic.w	r3, r3, #4
 800104a:	4a1e      	ldr	r2, [pc, #120]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 800104c:	6053      	str	r3, [r2, #4]
			/* Set log */
			GstSystemWarning.State = MAINSTATE_IDLE;
 800104e:	2301      	movs	r3, #1
 8001050:	7013      	strb	r3, [r2, #0]
		}
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON)
 8001052:	4b1c      	ldr	r3, [pc, #112]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8001054:	685b      	ldr	r3, [r3, #4]
 8001056:	f013 0f02 	tst.w	r3, #2
 800105a:	d02e      	beq.n	80010ba <ADCT_SYSTEM_FPT_CheckState_DHT+0x12a>
		{

			WriteBit(GstSystemWarning.othWarn, WARN_HIGHTEMP, WARN_OFF);
 800105c:	f023 0302 	bic.w	r3, r3, #2
 8001060:	4a18      	ldr	r2, [pc, #96]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8001062:	6053      	str	r3, [r2, #4]
			/* Set log */
			GstSystemWarning.State = MAINSTATE_IDLE;
 8001064:	2301      	movs	r3, #1
 8001066:	7013      	strb	r3, [r2, #0]
 8001068:	4770      	bx	lr
		}

	}

	/* High Temperature (SNMP_SYT_003) */
	else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 800106a:	4a15      	ldr	r2, [pc, #84]	; (80010c0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x130>)
 800106c:	8852      	ldrh	r2, [r2, #2]
 800106e:	4293      	cmp	r3, r2
 8001070:	d918      	bls.n	80010a4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x114>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
 8001072:	4a13      	ldr	r2, [pc, #76]	; (80010c0 <ADCT_SYSTEM_FPT_CheckState_DHT+0x130>)
 8001074:	8892      	ldrh	r2, [r2, #4]
		}

	}

	/* High Temperature (SNMP_SYT_003) */
	else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 8001076:	4293      	cmp	r3, r2
 8001078:	d814      	bhi.n	80010a4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x114>
			(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
	{
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_OFF)
 800107a:	4b12      	ldr	r3, [pc, #72]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 800107c:	685b      	ldr	r3, [r3, #4]
 800107e:	f013 0f02 	tst.w	r3, #2
 8001082:	d105      	bne.n	8001090 <ADCT_SYSTEM_FPT_CheckState_DHT+0x100>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHTEMP, WARN_ON);
 8001084:	f043 0302 	orr.w	r3, r3, #2
 8001088:	4a0e      	ldr	r2, [pc, #56]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 800108a:	6053      	str	r3, [r2, #4]
			/*Setlog*/
			GstSystemWarning.State = MAINSTATE_ALARM;
 800108c:	2306      	movs	r3, #6
 800108e:	7013      	strb	r3, [r2, #0]
		}
		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_ON)
 8001090:	4b0c      	ldr	r3, [pc, #48]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 8001092:	685b      	ldr	r3, [r3, #4]
 8001094:	f013 0f08 	tst.w	r3, #8
 8001098:	d00f      	beq.n	80010ba <ADCT_SYSTEM_FPT_CheckState_DHT+0x12a>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP, WARN_OFF);
 800109a:	f023 0308 	bic.w	r3, r3, #8
 800109e:	4a09      	ldr	r2, [pc, #36]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 80010a0:	6053      	str	r3, [r2, #4]
 80010a2:	4770      	bx	lr
	/* Fan Temperature (SNMP_SYT_004) */
	else
	{
		/* Set next state is FAN */

		if(ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_OFF)
 80010a4:	4b07      	ldr	r3, [pc, #28]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 80010a6:	685b      	ldr	r3, [r3, #4]
 80010a8:	f013 0f08 	tst.w	r3, #8
 80010ac:	d105      	bne.n	80010ba <ADCT_SYSTEM_FPT_CheckState_DHT+0x12a>
		{
			WriteBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP, WARN_ON);
 80010ae:	f043 0308 	orr.w	r3, r3, #8
 80010b2:	4a04      	ldr	r2, [pc, #16]	; (80010c4 <ADCT_SYSTEM_FPT_CheckState_DHT+0x134>)
 80010b4:	6053      	str	r3, [r2, #4]
			/*Set log */
			GstSystemWarning.State = MAINSTATE_ALARM;
 80010b6:	2306      	movs	r3, #6
 80010b8:	7013      	strb	r3, [r2, #0]
 80010ba:	4770      	bx	lr
 80010bc:	2000050c 	.word	0x2000050c
 80010c0:	200004c0 	.word	0x200004c0
 80010c4:	20000504 	.word	0x20000504

080010c8 <ADCT_SystemFPT_CheckAlarm>:
}

uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
	if(
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 80010c8:	4b1d      	ldr	r3, [pc, #116]	; (8001140 <ADCT_SystemFPT_CheckAlarm+0x78>)
 80010ca:	685b      	ldr	r3, [r3, #4]

}

uint8_t ADCT_SystemFPT_CheckAlarm(void)
{
	if(
 80010cc:	f013 0f40 	tst.w	r3, #64	; 0x40
 80010d0:	d11f      	bne.n	8001112 <ADCT_SystemFPT_CheckAlarm+0x4a>
			ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 80010d2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80010d6:	d11e      	bne.n	8001116 <ADCT_SystemFPT_CheckAlarm+0x4e>
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON ||
 80010d8:	f413 7f80 	tst.w	r3, #256	; 0x100
 80010dc:	d11d      	bne.n	800111a <ADCT_SystemFPT_CheckAlarm+0x52>
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON ||
 80010de:	f413 7f00 	tst.w	r3, #512	; 0x200
 80010e2:	d11c      	bne.n	800111e <ADCT_SystemFPT_CheckAlarm+0x56>
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON ||
 80010e4:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80010e8:	d11b      	bne.n	8001122 <ADCT_SystemFPT_CheckAlarm+0x5a>
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON ||
 80010ea:	f013 0f10 	tst.w	r3, #16
 80010ee:	d11a      	bne.n	8001126 <ADCT_SystemFPT_CheckAlarm+0x5e>
			ReadBit(GstSystemWarning.othWarn, WARN_LOWHUMID) == WARN_ON ||
 80010f0:	f013 0f20 	tst.w	r3, #32
 80010f4:	d119      	bne.n	800112a <ADCT_SystemFPT_CheckAlarm+0x62>
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHHUMID) == WARN_ON||
 80010f6:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80010fa:	d118      	bne.n	800112e <ADCT_SystemFPT_CheckAlarm+0x66>
			ReadBit(GstSystemWarning.othWarn, WARN_LOWFUEL) == WARN_ON||
 80010fc:	f013 0f02 	tst.w	r3, #2
 8001100:	d117      	bne.n	8001132 <ADCT_SystemFPT_CheckAlarm+0x6a>
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHTEMP) == WARN_ON||
 8001102:	f013 0f04 	tst.w	r3, #4
 8001106:	d116      	bne.n	8001136 <ADCT_SystemFPT_CheckAlarm+0x6e>
			ReadBit(GstSystemWarning.othWarn, WARN_LOWTEMP) == WARN_ON||
 8001108:	f013 0f08 	tst.w	r3, #8
 800110c:	d015      	beq.n	800113a <ADCT_SystemFPT_CheckAlarm+0x72>
			ReadBit(GstSystemWarning.othWarn, WARN_HIGHFANTEMP) == WARN_ON
	)
	{
		return TRUE;
 800110e:	2001      	movs	r0, #1
 8001110:	4770      	bx	lr
 8001112:	2001      	movs	r0, #1
 8001114:	4770      	bx	lr
 8001116:	2001      	movs	r0, #1
 8001118:	4770      	bx	lr
 800111a:	2001      	movs	r0, #1
 800111c:	4770      	bx	lr
 800111e:	2001      	movs	r0, #1
 8001120:	4770      	bx	lr
 8001122:	2001      	movs	r0, #1
 8001124:	4770      	bx	lr
 8001126:	2001      	movs	r0, #1
 8001128:	4770      	bx	lr
 800112a:	2001      	movs	r0, #1
 800112c:	4770      	bx	lr
 800112e:	2001      	movs	r0, #1
 8001130:	4770      	bx	lr
 8001132:	2001      	movs	r0, #1
 8001134:	4770      	bx	lr
 8001136:	2001      	movs	r0, #1
 8001138:	4770      	bx	lr
	}
	else
	{
		return FALSE;
 800113a:	2000      	movs	r0, #0
	}
}
 800113c:	4770      	bx	lr
 800113e:	bf00      	nop
 8001140:	20000504 	.word	0x20000504

08001144 <ADCT_SystemFPT_CheckAlarm_Siren>:
uint8_t ADCT_SystemFPT_CheckAlarm_Siren(void)
{
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||\
 8001144:	4b0e      	ldr	r3, [pc, #56]	; (8001180 <ADCT_SystemFPT_CheckAlarm_Siren+0x3c>)
 8001146:	685b      	ldr	r3, [r3, #4]
 8001148:	f013 0f40 	tst.w	r3, #64	; 0x40
 800114c:	d10d      	bne.n	800116a <ADCT_SystemFPT_CheckAlarm_Siren+0x26>
 800114e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001152:	d10c      	bne.n	800116e <ADCT_SystemFPT_CheckAlarm_Siren+0x2a>
			ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON||
 8001154:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001158:	d10b      	bne.n	8001172 <ADCT_SystemFPT_CheckAlarm_Siren+0x2e>
			ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON||
 800115a:	f413 7f00 	tst.w	r3, #512	; 0x200
 800115e:	d10a      	bne.n	8001176 <ADCT_SystemFPT_CheckAlarm_Siren+0x32>
			ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON||
 8001160:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8001164:	d009      	beq.n	800117a <ADCT_SystemFPT_CheckAlarm_Siren+0x36>
			ReadBit(GstSystemWarning.othWarn, WARN_WATER) == WARN_ON
	)	{
		return TRUE;
 8001166:	2001      	movs	r0, #1
 8001168:	4770      	bx	lr
 800116a:	2001      	movs	r0, #1
 800116c:	4770      	bx	lr
 800116e:	2001      	movs	r0, #1
 8001170:	4770      	bx	lr
 8001172:	2001      	movs	r0, #1
 8001174:	4770      	bx	lr
 8001176:	2001      	movs	r0, #1
 8001178:	4770      	bx	lr
	}
	else
	{

		return FALSE;
 800117a:	2000      	movs	r0, #0
	}
}
 800117c:	4770      	bx	lr
 800117e:	bf00      	nop
 8001180:	20000504 	.word	0x20000504

08001184 <ADCT_SystemFPT_RunOutput>:
void ADCT_SystemFPT_RunOutput(void)
{
 8001184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if(ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON||ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == WARN_ON)
 8001186:	4bbd      	ldr	r3, [pc, #756]	; (800147c <ADCT_SystemFPT_RunOutput+0x2f8>)
 8001188:	685b      	ldr	r3, [r3, #4]
 800118a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800118e:	d102      	bne.n	8001196 <ADCT_SystemFPT_RunOutput+0x12>
 8001190:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001194:	d028      	beq.n	80011e8 <ADCT_SystemFPT_RunOutput+0x64>
	{
		/* Off all AIR and FAN */
		ADCT_BGS_AIR_1_2_OFF();
 8001196:	4cba      	ldr	r4, [pc, #744]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001198:	2140      	movs	r1, #64	; 0x40
 800119a:	4620      	mov	r0, r4
 800119c:	f003 f820 	bl	80041e0 <GPIO_SetBits>
 80011a0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80011a4:	48b7      	ldr	r0, [pc, #732]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 80011a6:	f003 f81b 	bl	80041e0 <GPIO_SetBits>
		ADCT_BGS_AIR_3_4_OFF();
 80011aa:	2180      	movs	r1, #128	; 0x80
 80011ac:	4620      	mov	r0, r4
 80011ae:	f003 f817 	bl	80041e0 <GPIO_SetBits>
 80011b2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80011b6:	4620      	mov	r0, r4
 80011b8:	f003 f812 	bl	80041e0 <GPIO_SetBits>
		g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = ADCT_FALSE;
 80011bc:	4db2      	ldr	r5, [pc, #712]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80011be:	2600      	movs	r6, #0
 80011c0:	702e      	strb	r6, [r5, #0]
		g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = ADCT_FALSE;
 80011c2:	706e      	strb	r6, [r5, #1]
		ADCT_BGS_FAN_OFF();
 80011c4:	2104      	movs	r1, #4
 80011c6:	4620      	mov	r0, r4
 80011c8:	f003 f80c 	bl	80041e4 <GPIO_ResetBits>
 80011cc:	2108      	movs	r1, #8
 80011ce:	4620      	mov	r0, r4
 80011d0:	f003 f808 	bl	80041e4 <GPIO_ResetBits>
 80011d4:	2110      	movs	r1, #16
 80011d6:	4620      	mov	r0, r4
 80011d8:	f003 f804 	bl	80041e4 <GPIO_ResetBits>
 80011dc:	2120      	movs	r1, #32
 80011de:	4620      	mov	r0, r4
 80011e0:	f003 f800 	bl	80041e4 <GPIO_ResetBits>
		g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = ADCT_FALSE;
 80011e4:	70ae      	strb	r6, [r5, #2]
 80011e6:	e2e1      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
		}
		else
#endif
		{
			/* Low Temperature (SNMP_SYT_002) */
			if(GstSystemStatus.dhtData.usTemp_Main < GstSystemSetting.usLowTemperatureT1)
 80011e8:	4ba8      	ldr	r3, [pc, #672]	; (800148c <ADCT_SystemFPT_RunOutput+0x308>)
 80011ea:	8adb      	ldrh	r3, [r3, #22]
 80011ec:	4aa8      	ldr	r2, [pc, #672]	; (8001490 <ADCT_SystemFPT_RunOutput+0x30c>)
 80011ee:	8812      	ldrh	r2, [r2, #0]
 80011f0:	4293      	cmp	r3, r2
 80011f2:	d26b      	bcs.n	80012cc <ADCT_SystemFPT_RunOutput+0x148>
			{
				// Detect if the t_min_timer is still running, if YES, output remains high
				if((g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == TRUE) && (g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == TRUE))
 80011f4:	4ba4      	ldr	r3, [pc, #656]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80011f6:	795b      	ldrb	r3, [r3, #5]
 80011f8:	2b01      	cmp	r3, #1
 80011fa:	d10d      	bne.n	8001218 <ADCT_SystemFPT_RunOutput+0x94>
 80011fc:	4ba2      	ldr	r3, [pc, #648]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80011fe:	781b      	ldrb	r3, [r3, #0]
 8001200:	2b01      	cmp	r3, #1
 8001202:	d109      	bne.n	8001218 <ADCT_SystemFPT_RunOutput+0x94>
				{
					ADCT_BGS_AIR_1_2_ON();
 8001204:	2140      	movs	r1, #64	; 0x40
 8001206:	489e      	ldr	r0, [pc, #632]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001208:	f002 ffec 	bl	80041e4 <GPIO_ResetBits>
 800120c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001210:	489c      	ldr	r0, [pc, #624]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 8001212:	f002 ffe7 	bl	80041e4 <GPIO_ResetBits>
 8001216:	e00b      	b.n	8001230 <ADCT_SystemFPT_RunOutput+0xac>
				}
				else
				{
					ADCT_BGS_AIR_1_2_OFF();
 8001218:	2140      	movs	r1, #64	; 0x40
 800121a:	4899      	ldr	r0, [pc, #612]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 800121c:	f002 ffe0 	bl	80041e0 <GPIO_SetBits>
 8001220:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001224:	4897      	ldr	r0, [pc, #604]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 8001226:	f002 ffdb 	bl	80041e0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = FALSE;
 800122a:	2200      	movs	r2, #0
 800122c:	4b96      	ldr	r3, [pc, #600]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800122e:	701a      	strb	r2, [r3, #0]
				}
				// Detect if the t_min_timer is still running, if YES, output remains high
				if((g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == TRUE) && (g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == TRUE))
 8001230:	4b95      	ldr	r3, [pc, #596]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001232:	799b      	ldrb	r3, [r3, #6]
 8001234:	2b01      	cmp	r3, #1
 8001236:	d10e      	bne.n	8001256 <ADCT_SystemFPT_RunOutput+0xd2>
 8001238:	4b93      	ldr	r3, [pc, #588]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800123a:	785b      	ldrb	r3, [r3, #1]
 800123c:	2b01      	cmp	r3, #1
 800123e:	d10a      	bne.n	8001256 <ADCT_SystemFPT_RunOutput+0xd2>
				{
					ADCT_BGS_AIR_3_4_ON();
 8001240:	4c8f      	ldr	r4, [pc, #572]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001242:	2180      	movs	r1, #128	; 0x80
 8001244:	4620      	mov	r0, r4
 8001246:	f002 ffcd 	bl	80041e4 <GPIO_ResetBits>
 800124a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800124e:	4620      	mov	r0, r4
 8001250:	f002 ffc8 	bl	80041e4 <GPIO_ResetBits>
 8001254:	e00c      	b.n	8001270 <ADCT_SystemFPT_RunOutput+0xec>
				}
				else
				{
					ADCT_BGS_AIR_3_4_OFF();
 8001256:	4c8a      	ldr	r4, [pc, #552]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001258:	2180      	movs	r1, #128	; 0x80
 800125a:	4620      	mov	r0, r4
 800125c:	f002 ffc0 	bl	80041e0 <GPIO_SetBits>
 8001260:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001264:	4620      	mov	r0, r4
 8001266:	f002 ffbb 	bl	80041e0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
 800126a:	2200      	movs	r2, #0
 800126c:	4b86      	ldr	r3, [pc, #536]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800126e:	705a      	strb	r2, [r3, #1]
				}
				// Detect if the t_min_timer is still running, if YES, output remains high
				if((g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE )&&( g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE))
 8001270:	4b85      	ldr	r3, [pc, #532]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001272:	79db      	ldrb	r3, [r3, #7]
 8001274:	2b01      	cmp	r3, #1
 8001276:	d114      	bne.n	80012a2 <ADCT_SystemFPT_RunOutput+0x11e>
 8001278:	4b83      	ldr	r3, [pc, #524]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800127a:	789b      	ldrb	r3, [r3, #2]
 800127c:	b18b      	cbz	r3, 80012a2 <ADCT_SystemFPT_RunOutput+0x11e>
				{
					ADCT_BGS_FAN_ON();
 800127e:	4c80      	ldr	r4, [pc, #512]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001280:	2104      	movs	r1, #4
 8001282:	4620      	mov	r0, r4
 8001284:	f002 ffac 	bl	80041e0 <GPIO_SetBits>
 8001288:	2108      	movs	r1, #8
 800128a:	4620      	mov	r0, r4
 800128c:	f002 ffa8 	bl	80041e0 <GPIO_SetBits>
 8001290:	2110      	movs	r1, #16
 8001292:	4620      	mov	r0, r4
 8001294:	f002 ffa4 	bl	80041e0 <GPIO_SetBits>
 8001298:	2120      	movs	r1, #32
 800129a:	4620      	mov	r0, r4
 800129c:	f002 ffa0 	bl	80041e0 <GPIO_SetBits>
 80012a0:	e284      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
				}
				else
				{
					ADCT_BGS_FAN_OFF();
 80012a2:	4c77      	ldr	r4, [pc, #476]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 80012a4:	2104      	movs	r1, #4
 80012a6:	4620      	mov	r0, r4
 80012a8:	f002 ff9c 	bl	80041e4 <GPIO_ResetBits>
 80012ac:	2108      	movs	r1, #8
 80012ae:	4620      	mov	r0, r4
 80012b0:	f002 ff98 	bl	80041e4 <GPIO_ResetBits>
 80012b4:	2110      	movs	r1, #16
 80012b6:	4620      	mov	r0, r4
 80012b8:	f002 ff94 	bl	80041e4 <GPIO_ResetBits>
 80012bc:	2120      	movs	r1, #32
 80012be:	4620      	mov	r0, r4
 80012c0:	f002 ff90 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
 80012c4:	2200      	movs	r2, #0
 80012c6:	4b70      	ldr	r3, [pc, #448]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80012c8:	709a      	strb	r2, [r3, #2]
 80012ca:	e26f      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
				}
			}
			else if ((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1 ) &&
 80012cc:	4293      	cmp	r3, r2
 80012ce:	f0c0 80fc 	bcc.w	80014ca <ADCT_SystemFPT_RunOutput+0x346>
					(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
 80012d2:	4a6f      	ldr	r2, [pc, #444]	; (8001490 <ADCT_SystemFPT_RunOutput+0x30c>)
 80012d4:	8852      	ldrh	r2, [r2, #2]
				{
					ADCT_BGS_FAN_OFF();
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
				}
			}
			else if ((GstSystemStatus.dhtData.usTemp_Main >= GstSystemSetting.usLowTemperatureT1 ) &&
 80012d6:	4293      	cmp	r3, r2
 80012d8:	f200 80f7 	bhi.w	80014ca <ADCT_SystemFPT_RunOutput+0x346>
					(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usHighTemperatureT2))
			{
				if(g_ADCT_BGS_StateOutput.WITCH_AIR == TRUE)
 80012dc:	4b6a      	ldr	r3, [pc, #424]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80012de:	7a9b      	ldrb	r3, [r3, #10]
 80012e0:	2b01      	cmp	r3, #1
 80012e2:	d15a      	bne.n	800139a <ADCT_SystemFPT_RunOutput+0x216>
				{
					// Detect if the t_min_timer is still running, if YES, output remains high
					if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == TRUE)
 80012e4:	4b68      	ldr	r3, [pc, #416]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80012e6:	795b      	ldrb	r3, [r3, #5]
 80012e8:	2b01      	cmp	r3, #1
 80012ea:	d10d      	bne.n	8001308 <ADCT_SystemFPT_RunOutput+0x184>
 80012ec:	4b66      	ldr	r3, [pc, #408]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80012ee:	781b      	ldrb	r3, [r3, #0]
 80012f0:	2b01      	cmp	r3, #1
 80012f2:	d109      	bne.n	8001308 <ADCT_SystemFPT_RunOutput+0x184>
					{
						ADCT_BGS_AIR_1_2_ON();
 80012f4:	2140      	movs	r1, #64	; 0x40
 80012f6:	4862      	ldr	r0, [pc, #392]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 80012f8:	f002 ff74 	bl	80041e4 <GPIO_ResetBits>
 80012fc:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001300:	4860      	ldr	r0, [pc, #384]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 8001302:	f002 ff6f 	bl	80041e4 <GPIO_ResetBits>
 8001306:	e00b      	b.n	8001320 <ADCT_SystemFPT_RunOutput+0x19c>
					}
					else
					{
						ADCT_BGS_AIR_1_2_OFF();
 8001308:	2140      	movs	r1, #64	; 0x40
 800130a:	485d      	ldr	r0, [pc, #372]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 800130c:	f002 ff68 	bl	80041e0 <GPIO_SetBits>
 8001310:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001314:	485b      	ldr	r0, [pc, #364]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 8001316:	f002 ff63 	bl	80041e0 <GPIO_SetBits>
						g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = FALSE;
 800131a:	2200      	movs	r2, #0
 800131c:	4b5a      	ldr	r3, [pc, #360]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800131e:	701a      	strb	r2, [r3, #0]
					}
					// Detect if air 2 output just activate and run min_timer
					if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE)
 8001320:	4b59      	ldr	r3, [pc, #356]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001322:	799b      	ldrb	r3, [r3, #6]
 8001324:	bb5b      	cbnz	r3, 800137e <ADCT_SystemFPT_RunOutput+0x1fa>
 8001326:	4b58      	ldr	r3, [pc, #352]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001328:	785b      	ldrb	r3, [r3, #1]
 800132a:	bb43      	cbnz	r3, 800137e <ADCT_SystemFPT_RunOutput+0x1fa>
					{
						uint32_t temp_variable;
						temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 800132c:	4e58      	ldr	r6, [pc, #352]	; (8001490 <ADCT_SystemFPT_RunOutput+0x30c>)
 800132e:	6a33      	ldr	r3, [r6, #32]
 8001330:	4d58      	ldr	r5, [pc, #352]	; (8001494 <ADCT_SystemFPT_RunOutput+0x310>)
 8001332:	fba5 2403 	umull	r2, r4, r5, r3
 8001336:	0ae4      	lsrs	r4, r4, #11
 8001338:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800133c:	fb02 3414 	mls	r4, r2, r4, r3
						ADCT_BGS_AIR_3_4_ON();
 8001340:	4f4f      	ldr	r7, [pc, #316]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001342:	2180      	movs	r1, #128	; 0x80
 8001344:	4638      	mov	r0, r7
 8001346:	f002 ff4d 	bl	80041e4 <GPIO_ResetBits>
 800134a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800134e:	4638      	mov	r0, r7
 8001350:	f002 ff48 	bl	80041e4 <GPIO_ResetBits>
						g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001354:	4b4c      	ldr	r3, [pc, #304]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001356:	2201      	movs	r2, #1
 8001358:	705a      	strb	r2, [r3, #1]
						g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = TRUE;
 800135a:	719a      	strb	r2, [r3, #6]
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 800135c:	6a33      	ldr	r3, [r6, #32]
 800135e:	fba5 2303 	umull	r2, r3, r5, r3
 8001362:	0adb      	lsrs	r3, r3, #11
 8001364:	494c      	ldr	r1, [pc, #304]	; (8001498 <ADCT_SystemFPT_RunOutput+0x314>)
 8001366:	718b      	strb	r3, [r1, #6]
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
 8001368:	4b4c      	ldr	r3, [pc, #304]	; (800149c <ADCT_SystemFPT_RunOutput+0x318>)
 800136a:	fba3 2304 	umull	r2, r3, r3, r4
 800136e:	095b      	lsrs	r3, r3, #5
 8001370:	71cb      	strb	r3, [r1, #7]
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
 8001372:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8001376:	009a      	lsls	r2, r3, #2
 8001378:	1aa2      	subs	r2, r4, r2
 800137a:	720a      	strb	r2, [r1, #8]
						ADCT_BGS_AIR_1_2_OFF();
						g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = FALSE;
					}
					// Detect if air 2 output just activate and run min_timer
					if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE)
					{
 800137c:	e064      	b.n	8001448 <ADCT_SystemFPT_RunOutput+0x2c4>
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
					}
					else
					{
						ADCT_BGS_AIR_3_4_ON();
 800137e:	4c40      	ldr	r4, [pc, #256]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001380:	2180      	movs	r1, #128	; 0x80
 8001382:	4620      	mov	r0, r4
 8001384:	f002 ff2e 	bl	80041e4 <GPIO_ResetBits>
 8001388:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800138c:	4620      	mov	r0, r4
 800138e:	f002 ff29 	bl	80041e4 <GPIO_ResetBits>
						g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 8001392:	2201      	movs	r2, #1
 8001394:	4b3c      	ldr	r3, [pc, #240]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001396:	705a      	strb	r2, [r3, #1]
 8001398:	e056      	b.n	8001448 <ADCT_SystemFPT_RunOutput+0x2c4>
					}
				}
				else
				{
					if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE ==FALSE )
 800139a:	4b3b      	ldr	r3, [pc, #236]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800139c:	795b      	ldrb	r3, [r3, #5]
 800139e:	bb3b      	cbnz	r3, 80013f0 <ADCT_SystemFPT_RunOutput+0x26c>
 80013a0:	4b39      	ldr	r3, [pc, #228]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80013a2:	781b      	ldrb	r3, [r3, #0]
 80013a4:	bb23      	cbnz	r3, 80013f0 <ADCT_SystemFPT_RunOutput+0x26c>
					{
						ADCT_BGS_AIR_1_2_ON();
 80013a6:	2140      	movs	r1, #64	; 0x40
 80013a8:	4835      	ldr	r0, [pc, #212]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 80013aa:	f002 ff1b 	bl	80041e4 <GPIO_ResetBits>
 80013ae:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013b2:	4834      	ldr	r0, [pc, #208]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 80013b4:	f002 ff16 	bl	80041e4 <GPIO_ResetBits>
						g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 80013b8:	4b33      	ldr	r3, [pc, #204]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 80013ba:	2201      	movs	r2, #1
 80013bc:	701a      	strb	r2, [r3, #0]
						g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = TRUE;
 80013be:	715a      	strb	r2, [r3, #5]
						uint32_t temp_variable;
						temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 80013c0:	4b33      	ldr	r3, [pc, #204]	; (8001490 <ADCT_SystemFPT_RunOutput+0x30c>)
 80013c2:	6a1a      	ldr	r2, [r3, #32]
 80013c4:	4b33      	ldr	r3, [pc, #204]	; (8001494 <ADCT_SystemFPT_RunOutput+0x310>)
 80013c6:	fba3 1302 	umull	r1, r3, r3, r2
 80013ca:	0ad9      	lsrs	r1, r3, #11
 80013cc:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 80013d0:	fb00 2111 	mls	r1, r0, r1, r2
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80013d4:	0adb      	lsrs	r3, r3, #11
 80013d6:	4830      	ldr	r0, [pc, #192]	; (8001498 <ADCT_SystemFPT_RunOutput+0x314>)
 80013d8:	70c3      	strb	r3, [r0, #3]
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
 80013da:	4b30      	ldr	r3, [pc, #192]	; (800149c <ADCT_SystemFPT_RunOutput+0x318>)
 80013dc:	fba3 2301 	umull	r2, r3, r3, r1
 80013e0:	095b      	lsrs	r3, r3, #5
 80013e2:	7103      	strb	r3, [r0, #4]
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
 80013e4:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 80013e8:	009a      	lsls	r2, r3, #2
 80013ea:	1a8a      	subs	r2, r1, r2
 80013ec:	7142      	strb	r2, [r0, #5]
					}
				}
				else
				{
					if(g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE ==FALSE )
					{
 80013ee:	e00b      	b.n	8001408 <ADCT_SystemFPT_RunOutput+0x284>
						g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;

					}
					else
					{
						ADCT_BGS_AIR_1_2_ON();
 80013f0:	2140      	movs	r1, #64	; 0x40
 80013f2:	4823      	ldr	r0, [pc, #140]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 80013f4:	f002 fef6 	bl	80041e4 <GPIO_ResetBits>
 80013f8:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013fc:	4821      	ldr	r0, [pc, #132]	; (8001484 <ADCT_SystemFPT_RunOutput+0x300>)
 80013fe:	f002 fef1 	bl	80041e4 <GPIO_ResetBits>
						g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 8001402:	2201      	movs	r2, #1
 8001404:	4b20      	ldr	r3, [pc, #128]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001406:	701a      	strb	r2, [r3, #0]
					}
					// Detect if the t_min_timer is still running, if YES, output remains high
					if(g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == TRUE)
 8001408:	4b1f      	ldr	r3, [pc, #124]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800140a:	799b      	ldrb	r3, [r3, #6]
 800140c:	2b01      	cmp	r3, #1
 800140e:	d10e      	bne.n	800142e <ADCT_SystemFPT_RunOutput+0x2aa>
 8001410:	4b1d      	ldr	r3, [pc, #116]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001412:	785b      	ldrb	r3, [r3, #1]
 8001414:	2b01      	cmp	r3, #1
 8001416:	d10a      	bne.n	800142e <ADCT_SystemFPT_RunOutput+0x2aa>
					{
						ADCT_BGS_AIR_3_4_ON();
 8001418:	4c19      	ldr	r4, [pc, #100]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 800141a:	2180      	movs	r1, #128	; 0x80
 800141c:	4620      	mov	r0, r4
 800141e:	f002 fee1 	bl	80041e4 <GPIO_ResetBits>
 8001422:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001426:	4620      	mov	r0, r4
 8001428:	f002 fedc 	bl	80041e4 <GPIO_ResetBits>
 800142c:	e00c      	b.n	8001448 <ADCT_SystemFPT_RunOutput+0x2c4>
					}
					else
					{
						ADCT_BGS_AIR_3_4_OFF();
 800142e:	4c14      	ldr	r4, [pc, #80]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 8001430:	2180      	movs	r1, #128	; 0x80
 8001432:	4620      	mov	r0, r4
 8001434:	f002 fed4 	bl	80041e0 <GPIO_SetBits>
 8001438:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800143c:	4620      	mov	r0, r4
 800143e:	f002 fecf 	bl	80041e0 <GPIO_SetBits>
						g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = FALSE;
 8001442:	2200      	movs	r2, #0
 8001444:	4b10      	ldr	r3, [pc, #64]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001446:	705a      	strb	r2, [r3, #1]
					}
				}

				if(g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE)
 8001448:	4b0f      	ldr	r3, [pc, #60]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 800144a:	79db      	ldrb	r3, [r3, #7]
 800144c:	2b01      	cmp	r3, #1
 800144e:	d127      	bne.n	80014a0 <ADCT_SystemFPT_RunOutput+0x31c>
 8001450:	4b0d      	ldr	r3, [pc, #52]	; (8001488 <ADCT_SystemFPT_RunOutput+0x304>)
 8001452:	789b      	ldrb	r3, [r3, #2]
 8001454:	2b01      	cmp	r3, #1
 8001456:	d123      	bne.n	80014a0 <ADCT_SystemFPT_RunOutput+0x31c>
				{
					ADCT_BGS_FAN_ON();
 8001458:	4c09      	ldr	r4, [pc, #36]	; (8001480 <ADCT_SystemFPT_RunOutput+0x2fc>)
 800145a:	2104      	movs	r1, #4
 800145c:	4620      	mov	r0, r4
 800145e:	f002 febf 	bl	80041e0 <GPIO_SetBits>
 8001462:	2108      	movs	r1, #8
 8001464:	4620      	mov	r0, r4
 8001466:	f002 febb 	bl	80041e0 <GPIO_SetBits>
 800146a:	2110      	movs	r1, #16
 800146c:	4620      	mov	r0, r4
 800146e:	f002 feb7 	bl	80041e0 <GPIO_SetBits>
 8001472:	2120      	movs	r1, #32
 8001474:	4620      	mov	r0, r4
 8001476:	f002 feb3 	bl	80041e0 <GPIO_SetBits>
 800147a:	e197      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
 800147c:	20000504 	.word	0x20000504
 8001480:	40010800 	.word	0x40010800
 8001484:	40011000 	.word	0x40011000
 8001488:	200004b0 	.word	0x200004b0
 800148c:	2000050c 	.word	0x2000050c
 8001490:	200004c0 	.word	0x200004c0
 8001494:	91a2b3c5 	.word	0x91a2b3c5
 8001498:	20000490 	.word	0x20000490
 800149c:	88888889 	.word	0x88888889
				}
				else
				{
					ADCT_BGS_FAN_OFF();
 80014a0:	4cb1      	ldr	r4, [pc, #708]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 80014a2:	2104      	movs	r1, #4
 80014a4:	4620      	mov	r0, r4
 80014a6:	f002 fe9d 	bl	80041e4 <GPIO_ResetBits>
 80014aa:	2108      	movs	r1, #8
 80014ac:	4620      	mov	r0, r4
 80014ae:	f002 fe99 	bl	80041e4 <GPIO_ResetBits>
 80014b2:	2110      	movs	r1, #16
 80014b4:	4620      	mov	r0, r4
 80014b6:	f002 fe95 	bl	80041e4 <GPIO_ResetBits>
 80014ba:	2120      	movs	r1, #32
 80014bc:	4620      	mov	r0, r4
 80014be:	f002 fe91 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
 80014c2:	2200      	movs	r2, #0
 80014c4:	4ba9      	ldr	r3, [pc, #676]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80014c6:	709a      	strb	r2, [r3, #2]
 80014c8:	e170      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
				}
			}
			/* High Temperature (SNMP_SYT_003) */
			else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 80014ca:	4aa9      	ldr	r2, [pc, #676]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 80014cc:	8852      	ldrh	r2, [r2, #2]
 80014ce:	4293      	cmp	r3, r2
 80014d0:	f240 80a4 	bls.w	800161c <ADCT_SystemFPT_RunOutput+0x498>
					(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
 80014d4:	4aa6      	ldr	r2, [pc, #664]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 80014d6:	8892      	ldrh	r2, [r2, #4]
					ADCT_BGS_FAN_OFF();
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
				}
			}
			/* High Temperature (SNMP_SYT_003) */
			else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
 80014d8:	4293      	cmp	r3, r2
 80014da:	f200 809f 	bhi.w	800161c <ADCT_SystemFPT_RunOutput+0x498>
					(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
			{
				// Detect if air 1 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 80014de:	4ba3      	ldr	r3, [pc, #652]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80014e0:	795b      	ldrb	r3, [r3, #5]
 80014e2:	bb3b      	cbnz	r3, 8001534 <ADCT_SystemFPT_RunOutput+0x3b0>
 80014e4:	4ba1      	ldr	r3, [pc, #644]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80014e6:	781b      	ldrb	r3, [r3, #0]
 80014e8:	bb23      	cbnz	r3, 8001534 <ADCT_SystemFPT_RunOutput+0x3b0>
					ADCT_BGS_AIR_1_2_ON();
 80014ea:	2140      	movs	r1, #64	; 0x40
 80014ec:	489e      	ldr	r0, [pc, #632]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 80014ee:	f002 fe79 	bl	80041e4 <GPIO_ResetBits>
 80014f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80014f6:	489f      	ldr	r0, [pc, #636]	; (8001774 <ADCT_SystemFPT_RunOutput+0x5f0>)
 80014f8:	f002 fe74 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 80014fc:	4b9b      	ldr	r3, [pc, #620]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80014fe:	2201      	movs	r2, #1
 8001500:	701a      	strb	r2, [r3, #0]
					g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = TRUE;
 8001502:	715a      	strb	r2, [r3, #5]
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001504:	4b9a      	ldr	r3, [pc, #616]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 8001506:	6a1a      	ldr	r2, [r3, #32]
 8001508:	4b9b      	ldr	r3, [pc, #620]	; (8001778 <ADCT_SystemFPT_RunOutput+0x5f4>)
 800150a:	fba3 1302 	umull	r1, r3, r3, r2
 800150e:	0ad9      	lsrs	r1, r3, #11
 8001510:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8001514:	fb00 2111 	mls	r1, r0, r1, r2
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 8001518:	0adb      	lsrs	r3, r3, #11
 800151a:	4898      	ldr	r0, [pc, #608]	; (800177c <ADCT_SystemFPT_RunOutput+0x5f8>)
 800151c:	70c3      	strb	r3, [r0, #3]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
 800151e:	4b98      	ldr	r3, [pc, #608]	; (8001780 <ADCT_SystemFPT_RunOutput+0x5fc>)
 8001520:	fba3 2301 	umull	r2, r3, r3, r1
 8001524:	095b      	lsrs	r3, r3, #5
 8001526:	7103      	strb	r3, [r0, #4]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
 8001528:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 800152c:	009a      	lsls	r2, r3, #2
 800152e:	1a8a      	subs	r2, r1, r2
 8001530:	7142      	strb	r2, [r0, #5]
			/* High Temperature (SNMP_SYT_003) */
			else if((GstSystemStatus.dhtData.usTemp_Main > GstSystemSetting.usHighTemperatureT2) &&
					(GstSystemStatus.dhtData.usTemp_Main <= GstSystemSetting.usFanTemperatureT3))
			{
				// Detect if air 1 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 8001532:	e00b      	b.n	800154c <ADCT_SystemFPT_RunOutput+0x3c8>
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
				}
				else {
					ADCT_BGS_AIR_1_2_ON();
 8001534:	2140      	movs	r1, #64	; 0x40
 8001536:	488c      	ldr	r0, [pc, #560]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 8001538:	f002 fe54 	bl	80041e4 <GPIO_ResetBits>
 800153c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001540:	488c      	ldr	r0, [pc, #560]	; (8001774 <ADCT_SystemFPT_RunOutput+0x5f0>)
 8001542:	f002 fe4f 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 8001546:	2201      	movs	r2, #1
 8001548:	4b88      	ldr	r3, [pc, #544]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 800154a:	701a      	strb	r2, [r3, #0]
				}

				// Detect if air 2 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 800154c:	4b87      	ldr	r3, [pc, #540]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 800154e:	799b      	ldrb	r3, [r3, #6]
 8001550:	bb43      	cbnz	r3, 80015a4 <ADCT_SystemFPT_RunOutput+0x420>
 8001552:	4b86      	ldr	r3, [pc, #536]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001554:	785b      	ldrb	r3, [r3, #1]
 8001556:	bb2b      	cbnz	r3, 80015a4 <ADCT_SystemFPT_RunOutput+0x420>
					ADCT_BGS_AIR_3_4_ON();
 8001558:	4c83      	ldr	r4, [pc, #524]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 800155a:	2180      	movs	r1, #128	; 0x80
 800155c:	4620      	mov	r0, r4
 800155e:	f002 fe41 	bl	80041e4 <GPIO_ResetBits>
 8001562:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001566:	4620      	mov	r0, r4
 8001568:	f002 fe3c 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 800156c:	4b7f      	ldr	r3, [pc, #508]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 800156e:	2201      	movs	r2, #1
 8001570:	705a      	strb	r2, [r3, #1]
					g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = TRUE;
 8001572:	719a      	strb	r2, [r3, #6]
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001574:	4b7e      	ldr	r3, [pc, #504]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 8001576:	6a1a      	ldr	r2, [r3, #32]
 8001578:	4b7f      	ldr	r3, [pc, #508]	; (8001778 <ADCT_SystemFPT_RunOutput+0x5f4>)
 800157a:	fba3 1302 	umull	r1, r3, r3, r2
 800157e:	0ad9      	lsrs	r1, r3, #11
 8001580:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8001584:	fb00 2111 	mls	r1, r0, r1, r2
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 8001588:	0adb      	lsrs	r3, r3, #11
 800158a:	487c      	ldr	r0, [pc, #496]	; (800177c <ADCT_SystemFPT_RunOutput+0x5f8>)
 800158c:	7183      	strb	r3, [r0, #6]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
 800158e:	4b7c      	ldr	r3, [pc, #496]	; (8001780 <ADCT_SystemFPT_RunOutput+0x5fc>)
 8001590:	fba3 2301 	umull	r2, r3, r3, r1
 8001594:	095b      	lsrs	r3, r3, #5
 8001596:	71c3      	strb	r3, [r0, #7]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
 8001598:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 800159c:	009a      	lsls	r2, r3, #2
 800159e:	1a8a      	subs	r2, r1, r2
 80015a0:	7202      	strb	r2, [r0, #8]
					ADCT_BGS_AIR_1_2_ON();
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
				}

				// Detect if air 2 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 80015a2:	e00c      	b.n	80015be <ADCT_SystemFPT_RunOutput+0x43a>
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
				}
				else {
					ADCT_BGS_AIR_3_4_ON();
 80015a4:	4c70      	ldr	r4, [pc, #448]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 80015a6:	2180      	movs	r1, #128	; 0x80
 80015a8:	4620      	mov	r0, r4
 80015aa:	f002 fe1b 	bl	80041e4 <GPIO_ResetBits>
 80015ae:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80015b2:	4620      	mov	r0, r4
 80015b4:	f002 fe16 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 80015b8:	2201      	movs	r2, #1
 80015ba:	4b6c      	ldr	r3, [pc, #432]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80015bc:	705a      	strb	r2, [r3, #1]
				}

				// Detect if the t_min_timer is still running, if YES, output remains high
				if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == TRUE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == TRUE) {
 80015be:	4b6b      	ldr	r3, [pc, #428]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80015c0:	79db      	ldrb	r3, [r3, #7]
 80015c2:	2b01      	cmp	r3, #1
 80015c4:	d115      	bne.n	80015f2 <ADCT_SystemFPT_RunOutput+0x46e>
 80015c6:	4b69      	ldr	r3, [pc, #420]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80015c8:	789b      	ldrb	r3, [r3, #2]
 80015ca:	2b01      	cmp	r3, #1
 80015cc:	d111      	bne.n	80015f2 <ADCT_SystemFPT_RunOutput+0x46e>
					ADCT_BGS_FAN_ON();
 80015ce:	4c66      	ldr	r4, [pc, #408]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 80015d0:	2104      	movs	r1, #4
 80015d2:	4620      	mov	r0, r4
 80015d4:	f002 fe04 	bl	80041e0 <GPIO_SetBits>
 80015d8:	2108      	movs	r1, #8
 80015da:	4620      	mov	r0, r4
 80015dc:	f002 fe00 	bl	80041e0 <GPIO_SetBits>
 80015e0:	2110      	movs	r1, #16
 80015e2:	4620      	mov	r0, r4
 80015e4:	f002 fdfc 	bl	80041e0 <GPIO_SetBits>
 80015e8:	2120      	movs	r1, #32
 80015ea:	4620      	mov	r0, r4
 80015ec:	f002 fdf8 	bl	80041e0 <GPIO_SetBits>
 80015f0:	e0dc      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
				}
				else {
					ADCT_BGS_FAN_OFF();
 80015f2:	4c5d      	ldr	r4, [pc, #372]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 80015f4:	2104      	movs	r1, #4
 80015f6:	4620      	mov	r0, r4
 80015f8:	f002 fdf4 	bl	80041e4 <GPIO_ResetBits>
 80015fc:	2108      	movs	r1, #8
 80015fe:	4620      	mov	r0, r4
 8001600:	f002 fdf0 	bl	80041e4 <GPIO_ResetBits>
 8001604:	2110      	movs	r1, #16
 8001606:	4620      	mov	r0, r4
 8001608:	f002 fdec 	bl	80041e4 <GPIO_ResetBits>
 800160c:	2120      	movs	r1, #32
 800160e:	4620      	mov	r0, r4
 8001610:	f002 fde8 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = FALSE;
 8001614:	2200      	movs	r2, #0
 8001616:	4b55      	ldr	r3, [pc, #340]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001618:	709a      	strb	r2, [r3, #2]
 800161a:	e0c7      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
			}
			else
				/* Fan Temperature (SNMP_SYT_004) */
			{
				// Detect if air 1 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 800161c:	4b53      	ldr	r3, [pc, #332]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 800161e:	795b      	ldrb	r3, [r3, #5]
 8001620:	bb3b      	cbnz	r3, 8001672 <ADCT_SystemFPT_RunOutput+0x4ee>
 8001622:	4b52      	ldr	r3, [pc, #328]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001624:	781b      	ldrb	r3, [r3, #0]
 8001626:	bb23      	cbnz	r3, 8001672 <ADCT_SystemFPT_RunOutput+0x4ee>
					ADCT_BGS_AIR_1_2_ON();
 8001628:	2140      	movs	r1, #64	; 0x40
 800162a:	484f      	ldr	r0, [pc, #316]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 800162c:	f002 fdda 	bl	80041e4 <GPIO_ResetBits>
 8001630:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001634:	484f      	ldr	r0, [pc, #316]	; (8001774 <ADCT_SystemFPT_RunOutput+0x5f0>)
 8001636:	f002 fdd5 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 800163a:	4b4c      	ldr	r3, [pc, #304]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 800163c:	2201      	movs	r2, #1
 800163e:	701a      	strb	r2, [r3, #0]
					g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE = TRUE;
 8001640:	715a      	strb	r2, [r3, #5]
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001642:	4b4b      	ldr	r3, [pc, #300]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 8001644:	6a1a      	ldr	r2, [r3, #32]
 8001646:	4b4c      	ldr	r3, [pc, #304]	; (8001778 <ADCT_SystemFPT_RunOutput+0x5f4>)
 8001648:	fba3 1302 	umull	r1, r3, r3, r2
 800164c:	0ad9      	lsrs	r1, r3, #11
 800164e:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8001652:	fb00 2111 	mls	r1, r0, r1, r2
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 8001656:	0adb      	lsrs	r3, r3, #11
 8001658:	4848      	ldr	r0, [pc, #288]	; (800177c <ADCT_SystemFPT_RunOutput+0x5f8>)
 800165a:	70c3      	strb	r3, [r0, #3]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
 800165c:	4b48      	ldr	r3, [pc, #288]	; (8001780 <ADCT_SystemFPT_RunOutput+0x5fc>)
 800165e:	fba3 2301 	umull	r2, r3, r3, r1
 8001662:	095b      	lsrs	r3, r3, #5
 8001664:	7103      	strb	r3, [r0, #4]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
 8001666:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 800166a:	009a      	lsls	r2, r3, #2
 800166c:	1a8a      	subs	r2, r1, r2
 800166e:	7142      	strb	r2, [r0, #5]
			}
			else
				/* Fan Temperature (SNMP_SYT_004) */
			{
				// Detect if air 1 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_1_2TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE == FALSE) {
 8001670:	e00b      	b.n	800168a <ADCT_SystemFPT_RunOutput+0x506>
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.hour = GstSystemSetting.ulMinSwitchingTime/3600;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.minute =temp_variable/60;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR1_2.second =temp_variable%60;
				}
				else {
					ADCT_BGS_AIR_1_2_ON();
 8001672:	2140      	movs	r1, #64	; 0x40
 8001674:	483c      	ldr	r0, [pc, #240]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 8001676:	f002 fdb5 	bl	80041e4 <GPIO_ResetBits>
 800167a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800167e:	483d      	ldr	r0, [pc, #244]	; (8001774 <ADCT_SystemFPT_RunOutput+0x5f0>)
 8001680:	f002 fdb0 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
 8001684:	2201      	movs	r2, #1
 8001686:	4b39      	ldr	r3, [pc, #228]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001688:	701a      	strb	r2, [r3, #0]
				}

				// Detect if air 2 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 800168a:	4b38      	ldr	r3, [pc, #224]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 800168c:	799b      	ldrb	r3, [r3, #6]
 800168e:	bb43      	cbnz	r3, 80016e2 <ADCT_SystemFPT_RunOutput+0x55e>
 8001690:	4b36      	ldr	r3, [pc, #216]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001692:	785b      	ldrb	r3, [r3, #1]
 8001694:	bb2b      	cbnz	r3, 80016e2 <ADCT_SystemFPT_RunOutput+0x55e>
					ADCT_BGS_AIR_3_4_ON();
 8001696:	4c34      	ldr	r4, [pc, #208]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 8001698:	2180      	movs	r1, #128	; 0x80
 800169a:	4620      	mov	r0, r4
 800169c:	f002 fda2 	bl	80041e4 <GPIO_ResetBits>
 80016a0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80016a4:	4620      	mov	r0, r4
 80016a6:	f002 fd9d 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 80016aa:	4b30      	ldr	r3, [pc, #192]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80016ac:	2201      	movs	r2, #1
 80016ae:	705a      	strb	r2, [r3, #1]
					g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE = TRUE;
 80016b0:	719a      	strb	r2, [r3, #6]
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 80016b2:	4b2f      	ldr	r3, [pc, #188]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 80016b4:	6a1a      	ldr	r2, [r3, #32]
 80016b6:	4b30      	ldr	r3, [pc, #192]	; (8001778 <ADCT_SystemFPT_RunOutput+0x5f4>)
 80016b8:	fba3 1302 	umull	r1, r3, r3, r2
 80016bc:	0ad9      	lsrs	r1, r3, #11
 80016be:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 80016c2:	fb00 2111 	mls	r1, r0, r1, r2
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 80016c6:	0adb      	lsrs	r3, r3, #11
 80016c8:	482c      	ldr	r0, [pc, #176]	; (800177c <ADCT_SystemFPT_RunOutput+0x5f8>)
 80016ca:	7183      	strb	r3, [r0, #6]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
 80016cc:	4b2c      	ldr	r3, [pc, #176]	; (8001780 <ADCT_SystemFPT_RunOutput+0x5fc>)
 80016ce:	fba3 2301 	umull	r2, r3, r3, r1
 80016d2:	095b      	lsrs	r3, r3, #5
 80016d4:	71c3      	strb	r3, [r0, #7]
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
 80016d6:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 80016da:	009a      	lsls	r2, r3, #2
 80016dc:	1a8a      	subs	r2, r1, r2
 80016de:	7202      	strb	r2, [r0, #8]
					ADCT_BGS_AIR_1_2_ON();
					g_ADCT_BGS_StateOutput.AIR_1_2_OUTPUT_STATE = TRUE;
				}

				// Detect if air 2 output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.AIR_3_4TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE == FALSE) {
 80016e0:	e00c      	b.n	80016fc <ADCT_SystemFPT_RunOutput+0x578>
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.hour = GstSystemSetting.ulMinSwitchingTime/3600;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.minute =temp_variable/60;
					g_ADCT_BGS_TimerManager.MinSwitchingTimerAIR3_4.second =temp_variable%60;
				}
				else {
					ADCT_BGS_AIR_3_4_ON();
 80016e2:	4c21      	ldr	r4, [pc, #132]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 80016e4:	2180      	movs	r1, #128	; 0x80
 80016e6:	4620      	mov	r0, r4
 80016e8:	f002 fd7c 	bl	80041e4 <GPIO_ResetBits>
 80016ec:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80016f0:	4620      	mov	r0, r4
 80016f2:	f002 fd77 	bl	80041e4 <GPIO_ResetBits>
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
 80016f6:	2201      	movs	r2, #1
 80016f8:	4b1c      	ldr	r3, [pc, #112]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80016fa:	705a      	strb	r2, [r3, #1]
				}

				// Detect if a fan output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == FALSE) {
 80016fc:	4b1b      	ldr	r3, [pc, #108]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 80016fe:	79db      	ldrb	r3, [r3, #7]
 8001700:	2b00      	cmp	r3, #0
 8001702:	d13f      	bne.n	8001784 <ADCT_SystemFPT_RunOutput+0x600>
 8001704:	4b19      	ldr	r3, [pc, #100]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001706:	789b      	ldrb	r3, [r3, #2]
 8001708:	2b00      	cmp	r3, #0
 800170a:	d13b      	bne.n	8001784 <ADCT_SystemFPT_RunOutput+0x600>
					ADCT_BGS_FAN_ON();
 800170c:	4c16      	ldr	r4, [pc, #88]	; (8001768 <ADCT_SystemFPT_RunOutput+0x5e4>)
 800170e:	2104      	movs	r1, #4
 8001710:	4620      	mov	r0, r4
 8001712:	f002 fd65 	bl	80041e0 <GPIO_SetBits>
 8001716:	2108      	movs	r1, #8
 8001718:	4620      	mov	r0, r4
 800171a:	f002 fd61 	bl	80041e0 <GPIO_SetBits>
 800171e:	2110      	movs	r1, #16
 8001720:	4620      	mov	r0, r4
 8001722:	f002 fd5d 	bl	80041e0 <GPIO_SetBits>
 8001726:	2120      	movs	r1, #32
 8001728:	4620      	mov	r0, r4
 800172a:	f002 fd59 	bl	80041e0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = TRUE;
 800172e:	4b0f      	ldr	r3, [pc, #60]	; (800176c <ADCT_SystemFPT_RunOutput+0x5e8>)
 8001730:	2201      	movs	r2, #1
 8001732:	709a      	strb	r2, [r3, #2]
					g_ADCT_BGS_StateOutput.FAN_TIMER_STATE = TRUE;
 8001734:	71da      	strb	r2, [r3, #7]
					uint32_t temp_variable;
					temp_variable = GstSystemSetting.ulMinSwitchingTime%3600 ;
 8001736:	4b0e      	ldr	r3, [pc, #56]	; (8001770 <ADCT_SystemFPT_RunOutput+0x5ec>)
 8001738:	6a1a      	ldr	r2, [r3, #32]
 800173a:	4b0f      	ldr	r3, [pc, #60]	; (8001778 <ADCT_SystemFPT_RunOutput+0x5f4>)
 800173c:	fba3 1302 	umull	r1, r3, r3, r2
 8001740:	0ad9      	lsrs	r1, r3, #11
 8001742:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8001746:	fb00 2111 	mls	r1, r0, r1, r2
					g_ADCT_BGS_TimerManager.MinRuningTimerFan.hour = GstSystemSetting.ulMinSwitchingTime/3600;
 800174a:	0adb      	lsrs	r3, r3, #11
 800174c:	480b      	ldr	r0, [pc, #44]	; (800177c <ADCT_SystemFPT_RunOutput+0x5f8>)
 800174e:	7483      	strb	r3, [r0, #18]
					g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute = temp_variable/60;
 8001750:	4b0b      	ldr	r3, [pc, #44]	; (8001780 <ADCT_SystemFPT_RunOutput+0x5fc>)
 8001752:	fba3 2301 	umull	r2, r3, r3, r1
 8001756:	095b      	lsrs	r3, r3, #5
 8001758:	74c3      	strb	r3, [r0, #19]
					g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = temp_variable%60;
 800175a:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 800175e:	009a      	lsls	r2, r3, #2
 8001760:	1a8a      	subs	r2, r1, r2
 8001762:	7502      	strb	r2, [r0, #20]
					ADCT_BGS_AIR_3_4_ON();
					g_ADCT_BGS_StateOutput.AIR_3_4_OUTPUT_STATE = TRUE;
				}

				// Detect if a fan output just activate and run min_timer
				if (g_ADCT_BGS_StateOutput.FAN_TIMER_STATE == FALSE && g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE == FALSE) {
 8001764:	e022      	b.n	80017ac <ADCT_SystemFPT_RunOutput+0x628>
 8001766:	bf00      	nop
 8001768:	40010800 	.word	0x40010800
 800176c:	200004b0 	.word	0x200004b0
 8001770:	200004c0 	.word	0x200004c0
 8001774:	40011000 	.word	0x40011000
 8001778:	91a2b3c5 	.word	0x91a2b3c5
 800177c:	20000490 	.word	0x20000490
 8001780:	88888889 	.word	0x88888889
					g_ADCT_BGS_TimerManager.MinRuningTimerFan.hour = GstSystemSetting.ulMinSwitchingTime/3600;
					g_ADCT_BGS_TimerManager.MinRuningTimerFan.minute = temp_variable/60;
					g_ADCT_BGS_TimerManager.MinRuningTimerFan.second = temp_variable%60;
				}
				else {
					ADCT_BGS_FAN_ON();
 8001784:	4c3b      	ldr	r4, [pc, #236]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 8001786:	2104      	movs	r1, #4
 8001788:	4620      	mov	r0, r4
 800178a:	f002 fd29 	bl	80041e0 <GPIO_SetBits>
 800178e:	2108      	movs	r1, #8
 8001790:	4620      	mov	r0, r4
 8001792:	f002 fd25 	bl	80041e0 <GPIO_SetBits>
 8001796:	2110      	movs	r1, #16
 8001798:	4620      	mov	r0, r4
 800179a:	f002 fd21 	bl	80041e0 <GPIO_SetBits>
 800179e:	2120      	movs	r1, #32
 80017a0:	4620      	mov	r0, r4
 80017a2:	f002 fd1d 	bl	80041e0 <GPIO_SetBits>
					g_ADCT_BGS_StateOutput.FAN_OUTPUT_STATE = TRUE;
 80017a6:	2201      	movs	r2, #1
 80017a8:	4b33      	ldr	r3, [pc, #204]	; (8001878 <ADCT_SystemFPT_RunOutput+0x6f4>)
 80017aa:	709a      	strb	r2, [r3, #2]
				}
			}
		}
	}
	// Lamp alarm
	if (ADCT_SystemFPT_CheckAlarm()) {
 80017ac:	f7ff fc8c 	bl	80010c8 <ADCT_SystemFPT_CheckAlarm>
 80017b0:	b128      	cbz	r0, 80017be <ADCT_SystemFPT_RunOutput+0x63a>
		ADCT_BGS_RELAY_LAMP_ON();
 80017b2:	2201      	movs	r2, #1
 80017b4:	4611      	mov	r1, r2
 80017b6:	482f      	ldr	r0, [pc, #188]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 80017b8:	f002 fd16 	bl	80041e8 <GPIO_WriteBit>
 80017bc:	e004      	b.n	80017c8 <ADCT_SystemFPT_RunOutput+0x644>
	}
	else {
		ADCT_BGS_RELAY_LAMP_OFF();
 80017be:	2200      	movs	r2, #0
 80017c0:	2101      	movs	r1, #1
 80017c2:	482c      	ldr	r0, [pc, #176]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 80017c4:	f002 fd10 	bl	80041e8 <GPIO_WriteBit>
	}

	if(GstSystemWarning.State == MAINSTATE_ALARM )
 80017c8:	4b2c      	ldr	r3, [pc, #176]	; (800187c <ADCT_SystemFPT_RunOutput+0x6f8>)
 80017ca:	781b      	ldrb	r3, [r3, #0]
 80017cc:	2b06      	cmp	r3, #6
 80017ce:	d111      	bne.n	80017f4 <ADCT_SystemFPT_RunOutput+0x670>
	{
		// Check if siren should be activated or not. If ADCT_BGS_sys.siren_timer_run == FALSE
		// siren will be activated
		if ((g_ADCT_BGS_StateOutput.ALARM_TIMER_Flag == TRUE) && (g_ADCT_BGS_StateOutput.BUZZER_TIMER_STATE == FALSE) && (ADCT_SystemFPT_CheckAlarm_Siren() == TRUE) ){
 80017d0:	4b29      	ldr	r3, [pc, #164]	; (8001878 <ADCT_SystemFPT_RunOutput+0x6f4>)
 80017d2:	7adb      	ldrb	r3, [r3, #11]
 80017d4:	2b01      	cmp	r3, #1
 80017d6:	d10a      	bne.n	80017ee <ADCT_SystemFPT_RunOutput+0x66a>
 80017d8:	4b27      	ldr	r3, [pc, #156]	; (8001878 <ADCT_SystemFPT_RunOutput+0x6f4>)
 80017da:	791b      	ldrb	r3, [r3, #4]
 80017dc:	b93b      	cbnz	r3, 80017ee <ADCT_SystemFPT_RunOutput+0x66a>
 80017de:	f7ff fcb1 	bl	8001144 <ADCT_SystemFPT_CheckAlarm_Siren>
 80017e2:	2801      	cmp	r0, #1
 80017e4:	d103      	bne.n	80017ee <ADCT_SystemFPT_RunOutput+0x66a>
			g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE =  TRUE;
 80017e6:	2201      	movs	r2, #1
 80017e8:	4b23      	ldr	r3, [pc, #140]	; (8001878 <ADCT_SystemFPT_RunOutput+0x6f4>)
 80017ea:	70da      	strb	r2, [r3, #3]
 80017ec:	e002      	b.n	80017f4 <ADCT_SystemFPT_RunOutput+0x670>
		}
		else {
			g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE =FALSE;
 80017ee:	2200      	movs	r2, #0
 80017f0:	4b21      	ldr	r3, [pc, #132]	; (8001878 <ADCT_SystemFPT_RunOutput+0x6f4>)
 80017f2:	70da      	strb	r2, [r3, #3]
		}

	}
	// Siren alarm
	if (GstSystemSetting.ucEnableAlarm == FALSE) {
 80017f4:	4b22      	ldr	r3, [pc, #136]	; (8001880 <ADCT_SystemFPT_RunOutput+0x6fc>)
 80017f6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80017fa:	b92b      	cbnz	r3, 8001808 <ADCT_SystemFPT_RunOutput+0x684>
		ADCT_BGS_RELAY_BUZZER_OFF();
 80017fc:	2200      	movs	r2, #0
 80017fe:	2102      	movs	r1, #2
 8001800:	481c      	ldr	r0, [pc, #112]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 8001802:	f002 fcf1 	bl	80041e8 <GPIO_WriteBit>
 8001806:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	else {
		if (g_ADCT_BGS_StateOutput.BUZZER_OUTPUT_STATE == TRUE && ADCT_SystemFPT_CheckAlarm_Siren()) {
 8001808:	4b1b      	ldr	r3, [pc, #108]	; (8001878 <ADCT_SystemFPT_RunOutput+0x6f4>)
 800180a:	78db      	ldrb	r3, [r3, #3]
 800180c:	2b01      	cmp	r3, #1
 800180e:	d12a      	bne.n	8001866 <ADCT_SystemFPT_RunOutput+0x6e2>
 8001810:	f7ff fc98 	bl	8001144 <ADCT_SystemFPT_CheckAlarm_Siren>
 8001814:	b338      	cbz	r0, 8001866 <ADCT_SystemFPT_RunOutput+0x6e2>
			if (ReadBit(GstSystemWarning.othWarn, WARN_FIRE) == WARN_ON ||
 8001816:	4b19      	ldr	r3, [pc, #100]	; (800187c <ADCT_SystemFPT_RunOutput+0x6f8>)
 8001818:	685b      	ldr	r3, [r3, #4]
 800181a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800181e:	d105      	bne.n	800182c <ADCT_SystemFPT_RunOutput+0x6a8>
 8001820:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001824:	d102      	bne.n	800182c <ADCT_SystemFPT_RunOutput+0x6a8>
					ReadBit(GstSystemWarning.othWarn, WARN_SMOKE) == TRUE||
 8001826:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800182a:	d005      	beq.n	8001838 <ADCT_SystemFPT_RunOutput+0x6b4>
					ReadBit(GstSystemWarning.othWarn, WARN_WATER) == TRUE) {
				ADCT_BGS_RELAY_BUZZER_ON();
 800182c:	2201      	movs	r2, #1
 800182e:	2102      	movs	r1, #2
 8001830:	4810      	ldr	r0, [pc, #64]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 8001832:	f002 fcd9 	bl	80041e8 <GPIO_WriteBit>
 8001836:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			}
			else if (ReadBit(GstSystemWarning.othWarn, WARN_DOOR) == WARN_ON  || ReadBit(GstSystemWarning.othWarn, WARN_BURGLAR) == WARN_ON) {
 8001838:	f413 7f80 	tst.w	r3, #256	; 0x100
 800183c:	d102      	bne.n	8001844 <ADCT_SystemFPT_RunOutput+0x6c0>
 800183e:	f413 7f00 	tst.w	r3, #512	; 0x200
 8001842:	d015      	beq.n	8001870 <ADCT_SystemFPT_RunOutput+0x6ec>
				if (GstSystemSetting.ucDoorBurglarEnableAlarm == TRUE) {
 8001844:	4b0e      	ldr	r3, [pc, #56]	; (8001880 <ADCT_SystemFPT_RunOutput+0x6fc>)
 8001846:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800184a:	2b01      	cmp	r3, #1
 800184c:	d105      	bne.n	800185a <ADCT_SystemFPT_RunOutput+0x6d6>
					ADCT_BGS_RELAY_BUZZER_ON();
 800184e:	2201      	movs	r2, #1
 8001850:	2102      	movs	r1, #2
 8001852:	4808      	ldr	r0, [pc, #32]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 8001854:	f002 fcc8 	bl	80041e8 <GPIO_WriteBit>
 8001858:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				}
				else {
					ADCT_BGS_RELAY_BUZZER_OFF();
 800185a:	2200      	movs	r2, #0
 800185c:	2102      	movs	r1, #2
 800185e:	4805      	ldr	r0, [pc, #20]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 8001860:	f002 fcc2 	bl	80041e8 <GPIO_WriteBit>
 8001864:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				}
			}
		}
		else {
			ADCT_BGS_RELAY_BUZZER_OFF();
 8001866:	2200      	movs	r2, #0
 8001868:	2102      	movs	r1, #2
 800186a:	4802      	ldr	r0, [pc, #8]	; (8001874 <ADCT_SystemFPT_RunOutput+0x6f0>)
 800186c:	f002 fcbc 	bl	80041e8 <GPIO_WriteBit>
 8001870:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001872:	bf00      	nop
 8001874:	40010800 	.word	0x40010800
 8001878:	200004b0 	.word	0x200004b0
 800187c:	20000504 	.word	0x20000504
 8001880:	200004c0 	.word	0x200004c0

08001884 <ADCT_BGS_DHT22_02_CbkState>:

	timeUs=t;
}
#ifdef SUB_DHT22
void ADCT_BGS_DHT22_02_CbkState(ExtiLineState_t state)
{
 8001884:	b510      	push	{r4, lr}
 8001886:	4604      	mov	r4, r0
	static uint32_t timeUs=0;
	static uint8_t cnt=0;
	uint32_t t;

	t=TimerGetUS();
 8001888:	f002 fa28 	bl	8003cdc <TimerGetUS>

	if (g_DhtMeasuring[DHT22_Device_2])
 800188c:	4b16      	ldr	r3, [pc, #88]	; (80018e8 <ADCT_BGS_DHT22_02_CbkState+0x64>)
 800188e:	785b      	ldrb	r3, [r3, #1]
 8001890:	b31b      	cbz	r3, 80018da <ADCT_BGS_DHT22_02_CbkState+0x56>
	{
		if (state == LineState_Low) // last was low
 8001892:	bb2c      	cbnz	r4, 80018e0 <ADCT_BGS_DHT22_02_CbkState+0x5c>
		{
			if (cnt)
 8001894:	4b15      	ldr	r3, [pc, #84]	; (80018ec <ADCT_BGS_DHT22_02_CbkState+0x68>)
 8001896:	781b      	ldrb	r3, [r3, #0]
 8001898:	b19b      	cbz	r3, 80018c2 <ADCT_BGS_DHT22_02_CbkState+0x3e>
			{
				g_DhtRaw[DHT22_Device_2][ (cnt-1) / 8] <<= 1;
 800189a:	1e59      	subs	r1, r3, #1
 800189c:	d500      	bpl.n	80018a0 <ADCT_BGS_DHT22_02_CbkState+0x1c>
 800189e:	3107      	adds	r1, #7
 80018a0:	10c9      	asrs	r1, r1, #3
 80018a2:	4c13      	ldr	r4, [pc, #76]	; (80018f0 <ADCT_BGS_DHT22_02_CbkState+0x6c>)
 80018a4:	440c      	add	r4, r1
 80018a6:	7962      	ldrb	r2, [r4, #5]
 80018a8:	0052      	lsls	r2, r2, #1
 80018aa:	b2d2      	uxtb	r2, r2
 80018ac:	7162      	strb	r2, [r4, #5]
				if ((t - timeUs) > 50) // 1
 80018ae:	4c11      	ldr	r4, [pc, #68]	; (80018f4 <ADCT_BGS_DHT22_02_CbkState+0x70>)
 80018b0:	6824      	ldr	r4, [r4, #0]
 80018b2:	1b04      	subs	r4, r0, r4
 80018b4:	2c32      	cmp	r4, #50	; 0x32
 80018b6:	d904      	bls.n	80018c2 <ADCT_BGS_DHT22_02_CbkState+0x3e>
					g_DhtRaw[DHT22_Device_2][(cnt-1) / 8] |= 1;
 80018b8:	4c0d      	ldr	r4, [pc, #52]	; (80018f0 <ADCT_BGS_DHT22_02_CbkState+0x6c>)
 80018ba:	4421      	add	r1, r4
 80018bc:	f042 0201 	orr.w	r2, r2, #1
 80018c0:	714a      	strb	r2, [r1, #5]
			}

			cnt++;
 80018c2:	3301      	adds	r3, #1
 80018c4:	b2db      	uxtb	r3, r3
 80018c6:	4a09      	ldr	r2, [pc, #36]	; (80018ec <ADCT_BGS_DHT22_02_CbkState+0x68>)
 80018c8:	7013      	strb	r3, [r2, #0]

			if (cnt >= 41) {
 80018ca:	2b28      	cmp	r3, #40	; 0x28
 80018cc:	d908      	bls.n	80018e0 <ADCT_BGS_DHT22_02_CbkState+0x5c>
				g_DhtMeasuring[DHT22_Device_2] = 0;
 80018ce:	2300      	movs	r3, #0
 80018d0:	4a05      	ldr	r2, [pc, #20]	; (80018e8 <ADCT_BGS_DHT22_02_CbkState+0x64>)
 80018d2:	7053      	strb	r3, [r2, #1]
				cnt = 0;
 80018d4:	4a05      	ldr	r2, [pc, #20]	; (80018ec <ADCT_BGS_DHT22_02_CbkState+0x68>)
 80018d6:	7013      	strb	r3, [r2, #0]
 80018d8:	e002      	b.n	80018e0 <ADCT_BGS_DHT22_02_CbkState+0x5c>
			}
		}
	} else
		cnt = 0;
 80018da:	2200      	movs	r2, #0
 80018dc:	4b03      	ldr	r3, [pc, #12]	; (80018ec <ADCT_BGS_DHT22_02_CbkState+0x68>)
 80018de:	701a      	strb	r2, [r3, #0]

	timeUs=t;
 80018e0:	4b04      	ldr	r3, [pc, #16]	; (80018f4 <ADCT_BGS_DHT22_02_CbkState+0x70>)
 80018e2:	6018      	str	r0, [r3, #0]
 80018e4:	bd10      	pop	{r4, pc}
 80018e6:	bf00      	nop
 80018e8:	200002c0 	.word	0x200002c0
 80018ec:	200002bd 	.word	0x200002bd
 80018f0:	200002c4 	.word	0x200002c4
 80018f4:	200002b8 	.word	0x200002b8

080018f8 <ADCT_BGS_DHT22_01_CbkState>:
	GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
#endif
}

void ADCT_BGS_DHT22_01_CbkState(ExtiLineState_t state)
{
 80018f8:	b510      	push	{r4, lr}
 80018fa:	4604      	mov	r4, r0
	static uint32_t timeUs=0;
	static uint8_t cnt=0;
	uint32_t t;

	t=TimerGetUS();
 80018fc:	f002 f9ee 	bl	8003cdc <TimerGetUS>

	if (g_DhtMeasuring[DHT22_Device_1])
 8001900:	4b15      	ldr	r3, [pc, #84]	; (8001958 <ADCT_BGS_DHT22_01_CbkState+0x60>)
 8001902:	781b      	ldrb	r3, [r3, #0]
 8001904:	b30b      	cbz	r3, 800194a <ADCT_BGS_DHT22_01_CbkState+0x52>
	{
		if (state == LineState_Low) // last was low
 8001906:	bb1c      	cbnz	r4, 8001950 <ADCT_BGS_DHT22_01_CbkState+0x58>
		{
			if (cnt)
 8001908:	4b14      	ldr	r3, [pc, #80]	; (800195c <ADCT_BGS_DHT22_01_CbkState+0x64>)
 800190a:	781b      	ldrb	r3, [r3, #0]
 800190c:	b18b      	cbz	r3, 8001932 <ADCT_BGS_DHT22_01_CbkState+0x3a>
			{
				g_DhtRaw[DHT22_Device_1][ (cnt-1) / 8] <<= 1;
 800190e:	1e59      	subs	r1, r3, #1
 8001910:	d500      	bpl.n	8001914 <ADCT_BGS_DHT22_01_CbkState+0x1c>
 8001912:	3107      	adds	r1, #7
 8001914:	10c9      	asrs	r1, r1, #3
 8001916:	4c12      	ldr	r4, [pc, #72]	; (8001960 <ADCT_BGS_DHT22_01_CbkState+0x68>)
 8001918:	5c62      	ldrb	r2, [r4, r1]
 800191a:	0052      	lsls	r2, r2, #1
 800191c:	b2d2      	uxtb	r2, r2
 800191e:	5462      	strb	r2, [r4, r1]
				if ((t - timeUs) > 50) // 1
 8001920:	4c10      	ldr	r4, [pc, #64]	; (8001964 <ADCT_BGS_DHT22_01_CbkState+0x6c>)
 8001922:	6824      	ldr	r4, [r4, #0]
 8001924:	1b04      	subs	r4, r0, r4
 8001926:	2c32      	cmp	r4, #50	; 0x32
 8001928:	d903      	bls.n	8001932 <ADCT_BGS_DHT22_01_CbkState+0x3a>
					g_DhtRaw[DHT22_Device_1][(cnt-1) / 8] |= 1;
 800192a:	f042 0201 	orr.w	r2, r2, #1
 800192e:	4c0c      	ldr	r4, [pc, #48]	; (8001960 <ADCT_BGS_DHT22_01_CbkState+0x68>)
 8001930:	5462      	strb	r2, [r4, r1]
			}

			cnt++;
 8001932:	3301      	adds	r3, #1
 8001934:	b2db      	uxtb	r3, r3
 8001936:	4a09      	ldr	r2, [pc, #36]	; (800195c <ADCT_BGS_DHT22_01_CbkState+0x64>)
 8001938:	7013      	strb	r3, [r2, #0]

			if (cnt >= 41) {
 800193a:	2b28      	cmp	r3, #40	; 0x28
 800193c:	d908      	bls.n	8001950 <ADCT_BGS_DHT22_01_CbkState+0x58>
				g_DhtMeasuring[DHT22_Device_1] = 0;
 800193e:	2300      	movs	r3, #0
 8001940:	4a05      	ldr	r2, [pc, #20]	; (8001958 <ADCT_BGS_DHT22_01_CbkState+0x60>)
 8001942:	7013      	strb	r3, [r2, #0]
				cnt = 0;
 8001944:	4a05      	ldr	r2, [pc, #20]	; (800195c <ADCT_BGS_DHT22_01_CbkState+0x64>)
 8001946:	7013      	strb	r3, [r2, #0]
 8001948:	e002      	b.n	8001950 <ADCT_BGS_DHT22_01_CbkState+0x58>
			}
		}
	} else
		cnt = 0;
 800194a:	2200      	movs	r2, #0
 800194c:	4b03      	ldr	r3, [pc, #12]	; (800195c <ADCT_BGS_DHT22_01_CbkState+0x64>)
 800194e:	701a      	strb	r2, [r3, #0]

	timeUs=t;
 8001950:	4b04      	ldr	r3, [pc, #16]	; (8001964 <ADCT_BGS_DHT22_01_CbkState+0x6c>)
 8001952:	6018      	str	r0, [r3, #0]
 8001954:	bd10      	pop	{r4, pc}
 8001956:	bf00      	nop
 8001958:	200002c0 	.word	0x200002c0
 800195c:	200002bc 	.word	0x200002bc
 8001960:	200002c4 	.word	0x200002c4
 8001964:	200002d0 	.word	0x200002d0

08001968 <ADCT_BGS_DHT22Init>:
#endif
/******************************************************************************
 * Function definitions
 *****************************************************************************/
void ADCT_BGS_DHT22Init(void)
{
 8001968:	b530      	push	{r4, r5, lr}
 800196a:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(DHT22_01_CLK, ENABLE);
 800196c:	2101      	movs	r1, #1
 800196e:	2008      	movs	r0, #8
 8001970:	f002 fe7a 	bl	8004668 <RCC_APB2PeriphClockCmd>
#ifdef SUB_DHT22
	RCC_APB2PeriphClockCmd(DHT22_02_CLK, ENABLE);
 8001974:	2101      	movs	r1, #1
 8001976:	2010      	movs	r0, #16
 8001978:	f002 fe76 	bl	8004668 <RCC_APB2PeriphClockCmd>
#endif
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 800197c:	2101      	movs	r1, #1
 800197e:	4608      	mov	r0, r1
 8001980:	f002 fe72 	bl	8004668 <RCC_APB2PeriphClockCmd>
	vExtiAddCb(DHT22_01_PortSource, DHT22_01_PinSource, ADCT_BGS_DHT22_01_CbkState);
 8001984:	4a12      	ldr	r2, [pc, #72]	; (80019d0 <ADCT_BGS_DHT22Init+0x68>)
 8001986:	2109      	movs	r1, #9
 8001988:	2001      	movs	r0, #1
 800198a:	f000 f953 	bl	8001c34 <vExtiAddCb>
#ifdef SUB_DHT22
	vExtiAddCb(DHT22_02_PortSource, DHT22_02_PinSource, ADCT_BGS_DHT22_02_CbkState);
 800198e:	4a11      	ldr	r2, [pc, #68]	; (80019d4 <ADCT_BGS_DHT22Init+0x6c>)
 8001990:	210c      	movs	r1, #12
 8001992:	2002      	movs	r0, #2
 8001994:	f000 f94e 	bl	8001c34 <vExtiAddCb>
#endif
	GPIO_InitStructure.GPIO_Pin = DHT22_01_PIN;
 8001998:	f44f 7300 	mov.w	r3, #512	; 0x200
 800199c:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80019a0:	2503      	movs	r5, #3
 80019a2:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80019a6:	2448      	movs	r4, #72	; 0x48
 80019a8:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(DHT22_01_PORT, &GPIO_InitStructure);
 80019ac:	a901      	add	r1, sp, #4
 80019ae:	480a      	ldr	r0, [pc, #40]	; (80019d8 <ADCT_BGS_DHT22Init+0x70>)
 80019b0:	f002 fbb8 	bl	8004124 <GPIO_Init>
#ifdef SUB_DHT22
	GPIO_InitStructure.GPIO_Pin = DHT22_02_PIN;
 80019b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80019b8:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80019bc:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80019c0:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
 80019c4:	a901      	add	r1, sp, #4
 80019c6:	4805      	ldr	r0, [pc, #20]	; (80019dc <ADCT_BGS_DHT22Init+0x74>)
 80019c8:	f002 fbac 	bl	8004124 <GPIO_Init>
#endif
}
 80019cc:	b003      	add	sp, #12
 80019ce:	bd30      	pop	{r4, r5, pc}
 80019d0:	080018f9 	.word	0x080018f9
 80019d4:	08001885 	.word	0x08001885
 80019d8:	40010c00 	.word	0x40010c00
 80019dc:	40011000 	.word	0x40011000

080019e0 <DHT22_Module_Init_Hardware>:
/******************************************************************************
 * Defines
 *****************************************************************************/

void DHT22_Module_Init_Hardware(void)
{
 80019e0:	b508      	push	{r3, lr}
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
 80019e2:	f44f 7040 	mov.w	r0, #768	; 0x300
 80019e6:	f002 f9c5 	bl	8003d74 <NVIC_PriorityGroupConfig>
	TM_DELAY_Init();
 80019ea:	f002 f92f 	bl	8003c4c <TM_DELAY_Init>
	vExtiInit();
 80019ee:	f000 f917 	bl	8001c20 <vExtiInit>
	ADCT_BGS_DHT22Init();
 80019f2:	f7ff ffb9 	bl	8001968 <ADCT_BGS_DHT22Init>
	vExtiStart();
 80019f6:	f000 f92b 	bl	8001c50 <vExtiStart>
 80019fa:	bd08      	pop	{r3, pc}

080019fc <ADCT_BGS_DHT22_CheckCRC>:

	timeUs=t;
}
#endif
uint8_t ADCT_BGS_DHT22_CheckCRC(ADCT_BGS_DHT22_devicetypes device)
{
 80019fc:	b410      	push	{r4}
	uint8_t crc;
	crc=g_DhtRaw[device][0]+g_DhtRaw[device][1]+g_DhtRaw[device][2]+g_DhtRaw[device][3];
 80019fe:	4b09      	ldr	r3, [pc, #36]	; (8001a24 <ADCT_BGS_DHT22_CheckCRC+0x28>)
 8001a00:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a04:	1819      	adds	r1, r3, r0
 8001a06:	5c1c      	ldrb	r4, [r3, r0]
 8001a08:	784a      	ldrb	r2, [r1, #1]
 8001a0a:	788b      	ldrb	r3, [r1, #2]
 8001a0c:	78c8      	ldrb	r0, [r1, #3]
 8001a0e:	4422      	add	r2, r4
 8001a10:	4413      	add	r3, r2
 8001a12:	4403      	add	r3, r0
 8001a14:	b2db      	uxtb	r3, r3
	return crc==g_DhtRaw[device][4];
 8001a16:	7908      	ldrb	r0, [r1, #4]
}
 8001a18:	4283      	cmp	r3, r0
 8001a1a:	bf14      	ite	ne
 8001a1c:	2000      	movne	r0, #0
 8001a1e:	2001      	moveq	r0, #1
 8001a20:	bc10      	pop	{r4}
 8001a22:	4770      	bx	lr
 8001a24:	200002c4 	.word	0x200002c4

08001a28 <ADCT_BGS_DHT22Start>:

void ADCT_BGS_DHT22Start(ADCT_BGS_DHT22_devicetypes device)
{
 8001a28:	b530      	push	{r4, r5, lr}
 8001a2a:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	switch (device)
 8001a2c:	b110      	cbz	r0, 8001a34 <ADCT_BGS_DHT22Start+0xc>
 8001a2e:	2801      	cmp	r0, #1
 8001a30:	d04f      	beq.n	8001ad2 <ADCT_BGS_DHT22Start+0xaa>
 8001a32:	e09d      	b.n	8001b70 <ADCT_BGS_DHT22Start+0x148>
	{

	case DHT22_Device_1:
	{

		GPIO_InitStructure.GPIO_Pin = DHT22_01_PIN;
 8001a34:	f44f 7500 	mov.w	r5, #512	; 0x200
 8001a38:	f8ad 5004 	strh.w	r5, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a3c:	2303      	movs	r3, #3
 8001a3e:	f88d 3006 	strb.w	r3, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8001a42:	2310      	movs	r3, #16
 8001a44:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(DHT22_01_PORT, &GPIO_InitStructure);
 8001a48:	4c4a      	ldr	r4, [pc, #296]	; (8001b74 <ADCT_BGS_DHT22Start+0x14c>)
 8001a4a:	a901      	add	r1, sp, #4
 8001a4c:	4620      	mov	r0, r4
 8001a4e:	f002 fb69 	bl	8004124 <GPIO_Init>

		DHT22_01_PIN_LOW();
 8001a52:	4629      	mov	r1, r5
 8001a54:	4620      	mov	r0, r4
 8001a56:	f002 fbc5 	bl	80041e4 <GPIO_ResetBits>
 8001a5a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 * @param  micros: Number of microseconds for delay
 * @retval None
 */
__STATIC_INLINE void Delay(__IO uint32_t micros) {
#if !defined(STM32F0xx)
	uint32_t start = DWT->CYCCNT;
 8001a5e:	4b46      	ldr	r3, [pc, #280]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001a60:	6859      	ldr	r1, [r3, #4]

	/* Go to number of cycles for system */
	micros *= (SystemCoreClock / 1000000);
 8001a62:	4b46      	ldr	r3, [pc, #280]	; (8001b7c <ADCT_BGS_DHT22Start+0x154>)
 8001a64:	681b      	ldr	r3, [r3, #0]
 8001a66:	4846      	ldr	r0, [pc, #280]	; (8001b80 <ADCT_BGS_DHT22Start+0x158>)
 8001a68:	fba0 0303 	umull	r0, r3, r0, r3
 8001a6c:	0c9b      	lsrs	r3, r3, #18
 8001a6e:	fb02 f203 	mul.w	r2, r2, r3

	/* Delay till end */
	while ((DWT->CYCCNT - start) < micros);
 8001a72:	4b41      	ldr	r3, [pc, #260]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001a74:	685b      	ldr	r3, [r3, #4]
 8001a76:	1a5b      	subs	r3, r3, r1
 8001a78:	4293      	cmp	r3, r2
 8001a7a:	d3fa      	bcc.n	8001a72 <ADCT_BGS_DHT22Start+0x4a>
		Delay(500);
		DHT22_01_PIN_HIGH();
 8001a7c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001a80:	483c      	ldr	r0, [pc, #240]	; (8001b74 <ADCT_BGS_DHT22Start+0x14c>)
 8001a82:	f002 fbad 	bl	80041e0 <GPIO_SetBits>
 8001a86:	2228      	movs	r2, #40	; 0x28
 * @param  micros: Number of microseconds for delay
 * @retval None
 */
__STATIC_INLINE void Delay(__IO uint32_t micros) {
#if !defined(STM32F0xx)
	uint32_t start = DWT->CYCCNT;
 8001a88:	4b3b      	ldr	r3, [pc, #236]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001a8a:	6859      	ldr	r1, [r3, #4]

	/* Go to number of cycles for system */
	micros *= (SystemCoreClock / 1000000);
 8001a8c:	4b3b      	ldr	r3, [pc, #236]	; (8001b7c <ADCT_BGS_DHT22Start+0x154>)
 8001a8e:	681b      	ldr	r3, [r3, #0]
 8001a90:	483b      	ldr	r0, [pc, #236]	; (8001b80 <ADCT_BGS_DHT22Start+0x158>)
 8001a92:	fba0 0303 	umull	r0, r3, r0, r3
 8001a96:	0c9b      	lsrs	r3, r3, #18
 8001a98:	fb02 f203 	mul.w	r2, r2, r3

	/* Delay till end */
	while ((DWT->CYCCNT - start) < micros);
 8001a9c:	4b36      	ldr	r3, [pc, #216]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001a9e:	685b      	ldr	r3, [r3, #4]
 8001aa0:	1a5b      	subs	r3, r3, r1
 8001aa2:	4293      	cmp	r3, r2
 8001aa4:	d3fa      	bcc.n	8001a9c <ADCT_BGS_DHT22Start+0x74>
		Delay(40);


		GPIO_InitStructure.GPIO_Pin = DHT22_01_PIN;
 8001aa6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001aaa:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001aae:	2303      	movs	r3, #3
 8001ab0:	f88d 3006 	strb.w	r3, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8001ab4:	2348      	movs	r3, #72	; 0x48
 8001ab6:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(DHT22_01_PORT, &GPIO_InitStructure);
 8001aba:	a901      	add	r1, sp, #4
 8001abc:	482d      	ldr	r0, [pc, #180]	; (8001b74 <ADCT_BGS_DHT22Start+0x14c>)
 8001abe:	f002 fb31 	bl	8004124 <GPIO_Init>

		g_DhtMeasuring[DHT22_Device_1] = 1;
 8001ac2:	2201      	movs	r2, #1
 8001ac4:	4b2f      	ldr	r3, [pc, #188]	; (8001b84 <ADCT_BGS_DHT22Start+0x15c>)
 8001ac6:	701a      	strb	r2, [r3, #0]
		memset(&g_DhtRaw[DHT22_Device_1], 0, 5);
 8001ac8:	4b2f      	ldr	r3, [pc, #188]	; (8001b88 <ADCT_BGS_DHT22Start+0x160>)
 8001aca:	2200      	movs	r2, #0
 8001acc:	601a      	str	r2, [r3, #0]
 8001ace:	711a      	strb	r2, [r3, #4]
		break;
 8001ad0:	e04e      	b.n	8001b70 <ADCT_BGS_DHT22Start+0x148>
	}
#ifdef SUB_DHT22
	case DHT22_Device_2:
	{
		GPIO_InitStructure.GPIO_Pin = DHT22_02_PIN;
 8001ad2:	f44f 5580 	mov.w	r5, #4096	; 0x1000
 8001ad6:	f8ad 5004 	strh.w	r5, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001ada:	2303      	movs	r3, #3
 8001adc:	f88d 3006 	strb.w	r3, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8001ae0:	2310      	movs	r3, #16
 8001ae2:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
 8001ae6:	4c29      	ldr	r4, [pc, #164]	; (8001b8c <ADCT_BGS_DHT22Start+0x164>)
 8001ae8:	a901      	add	r1, sp, #4
 8001aea:	4620      	mov	r0, r4
 8001aec:	f002 fb1a 	bl	8004124 <GPIO_Init>

		DHT22_02_PIN_LOW();
 8001af0:	4629      	mov	r1, r5
 8001af2:	4620      	mov	r0, r4
 8001af4:	f002 fb76 	bl	80041e4 <GPIO_ResetBits>
 8001af8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 * @param  micros: Number of microseconds for delay
 * @retval None
 */
__STATIC_INLINE void Delay(__IO uint32_t micros) {
#if !defined(STM32F0xx)
	uint32_t start = DWT->CYCCNT;
 8001afc:	4b1e      	ldr	r3, [pc, #120]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001afe:	6859      	ldr	r1, [r3, #4]

	/* Go to number of cycles for system */
	micros *= (SystemCoreClock / 1000000);
 8001b00:	4b1e      	ldr	r3, [pc, #120]	; (8001b7c <ADCT_BGS_DHT22Start+0x154>)
 8001b02:	681b      	ldr	r3, [r3, #0]
 8001b04:	481e      	ldr	r0, [pc, #120]	; (8001b80 <ADCT_BGS_DHT22Start+0x158>)
 8001b06:	fba0 0303 	umull	r0, r3, r0, r3
 8001b0a:	0c9b      	lsrs	r3, r3, #18
 8001b0c:	fb02 f203 	mul.w	r2, r2, r3

	/* Delay till end */
	while ((DWT->CYCCNT - start) < micros);
 8001b10:	4b19      	ldr	r3, [pc, #100]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001b12:	685b      	ldr	r3, [r3, #4]
 8001b14:	1a5b      	subs	r3, r3, r1
 8001b16:	4293      	cmp	r3, r2
 8001b18:	d3fa      	bcc.n	8001b10 <ADCT_BGS_DHT22Start+0xe8>
		Delay(500);
		DHT22_02_PIN_HIGH();
 8001b1a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001b1e:	481b      	ldr	r0, [pc, #108]	; (8001b8c <ADCT_BGS_DHT22Start+0x164>)
 8001b20:	f002 fb5e 	bl	80041e0 <GPIO_SetBits>
 8001b24:	2228      	movs	r2, #40	; 0x28
 * @param  micros: Number of microseconds for delay
 * @retval None
 */
__STATIC_INLINE void Delay(__IO uint32_t micros) {
#if !defined(STM32F0xx)
	uint32_t start = DWT->CYCCNT;
 8001b26:	4b14      	ldr	r3, [pc, #80]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001b28:	6859      	ldr	r1, [r3, #4]

	/* Go to number of cycles for system */
	micros *= (SystemCoreClock / 1000000);
 8001b2a:	4b14      	ldr	r3, [pc, #80]	; (8001b7c <ADCT_BGS_DHT22Start+0x154>)
 8001b2c:	681b      	ldr	r3, [r3, #0]
 8001b2e:	4814      	ldr	r0, [pc, #80]	; (8001b80 <ADCT_BGS_DHT22Start+0x158>)
 8001b30:	fba0 0303 	umull	r0, r3, r0, r3
 8001b34:	0c9b      	lsrs	r3, r3, #18
 8001b36:	fb02 f203 	mul.w	r2, r2, r3

	/* Delay till end */
	while ((DWT->CYCCNT - start) < micros);
 8001b3a:	4b0f      	ldr	r3, [pc, #60]	; (8001b78 <ADCT_BGS_DHT22Start+0x150>)
 8001b3c:	685b      	ldr	r3, [r3, #4]
 8001b3e:	1a5b      	subs	r3, r3, r1
 8001b40:	4293      	cmp	r3, r2
 8001b42:	d3fa      	bcc.n	8001b3a <ADCT_BGS_DHT22Start+0x112>
		Delay(40);


		GPIO_InitStructure.GPIO_Pin = DHT22_02_PIN;
 8001b44:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001b48:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001b4c:	2303      	movs	r3, #3
 8001b4e:	f88d 3006 	strb.w	r3, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8001b52:	2348      	movs	r3, #72	; 0x48
 8001b54:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(DHT22_02_PORT, &GPIO_InitStructure);
 8001b58:	a901      	add	r1, sp, #4
 8001b5a:	480c      	ldr	r0, [pc, #48]	; (8001b8c <ADCT_BGS_DHT22Start+0x164>)
 8001b5c:	f002 fae2 	bl	8004124 <GPIO_Init>

		g_DhtMeasuring[DHT22_Device_2] = 1;
 8001b60:	2201      	movs	r2, #1
 8001b62:	4b08      	ldr	r3, [pc, #32]	; (8001b84 <ADCT_BGS_DHT22Start+0x15c>)
 8001b64:	705a      	strb	r2, [r3, #1]
		memset(&g_DhtRaw[DHT22_Device_2], 0, 5);
 8001b66:	4a08      	ldr	r2, [pc, #32]	; (8001b88 <ADCT_BGS_DHT22Start+0x160>)
 8001b68:	2300      	movs	r3, #0
 8001b6a:	f8c2 3005 	str.w	r3, [r2, #5]
 8001b6e:	7253      	strb	r3, [r2, #9]
	}
#endif
	default : break;
	}
}
 8001b70:	b003      	add	sp, #12
 8001b72:	bd30      	pop	{r4, r5, pc}
 8001b74:	40010c00 	.word	0x40010c00
 8001b78:	e0001000 	.word	0xe0001000
 8001b7c:	20000190 	.word	0x20000190
 8001b80:	431bde83 	.word	0x431bde83
 8001b84:	200002c0 	.word	0x200002c0
 8001b88:	200002c4 	.word	0x200002c4
 8001b8c:	40011000 	.word	0x40011000

08001b90 <ADCT_BGS_DHT22Measuring>:


uint8_t ADCT_BGS_DHT22Measuring(ADCT_BGS_DHT22_devicetypes device)
{
	return 	g_DhtMeasuring[device];
}
 8001b90:	4b01      	ldr	r3, [pc, #4]	; (8001b98 <ADCT_BGS_DHT22Measuring+0x8>)
 8001b92:	5c18      	ldrb	r0, [r3, r0]
 8001b94:	4770      	bx	lr
 8001b96:	bf00      	nop
 8001b98:	200002c0 	.word	0x200002c0

08001b9c <ADCT_BGS_DHT22GetTemp>:

uint32_t ADCT_BGS_DHT22GetTemp(ADCT_BGS_DHT22_devicetypes device)
{
	uint32_t res=0;
	res=g_DhtRaw[device][2];
 8001b9c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001ba0:	4b03      	ldr	r3, [pc, #12]	; (8001bb0 <ADCT_BGS_DHT22GetTemp+0x14>)
 8001ba2:	4403      	add	r3, r0
 8001ba4:	7898      	ldrb	r0, [r3, #2]
	res<<=8;
	res|=g_DhtRaw[device][3];
 8001ba6:	78db      	ldrb	r3, [r3, #3]
	return res;
}
 8001ba8:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8001bac:	4770      	bx	lr
 8001bae:	bf00      	nop
 8001bb0:	200002c4 	.word	0x200002c4

08001bb4 <ADCT_BGS_DHT22GetHumidity>:

uint32_t ADCT_BGS_DHT22GetHumidity(ADCT_BGS_DHT22_devicetypes device)
{
	uint32_t res=0;
	res=g_DhtRaw[device][0];
 8001bb4:	4b04      	ldr	r3, [pc, #16]	; (8001bc8 <ADCT_BGS_DHT22GetHumidity+0x14>)
 8001bb6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001bba:	181a      	adds	r2, r3, r0
 8001bbc:	5c18      	ldrb	r0, [r3, r0]
	res<<=8;
	res|=g_DhtRaw[device][1];
 8001bbe:	7853      	ldrb	r3, [r2, #1]
	return res;
}
 8001bc0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8001bc4:	4770      	bx	lr
 8001bc6:	bf00      	nop
 8001bc8:	200002c4 	.word	0x200002c4

08001bcc <ADCT_DHT22_FPT_GetValue>:
	vExtiInit();
	ADCT_BGS_DHT22Init();
	vExtiStart();
}
void ADCT_DHT22_FPT_GetValue(DHT22_MODULE_DATA *pDHT22Data)
{
 8001bcc:	b538      	push	{r3, r4, r5, lr}
 8001bce:	4604      	mov	r4, r0
	if(ADCT_BGS_DHT22Measuring(DHT22_Device_1) == ADCT_FALSE)
 8001bd0:	2000      	movs	r0, #0
 8001bd2:	f7ff ffdd 	bl	8001b90 <ADCT_BGS_DHT22Measuring>
 8001bd6:	b970      	cbnz	r0, 8001bf6 <ADCT_DHT22_FPT_GetValue+0x2a>
	{
		if (ADCT_BGS_DHT22_CheckCRC(DHT22_Device_1))
 8001bd8:	f7ff ff10 	bl	80019fc <ADCT_BGS_DHT22_CheckCRC>
 8001bdc:	b158      	cbz	r0, 8001bf6 <ADCT_DHT22_FPT_GetValue+0x2a>
			uint32_t temp_value = 0;
			uint32_t humid_value = 0;
//			pDHT22Data->usTemp_Main = ADCT_BGS_DHT22GetTemp(DHT22_Device_1);
//			pDHT22Data->usHumid_Main = ADCT_BGS_DHT22GetHumidity(DHT22_Device_1) ;

			temp_value = ADCT_BGS_DHT22GetTemp(DHT22_Device_1);
 8001bde:	2000      	movs	r0, #0
 8001be0:	f7ff ffdc 	bl	8001b9c <ADCT_BGS_DHT22GetTemp>
 8001be4:	4605      	mov	r5, r0
			humid_value = ADCT_BGS_DHT22GetHumidity(DHT22_Device_1) ;
 8001be6:	2000      	movs	r0, #0
 8001be8:	f7ff ffe4 	bl	8001bb4 <ADCT_BGS_DHT22GetHumidity>
			if(temp_value < 5)
 8001bec:	2d04      	cmp	r5, #4
 8001bee:	d900      	bls.n	8001bf2 <ADCT_DHT22_FPT_GetValue+0x26>
			{

			}
			else
			{
				pDHT22Data->usTemp_Main = temp_value;
 8001bf0:	8025      	strh	r5, [r4, #0]
			}

			if (!humid_value)
 8001bf2:	b100      	cbz	r0, 8001bf6 <ADCT_DHT22_FPT_GetValue+0x2a>
			{

			}
			else
			{
				pDHT22Data->usHumid_Main = humid_value ;
 8001bf4:	8060      	strh	r0, [r4, #2]
			}
		}
	}
#ifdef SUB_DHT22
	if(ADCT_BGS_DHT22Measuring(DHT22_Device_2) == ADCT_FALSE)
 8001bf6:	2001      	movs	r0, #1
 8001bf8:	f7ff ffca 	bl	8001b90 <ADCT_BGS_DHT22Measuring>
 8001bfc:	b978      	cbnz	r0, 8001c1e <ADCT_DHT22_FPT_GetValue+0x52>
	{

		if (ADCT_BGS_DHT22_CheckCRC(DHT22_Device_2))
 8001bfe:	2001      	movs	r0, #1
 8001c00:	f7ff fefc 	bl	80019fc <ADCT_BGS_DHT22_CheckCRC>
 8001c04:	b158      	cbz	r0, 8001c1e <ADCT_DHT22_FPT_GetValue+0x52>
			uint32_t temp_value = 0;
			uint32_t humid_value = 0;
//			pDHT22Data->usTemp_Sub = ADCT_BGS_DHT22GetTemp(DHT22_Device_2) ;
//			pDHT22Data->usHumid_Sub = ADCT_BGS_DHT22GetHumidity(DHT22_Device_2) ;

			temp_value = ADCT_BGS_DHT22GetTemp(DHT22_Device_2) ;
 8001c06:	2001      	movs	r0, #1
 8001c08:	f7ff ffc8 	bl	8001b9c <ADCT_BGS_DHT22GetTemp>
 8001c0c:	4605      	mov	r5, r0
			humid_value = ADCT_BGS_DHT22GetHumidity(DHT22_Device_2) ;
 8001c0e:	2001      	movs	r0, #1
 8001c10:	f7ff ffd0 	bl	8001bb4 <ADCT_BGS_DHT22GetHumidity>
			if(temp_value < 5)
 8001c14:	2d04      	cmp	r5, #4
 8001c16:	d900      	bls.n	8001c1a <ADCT_DHT22_FPT_GetValue+0x4e>
			{

			}
			else
			{
				pDHT22Data->usTemp_Sub = temp_value ;
 8001c18:	80a5      	strh	r5, [r4, #4]
			}

			if(! humid_value)
 8001c1a:	b100      	cbz	r0, 8001c1e <ADCT_DHT22_FPT_GetValue+0x52>
			{

			}
			else
			{
				pDHT22Data->usHumid_Sub = humid_value;
 8001c1c:	80e0      	strh	r0, [r4, #6]
 8001c1e:	bd38      	pop	{r3, r4, r5, pc}

08001c20 <vExtiInit>:
/******************************************************************************
 * Function definitions
 *****************************************************************************/

void vExtiInit(void)
{
 8001c20:	b508      	push	{r3, lr}
	memset(&g_ExtiConfig, 0, sizeof(ExtiConfig_t)*MAX_NUMS_OF_EXTI);
 8001c22:	22c0      	movs	r2, #192	; 0xc0
 8001c24:	2100      	movs	r1, #0
 8001c26:	4802      	ldr	r0, [pc, #8]	; (8001c30 <vExtiInit+0x10>)
 8001c28:	f003 f98f 	bl	8004f4a <memset>
 8001c2c:	bd08      	pop	{r3, pc}
 8001c2e:	bf00      	nop
 8001c30:	200002d4 	.word	0x200002d4

08001c34 <vExtiAddCb>:
}

void vExtiAddCb(uint8_t port, uint8_t line, vExtiCbState_t pCb)
{
 8001c34:	b470      	push	{r4, r5, r6}
	g_ExtiConfig[line].port=port;
 8001c36:	4c05      	ldr	r4, [pc, #20]	; (8001c4c <vExtiAddCb+0x18>)
 8001c38:	004d      	lsls	r5, r1, #1
 8001c3a:	186e      	adds	r6, r5, r1
 8001c3c:	00b3      	lsls	r3, r6, #2
 8001c3e:	18e6      	adds	r6, r4, r3
 8001c40:	54e0      	strb	r0, [r4, r3]
	g_ExtiConfig[line].cb=pCb;
 8001c42:	6072      	str	r2, [r6, #4]
	g_ExtiConfig[line].state=ENABLE;
 8001c44:	2201      	movs	r2, #1
 8001c46:	7232      	strb	r2, [r6, #8]
}
 8001c48:	bc70      	pop	{r4, r5, r6}
 8001c4a:	4770      	bx	lr
 8001c4c:	200002d4 	.word	0x200002d4

08001c50 <vExtiStart>:
{
	g_ExtiConfig[line].state=state;
}

void vExtiStart(void)
{
 8001c50:	b570      	push	{r4, r5, r6, lr}
 8001c52:	b084      	sub	sp, #16
	NVIC_InitTypeDef NVIC_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	uint32_t uExtiLines=0;
	uint8_t exti=0;

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;
 8001c54:	230a      	movs	r3, #10
 8001c56:	f88d 300d 	strb.w	r3, [sp, #13]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 10;
 8001c5a:	f88d 300e 	strb.w	r3, [sp, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001c5e:	2301      	movs	r3, #1
 8001c60:	f88d 300f 	strb.w	r3, [sp, #15]

    for (exti=0;exti<MAX_NUMS_OF_EXTI;exti++)
 8001c64:	2400      	movs	r4, #0

void vExtiStart(void)
{
	NVIC_InitTypeDef NVIC_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	uint32_t uExtiLines=0;
 8001c66:	4626      	mov	r6, r4

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 10;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

    for (exti=0;exti<MAX_NUMS_OF_EXTI;exti++)
 8001c68:	e047      	b.n	8001cfa <vExtiStart+0xaa>
	{
		if ((g_ExtiConfig[exti].state==ENABLE) && (g_ExtiConfig[exti].cb!=0))
 8001c6a:	4625      	mov	r5, r4
 8001c6c:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8001c70:	0093      	lsls	r3, r2, #2
 8001c72:	4a2b      	ldr	r2, [pc, #172]	; (8001d20 <vExtiStart+0xd0>)
 8001c74:	4413      	add	r3, r2
 8001c76:	7a1b      	ldrb	r3, [r3, #8]
 8001c78:	2b01      	cmp	r3, #1
 8001c7a:	d13c      	bne.n	8001cf6 <vExtiStart+0xa6>
 8001c7c:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8001c80:	0093      	lsls	r3, r2, #2
 8001c82:	4a27      	ldr	r2, [pc, #156]	; (8001d20 <vExtiStart+0xd0>)
 8001c84:	4413      	add	r3, r2
 8001c86:	685b      	ldr	r3, [r3, #4]
 8001c88:	b3ab      	cbz	r3, 8001cf6 <vExtiStart+0xa6>
		{
			uExtiLines|=(1<<exti);	// set line for exti
 8001c8a:	2301      	movs	r3, #1
 8001c8c:	40a3      	lsls	r3, r4
 8001c8e:	431e      	orrs	r6, r3

			if (exti>9)
 8001c90:	2c09      	cmp	r4, #9
 8001c92:	d903      	bls.n	8001c9c <vExtiStart+0x4c>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 8001c94:	2328      	movs	r3, #40	; 0x28
 8001c96:	f88d 300c 	strb.w	r3, [sp, #12]
 8001c9a:	e021      	b.n	8001ce0 <vExtiStart+0x90>
			else if (exti>4)
 8001c9c:	2c04      	cmp	r4, #4
 8001c9e:	d903      	bls.n	8001ca8 <vExtiStart+0x58>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
 8001ca0:	2317      	movs	r3, #23
 8001ca2:	f88d 300c 	strb.w	r3, [sp, #12]
 8001ca6:	e01b      	b.n	8001ce0 <vExtiStart+0x90>
			else if (exti==4)
 8001ca8:	2c04      	cmp	r4, #4
 8001caa:	d103      	bne.n	8001cb4 <vExtiStart+0x64>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
 8001cac:	230a      	movs	r3, #10
 8001cae:	f88d 300c 	strb.w	r3, [sp, #12]
 8001cb2:	e015      	b.n	8001ce0 <vExtiStart+0x90>
			else if (exti==3)
 8001cb4:	2c03      	cmp	r4, #3
 8001cb6:	d103      	bne.n	8001cc0 <vExtiStart+0x70>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;
 8001cb8:	2309      	movs	r3, #9
 8001cba:	f88d 300c 	strb.w	r3, [sp, #12]
 8001cbe:	e00f      	b.n	8001ce0 <vExtiStart+0x90>
			else if (exti==2)
 8001cc0:	2c02      	cmp	r4, #2
 8001cc2:	d103      	bne.n	8001ccc <vExtiStart+0x7c>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
 8001cc4:	2308      	movs	r3, #8
 8001cc6:	f88d 300c 	strb.w	r3, [sp, #12]
 8001cca:	e009      	b.n	8001ce0 <vExtiStart+0x90>
			else if (exti==1)
 8001ccc:	2c01      	cmp	r4, #1
 8001cce:	d103      	bne.n	8001cd8 <vExtiStart+0x88>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
 8001cd0:	2307      	movs	r3, #7
 8001cd2:	f88d 300c 	strb.w	r3, [sp, #12]
 8001cd6:	e003      	b.n	8001ce0 <vExtiStart+0x90>
			else if (exti==0)
 8001cd8:	b914      	cbnz	r4, 8001ce0 <vExtiStart+0x90>
				NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
 8001cda:	2306      	movs	r3, #6
 8001cdc:	f88d 300c 	strb.w	r3, [sp, #12]
		    // Enable the EXTIxxxx Interrupt
		    NVIC_Init(&NVIC_InitStructure);
 8001ce0:	a803      	add	r0, sp, #12
 8001ce2:	f002 f851 	bl	8003d88 <NVIC_Init>

		    // Connect EXTI LineXX to port
		    GPIO_EXTILineConfig(g_ExtiConfig[exti].port, exti);
 8001ce6:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8001cea:	00ab      	lsls	r3, r5, #2
 8001cec:	4621      	mov	r1, r4
 8001cee:	4a0c      	ldr	r2, [pc, #48]	; (8001d20 <vExtiStart+0xd0>)
 8001cf0:	5cd0      	ldrb	r0, [r2, r3]
 8001cf2:	f002 fab9 	bl	8004268 <GPIO_EXTILineConfig>

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 10;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

    for (exti=0;exti<MAX_NUMS_OF_EXTI;exti++)
 8001cf6:	3401      	adds	r4, #1
 8001cf8:	b2e4      	uxtb	r4, r4
 8001cfa:	2c0f      	cmp	r4, #15
 8001cfc:	d9b5      	bls.n	8001c6a <vExtiStart+0x1a>
		    GPIO_EXTILineConfig(g_ExtiConfig[exti].port, exti);
		}
	}


    if (uExtiLines)	// if any of exti set
 8001cfe:	b166      	cbz	r6, 8001d1a <vExtiStart+0xca>
    {
		// Configure EXTI Lines to generate an interrupt on rising or falling edge
		EXTI_InitStructure.EXTI_Line = uExtiLines;
 8001d00:	9601      	str	r6, [sp, #4]
		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8001d02:	2300      	movs	r3, #0
 8001d04:	f88d 3008 	strb.w	r3, [sp, #8]
		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8001d08:	2310      	movs	r3, #16
 8001d0a:	f88d 3009 	strb.w	r3, [sp, #9]
		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8001d0e:	2301      	movs	r3, #1
 8001d10:	f88d 300a 	strb.w	r3, [sp, #10]
		EXTI_Init(&EXTI_InitStructure);
 8001d14:	a801      	add	r0, sp, #4
 8001d16:	f002 f985 	bl	8004024 <EXTI_Init>
    }
}
 8001d1a:	b004      	add	sp, #16
 8001d1c:	bd70      	pop	{r4, r5, r6, pc}
 8001d1e:	bf00      	nop
 8001d20:	200002d4 	.word	0x200002d4

08001d24 <vExtiHandleInt>:
// Handle interrupt
void vExtiHandleInt(uint8_t line)
{
	GPIO_TypeDef *pGPIO=0;

	if (g_ExtiConfig[line].state==ENABLE) // if interrupt handler enabled
 8001d24:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8001d28:	0093      	lsls	r3, r2, #2
 8001d2a:	4a1d      	ldr	r2, [pc, #116]	; (8001da0 <vExtiHandleInt+0x7c>)
 8001d2c:	4413      	add	r3, r2
 8001d2e:	7a1b      	ldrb	r3, [r3, #8]
 8001d30:	2b01      	cmp	r3, #1
 8001d32:	d134      	bne.n	8001d9e <vExtiHandleInt+0x7a>
	{
		if (g_ExtiConfig[line].cb!=0)		// and handler is set
 8001d34:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8001d38:	0093      	lsls	r3, r2, #2
 8001d3a:	4a19      	ldr	r2, [pc, #100]	; (8001da0 <vExtiHandleInt+0x7c>)
 8001d3c:	4413      	add	r3, r2
 8001d3e:	685b      	ldr	r3, [r3, #4]
 8001d40:	b36b      	cbz	r3, 8001d9e <vExtiHandleInt+0x7a>
		{
			switch(g_ExtiConfig[line].port)
 8001d42:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8001d46:	0093      	lsls	r3, r2, #2
 8001d48:	4a15      	ldr	r2, [pc, #84]	; (8001da0 <vExtiHandleInt+0x7c>)
 8001d4a:	5cd3      	ldrb	r3, [r2, r3]
 8001d4c:	2b01      	cmp	r3, #1
 8001d4e:	d004      	beq.n	8001d5a <vExtiHandleInt+0x36>
 8001d50:	b13b      	cbz	r3, 8001d62 <vExtiHandleInt+0x3e>
 8001d52:	2b02      	cmp	r3, #2
 8001d54:	d003      	beq.n	8001d5e <vExtiHandleInt+0x3a>
}

// Handle interrupt
void vExtiHandleInt(uint8_t line)
{
	GPIO_TypeDef *pGPIO=0;
 8001d56:	2300      	movs	r3, #0
 8001d58:	e004      	b.n	8001d64 <vExtiHandleInt+0x40>
			{
			case GPIO_PortSourceGPIOA:
				pGPIO = GPIOA;
				break;
			case GPIO_PortSourceGPIOB:
				pGPIO = GPIOB;
 8001d5a:	4b12      	ldr	r3, [pc, #72]	; (8001da4 <vExtiHandleInt+0x80>)
				break;
 8001d5c:	e002      	b.n	8001d64 <vExtiHandleInt+0x40>
			case GPIO_PortSourceGPIOC:
				pGPIO = GPIOC;
 8001d5e:	4b12      	ldr	r3, [pc, #72]	; (8001da8 <vExtiHandleInt+0x84>)
				break;
 8001d60:	e000      	b.n	8001d64 <vExtiHandleInt+0x40>
		if (g_ExtiConfig[line].cb!=0)		// and handler is set
		{
			switch(g_ExtiConfig[line].port)
			{
			case GPIO_PortSourceGPIOA:
				pGPIO = GPIOA;
 8001d62:	4b12      	ldr	r3, [pc, #72]	; (8001dac <vExtiHandleInt+0x88>)
				break;
			default:
				break;
			}

			if (pGPIO)
 8001d64:	b1db      	cbz	r3, 8001d9e <vExtiHandleInt+0x7a>
	// tbd
}

// Handle interrupt
void vExtiHandleInt(uint8_t line)
{
 8001d66:	b510      	push	{r4, lr}
 8001d68:	4604      	mov	r4, r0
				break;
			}

			if (pGPIO)
			{
				if (GPIO_ReadInputDataBit(pGPIO, (1 << line)) == 1)
 8001d6a:	2101      	movs	r1, #1
 8001d6c:	4081      	lsls	r1, r0
 8001d6e:	b289      	uxth	r1, r1
 8001d70:	4618      	mov	r0, r3
 8001d72:	f002 fa25 	bl	80041c0 <GPIO_ReadInputDataBit>
 8001d76:	2801      	cmp	r0, #1
 8001d78:	d108      	bne.n	8001d8c <vExtiHandleInt+0x68>
					g_ExtiConfig[line].cb(LineState_High);
 8001d7a:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 8001d7e:	0083      	lsls	r3, r0, #2
 8001d80:	4a07      	ldr	r2, [pc, #28]	; (8001da0 <vExtiHandleInt+0x7c>)
 8001d82:	4413      	add	r3, r2
 8001d84:	685b      	ldr	r3, [r3, #4]
 8001d86:	2001      	movs	r0, #1
 8001d88:	4798      	blx	r3
 8001d8a:	bd10      	pop	{r4, pc}
				else
					g_ExtiConfig[line].cb(LineState_Low);
 8001d8c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 8001d90:	0083      	lsls	r3, r0, #2
 8001d92:	4a03      	ldr	r2, [pc, #12]	; (8001da0 <vExtiHandleInt+0x7c>)
 8001d94:	4413      	add	r3, r2
 8001d96:	685b      	ldr	r3, [r3, #4]
 8001d98:	2000      	movs	r0, #0
 8001d9a:	4798      	blx	r3
 8001d9c:	bd10      	pop	{r4, pc}
 8001d9e:	4770      	bx	lr
 8001da0:	200002d4 	.word	0x200002d4
 8001da4:	40010c00 	.word	0x40010c00
 8001da8:	40011000 	.word	0x40011000
 8001dac:	40010800 	.word	0x40010800

08001db0 <EXTI0_IRQHandler>:
//
//This function handles External line 0 interrupt request.
//
//**************************************************************************
void EXTI0_IRQHandler(void)
{
 8001db0:	b508      	push	{r3, lr}
    if (EXTI_GetITStatus(EXTI_Line0) != RESET)
 8001db2:	2001      	movs	r0, #1
 8001db4:	f002 f97e 	bl	80040b4 <EXTI_GetITStatus>
 8001db8:	b110      	cbz	r0, 8001dc0 <EXTI0_IRQHandler+0x10>
    {
        EXTI_ClearITPendingBit(EXTI_Line0);
 8001dba:	2001      	movs	r0, #1
 8001dbc:	f002 f98a 	bl	80040d4 <EXTI_ClearITPendingBit>
    }
    vExtiHandleInt(0);
 8001dc0:	2000      	movs	r0, #0
 8001dc2:	f7ff ffaf 	bl	8001d24 <vExtiHandleInt>
 8001dc6:	bd08      	pop	{r3, pc}

08001dc8 <EXTI1_IRQHandler>:
}
void EXTI1_IRQHandler(void)
{
 8001dc8:	b508      	push	{r3, lr}
    if (EXTI_GetITStatus(EXTI_Line1) != RESET)
 8001dca:	2002      	movs	r0, #2
 8001dcc:	f002 f972 	bl	80040b4 <EXTI_GetITStatus>
 8001dd0:	b110      	cbz	r0, 8001dd8 <EXTI1_IRQHandler+0x10>
    {
        EXTI_ClearITPendingBit(EXTI_Line1);
 8001dd2:	2002      	movs	r0, #2
 8001dd4:	f002 f97e 	bl	80040d4 <EXTI_ClearITPendingBit>
    }
    vExtiHandleInt(1);
 8001dd8:	2001      	movs	r0, #1
 8001dda:	f7ff ffa3 	bl	8001d24 <vExtiHandleInt>
 8001dde:	bd08      	pop	{r3, pc}

08001de0 <EXTI2_IRQHandler>:
}
void EXTI2_IRQHandler(void)
{
 8001de0:	b508      	push	{r3, lr}
    if (EXTI_GetITStatus(EXTI_Line2) != RESET)
 8001de2:	2004      	movs	r0, #4
 8001de4:	f002 f966 	bl	80040b4 <EXTI_GetITStatus>
 8001de8:	b110      	cbz	r0, 8001df0 <EXTI2_IRQHandler+0x10>
    {
        EXTI_ClearITPendingBit(EXTI_Line2);
 8001dea:	2004      	movs	r0, #4
 8001dec:	f002 f972 	bl	80040d4 <EXTI_ClearITPendingBit>
    }
    vExtiHandleInt(2);
 8001df0:	2002      	movs	r0, #2
 8001df2:	f7ff ff97 	bl	8001d24 <vExtiHandleInt>
 8001df6:	bd08      	pop	{r3, pc}

08001df8 <EXTI15_10_IRQHandler>:
//
//This function handles External lines 10 to 15 interrupt request.
//
//**************************************************************************
void EXTI15_10_IRQHandler(void)
{
 8001df8:	b508      	push	{r3, lr}
	uint8_t line=0;

    if (EXTI_GetITStatus(EXTI_Line10) != RESET)
 8001dfa:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001dfe:	f002 f959 	bl	80040b4 <EXTI_GetITStatus>
 8001e02:	b128      	cbz	r0, 8001e10 <EXTI15_10_IRQHandler+0x18>
    {
    	line=10;
        EXTI_ClearITPendingBit(EXTI_Line10);
 8001e04:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001e08:	f002 f964 	bl	80040d4 <EXTI_ClearITPendingBit>
{
	uint8_t line=0;

    if (EXTI_GetITStatus(EXTI_Line10) != RESET)
    {
    	line=10;
 8001e0c:	200a      	movs	r0, #10
 8001e0e:	e037      	b.n	8001e80 <EXTI15_10_IRQHandler+0x88>
        EXTI_ClearITPendingBit(EXTI_Line10);
    }
    else if (EXTI_GetITStatus(EXTI_Line11) != RESET)
 8001e10:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001e14:	f002 f94e 	bl	80040b4 <EXTI_GetITStatus>
 8001e18:	b128      	cbz	r0, 8001e26 <EXTI15_10_IRQHandler+0x2e>
    {
    	line=11;
        EXTI_ClearITPendingBit(EXTI_Line11);
 8001e1a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001e1e:	f002 f959 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=10;
        EXTI_ClearITPendingBit(EXTI_Line10);
    }
    else if (EXTI_GetITStatus(EXTI_Line11) != RESET)
    {
    	line=11;
 8001e22:	200b      	movs	r0, #11
 8001e24:	e02c      	b.n	8001e80 <EXTI15_10_IRQHandler+0x88>
        EXTI_ClearITPendingBit(EXTI_Line11);
    }
    else if (EXTI_GetITStatus(EXTI_Line12) != RESET)
 8001e26:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001e2a:	f002 f943 	bl	80040b4 <EXTI_GetITStatus>
 8001e2e:	b128      	cbz	r0, 8001e3c <EXTI15_10_IRQHandler+0x44>
    {
    	line=12;
        EXTI_ClearITPendingBit(EXTI_Line12);
 8001e30:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001e34:	f002 f94e 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=11;
        EXTI_ClearITPendingBit(EXTI_Line11);
    }
    else if (EXTI_GetITStatus(EXTI_Line12) != RESET)
    {
    	line=12;
 8001e38:	200c      	movs	r0, #12
 8001e3a:	e021      	b.n	8001e80 <EXTI15_10_IRQHandler+0x88>
        EXTI_ClearITPendingBit(EXTI_Line12);
    }
    else if (EXTI_GetITStatus(EXTI_Line13) != RESET)
 8001e3c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001e40:	f002 f938 	bl	80040b4 <EXTI_GetITStatus>
 8001e44:	b128      	cbz	r0, 8001e52 <EXTI15_10_IRQHandler+0x5a>
    {
    	line=13;
        EXTI_ClearITPendingBit(EXTI_Line13);
 8001e46:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001e4a:	f002 f943 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=12;
        EXTI_ClearITPendingBit(EXTI_Line12);
    }
    else if (EXTI_GetITStatus(EXTI_Line13) != RESET)
    {
    	line=13;
 8001e4e:	200d      	movs	r0, #13
 8001e50:	e016      	b.n	8001e80 <EXTI15_10_IRQHandler+0x88>
        EXTI_ClearITPendingBit(EXTI_Line13);
    }
    else if (EXTI_GetITStatus(EXTI_Line14) != RESET)
 8001e52:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001e56:	f002 f92d 	bl	80040b4 <EXTI_GetITStatus>
 8001e5a:	b128      	cbz	r0, 8001e68 <EXTI15_10_IRQHandler+0x70>
    {
    	line=14;
        EXTI_ClearITPendingBit(EXTI_Line14);
 8001e5c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001e60:	f002 f938 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=13;
        EXTI_ClearITPendingBit(EXTI_Line13);
    }
    else if (EXTI_GetITStatus(EXTI_Line14) != RESET)
    {
    	line=14;
 8001e64:	200e      	movs	r0, #14
 8001e66:	e00b      	b.n	8001e80 <EXTI15_10_IRQHandler+0x88>
        EXTI_ClearITPendingBit(EXTI_Line14);
    }
    else if (EXTI_GetITStatus(EXTI_Line15) != RESET)
 8001e68:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001e6c:	f002 f922 	bl	80040b4 <EXTI_GetITStatus>
 8001e70:	b128      	cbz	r0, 8001e7e <EXTI15_10_IRQHandler+0x86>
    {
    	line=15;
        EXTI_ClearITPendingBit(EXTI_Line15);
 8001e72:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8001e76:	f002 f92d 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=14;
        EXTI_ClearITPendingBit(EXTI_Line14);
    }
    else if (EXTI_GetITStatus(EXTI_Line15) != RESET)
    {
    	line=15;
 8001e7a:	200f      	movs	r0, #15
 8001e7c:	e000      	b.n	8001e80 <EXTI15_10_IRQHandler+0x88>
//This function handles External lines 10 to 15 interrupt request.
//
//**************************************************************************
void EXTI15_10_IRQHandler(void)
{
	uint8_t line=0;
 8001e7e:	2000      	movs	r0, #0
    {
    	line=15;
        EXTI_ClearITPendingBit(EXTI_Line15);
    }

    vExtiHandleInt(line);
 8001e80:	f7ff ff50 	bl	8001d24 <vExtiHandleInt>
 8001e84:	bd08      	pop	{r3, pc}
 8001e86:	bf00      	nop

08001e88 <EXTI9_5_IRQHandler>:
//
//This function handles External lines 9 to 5 interrupt request.
//
//**************************************************************************
void EXTI9_5_IRQHandler(void)
{
 8001e88:	b508      	push	{r3, lr}
	uint8_t line=0;

    if (EXTI_GetITStatus(EXTI_Line5) != RESET)
 8001e8a:	2020      	movs	r0, #32
 8001e8c:	f002 f912 	bl	80040b4 <EXTI_GetITStatus>
 8001e90:	b120      	cbz	r0, 8001e9c <EXTI9_5_IRQHandler+0x14>
    {
    	line=5;
        EXTI_ClearITPendingBit(EXTI_Line5);
 8001e92:	2020      	movs	r0, #32
 8001e94:	f002 f91e 	bl	80040d4 <EXTI_ClearITPendingBit>
{
	uint8_t line=0;

    if (EXTI_GetITStatus(EXTI_Line5) != RESET)
    {
    	line=5;
 8001e98:	2005      	movs	r0, #5
 8001e9a:	e028      	b.n	8001eee <EXTI9_5_IRQHandler+0x66>
        EXTI_ClearITPendingBit(EXTI_Line5);
    }
    else if (EXTI_GetITStatus(EXTI_Line6) != RESET)
 8001e9c:	2040      	movs	r0, #64	; 0x40
 8001e9e:	f002 f909 	bl	80040b4 <EXTI_GetITStatus>
 8001ea2:	b120      	cbz	r0, 8001eae <EXTI9_5_IRQHandler+0x26>
    {
    	line=6;
        EXTI_ClearITPendingBit(EXTI_Line6);
 8001ea4:	2040      	movs	r0, #64	; 0x40
 8001ea6:	f002 f915 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=5;
        EXTI_ClearITPendingBit(EXTI_Line5);
    }
    else if (EXTI_GetITStatus(EXTI_Line6) != RESET)
    {
    	line=6;
 8001eaa:	2006      	movs	r0, #6
 8001eac:	e01f      	b.n	8001eee <EXTI9_5_IRQHandler+0x66>
        EXTI_ClearITPendingBit(EXTI_Line6);
    }
    else if (EXTI_GetITStatus(EXTI_Line7) != RESET)
 8001eae:	2080      	movs	r0, #128	; 0x80
 8001eb0:	f002 f900 	bl	80040b4 <EXTI_GetITStatus>
 8001eb4:	b120      	cbz	r0, 8001ec0 <EXTI9_5_IRQHandler+0x38>
    {
    	line=7;
        EXTI_ClearITPendingBit(EXTI_Line7);
 8001eb6:	2080      	movs	r0, #128	; 0x80
 8001eb8:	f002 f90c 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=6;
        EXTI_ClearITPendingBit(EXTI_Line6);
    }
    else if (EXTI_GetITStatus(EXTI_Line7) != RESET)
    {
    	line=7;
 8001ebc:	2007      	movs	r0, #7
 8001ebe:	e016      	b.n	8001eee <EXTI9_5_IRQHandler+0x66>
        EXTI_ClearITPendingBit(EXTI_Line7);
    }
    else if (EXTI_GetITStatus(EXTI_Line8) != RESET)
 8001ec0:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001ec4:	f002 f8f6 	bl	80040b4 <EXTI_GetITStatus>
 8001ec8:	b128      	cbz	r0, 8001ed6 <EXTI9_5_IRQHandler+0x4e>
    {
    	line=8;
        EXTI_ClearITPendingBit(EXTI_Line8);
 8001eca:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001ece:	f002 f901 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=7;
        EXTI_ClearITPendingBit(EXTI_Line7);
    }
    else if (EXTI_GetITStatus(EXTI_Line8) != RESET)
    {
    	line=8;
 8001ed2:	2008      	movs	r0, #8
 8001ed4:	e00b      	b.n	8001eee <EXTI9_5_IRQHandler+0x66>
        EXTI_ClearITPendingBit(EXTI_Line8);
    }
    else if (EXTI_GetITStatus(EXTI_Line9) != RESET)
 8001ed6:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001eda:	f002 f8eb 	bl	80040b4 <EXTI_GetITStatus>
 8001ede:	b128      	cbz	r0, 8001eec <EXTI9_5_IRQHandler+0x64>
    {
    	line=9;
        EXTI_ClearITPendingBit(EXTI_Line9);
 8001ee0:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001ee4:	f002 f8f6 	bl	80040d4 <EXTI_ClearITPendingBit>
    	line=8;
        EXTI_ClearITPendingBit(EXTI_Line8);
    }
    else if (EXTI_GetITStatus(EXTI_Line9) != RESET)
    {
    	line=9;
 8001ee8:	2009      	movs	r0, #9
 8001eea:	e000      	b.n	8001eee <EXTI9_5_IRQHandler+0x66>
//This function handles External lines 9 to 5 interrupt request.
//
//**************************************************************************
void EXTI9_5_IRQHandler(void)
{
	uint8_t line=0;
 8001eec:	2000      	movs	r0, #0
    {
    	line=9;
        EXTI_ClearITPendingBit(EXTI_Line9);
    }

    vExtiHandleInt(line);
 8001eee:	f7ff ff19 	bl	8001d24 <vExtiHandleInt>
 8001ef2:	bd08      	pop	{r3, pc}

08001ef4 <EEPROM_LowLevel_Init>:
 * @brief  Initializes peripherals used by the I2C EEPROM driver.
 * @param  None
 * @retval None
 */
void EEPROM_LowLevel_Init(void)
{
 8001ef4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001ef8:	b082      	sub	sp, #8

	GPIO_InitTypeDef  GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/*!< EEPROM_I2C_SCL_GPIO_CLK and EEPROM_I2C_SDA_GPIO_CLK Periph clock enable */
	RCC_APB2PeriphClockCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);
 8001efa:	2101      	movs	r1, #1
 8001efc:	2008      	movs	r0, #8
 8001efe:	f002 fbb3 	bl	8004668 <RCC_APB2PeriphClockCmd>

	/*!< EEPROM_I2C Periph clock enable */
	RCC_APB1PeriphClockCmd(EEPROM_I2C_CLK, ENABLE);
 8001f02:	2101      	movs	r1, #1
 8001f04:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8001f08:	f002 fbbc 	bl	8004684 <RCC_APB1PeriphClockCmd>

	/*!< GPIO configuration */
	/*!< Configure EEPROM_I2C pins: SCL */
	GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_PIN;
 8001f0c:	2340      	movs	r3, #64	; 0x40
 8001f0e:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001f12:	2403      	movs	r4, #3
 8001f14:	f88d 4006 	strb.w	r4, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8001f18:	231c      	movs	r3, #28
 8001f1a:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
 8001f1e:	4d2d      	ldr	r5, [pc, #180]	; (8001fd4 <EEPROM_LowLevel_Init+0xe0>)
 8001f20:	a901      	add	r1, sp, #4
 8001f22:	4628      	mov	r0, r5
 8001f24:	f002 f8fe 	bl	8004124 <GPIO_Init>

	/*!< Configure EEPROM_I2C pins: SDA */
	GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_PIN;
 8001f28:	2680      	movs	r6, #128	; 0x80
 8001f2a:	f8ad 6004 	strh.w	r6, [sp, #4]
	GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
 8001f2e:	a901      	add	r1, sp, #4
 8001f30:	4628      	mov	r0, r5
 8001f32:	f002 f8f7 	bl	8004124 <GPIO_Init>

	/* Configure and enable I2C DMA TX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EEPROM_I2C_DMA_TX_IRQn;
 8001f36:	f04f 0810 	mov.w	r8, #16
 8001f3a:	f88d 8000 	strb.w	r8, [sp]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EEPROM_I2C_DMA_PREPRIO;
 8001f3e:	f88d 4001 	strb.w	r4, [sp, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = EEPROM_I2C_DMA_SUBPRIO;
 8001f42:	f88d 4002 	strb.w	r4, [sp, #2]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001f46:	2501      	movs	r5, #1
 8001f48:	f88d 5003 	strb.w	r5, [sp, #3]
	NVIC_Init(&NVIC_InitStructure);
 8001f4c:	4668      	mov	r0, sp
 8001f4e:	f001 ff1b 	bl	8003d88 <NVIC_Init>

	/* Configure and enable I2C DMA RX Channel interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EEPROM_I2C_DMA_RX_IRQn;
 8001f52:	2311      	movs	r3, #17
 8001f54:	f88d 3000 	strb.w	r3, [sp]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EEPROM_I2C_DMA_PREPRIO;
 8001f58:	f88d 4001 	strb.w	r4, [sp, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = EEPROM_I2C_DMA_SUBPRIO;
 8001f5c:	f88d 4002 	strb.w	r4, [sp, #2]
	NVIC_Init(&NVIC_InitStructure);
 8001f60:	4668      	mov	r0, sp
 8001f62:	f001 ff11 	bl	8003d88 <NVIC_Init>

	/*!< I2C DMA TX and RX channels configuration */
	/* Enable the DMA clock */
	RCC_AHBPeriphClockCmd(EEPROM_I2C_DMA_CLK, ENABLE);
 8001f66:	4629      	mov	r1, r5
 8001f68:	4628      	mov	r0, r5
 8001f6a:	f002 fb6f 	bl	800464c <RCC_AHBPeriphClockCmd>

	/* I2C TX DMA Channel configuration */
	DMA_DeInit(EEPROM_I2C_DMA_CHANNEL_TX);
 8001f6e:	4f1a      	ldr	r7, [pc, #104]	; (8001fd8 <EEPROM_LowLevel_Init+0xe4>)
 8001f70:	4638      	mov	r0, r7
 8001f72:	f001 ff6b 	bl	8003e4c <DMA_DeInit>
	EEPROMDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)EEPROM_I2C_DR_Address;
 8001f76:	4c19      	ldr	r4, [pc, #100]	; (8001fdc <EEPROM_LowLevel_Init+0xe8>)
 8001f78:	4b19      	ldr	r3, [pc, #100]	; (8001fe0 <EEPROM_LowLevel_Init+0xec>)
 8001f7a:	6023      	str	r3, [r4, #0]
	EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)0;   /* This parameter will be configured durig communication */
 8001f7c:	2300      	movs	r3, #0
 8001f7e:	6063      	str	r3, [r4, #4]
	EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;    /* This parameter will be configured durig communication */
 8001f80:	f8c4 8008 	str.w	r8, [r4, #8]
	EEPROMDMA_InitStructure.DMA_BufferSize = 0xFFFF;            /* This parameter will be configured durig communication */
 8001f84:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001f88:	60e2      	str	r2, [r4, #12]
	EEPROMDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8001f8a:	6123      	str	r3, [r4, #16]
	EEPROMDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8001f8c:	6166      	str	r6, [r4, #20]
	EEPROMDMA_InitStructure.DMA_PeripheralDataSize = DMA_MemoryDataSize_Byte;
 8001f8e:	61a3      	str	r3, [r4, #24]
	EEPROMDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8001f90:	61e3      	str	r3, [r4, #28]
	EEPROMDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8001f92:	6223      	str	r3, [r4, #32]
	EEPROMDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 8001f94:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8001f98:	6262      	str	r2, [r4, #36]	; 0x24
	EEPROMDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8001f9a:	62a3      	str	r3, [r4, #40]	; 0x28
	DMA_Init(EEPROM_I2C_DMA_CHANNEL_TX, &EEPROMDMA_InitStructure);
 8001f9c:	4621      	mov	r1, r4
 8001f9e:	4638      	mov	r0, r7
 8001fa0:	f001 ffe8 	bl	8003f74 <DMA_Init>

	/* I2C RX DMA Channel configuration */
	DMA_DeInit(EEPROM_I2C_DMA_CHANNEL_RX);
 8001fa4:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8001fa8:	f506 3600 	add.w	r6, r6, #131072	; 0x20000
 8001fac:	4630      	mov	r0, r6
 8001fae:	f001 ff4d 	bl	8003e4c <DMA_DeInit>
	DMA_Init(EEPROM_I2C_DMA_CHANNEL_RX, &EEPROMDMA_InitStructure);
 8001fb2:	4621      	mov	r1, r4
 8001fb4:	4630      	mov	r0, r6
 8001fb6:	f001 ffdd 	bl	8003f74 <DMA_Init>

	/* Enable the DMA Channels Interrupts */
	DMA_ITConfig(EEPROM_I2C_DMA_CHANNEL_TX, DMA_IT_TC, ENABLE);
 8001fba:	462a      	mov	r2, r5
 8001fbc:	2102      	movs	r1, #2
 8001fbe:	4638      	mov	r0, r7
 8001fc0:	f002 f806 	bl	8003fd0 <DMA_ITConfig>
	DMA_ITConfig(EEPROM_I2C_DMA_CHANNEL_RX, DMA_IT_TC, ENABLE);
 8001fc4:	462a      	mov	r2, r5
 8001fc6:	2102      	movs	r1, #2
 8001fc8:	4630      	mov	r0, r6
 8001fca:	f002 f801 	bl	8003fd0 <DMA_ITConfig>
}
 8001fce:	b002      	add	sp, #8
 8001fd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001fd4:	40010c00 	.word	0x40010c00
 8001fd8:	4002006c 	.word	0x4002006c
 8001fdc:	20000548 	.word	0x20000548
 8001fe0:	40005410 	.word	0x40005410

08001fe4 <EEPROM_LowLevel_DMAConfig>:
 * @brief  Initializes DMA channel used by the I2C EEPROM driver.
 * @param  None
 * @retval None
 */
void EEPROM_LowLevel_DMAConfig(uint32_t pBuffer, uint32_t BufferSize, uint32_t Direction)
{
 8001fe4:	b508      	push	{r3, lr}
	/* Initialize the DMA with the new parameters */
	if (Direction == EEPROM_DIRECTION_TX)
 8001fe6:	b94a      	cbnz	r2, 8001ffc <EEPROM_LowLevel_DMAConfig+0x18>
	{
		/* Configure the DMA Tx Channel with the buffer address and the buffer size */
		EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer;
 8001fe8:	4b09      	ldr	r3, [pc, #36]	; (8002010 <EEPROM_LowLevel_DMAConfig+0x2c>)
 8001fea:	6058      	str	r0, [r3, #4]
		EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8001fec:	2210      	movs	r2, #16
 8001fee:	609a      	str	r2, [r3, #8]
		EEPROMDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;
 8001ff0:	60d9      	str	r1, [r3, #12]
		DMA_Init(EEPROM_I2C_DMA_CHANNEL_TX, &EEPROMDMA_InitStructure);
 8001ff2:	4619      	mov	r1, r3
 8001ff4:	4807      	ldr	r0, [pc, #28]	; (8002014 <EEPROM_LowLevel_DMAConfig+0x30>)
 8001ff6:	f001 ffbd 	bl	8003f74 <DMA_Init>
 8001ffa:	bd08      	pop	{r3, pc}
	}
	else
	{
		/* Configure the DMA Rx Channel with the buffer address and the buffer size */
		EEPROMDMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer;
 8001ffc:	4b04      	ldr	r3, [pc, #16]	; (8002010 <EEPROM_LowLevel_DMAConfig+0x2c>)
 8001ffe:	6058      	str	r0, [r3, #4]
		EEPROMDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8002000:	2200      	movs	r2, #0
 8002002:	609a      	str	r2, [r3, #8]
		EEPROMDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;
 8002004:	60d9      	str	r1, [r3, #12]
		DMA_Init(EEPROM_I2C_DMA_CHANNEL_RX, &EEPROMDMA_InitStructure);
 8002006:	4619      	mov	r1, r3
 8002008:	4803      	ldr	r0, [pc, #12]	; (8002018 <EEPROM_LowLevel_DMAConfig+0x34>)
 800200a:	f001 ffb3 	bl	8003f74 <DMA_Init>
 800200e:	bd08      	pop	{r3, pc}
 8002010:	20000548 	.word	0x20000548
 8002014:	4002006c 	.word	0x4002006c
 8002018:	40020080 	.word	0x40020080

0800201c <EEPROM_Init>:
 * @brief  Initializes peripherals used by the I2C EEPROM driver.
 * @param  None
 * @retval None
 */
void EEPROM_Init(void)
{
 800201c:	b570      	push	{r4, r5, r6, lr}
 800201e:	b084      	sub	sp, #16
	I2C_InitTypeDef  I2C_InitStructure;

	EEPROM_LowLevel_Init();
 8002020:	f7ff ff68 	bl	8001ef4 <EEPROM_LowLevel_Init>

	/*!< I2C configuration */
	/* EEPROM_I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8002024:	2300      	movs	r3, #0
 8002026:	f8ad 3004 	strh.w	r3, [sp, #4]
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 800202a:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 800202e:	f8ad 3006 	strh.w	r3, [sp, #6]
	I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;
 8002032:	26a0      	movs	r6, #160	; 0xa0
 8002034:	f8ad 6008 	strh.w	r6, [sp, #8]
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8002038:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800203c:	f8ad 300a 	strh.w	r3, [sp, #10]
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8002040:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8002044:	f8ad 300c 	strh.w	r3, [sp, #12]
	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 8002048:	ad04      	add	r5, sp, #16
 800204a:	4b0a      	ldr	r3, [pc, #40]	; (8002074 <EEPROM_Init+0x58>)
 800204c:	f845 3d10 	str.w	r3, [r5, #-16]!

	/* EEPROM_I2C Peripheral Enable */
	I2C_Cmd(EEPROM_I2C, ENABLE);
 8002050:	4c09      	ldr	r4, [pc, #36]	; (8002078 <EEPROM_Init+0x5c>)
 8002052:	2101      	movs	r1, #1
 8002054:	4620      	mov	r0, r4
 8002056:	f002 f98f 	bl	8004378 <I2C_Cmd>
	/* Apply EEPROM_I2C configuration after enabling it */
	I2C_Init(EEPROM_I2C, &I2C_InitStructure);
 800205a:	4629      	mov	r1, r5
 800205c:	4620      	mov	r0, r4
 800205e:	f002 f91d 	bl	800429c <I2C_Init>

	/* Enable the EEPROM_I2C peripheral DMA requests */
	I2C_DMACmd(EEPROM_I2C, ENABLE);
 8002062:	2101      	movs	r1, #1
 8002064:	4620      	mov	r0, r4
 8002066:	f002 f995 	bl	8004394 <I2C_DMACmd>

#if defined (EEPROM_M24C64_32)
	/*!< Select the EEPROM address according to the state of E0, E1, E2 pins */
	EEPROMAddress = EEPROM_HW_ADDRESS;
 800206a:	4b04      	ldr	r3, [pc, #16]	; (800207c <EEPROM_Init+0x60>)
 800206c:	801e      	strh	r6, [r3, #0]
#endif /*!< EEPROM_M24C64_32 */
}
 800206e:	b004      	add	sp, #16
 8002070:	bd70      	pop	{r4, r5, r6, pc}
 8002072:	bf00      	nop
 8002074:	000493e0 	.word	0x000493e0
 8002078:	40005400 	.word	0x40005400
 800207c:	20000394 	.word	0x20000394

08002080 <DMA1_Channel7_IRQHandler>:
 * @brief  This function handles the DMA Rx Channel interrupt Handler.
 * @param  None
 * @retval None
 */
void EEPROM_I2C_DMA_RX_IRQHandler(void)
{
 8002080:	b508      	push	{r3, lr}
	/* Check if the DMA transfer is complete */
	if(DMA_GetFlagStatus(EEPROM_I2C_DMA_FLAG_RX_TC) != RESET)
 8002082:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8002086:	f001 ffad 	bl	8003fe4 <DMA_GetFlagStatus>
 800208a:	b178      	cbz	r0, 80020ac <DMA1_Channel7_IRQHandler+0x2c>
	{
		/*!< Send STOP Condition */
		I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 800208c:	2101      	movs	r1, #1
 800208e:	4808      	ldr	r0, [pc, #32]	; (80020b0 <DMA1_Channel7_IRQHandler+0x30>)
 8002090:	f002 f9aa 	bl	80043e8 <I2C_GenerateSTOP>

		/* Disable the DMA Rx Channel and Clear all its Flags */
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_RX, DISABLE);
 8002094:	2100      	movs	r1, #0
 8002096:	4807      	ldr	r0, [pc, #28]	; (80020b4 <DMA1_Channel7_IRQHandler+0x34>)
 8002098:	f001 ff8c 	bl	8003fb4 <DMA_Cmd>
		DMA_ClearFlag(EEPROM_I2C_DMA_FLAG_RX_GL);
 800209c:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 80020a0:	f001 ffb2 	bl	8004008 <DMA_ClearFlag>

		/* Reset the variable holding the number of data to be read */
		*EEPROMDataReadPointer = 0;
 80020a4:	4b04      	ldr	r3, [pc, #16]	; (80020b8 <DMA1_Channel7_IRQHandler+0x38>)
 80020a6:	681b      	ldr	r3, [r3, #0]
 80020a8:	2200      	movs	r2, #0
 80020aa:	801a      	strh	r2, [r3, #0]
 80020ac:	bd08      	pop	{r3, pc}
 80020ae:	bf00      	nop
 80020b0:	40005400 	.word	0x40005400
 80020b4:	40020080 	.word	0x40020080
 80020b8:	20000544 	.word	0x20000544

080020bc <EEPROM_TIMEOUT_UserCallback>:
 * @brief  Basic management of the timeout situation.
 * @param  None.
 * @retval None.
 */
uint32_t EEPROM_TIMEOUT_UserCallback(void)
{
 80020bc:	e7fe      	b.n	80020bc <EEPROM_TIMEOUT_UserCallback>
 80020be:	bf00      	nop

080020c0 <EEPROM_WritePage>:
 *
 * @retval EEPROM_OK (0) if operation is correctly performed, else return value
 *         different from EEPROM_OK (0) or the timeout user callback.
 */
uint32_t EEPROM_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite)
{
 80020c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80020c4:	4680      	mov	r8, r0
 80020c6:	460d      	mov	r5, r1
 80020c8:	4614      	mov	r4, r2
	/* Set the pointer to the Number of data to be written. This pointer will be used
      by the DMA Transfer Completer interrupt Handler in order to reset the
      variable to 0. User should check on this variable in order to know if the
      DMA transfer has been complete or not. */
	EEPROMDataWritePointer = NumByteToWrite;
 80020ca:	4b3e      	ldr	r3, [pc, #248]	; (80021c4 <EEPROM_WritePage+0x104>)
 80020cc:	601a      	str	r2, [r3, #0]

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80020ce:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80020d2:	4b3d      	ldr	r3, [pc, #244]	; (80021c8 <EEPROM_WritePage+0x108>)
 80020d4:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80020d6:	e006      	b.n	80020e6 <EEPROM_WritePage+0x26>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80020d8:	4a3b      	ldr	r2, [pc, #236]	; (80021c8 <EEPROM_WritePage+0x108>)
 80020da:	6813      	ldr	r3, [r2, #0]
 80020dc:	1e59      	subs	r1, r3, #1
 80020de:	6011      	str	r1, [r2, #0]
 80020e0:	b90b      	cbnz	r3, 80020e6 <EEPROM_WritePage+0x26>
 80020e2:	f7ff ffeb 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
      DMA transfer has been complete or not. */
	EEPROMDataWritePointer = NumByteToWrite;

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80020e6:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 80020ea:	4838      	ldr	r0, [pc, #224]	; (80021cc <EEPROM_WritePage+0x10c>)
 80020ec:	f002 f9b6 	bl	800445c <I2C_GetFlagStatus>
 80020f0:	2800      	cmp	r0, #0
 80020f2:	d1f1      	bne.n	80020d8 <EEPROM_WritePage+0x18>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 80020f4:	2101      	movs	r1, #1
 80020f6:	4835      	ldr	r0, [pc, #212]	; (80021cc <EEPROM_WritePage+0x10c>)
 80020f8:	f002 f968 	bl	80043cc <I2C_GenerateSTART>

	/*!< Test on EV5 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80020fc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002100:	4b31      	ldr	r3, [pc, #196]	; (80021c8 <EEPROM_WritePage+0x108>)
 8002102:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002104:	e006      	b.n	8002114 <EEPROM_WritePage+0x54>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002106:	4a30      	ldr	r2, [pc, #192]	; (80021c8 <EEPROM_WritePage+0x108>)
 8002108:	6813      	ldr	r3, [r2, #0]
 800210a:	1e59      	subs	r1, r3, #1
 800210c:	6011      	str	r1, [r2, #0]
 800210e:	b90b      	cbnz	r3, 8002114 <EEPROM_WritePage+0x54>
 8002110:	f7ff ffd4 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);

	/*!< Test on EV5 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002114:	492e      	ldr	r1, [pc, #184]	; (80021d0 <EEPROM_WritePage+0x110>)
 8002116:	482d      	ldr	r0, [pc, #180]	; (80021cc <EEPROM_WritePage+0x10c>)
 8002118:	f002 f992 	bl	8004440 <I2C_CheckEvent>
 800211c:	2800      	cmp	r0, #0
 800211e:	d0f2      	beq.n	8002106 <EEPROM_WritePage+0x46>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send EEPROM address for write */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002120:	4f29      	ldr	r7, [pc, #164]	; (80021c8 <EEPROM_WritePage+0x108>)
 8002122:	f44f 5680 	mov.w	r6, #4096	; 0x1000
 8002126:	603e      	str	r6, [r7, #0]
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);
 8002128:	4b2a      	ldr	r3, [pc, #168]	; (80021d4 <EEPROM_WritePage+0x114>)
 800212a:	8819      	ldrh	r1, [r3, #0]
 800212c:	2200      	movs	r2, #0
 800212e:	b2c9      	uxtb	r1, r1
 8002130:	4826      	ldr	r0, [pc, #152]	; (80021cc <EEPROM_WritePage+0x10c>)
 8002132:	f002 f97b 	bl	800442c <I2C_Send7bitAddress>

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002136:	603e      	str	r6, [r7, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8002138:	e006      	b.n	8002148 <EEPROM_WritePage+0x88>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800213a:	4a23      	ldr	r2, [pc, #140]	; (80021c8 <EEPROM_WritePage+0x108>)
 800213c:	6813      	ldr	r3, [r2, #0]
 800213e:	1e59      	subs	r1, r3, #1
 8002140:	6011      	str	r1, [r2, #0]
 8002142:	b90b      	cbnz	r3, 8002148 <EEPROM_WritePage+0x88>
 8002144:	f7ff ffba 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8002148:	4923      	ldr	r1, [pc, #140]	; (80021d8 <EEPROM_WritePage+0x118>)
 800214a:	4820      	ldr	r0, [pc, #128]	; (80021cc <EEPROM_WritePage+0x10c>)
 800214c:	f002 f978 	bl	8004440 <I2C_CheckEvent>
 8002150:	2800      	cmp	r0, #0
 8002152:	d0f2      	beq.n	800213a <EEPROM_WritePage+0x7a>
	I2C_SendData(EEPROM_I2C, WriteAddr);

#elif defined(EEPROM_M24C64_32)

	/*!< Send the EEPROM's internal address to write to : MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));
 8002154:	0a29      	lsrs	r1, r5, #8
 8002156:	481d      	ldr	r0, [pc, #116]	; (80021cc <EEPROM_WritePage+0x10c>)
 8002158:	f002 f962 	bl	8004420 <I2C_SendData>

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 800215c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002160:	4b19      	ldr	r3, [pc, #100]	; (80021c8 <EEPROM_WritePage+0x108>)
 8002162:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8002164:	e006      	b.n	8002174 <EEPROM_WritePage+0xb4>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002166:	4a18      	ldr	r2, [pc, #96]	; (80021c8 <EEPROM_WritePage+0x108>)
 8002168:	6813      	ldr	r3, [r2, #0]
 800216a:	1e59      	subs	r1, r3, #1
 800216c:	6011      	str	r1, [r2, #0]
 800216e:	b90b      	cbnz	r3, 8002174 <EEPROM_WritePage+0xb4>
 8002170:	f7ff ffa4 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/*!< Send the EEPROM's internal address to write to : MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8002174:	4919      	ldr	r1, [pc, #100]	; (80021dc <EEPROM_WritePage+0x11c>)
 8002176:	4815      	ldr	r0, [pc, #84]	; (80021cc <EEPROM_WritePage+0x10c>)
 8002178:	f002 f962 	bl	8004440 <I2C_CheckEvent>
 800217c:	2800      	cmp	r0, #0
 800217e:	d0f2      	beq.n	8002166 <EEPROM_WritePage+0xa6>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send the EEPROM's internal address to write to : LSB of the address */
	I2C_SendData(EEPROM_I2C, (uint8_t)(WriteAddr & 0x00FF));
 8002180:	b2e9      	uxtb	r1, r5
 8002182:	4812      	ldr	r0, [pc, #72]	; (80021cc <EEPROM_WritePage+0x10c>)
 8002184:	f002 f94c 	bl	8004420 <I2C_SendData>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002188:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800218c:	4b0e      	ldr	r3, [pc, #56]	; (80021c8 <EEPROM_WritePage+0x108>)
 800218e:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 8002190:	e006      	b.n	80021a0 <EEPROM_WritePage+0xe0>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002192:	4a0d      	ldr	r2, [pc, #52]	; (80021c8 <EEPROM_WritePage+0x108>)
 8002194:	6813      	ldr	r3, [r2, #0]
 8002196:	1e59      	subs	r1, r3, #1
 8002198:	6011      	str	r1, [r2, #0]
 800219a:	b90b      	cbnz	r3, 80021a0 <EEPROM_WritePage+0xe0>
 800219c:	f7ff ff8e 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 80021a0:	490e      	ldr	r1, [pc, #56]	; (80021dc <EEPROM_WritePage+0x11c>)
 80021a2:	480a      	ldr	r0, [pc, #40]	; (80021cc <EEPROM_WritePage+0x10c>)
 80021a4:	f002 f94c 	bl	8004440 <I2C_CheckEvent>
 80021a8:	2800      	cmp	r0, #0
 80021aa:	d0f2      	beq.n	8002192 <EEPROM_WritePage+0xd2>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/* Configure the DMA Tx Channel with the buffer address and the buffer size */
	EEPROM_LowLevel_DMAConfig((uint32_t)pBuffer, (uint8_t)(*NumByteToWrite), EEPROM_DIRECTION_TX);
 80021ac:	2200      	movs	r2, #0
 80021ae:	7821      	ldrb	r1, [r4, #0]
 80021b0:	4640      	mov	r0, r8
 80021b2:	f7ff ff17 	bl	8001fe4 <EEPROM_LowLevel_DMAConfig>

	/* Enable the DMA Tx Channel */
	DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_TX, ENABLE);
 80021b6:	2101      	movs	r1, #1
 80021b8:	4809      	ldr	r0, [pc, #36]	; (80021e0 <EEPROM_WritePage+0x120>)
 80021ba:	f001 fefb 	bl	8003fb4 <DMA_Cmd>

	/* If all operations OK, return EEPROM_OK (0) */
	return EEPROM_OK;
}
 80021be:	2000      	movs	r0, #0
 80021c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80021c4:	20000540 	.word	0x20000540
 80021c8:	200000f0 	.word	0x200000f0
 80021cc:	40005400 	.word	0x40005400
 80021d0:	00030001 	.word	0x00030001
 80021d4:	20000394 	.word	0x20000394
 80021d8:	00070082 	.word	0x00070082
 80021dc:	00070084 	.word	0x00070084
 80021e0:	4002006c 	.word	0x4002006c

080021e4 <EEPROM_WaitEepromStandbyState>:
 * @param  None
 * @retval EEPROM_OK (0) if operation is correctly performed, else return value
 *         different from EEPROM_OK (0) or the timeout user callback.
 */
uint32_t EEPROM_WaitEepromStandbyState(void)
{
 80021e4:	b500      	push	{lr}
 80021e6:	b083      	sub	sp, #12
	__IO uint16_t tmpSR1 = 0;
 80021e8:	2300      	movs	r3, #0
 80021ea:	f8ad 3006 	strh.w	r3, [sp, #6]
	__IO uint32_t EEPROMTrials = 0;
 80021ee:	9300      	str	r3, [sp, #0]

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80021f0:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80021f4:	4b2e      	ldr	r3, [pc, #184]	; (80022b0 <EEPROM_WaitEepromStandbyState+0xcc>)
 80021f6:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80021f8:	e006      	b.n	8002208 <EEPROM_WaitEepromStandbyState+0x24>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80021fa:	4a2d      	ldr	r2, [pc, #180]	; (80022b0 <EEPROM_WaitEepromStandbyState+0xcc>)
 80021fc:	6813      	ldr	r3, [r2, #0]
 80021fe:	1e59      	subs	r1, r3, #1
 8002200:	6011      	str	r1, [r2, #0]
 8002202:	b90b      	cbnz	r3, 8002208 <EEPROM_WaitEepromStandbyState+0x24>
 8002204:	f7ff ff5a 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	__IO uint16_t tmpSR1 = 0;
	__IO uint32_t EEPROMTrials = 0;

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 8002208:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 800220c:	4829      	ldr	r0, [pc, #164]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 800220e:	f002 f925 	bl	800445c <I2C_GetFlagStatus>
 8002212:	2800      	cmp	r0, #0
 8002214:	d1f1      	bne.n	80021fa <EEPROM_WaitEepromStandbyState+0x16>
     of trials is reached (this number is defined by EEPROM_MAX_TRIALS_NUMBER define
     in stm32_eval_i2c_ee.h file) */
	while (1)
	{
		/*!< Send START condition */
		I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 8002216:	2101      	movs	r1, #1
 8002218:	4826      	ldr	r0, [pc, #152]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 800221a:	f002 f8d7 	bl	80043cc <I2C_GenerateSTART>

		/*!< Test on EV5 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 800221e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002222:	4b23      	ldr	r3, [pc, #140]	; (80022b0 <EEPROM_WaitEepromStandbyState+0xcc>)
 8002224:	601a      	str	r2, [r3, #0]
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002226:	e006      	b.n	8002236 <EEPROM_WaitEepromStandbyState+0x52>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002228:	4a21      	ldr	r2, [pc, #132]	; (80022b0 <EEPROM_WaitEepromStandbyState+0xcc>)
 800222a:	6813      	ldr	r3, [r2, #0]
 800222c:	1e59      	subs	r1, r3, #1
 800222e:	6011      	str	r1, [r2, #0]
 8002230:	b90b      	cbnz	r3, 8002236 <EEPROM_WaitEepromStandbyState+0x52>
 8002232:	f7ff ff43 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
		/*!< Send START condition */
		I2C_GenerateSTART(EEPROM_I2C, ENABLE);

		/*!< Test on EV5 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002236:	4920      	ldr	r1, [pc, #128]	; (80022b8 <EEPROM_WaitEepromStandbyState+0xd4>)
 8002238:	481e      	ldr	r0, [pc, #120]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 800223a:	f002 f901 	bl	8004440 <I2C_CheckEvent>
 800223e:	2800      	cmp	r0, #0
 8002240:	d0f2      	beq.n	8002228 <EEPROM_WaitEepromStandbyState+0x44>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Send EEPROM address for write */
		I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);
 8002242:	4b1e      	ldr	r3, [pc, #120]	; (80022bc <EEPROM_WaitEepromStandbyState+0xd8>)
 8002244:	8819      	ldrh	r1, [r3, #0]
 8002246:	2200      	movs	r2, #0
 8002248:	b2c9      	uxtb	r1, r1
 800224a:	481a      	ldr	r0, [pc, #104]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 800224c:	f002 f8ee 	bl	800442c <I2C_Send7bitAddress>

		/* Wait for ADDR flag to be set (Slave acknowledged his address) */
		EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002250:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002254:	4b16      	ldr	r3, [pc, #88]	; (80022b0 <EEPROM_WaitEepromStandbyState+0xcc>)
 8002256:	601a      	str	r2, [r3, #0]
		do
		{
			/* Get the current value of the SR1 register */
			tmpSR1 = EEPROM_I2C->SR1;
 8002258:	4b16      	ldr	r3, [pc, #88]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 800225a:	8a9b      	ldrh	r3, [r3, #20]
 800225c:	b29b      	uxth	r3, r3
 800225e:	f8ad 3006 	strh.w	r3, [sp, #6]

			/* Update the timeout value and exit if it reach 0 */
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002262:	4a13      	ldr	r2, [pc, #76]	; (80022b0 <EEPROM_WaitEepromStandbyState+0xcc>)
 8002264:	6813      	ldr	r3, [r2, #0]
 8002266:	1e59      	subs	r1, r3, #1
 8002268:	6011      	str	r1, [r2, #0]
 800226a:	b90b      	cbnz	r3, 8002270 <EEPROM_WaitEepromStandbyState+0x8c>
 800226c:	f7ff ff26 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
		}
		/* Keep looping till the Address is acknowledged or the AF flag is
       set (address not acknowledged at time) */
		while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);
 8002270:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8002274:	f240 4202 	movw	r2, #1026	; 0x402
 8002278:	421a      	tst	r2, r3
 800227a:	d0ed      	beq.n	8002258 <EEPROM_WaitEepromStandbyState+0x74>

		/* Check if the ADDR flag has been set */
		if (tmpSR1 & I2C_SR1_ADDR)
 800227c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8002280:	f003 0302 	and.w	r3, r3, #2
 8002284:	b29b      	uxth	r3, r3
 8002286:	b953      	cbnz	r3, 800229e <EEPROM_WaitEepromStandbyState+0xba>
			return EEPROM_OK;
		}
		else
		{
			/*!< Clear AF flag */
			I2C_ClearFlag(EEPROM_I2C, I2C_FLAG_AF);
 8002288:	490d      	ldr	r1, [pc, #52]	; (80022c0 <EEPROM_WaitEepromStandbyState+0xdc>)
 800228a:	480a      	ldr	r0, [pc, #40]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 800228c:	f002 f902 	bl	8004494 <I2C_ClearFlag>
		}

		/* Check if the maximum allowed numbe of trials has bee reached */
		if (EEPROMTrials++ == EEPROM_MAX_TRIALS_NUMBER)
 8002290:	9b00      	ldr	r3, [sp, #0]
 8002292:	1c5a      	adds	r2, r3, #1
 8002294:	9200      	str	r2, [sp, #0]
 8002296:	2b96      	cmp	r3, #150	; 0x96
 8002298:	d1bd      	bne.n	8002216 <EEPROM_WaitEepromStandbyState+0x32>
		{
			/* If the maximum number of trials has been reached, exit the function */
			return EEPROM_TIMEOUT_UserCallback();
 800229a:	f7ff ff0f 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
		/* Check if the ADDR flag has been set */
		if (tmpSR1 & I2C_SR1_ADDR)
		{
			/* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already
         been read) */
			(void)EEPROM_I2C->SR2;
 800229e:	4805      	ldr	r0, [pc, #20]	; (80022b4 <EEPROM_WaitEepromStandbyState+0xd0>)
 80022a0:	8b03      	ldrh	r3, [r0, #24]

			/*!< STOP condition */
			I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 80022a2:	2101      	movs	r1, #1
 80022a4:	f002 f8a0 	bl	80043e8 <I2C_GenerateSTOP>
		{
			/* If the maximum number of trials has been reached, exit the function */
			return EEPROM_TIMEOUT_UserCallback();
		}
	}
}
 80022a8:	2000      	movs	r0, #0
 80022aa:	b003      	add	sp, #12
 80022ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80022b0:	200000f0 	.word	0x200000f0
 80022b4:	40005400 	.word	0x40005400
 80022b8:	00030001 	.word	0x00030001
 80022bc:	20000394 	.word	0x20000394
 80022c0:	10000400 	.word	0x10000400

080022c4 <EEPROM_WriteBuffer>:
 * @param  WriteAddr : EEPROM's internal address to write to.
 * @param  NumByteToWrite : number of bytes to write to the EEPROM.
 * @retval None
 */
void EEPROM_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
{
 80022c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80022c8:	4605      	mov	r5, r0
 80022ca:	460c      	mov	r4, r1
	uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
	uint16_t Addr = 0;

	Addr = WriteAddr % EEPROM_PAGESIZE;
 80022cc:	f001 011f 	and.w	r1, r1, #31
	count = EEPROM_PAGESIZE - Addr;
	NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;
 80022d0:	f3c2 1347 	ubfx	r3, r2, #5, #8
	NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;
 80022d4:	fa5f f882 	uxtb.w	r8, r2
 80022d8:	f008 071f 	and.w	r7, r8, #31

	/*!< If WriteAddr is EEPROM_PAGESIZE aligned  */
	if(Addr == 0)
 80022dc:	2900      	cmp	r1, #0
 80022de:	d15b      	bne.n	8002398 <EEPROM_WriteBuffer+0xd4>
	{
		/*!< If NumByteToWrite < EEPROM_PAGESIZE */
		if(NumOfPage == 0)
 80022e0:	2b00      	cmp	r3, #0
 80022e2:	d137      	bne.n	8002354 <EEPROM_WriteBuffer+0x90>
		{
			/* Store the number of data to be written */
			EEPROMDataNum = NumOfSingle;
 80022e4:	4a8e      	ldr	r2, [pc, #568]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 80022e6:	7017      	strb	r7, [r2, #0]
			/* Start writing data */
			EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80022e8:	4621      	mov	r1, r4
 80022ea:	f7ff fee9 	bl	80020c0 <EEPROM_WritePage>
			/* Wait transfer through DMA to be complete */
			EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80022ee:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80022f2:	4b8c      	ldr	r3, [pc, #560]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80022f4:	601a      	str	r2, [r3, #0]
			while (EEPROMDataNum > 0)
 80022f6:	e006      	b.n	8002306 <EEPROM_WriteBuffer+0x42>
			{
				if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80022f8:	4a8a      	ldr	r2, [pc, #552]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80022fa:	6813      	ldr	r3, [r2, #0]
 80022fc:	1e59      	subs	r1, r3, #1
 80022fe:	6011      	str	r1, [r2, #0]
 8002300:	b90b      	cbnz	r3, 8002306 <EEPROM_WriteBuffer+0x42>
 8002302:	f7ff fedb 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
			EEPROMDataNum = NumOfSingle;
			/* Start writing data */
			EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
			/* Wait transfer through DMA to be complete */
			EEPROMTimeout = EEPROM_LONG_TIMEOUT;
			while (EEPROMDataNum > 0)
 8002306:	4b86      	ldr	r3, [pc, #536]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 8002308:	781b      	ldrb	r3, [r3, #0]
 800230a:	f013 0fff 	tst.w	r3, #255	; 0xff
 800230e:	d1f3      	bne.n	80022f8 <EEPROM_WriteBuffer+0x34>
			{
				if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
			}
			EEPROM_WaitEepromStandbyState();
 8002310:	f7ff ff68 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
 8002314:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		else
		{
			while(NumOfPage--)
			{
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
 8002318:	4a81      	ldr	r2, [pc, #516]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 800231a:	2320      	movs	r3, #32
 800231c:	7013      	strb	r3, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 800231e:	4621      	mov	r1, r4
 8002320:	4628      	mov	r0, r5
 8002322:	f7ff fecd 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002326:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 800232a:	4b7e      	ldr	r3, [pc, #504]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 800232c:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 800232e:	e006      	b.n	800233e <EEPROM_WriteBuffer+0x7a>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002330:	4a7c      	ldr	r2, [pc, #496]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 8002332:	6813      	ldr	r3, [r2, #0]
 8002334:	1e59      	subs	r1, r3, #1
 8002336:	6011      	str	r1, [r2, #0]
 8002338:	b90b      	cbnz	r3, 800233e <EEPROM_WriteBuffer+0x7a>
 800233a:	f7ff febf 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 800233e:	4b78      	ldr	r3, [pc, #480]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 8002340:	781b      	ldrb	r3, [r3, #0]
 8002342:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002346:	d1f3      	bne.n	8002330 <EEPROM_WriteBuffer+0x6c>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002348:	f7ff ff4c 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
				WriteAddr +=  EEPROM_PAGESIZE;
 800234c:	3420      	adds	r4, #32
 800234e:	b2a4      	uxth	r4, r4
				pBuffer += EEPROM_PAGESIZE;
 8002350:	3520      	adds	r5, #32
			EEPROM_WaitEepromStandbyState();
		}
		/*!< If NumByteToWrite > EEPROM_PAGESIZE */
		else
		{
			while(NumOfPage--)
 8002352:	4633      	mov	r3, r6
 8002354:	1e5e      	subs	r6, r3, #1
 8002356:	b2f6      	uxtb	r6, r6
 8002358:	2b00      	cmp	r3, #0
 800235a:	d1dd      	bne.n	8002318 <EEPROM_WriteBuffer+0x54>
				EEPROM_WaitEepromStandbyState();
				WriteAddr +=  EEPROM_PAGESIZE;
				pBuffer += EEPROM_PAGESIZE;
			}

			if(NumOfSingle!=0)
 800235c:	2f00      	cmp	r7, #0
 800235e:	f000 80dc 	beq.w	800251a <EEPROM_WriteBuffer+0x256>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
 8002362:	4a6f      	ldr	r2, [pc, #444]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 8002364:	7017      	strb	r7, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 8002366:	4621      	mov	r1, r4
 8002368:	4628      	mov	r0, r5
 800236a:	f7ff fea9 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 800236e:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002372:	4b6c      	ldr	r3, [pc, #432]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 8002374:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002376:	e006      	b.n	8002386 <EEPROM_WriteBuffer+0xc2>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002378:	4a6a      	ldr	r2, [pc, #424]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 800237a:	6813      	ldr	r3, [r2, #0]
 800237c:	1e59      	subs	r1, r3, #1
 800237e:	6011      	str	r1, [r2, #0]
 8002380:	b90b      	cbnz	r3, 8002386 <EEPROM_WriteBuffer+0xc2>
 8002382:	f7ff fe9b 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002386:	4b66      	ldr	r3, [pc, #408]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 8002388:	781b      	ldrb	r3, [r3, #0]
 800238a:	f013 0fff 	tst.w	r3, #255	; 0xff
 800238e:	d1f3      	bne.n	8002378 <EEPROM_WriteBuffer+0xb4>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002390:	f7ff ff28 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
 8002394:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002398:	f1c1 0620 	rsb	r6, r1, #32
 800239c:	b2f6      	uxtb	r6, r6
	}
	/*!< If WriteAddr is not EEPROM_PAGESIZE aligned  */
	else
	{
		/*!< If NumByteToWrite < EEPROM_PAGESIZE */
		if(NumOfPage== 0)
 800239e:	2b00      	cmp	r3, #0
 80023a0:	d155      	bne.n	800244e <EEPROM_WriteBuffer+0x18a>
		{
			/*!< If the number of data to be written is more than the remaining space
      in the current page: */
			if (NumByteToWrite > count)
 80023a2:	fa1f f986 	uxth.w	r9, r6
 80023a6:	454a      	cmp	r2, r9
 80023a8:	d937      	bls.n	800241a <EEPROM_WriteBuffer+0x156>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = count;
 80023aa:	4a5d      	ldr	r2, [pc, #372]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 80023ac:	7016      	strb	r6, [r2, #0]
				/*!< Write the data conained in same page */
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80023ae:	4621      	mov	r1, r4
 80023b0:	f7ff fe86 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80023b4:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80023b8:	4b5a      	ldr	r3, [pc, #360]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80023ba:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 80023bc:	e006      	b.n	80023cc <EEPROM_WriteBuffer+0x108>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80023be:	4a59      	ldr	r2, [pc, #356]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80023c0:	6813      	ldr	r3, [r2, #0]
 80023c2:	1e59      	subs	r1, r3, #1
 80023c4:	6011      	str	r1, [r2, #0]
 80023c6:	b90b      	cbnz	r3, 80023cc <EEPROM_WriteBuffer+0x108>
 80023c8:	f7ff fe78 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				EEPROMDataNum = count;
				/*!< Write the data conained in same page */
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 80023cc:	4b54      	ldr	r3, [pc, #336]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 80023ce:	781b      	ldrb	r3, [r3, #0]
 80023d0:	f013 0fff 	tst.w	r3, #255	; 0xff
 80023d4:	d1f3      	bne.n	80023be <EEPROM_WriteBuffer+0xfa>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 80023d6:	f7ff ff05 	bl	80021e4 <EEPROM_WaitEepromStandbyState>

				/* Store the number of data to be written */
				EEPROMDataNum = (NumByteToWrite - count);
 80023da:	ebc6 0308 	rsb	r3, r6, r8
 80023de:	b2db      	uxtb	r3, r3
 80023e0:	4a4f      	ldr	r2, [pc, #316]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 80023e2:	7013      	strb	r3, [r2, #0]
				/*!< Write the remaining data in the following page */
				EEPROM_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&EEPROMDataNum));
 80023e4:	eb04 0109 	add.w	r1, r4, r9
 80023e8:	b289      	uxth	r1, r1
 80023ea:	19a8      	adds	r0, r5, r6
 80023ec:	f7ff fe68 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80023f0:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80023f4:	4b4b      	ldr	r3, [pc, #300]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80023f6:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 80023f8:	e006      	b.n	8002408 <EEPROM_WriteBuffer+0x144>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80023fa:	4a4a      	ldr	r2, [pc, #296]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80023fc:	6813      	ldr	r3, [r2, #0]
 80023fe:	1e59      	subs	r1, r3, #1
 8002400:	6011      	str	r1, [r2, #0]
 8002402:	b90b      	cbnz	r3, 8002408 <EEPROM_WriteBuffer+0x144>
 8002404:	f7ff fe5a 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				EEPROMDataNum = (NumByteToWrite - count);
				/*!< Write the remaining data in the following page */
				EEPROM_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002408:	4b45      	ldr	r3, [pc, #276]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 800240a:	781b      	ldrb	r3, [r3, #0]
 800240c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002410:	d1f3      	bne.n	80023fa <EEPROM_WriteBuffer+0x136>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002412:	f7ff fee7 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
 8002416:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			}
			else
			{
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
 800241a:	4a41      	ldr	r2, [pc, #260]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 800241c:	7017      	strb	r7, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 800241e:	4621      	mov	r1, r4
 8002420:	f7ff fe4e 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002424:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002428:	4b3e      	ldr	r3, [pc, #248]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 800242a:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 800242c:	e006      	b.n	800243c <EEPROM_WriteBuffer+0x178>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 800242e:	4a3d      	ldr	r2, [pc, #244]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 8002430:	6813      	ldr	r3, [r2, #0]
 8002432:	1e59      	subs	r1, r3, #1
 8002434:	6011      	str	r1, [r2, #0]
 8002436:	b90b      	cbnz	r3, 800243c <EEPROM_WriteBuffer+0x178>
 8002438:	f7ff fe40 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 800243c:	4b38      	ldr	r3, [pc, #224]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 800243e:	781b      	ldrb	r3, [r3, #0]
 8002440:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002444:	d1f3      	bne.n	800242e <EEPROM_WriteBuffer+0x16a>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002446:	f7ff fecd 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
 800244a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			}
		}
		/*!< If NumByteToWrite > EEPROM_PAGESIZE */
		else
		{
			NumByteToWrite -= count;
 800244e:	fa1f f986 	uxth.w	r9, r6
 8002452:	ebc9 0702 	rsb	r7, r9, r2
 8002456:	b2bb      	uxth	r3, r7
			NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;
 8002458:	f3c3 1747 	ubfx	r7, r3, #5, #8
			NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;
 800245c:	f003 081f 	and.w	r8, r3, #31

			if(count != 0)
 8002460:	2e00      	cmp	r6, #0
 8002462:	d039      	beq.n	80024d8 <EEPROM_WriteBuffer+0x214>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = count;
 8002464:	4a2e      	ldr	r2, [pc, #184]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 8002466:	7016      	strb	r6, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 8002468:	4621      	mov	r1, r4
 800246a:	f7ff fe29 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 800246e:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002472:	4b2c      	ldr	r3, [pc, #176]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 8002474:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 8002476:	e006      	b.n	8002486 <EEPROM_WriteBuffer+0x1c2>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 8002478:	4a2a      	ldr	r2, [pc, #168]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 800247a:	6813      	ldr	r3, [r2, #0]
 800247c:	1e59      	subs	r1, r3, #1
 800247e:	6011      	str	r1, [r2, #0]
 8002480:	b90b      	cbnz	r3, 8002486 <EEPROM_WriteBuffer+0x1c2>
 8002482:	f7ff fe1b 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				/* Store the number of data to be written */
				EEPROMDataNum = count;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 8002486:	4b26      	ldr	r3, [pc, #152]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 8002488:	781b      	ldrb	r3, [r3, #0]
 800248a:	f013 0fff 	tst.w	r3, #255	; 0xff
 800248e:	d1f3      	bne.n	8002478 <EEPROM_WriteBuffer+0x1b4>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002490:	f7ff fea8 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
				WriteAddr += count;
 8002494:	444c      	add	r4, r9
 8002496:	b2a4      	uxth	r4, r4
				pBuffer += count;
 8002498:	4435      	add	r5, r6
 800249a:	e01d      	b.n	80024d8 <EEPROM_WriteBuffer+0x214>
			}

			while(NumOfPage--)
			{
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
 800249c:	4a20      	ldr	r2, [pc, #128]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 800249e:	2320      	movs	r3, #32
 80024a0:	7013      	strb	r3, [r2, #0]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80024a2:	4621      	mov	r1, r4
 80024a4:	4628      	mov	r0, r5
 80024a6:	f7ff fe0b 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80024aa:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80024ae:	4b1d      	ldr	r3, [pc, #116]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80024b0:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 80024b2:	e006      	b.n	80024c2 <EEPROM_WriteBuffer+0x1fe>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80024b4:	4a1b      	ldr	r2, [pc, #108]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80024b6:	6813      	ldr	r3, [r2, #0]
 80024b8:	1e59      	subs	r1, r3, #1
 80024ba:	6011      	str	r1, [r2, #0]
 80024bc:	b90b      	cbnz	r3, 80024c2 <EEPROM_WriteBuffer+0x1fe>
 80024be:	f7ff fdfd 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				/* Store the number of data to be written */
				EEPROMDataNum = EEPROM_PAGESIZE;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 80024c2:	4b17      	ldr	r3, [pc, #92]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 80024c4:	781b      	ldrb	r3, [r3, #0]
 80024c6:	f013 0fff 	tst.w	r3, #255	; 0xff
 80024ca:	d1f3      	bne.n	80024b4 <EEPROM_WriteBuffer+0x1f0>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 80024cc:	f7ff fe8a 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
				WriteAddr +=  EEPROM_PAGESIZE;
 80024d0:	3420      	adds	r4, #32
 80024d2:	b2a4      	uxth	r4, r4
				pBuffer += EEPROM_PAGESIZE;
 80024d4:	3520      	adds	r5, #32
				EEPROM_WaitEepromStandbyState();
				WriteAddr += count;
				pBuffer += count;
			}

			while(NumOfPage--)
 80024d6:	4637      	mov	r7, r6
 80024d8:	1e7e      	subs	r6, r7, #1
 80024da:	b2f6      	uxtb	r6, r6
 80024dc:	2f00      	cmp	r7, #0
 80024de:	d1dd      	bne.n	800249c <EEPROM_WriteBuffer+0x1d8>
				}
				EEPROM_WaitEepromStandbyState();
				WriteAddr +=  EEPROM_PAGESIZE;
				pBuffer += EEPROM_PAGESIZE;
			}
			if(NumOfSingle != 0)
 80024e0:	f1b8 0f00 	cmp.w	r8, #0
 80024e4:	d019      	beq.n	800251a <EEPROM_WriteBuffer+0x256>
			{
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
 80024e6:	4a0e      	ldr	r2, [pc, #56]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 80024e8:	f882 8000 	strb.w	r8, [r2]
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
 80024ec:	4621      	mov	r1, r4
 80024ee:	4628      	mov	r0, r5
 80024f0:	f7ff fde6 	bl	80020c0 <EEPROM_WritePage>
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80024f4:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80024f8:	4b0a      	ldr	r3, [pc, #40]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 80024fa:	601a      	str	r2, [r3, #0]
				while (EEPROMDataNum > 0)
 80024fc:	e006      	b.n	800250c <EEPROM_WriteBuffer+0x248>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
 80024fe:	4a09      	ldr	r2, [pc, #36]	; (8002524 <EEPROM_WriteBuffer+0x260>)
 8002500:	6813      	ldr	r3, [r2, #0]
 8002502:	1e59      	subs	r1, r3, #1
 8002504:	6011      	str	r1, [r2, #0]
 8002506:	b90b      	cbnz	r3, 800250c <EEPROM_WriteBuffer+0x248>
 8002508:	f7ff fdd8 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
				/* Store the number of data to be written */
				EEPROMDataNum = NumOfSingle;
				EEPROM_WritePage(pBuffer, WriteAddr, (uint8_t*)(&EEPROMDataNum));
				/* Wait transfer through DMA to be complete */
				EEPROMTimeout = EEPROM_LONG_TIMEOUT;
				while (EEPROMDataNum > 0)
 800250c:	4b04      	ldr	r3, [pc, #16]	; (8002520 <EEPROM_WriteBuffer+0x25c>)
 800250e:	781b      	ldrb	r3, [r3, #0]
 8002510:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002514:	d1f3      	bne.n	80024fe <EEPROM_WriteBuffer+0x23a>
				{
					if((EEPROMTimeout--) == 0) {EEPROM_TIMEOUT_UserCallback(); return;};
				}
				EEPROM_WaitEepromStandbyState();
 8002516:	f7ff fe65 	bl	80021e4 <EEPROM_WaitEepromStandbyState>
 800251a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800251e:	bf00      	nop
 8002520:	20000574 	.word	0x20000574
 8002524:	200000f0 	.word	0x200000f0

08002528 <DMA1_Channel6_IRQHandler>:
 * @brief  This function handles the DMA Tx Channel interrupt Handler.
 * @param  None
 * @retval None
 */
void EEPROM_I2C_DMA_TX_IRQHandler(void)
{
 8002528:	b510      	push	{r4, lr}
	/* Check if the DMA transfer is complete */
	if(DMA_GetFlagStatus(EEPROM_I2C_DMA_FLAG_TX_TC) != RESET)
 800252a:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800252e:	f001 fd59 	bl	8003fe4 <DMA_GetFlagStatus>
 8002532:	b320      	cbz	r0, 800257e <DMA1_Channel6_IRQHandler+0x56>
	{
		/* Disable the DMA Tx Channel and Clear all its Flags */
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_TX, DISABLE);
 8002534:	2100      	movs	r1, #0
 8002536:	4812      	ldr	r0, [pc, #72]	; (8002580 <DMA1_Channel6_IRQHandler+0x58>)
 8002538:	f001 fd3c 	bl	8003fb4 <DMA_Cmd>
		DMA_ClearFlag(EEPROM_I2C_DMA_FLAG_TX_GL);
 800253c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8002540:	f001 fd62 	bl	8004008 <DMA_ClearFlag>

		/*!< Wait till all data have been physically transferred on the bus */
		EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 8002544:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 8002548:	4b0e      	ldr	r3, [pc, #56]	; (8002584 <DMA1_Channel6_IRQHandler+0x5c>)
 800254a:	601a      	str	r2, [r3, #0]
		while(!I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF))
 800254c:	e006      	b.n	800255c <DMA1_Channel6_IRQHandler+0x34>
		{
			if((EEPROMTimeout--) == 0) EEPROM_TIMEOUT_UserCallback();
 800254e:	4a0d      	ldr	r2, [pc, #52]	; (8002584 <DMA1_Channel6_IRQHandler+0x5c>)
 8002550:	6813      	ldr	r3, [r2, #0]
 8002552:	1e59      	subs	r1, r3, #1
 8002554:	6011      	str	r1, [r2, #0]
 8002556:	b90b      	cbnz	r3, 800255c <DMA1_Channel6_IRQHandler+0x34>
 8002558:	f7ff fdb0 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_TX, DISABLE);
		DMA_ClearFlag(EEPROM_I2C_DMA_FLAG_TX_GL);

		/*!< Wait till all data have been physically transferred on the bus */
		EEPROMTimeout = EEPROM_LONG_TIMEOUT;
		while(!I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF))
 800255c:	490a      	ldr	r1, [pc, #40]	; (8002588 <DMA1_Channel6_IRQHandler+0x60>)
 800255e:	480b      	ldr	r0, [pc, #44]	; (800258c <DMA1_Channel6_IRQHandler+0x64>)
 8002560:	f001 ff7c 	bl	800445c <I2C_GetFlagStatus>
 8002564:	2800      	cmp	r0, #0
 8002566:	d0f2      	beq.n	800254e <DMA1_Channel6_IRQHandler+0x26>
		{
			if((EEPROMTimeout--) == 0) EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Send STOP condition */
		I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 8002568:	4c08      	ldr	r4, [pc, #32]	; (800258c <DMA1_Channel6_IRQHandler+0x64>)
 800256a:	2101      	movs	r1, #1
 800256c:	4620      	mov	r0, r4
 800256e:	f001 ff3b 	bl	80043e8 <I2C_GenerateSTOP>

		/* Perform a read on SR1 and SR2 register to clear eventualaly pending flags */
		(void)EEPROM_I2C->SR1;
 8002572:	8aa3      	ldrh	r3, [r4, #20]
		(void)EEPROM_I2C->SR2;
 8002574:	8b23      	ldrh	r3, [r4, #24]

		/* Reset the variable holding the number of data to be written */
		*EEPROMDataWritePointer = 0;
 8002576:	4b06      	ldr	r3, [pc, #24]	; (8002590 <DMA1_Channel6_IRQHandler+0x68>)
 8002578:	681b      	ldr	r3, [r3, #0]
 800257a:	2200      	movs	r2, #0
 800257c:	701a      	strb	r2, [r3, #0]
 800257e:	bd10      	pop	{r4, pc}
 8002580:	4002006c 	.word	0x4002006c
 8002584:	200000f0 	.word	0x200000f0
 8002588:	10000004 	.word	0x10000004
 800258c:	40005400 	.word	0x40005400
 8002590:	20000540 	.word	0x20000540

08002594 <EEPROM_EnterCriticalSection_UserCallback>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8002594:	b672      	cpsid	i
 8002596:	4770      	bx	lr

08002598 <EEPROM_ExitCriticalSection_UserCallback>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 8002598:	b662      	cpsie	i
 800259a:	4770      	bx	lr

0800259c <EEPROM_ReadBuffer>:
 *
 * @retval EEPROM_OK (0) if operation is correctly performed, else return value
 *         different from EEPROM_OK (0) or the timeout user callback.
 */
uint32_t EEPROM_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
{
 800259c:	b570      	push	{r4, r5, r6, lr}
 800259e:	4606      	mov	r6, r0
 80025a0:	460d      	mov	r5, r1
 80025a2:	4614      	mov	r4, r2
	/* Set the pointer to the Number of data to be read. This pointer will be used
      by the DMA Transfer Completer interrupt Handler in order to reset the
      variable to 0. User should check on this variable in order to know if the
      DMA transfer has been complete or not. */
	EEPROMDataReadPointer = NumByteToRead;
 80025a4:	4b80      	ldr	r3, [pc, #512]	; (80027a8 <EEPROM_ReadBuffer+0x20c>)
 80025a6:	601a      	str	r2, [r3, #0]

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
 80025a8:	f44f 4220 	mov.w	r2, #40960	; 0xa000
 80025ac:	4b7f      	ldr	r3, [pc, #508]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 80025ae:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80025b0:	e006      	b.n	80025c0 <EEPROM_ReadBuffer+0x24>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80025b2:	4a7e      	ldr	r2, [pc, #504]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 80025b4:	6813      	ldr	r3, [r2, #0]
 80025b6:	1e59      	subs	r1, r3, #1
 80025b8:	6011      	str	r1, [r2, #0]
 80025ba:	b90b      	cbnz	r3, 80025c0 <EEPROM_ReadBuffer+0x24>
 80025bc:	f7ff fd7e 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
      DMA transfer has been complete or not. */
	EEPROMDataReadPointer = NumByteToRead;

	/*!< While the bus is busy */
	EEPROMTimeout = EEPROM_LONG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BUSY))
 80025c0:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 80025c4:	487a      	ldr	r0, [pc, #488]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80025c6:	f001 ff49 	bl	800445c <I2C_GetFlagStatus>
 80025ca:	2800      	cmp	r0, #0
 80025cc:	d1f1      	bne.n	80025b2 <EEPROM_ReadBuffer+0x16>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 80025ce:	2101      	movs	r1, #1
 80025d0:	4877      	ldr	r0, [pc, #476]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80025d2:	f001 fefb 	bl	80043cc <I2C_GenerateSTART>

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80025d6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80025da:	4b74      	ldr	r3, [pc, #464]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 80025dc:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80025de:	e006      	b.n	80025ee <EEPROM_ReadBuffer+0x52>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80025e0:	4a72      	ldr	r2, [pc, #456]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 80025e2:	6813      	ldr	r3, [r2, #0]
 80025e4:	1e59      	subs	r1, r3, #1
 80025e6:	6011      	str	r1, [r2, #0]
 80025e8:	b90b      	cbnz	r3, 80025ee <EEPROM_ReadBuffer+0x52>
 80025ea:	f7ff fd67 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/*!< Send START condition */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80025ee:	4971      	ldr	r1, [pc, #452]	; (80027b4 <EEPROM_ReadBuffer+0x218>)
 80025f0:	486f      	ldr	r0, [pc, #444]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80025f2:	f001 ff25 	bl	8004440 <I2C_CheckEvent>
 80025f6:	2800      	cmp	r0, #0
 80025f8:	d0f2      	beq.n	80025e0 <EEPROM_ReadBuffer+0x44>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send EEPROM address for write */
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);
 80025fa:	4b6f      	ldr	r3, [pc, #444]	; (80027b8 <EEPROM_ReadBuffer+0x21c>)
 80025fc:	8819      	ldrh	r1, [r3, #0]
 80025fe:	2200      	movs	r2, #0
 8002600:	b2c9      	uxtb	r1, r1
 8002602:	486b      	ldr	r0, [pc, #428]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002604:	f001 ff12 	bl	800442c <I2C_Send7bitAddress>

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002608:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800260c:	4b67      	ldr	r3, [pc, #412]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 800260e:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8002610:	e006      	b.n	8002620 <EEPROM_ReadBuffer+0x84>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002612:	4a66      	ldr	r2, [pc, #408]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002614:	6813      	ldr	r3, [r2, #0]
 8002616:	1e59      	subs	r1, r3, #1
 8002618:	6011      	str	r1, [r2, #0]
 800261a:	b90b      	cbnz	r3, 8002620 <EEPROM_ReadBuffer+0x84>
 800261c:	f7ff fd4e 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/*!< Send EEPROM address for write */
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Transmitter);

	/*!< Test on EV6 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 8002620:	4966      	ldr	r1, [pc, #408]	; (80027bc <EEPROM_ReadBuffer+0x220>)
 8002622:	4863      	ldr	r0, [pc, #396]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002624:	f001 ff0c 	bl	8004440 <I2C_CheckEvent>
 8002628:	2800      	cmp	r0, #0
 800262a:	d0f2      	beq.n	8002612 <EEPROM_ReadBuffer+0x76>
	I2C_SendData(EEPROM_I2C, ReadAddr);

#elif defined (EEPROM_M24C64_32)

	/*!< Send the EEPROM's internal address to read from: MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));
 800262c:	0a29      	lsrs	r1, r5, #8
 800262e:	4860      	ldr	r0, [pc, #384]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002630:	f001 fef6 	bl	8004420 <I2C_SendData>

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002634:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002638:	4b5c      	ldr	r3, [pc, #368]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 800263a:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 800263c:	e006      	b.n	800264c <EEPROM_ReadBuffer+0xb0>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800263e:	4a5b      	ldr	r2, [pc, #364]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002640:	6813      	ldr	r3, [r2, #0]
 8002642:	1e59      	subs	r1, r3, #1
 8002644:	6011      	str	r1, [r2, #0]
 8002646:	b90b      	cbnz	r3, 800264c <EEPROM_ReadBuffer+0xb0>
 8002648:	f7ff fd38 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/*!< Send the EEPROM's internal address to read from: MSB of the address first */
	I2C_SendData(EEPROM_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 800264c:	495c      	ldr	r1, [pc, #368]	; (80027c0 <EEPROM_ReadBuffer+0x224>)
 800264e:	4858      	ldr	r0, [pc, #352]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002650:	f001 fef6 	bl	8004440 <I2C_CheckEvent>
 8002654:	2800      	cmp	r0, #0
 8002656:	d0f2      	beq.n	800263e <EEPROM_ReadBuffer+0xa2>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send the EEPROM's internal address to read from: LSB of the address */
	I2C_SendData(EEPROM_I2C, (uint8_t)(ReadAddr & 0x00FF));
 8002658:	b2e9      	uxtb	r1, r5
 800265a:	4855      	ldr	r0, [pc, #340]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 800265c:	f001 fee0 	bl	8004420 <I2C_SendData>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002660:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002664:	4b51      	ldr	r3, [pc, #324]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002666:	601a      	str	r2, [r3, #0]
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF) == RESET)
 8002668:	e006      	b.n	8002678 <EEPROM_ReadBuffer+0xdc>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800266a:	4a50      	ldr	r2, [pc, #320]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 800266c:	6813      	ldr	r3, [r2, #0]
 800266e:	1e59      	subs	r1, r3, #1
 8002670:	6011      	str	r1, [r2, #0]
 8002672:	b90b      	cbnz	r3, 8002678 <EEPROM_ReadBuffer+0xdc>
 8002674:	f7ff fd22 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>

#endif /*!< EEPROM_M24C08 */

	/*!< Test on EV8 and clear it */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_BTF) == RESET)
 8002678:	4952      	ldr	r1, [pc, #328]	; (80027c4 <EEPROM_ReadBuffer+0x228>)
 800267a:	484d      	ldr	r0, [pc, #308]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 800267c:	f001 feee 	bl	800445c <I2C_GetFlagStatus>
 8002680:	2800      	cmp	r0, #0
 8002682:	d0f2      	beq.n	800266a <EEPROM_ReadBuffer+0xce>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send STRAT condition a second time */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);
 8002684:	2101      	movs	r1, #1
 8002686:	484a      	ldr	r0, [pc, #296]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002688:	f001 fea0 	bl	80043cc <I2C_GenerateSTART>

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 800268c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002690:	4b46      	ldr	r3, [pc, #280]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002692:	601a      	str	r2, [r3, #0]
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 8002694:	e006      	b.n	80026a4 <EEPROM_ReadBuffer+0x108>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002696:	4a45      	ldr	r2, [pc, #276]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002698:	6813      	ldr	r3, [r2, #0]
 800269a:	1e59      	subs	r1, r3, #1
 800269c:	6011      	str	r1, [r2, #0]
 800269e:	b90b      	cbnz	r3, 80026a4 <EEPROM_ReadBuffer+0x108>
 80026a0:	f7ff fd0c 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/*!< Send STRAT condition a second time */
	I2C_GenerateSTART(EEPROM_I2C, ENABLE);

	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
	EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
	while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 80026a4:	4943      	ldr	r1, [pc, #268]	; (80027b4 <EEPROM_ReadBuffer+0x218>)
 80026a6:	4842      	ldr	r0, [pc, #264]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80026a8:	f001 feca 	bl	8004440 <I2C_CheckEvent>
 80026ac:	2800      	cmp	r0, #0
 80026ae:	d0f2      	beq.n	8002696 <EEPROM_ReadBuffer+0xfa>
	{
		if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
	}

	/*!< Send EEPROM address for read */
	I2C_Send7bitAddress(EEPROM_I2C, EEPROMAddress, I2C_Direction_Receiver);
 80026b0:	4b41      	ldr	r3, [pc, #260]	; (80027b8 <EEPROM_ReadBuffer+0x21c>)
 80026b2:	8819      	ldrh	r1, [r3, #0]
 80026b4:	2201      	movs	r2, #1
 80026b6:	b2c9      	uxtb	r1, r1
 80026b8:	483d      	ldr	r0, [pc, #244]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80026ba:	f001 feb7 	bl	800442c <I2C_Send7bitAddress>

	/* If number of data to be read is 1, then DMA couldn't be used */
	/* One Byte Master Reception procedure (POLLING) ---------------------------*/
	if ((uint16_t)(*NumByteToRead) < 2)
 80026be:	8823      	ldrh	r3, [r4, #0]
 80026c0:	2b01      	cmp	r3, #1
 80026c2:	d850      	bhi.n	8002766 <EEPROM_ReadBuffer+0x1ca>
	{
		/* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 80026c4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80026c8:	4b38      	ldr	r3, [pc, #224]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 80026ca:	601a      	str	r2, [r3, #0]
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET)
 80026cc:	e006      	b.n	80026dc <EEPROM_ReadBuffer+0x140>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 80026ce:	4a37      	ldr	r2, [pc, #220]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 80026d0:	6813      	ldr	r3, [r2, #0]
 80026d2:	1e59      	subs	r1, r3, #1
 80026d4:	6011      	str	r1, [r2, #0]
 80026d6:	b90b      	cbnz	r3, 80026dc <EEPROM_ReadBuffer+0x140>
 80026d8:	f7ff fcf0 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	/* One Byte Master Reception procedure (POLLING) ---------------------------*/
	if ((uint16_t)(*NumByteToRead) < 2)
	{
		/* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET)
 80026dc:	493a      	ldr	r1, [pc, #232]	; (80027c8 <EEPROM_ReadBuffer+0x22c>)
 80026de:	4834      	ldr	r0, [pc, #208]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80026e0:	f001 febc 	bl	800445c <I2C_GetFlagStatus>
 80026e4:	2800      	cmp	r0, #0
 80026e6:	d0f2      	beq.n	80026ce <EEPROM_ReadBuffer+0x132>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Disable Acknowledgement */
		I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);
 80026e8:	4d31      	ldr	r5, [pc, #196]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 80026ea:	2100      	movs	r1, #0
 80026ec:	4628      	mov	r0, r5
 80026ee:	f001 fe89 	bl	8004404 <I2C_AcknowledgeConfig>

		/* Call User callback for critical section start (should typically disable interrupts) */
		EEPROM_EnterCriticalSection_UserCallback();
 80026f2:	f7ff ff4f 	bl	8002594 <EEPROM_EnterCriticalSection_UserCallback>

		/* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
		(void)EEPROM_I2C->SR2;
 80026f6:	8b2b      	ldrh	r3, [r5, #24]

		/*!< Send STOP Condition */
		I2C_GenerateSTOP(EEPROM_I2C, ENABLE);
 80026f8:	2101      	movs	r1, #1
 80026fa:	4628      	mov	r0, r5
 80026fc:	f001 fe74 	bl	80043e8 <I2C_GenerateSTOP>

		/* Call User callback for critical section end (should typically re-enable interrupts) */
		EEPROM_ExitCriticalSection_UserCallback();
 8002700:	f7ff ff4a 	bl	8002598 <EEPROM_ExitCriticalSection_UserCallback>

		/* Wait for the byte to be received */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002704:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002708:	4b28      	ldr	r3, [pc, #160]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 800270a:	601a      	str	r2, [r3, #0]
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_RXNE) == RESET)
 800270c:	e006      	b.n	800271c <EEPROM_ReadBuffer+0x180>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 800270e:	4a27      	ldr	r2, [pc, #156]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002710:	6813      	ldr	r3, [r2, #0]
 8002712:	1e59      	subs	r1, r3, #1
 8002714:	6011      	str	r1, [r2, #0]
 8002716:	b90b      	cbnz	r3, 800271c <EEPROM_ReadBuffer+0x180>
 8002718:	f7ff fcd0 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
		/* Call User callback for critical section end (should typically re-enable interrupts) */
		EEPROM_ExitCriticalSection_UserCallback();

		/* Wait for the byte to be received */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_RXNE) == RESET)
 800271c:	492b      	ldr	r1, [pc, #172]	; (80027cc <EEPROM_ReadBuffer+0x230>)
 800271e:	4824      	ldr	r0, [pc, #144]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002720:	f001 fe9c 	bl	800445c <I2C_GetFlagStatus>
 8002724:	2800      	cmp	r0, #0
 8002726:	d0f2      	beq.n	800270e <EEPROM_ReadBuffer+0x172>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Read the byte received from the EEPROM */
		*pBuffer = I2C_ReceiveData(EEPROM_I2C);
 8002728:	4821      	ldr	r0, [pc, #132]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 800272a:	f001 fe7b 	bl	8004424 <I2C_ReceiveData>
 800272e:	7030      	strb	r0, [r6, #0]

		/*!< Decrement the read bytes counter */
		(uint16_t)(*NumByteToRead)--;
 8002730:	8823      	ldrh	r3, [r4, #0]
 8002732:	3b01      	subs	r3, #1
 8002734:	8023      	strh	r3, [r4, #0]

		/* Wait to make sure that STOP control bit has been cleared */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002736:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800273a:	4b1c      	ldr	r3, [pc, #112]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 800273c:	601a      	str	r2, [r3, #0]
		while(EEPROM_I2C->CR1 & I2C_CR1_STOP)
 800273e:	e006      	b.n	800274e <EEPROM_ReadBuffer+0x1b2>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002740:	4a1a      	ldr	r2, [pc, #104]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002742:	6813      	ldr	r3, [r2, #0]
 8002744:	1e59      	subs	r1, r3, #1
 8002746:	6011      	str	r1, [r2, #0]
 8002748:	b90b      	cbnz	r3, 800274e <EEPROM_ReadBuffer+0x1b2>
 800274a:	f7ff fcb7 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
		/*!< Decrement the read bytes counter */
		(uint16_t)(*NumByteToRead)--;

		/* Wait to make sure that STOP control bit has been cleared */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(EEPROM_I2C->CR1 & I2C_CR1_STOP)
 800274e:	4b18      	ldr	r3, [pc, #96]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002750:	881b      	ldrh	r3, [r3, #0]
 8002752:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002756:	b29b      	uxth	r3, r3
 8002758:	2b00      	cmp	r3, #0
 800275a:	d1f1      	bne.n	8002740 <EEPROM_ReadBuffer+0x1a4>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/*!< Re-Enable Acknowledgement to be ready for another reception */
		I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);
 800275c:	2101      	movs	r1, #1
 800275e:	4814      	ldr	r0, [pc, #80]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002760:	f001 fe50 	bl	8004404 <I2C_AcknowledgeConfig>
 8002764:	e01e      	b.n	80027a4 <EEPROM_ReadBuffer+0x208>
	}
	else/* More than one Byte Master Reception procedure (DMA) -----------------*/
	{
		/*!< Test on EV6 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
 8002766:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800276a:	4b10      	ldr	r3, [pc, #64]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 800276c:	601a      	str	r2, [r3, #0]
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 800276e:	e006      	b.n	800277e <EEPROM_ReadBuffer+0x1e2>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
 8002770:	4a0e      	ldr	r2, [pc, #56]	; (80027ac <EEPROM_ReadBuffer+0x210>)
 8002772:	6813      	ldr	r3, [r2, #0]
 8002774:	1e59      	subs	r1, r3, #1
 8002776:	6011      	str	r1, [r2, #0]
 8002778:	b90b      	cbnz	r3, 800277e <EEPROM_ReadBuffer+0x1e2>
 800277a:	f7ff fc9f 	bl	80020bc <EEPROM_TIMEOUT_UserCallback>
	}
	else/* More than one Byte Master Reception procedure (DMA) -----------------*/
	{
		/*!< Test on EV6 and clear it */
		EEPROMTimeout = EEPROM_FLAG_TIMEOUT;
		while(!I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 800277e:	4914      	ldr	r1, [pc, #80]	; (80027d0 <EEPROM_ReadBuffer+0x234>)
 8002780:	480b      	ldr	r0, [pc, #44]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002782:	f001 fe5d 	bl	8004440 <I2C_CheckEvent>
 8002786:	2800      	cmp	r0, #0
 8002788:	d0f2      	beq.n	8002770 <EEPROM_ReadBuffer+0x1d4>
		{
			if((EEPROMTimeout--) == 0) return EEPROM_TIMEOUT_UserCallback();
		}

		/* Configure the DMA Rx Channel with the buffer address and the buffer size */
		EEPROM_LowLevel_DMAConfig((uint32_t)pBuffer, (uint16_t)(*NumByteToRead), EEPROM_DIRECTION_RX);
 800278a:	2201      	movs	r2, #1
 800278c:	8821      	ldrh	r1, [r4, #0]
 800278e:	4630      	mov	r0, r6
 8002790:	f7ff fc28 	bl	8001fe4 <EEPROM_LowLevel_DMAConfig>

		/* Inform the DMA that the next End Of Transfer Signal will be the last one */
		I2C_DMALastTransferCmd(EEPROM_I2C, ENABLE);
 8002794:	2101      	movs	r1, #1
 8002796:	4806      	ldr	r0, [pc, #24]	; (80027b0 <EEPROM_ReadBuffer+0x214>)
 8002798:	f001 fe0a 	bl	80043b0 <I2C_DMALastTransferCmd>

		/* Enable the DMA Rx Channel */
		DMA_Cmd(EEPROM_I2C_DMA_CHANNEL_RX, ENABLE);
 800279c:	2101      	movs	r1, #1
 800279e:	480d      	ldr	r0, [pc, #52]	; (80027d4 <EEPROM_ReadBuffer+0x238>)
 80027a0:	f001 fc08 	bl	8003fb4 <DMA_Cmd>
	}

	/* If all operations OK, return EEPROM_OK (0) */
	return EEPROM_OK;
}
 80027a4:	2000      	movs	r0, #0
 80027a6:	bd70      	pop	{r4, r5, r6, pc}
 80027a8:	20000544 	.word	0x20000544
 80027ac:	200000f0 	.word	0x200000f0
 80027b0:	40005400 	.word	0x40005400
 80027b4:	00030001 	.word	0x00030001
 80027b8:	20000394 	.word	0x20000394
 80027bc:	00070082 	.word	0x00070082
 80027c0:	00070084 	.word	0x00070084
 80027c4:	10000004 	.word	0x10000004
 80027c8:	10000002 	.word	0x10000002
 80027cc:	10000040 	.word	0x10000040
 80027d0:	00030002 	.word	0x00030002
 80027d4:	40020080 	.word	0x40020080

080027d8 <ADCT_AT24C64_ReadOneByte>:
{
	__enable_irq();
}

uint8_t ADCT_AT24C64_ReadOneByte(uint16_t Address_ui16 )
{
 80027d8:	b500      	push	{lr}
 80027da:	b083      	sub	sp, #12
	volatile uint16_t NumDataRead_ui16 = 1;
 80027dc:	aa02      	add	r2, sp, #8
 80027de:	2301      	movs	r3, #1
 80027e0:	f822 3d02 	strh.w	r3, [r2, #-2]!
	uint8_t data_ui8;
	EEPROM_ReadBuffer(&data_ui8, Address_ui16, (uint16_t *)(&NumDataRead_ui16));
 80027e4:	4601      	mov	r1, r0
 80027e6:	f10d 0005 	add.w	r0, sp, #5
 80027ea:	f7ff fed7 	bl	800259c <EEPROM_ReadBuffer>
	while(NumDataRead_ui16 >0)
 80027ee:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80027f2:	b29b      	uxth	r3, r3
 80027f4:	2b00      	cmp	r3, #0
 80027f6:	d1fa      	bne.n	80027ee <ADCT_AT24C64_ReadOneByte+0x16>
	{

	}
	return data_ui8;
}
 80027f8:	f89d 0005 	ldrb.w	r0, [sp, #5]
 80027fc:	b003      	add	sp, #12
 80027fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8002802:	bf00      	nop

08002804 <ADCT_AT24C64_WriteTwoBytes>:
	{}
	return (pDataui8[1] * 256 + pDataui8[0]);
}

void ADCT_AT24C64_WriteTwoBytes(uint16_t ui16MemAddr , uint16_t ui16data)
{
 8002804:	b500      	push	{lr}
 8002806:	b083      	sub	sp, #12
	uint8_t txbuffer_a[2] = {(uint8_t)(ui16data%256), (uint8_t)(ui16data >> 8) };
 8002808:	f88d 1004 	strb.w	r1, [sp, #4]
 800280c:	0a09      	lsrs	r1, r1, #8
 800280e:	f88d 1005 	strb.w	r1, [sp, #5]
	EEPROM_WriteBuffer(txbuffer_a , ui16MemAddr , 2 );
 8002812:	2202      	movs	r2, #2
 8002814:	4601      	mov	r1, r0
 8002816:	a801      	add	r0, sp, #4
 8002818:	f7ff fd54 	bl	80022c4 <EEPROM_WriteBuffer>
}
 800281c:	b003      	add	sp, #12
 800281e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002822:	bf00      	nop

08002824 <ADCT_AT24C64_WriteOneBytes>:
void ADCT_AT24C64_WriteOneBytes(uint16_t ui16MemAddr, uint8_t ui8data)
{
 8002824:	b500      	push	{lr}
 8002826:	b083      	sub	sp, #12
 8002828:	ab02      	add	r3, sp, #8
 800282a:	f803 1d01 	strb.w	r1, [r3, #-1]!
	EEPROM_WriteBuffer(&ui8data , ui16MemAddr , 1 );
 800282e:	2201      	movs	r2, #1
 8002830:	4601      	mov	r1, r0
 8002832:	4618      	mov	r0, r3
 8002834:	f7ff fd46 	bl	80022c4 <EEPROM_WriteBuffer>
}
 8002838:	b003      	add	sp, #12
 800283a:	f85d fb04 	ldr.w	pc, [sp], #4
 800283e:	bf00      	nop

08002840 <ADCT_BGS_Button_Init>:
TM_BUTTON_t* UpButton;
TM_BUTTON_t* DownButton;


void ADCT_BGS_Button_Init(void )
{
 8002840:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002842:	b083      	sub	sp, #12
	/* Enter button initialization  */
	EnterButton = TM_BUTTON_Init(ENTER_BUTTON_GPIO_PORT,ENTER_BUTTON_GPIO_CLK,ENTER_BUTTON_PIN, 0, BUTTON_ENTER_Callback);
 8002844:	4c23      	ldr	r4, [pc, #140]	; (80028d4 <ADCT_BGS_Button_Init+0x94>)
 8002846:	4b24      	ldr	r3, [pc, #144]	; (80028d8 <ADCT_BGS_Button_Init+0x98>)
 8002848:	9300      	str	r3, [sp, #0]
 800284a:	2300      	movs	r3, #0
 800284c:	2201      	movs	r2, #1
 800284e:	2108      	movs	r1, #8
 8002850:	4620      	mov	r0, r4
 8002852:	f000 f851 	bl	80028f8 <TM_BUTTON_Init>
 8002856:	4f21      	ldr	r7, [pc, #132]	; (80028dc <ADCT_BGS_Button_Init+0x9c>)
 8002858:	6038      	str	r0, [r7, #0]
	/* ESC button initialization */
	CancelButton = TM_BUTTON_Init(ESC_BUTTON_GPIO_PORT,ESC_BUTTON_GPIO_CLK,ESC_BUTTON_PIN, 0, BUTTON_CANCEL_Callback);
 800285a:	4b21      	ldr	r3, [pc, #132]	; (80028e0 <ADCT_BGS_Button_Init+0xa0>)
 800285c:	9300      	str	r3, [sp, #0]
 800285e:	2300      	movs	r3, #0
 8002860:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002864:	2108      	movs	r1, #8
 8002866:	4620      	mov	r0, r4
 8002868:	f000 f846 	bl	80028f8 <TM_BUTTON_Init>
 800286c:	4e1d      	ldr	r6, [pc, #116]	; (80028e4 <ADCT_BGS_Button_Init+0xa4>)
 800286e:	6030      	str	r0, [r6, #0]
	/* Up button initialization */
	UpButton = TM_BUTTON_Init(UP_BUTTON_GPIO_PORT,UP_BUTTON_GPIO_CLK,UP_BUTTON_PIN, 0, BUTTON_UP_Callback);
 8002870:	4b1d      	ldr	r3, [pc, #116]	; (80028e8 <ADCT_BGS_Button_Init+0xa8>)
 8002872:	9300      	str	r3, [sp, #0]
 8002874:	2300      	movs	r3, #0
 8002876:	2204      	movs	r2, #4
 8002878:	2108      	movs	r1, #8
 800287a:	4620      	mov	r0, r4
 800287c:	f000 f83c 	bl	80028f8 <TM_BUTTON_Init>
 8002880:	4d1a      	ldr	r5, [pc, #104]	; (80028ec <ADCT_BGS_Button_Init+0xac>)
 8002882:	6028      	str	r0, [r5, #0]
	/* Down button initialization */
	DownButton = TM_BUTTON_Init(DOWN_BUTTON_GPIO_PORT,DOWN_BUTTON_GPIO_CLK,DOWN_BUTTON_PIN, 0, BUTTON_DOWN_Callback);
 8002884:	4b1a      	ldr	r3, [pc, #104]	; (80028f0 <ADCT_BGS_Button_Init+0xb0>)
 8002886:	9300      	str	r3, [sp, #0]
 8002888:	2300      	movs	r3, #0
 800288a:	2202      	movs	r2, #2
 800288c:	2108      	movs	r1, #8
 800288e:	4620      	mov	r0, r4
 8002890:	f000 f832 	bl	80028f8 <TM_BUTTON_Init>
 8002894:	4c17      	ldr	r4, [pc, #92]	; (80028f4 <ADCT_BGS_Button_Init+0xb4>)
 8002896:	6020      	str	r0, [r4, #0]

	TM_BUTTON_SetPressTime(EnterButton, 2000, 3000);
 8002898:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800289c:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80028a0:	6838      	ldr	r0, [r7, #0]
 80028a2:	f000 f86b 	bl	800297c <TM_BUTTON_SetPressTime>
	TM_BUTTON_SetPressTime(CancelButton, 2000, 3000);
 80028a6:	f640 32b8 	movw	r2, #3000	; 0xbb8
 80028aa:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80028ae:	6830      	ldr	r0, [r6, #0]
 80028b0:	f000 f864 	bl	800297c <TM_BUTTON_SetPressTime>
	TM_BUTTON_SetPressTime(UpButton, 2000, 3000);
 80028b4:	f640 32b8 	movw	r2, #3000	; 0xbb8
 80028b8:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80028bc:	6828      	ldr	r0, [r5, #0]
 80028be:	f000 f85d 	bl	800297c <TM_BUTTON_SetPressTime>
	TM_BUTTON_SetPressTime(DownButton, 2000, 3000);
 80028c2:	f640 32b8 	movw	r2, #3000	; 0xbb8
 80028c6:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80028ca:	6820      	ldr	r0, [r4, #0]
 80028cc:	f000 f856 	bl	800297c <TM_BUTTON_SetPressTime>
}
 80028d0:	b003      	add	sp, #12
 80028d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80028d4:	40010c00 	.word	0x40010c00
 80028d8:	08000239 	.word	0x08000239
 80028dc:	20000584 	.word	0x20000584
 80028e0:	08000269 	.word	0x08000269
 80028e4:	20000578 	.word	0x20000578
 80028e8:	0800029d 	.word	0x0800029d
 80028ec:	2000057c 	.word	0x2000057c
 80028f0:	080002d1 	.word	0x080002d1
 80028f4:	20000580 	.word	0x20000580

080028f8 <TM_BUTTON_Init>:
static TM_BUTTON_INT_t Buttons;

/* Internal functions */
static void TM_BUTTON_INT_CheckButton(TM_BUTTON_t* ButtonStruct);

TM_BUTTON_t* TM_BUTTON_Init(GPIO_TypeDef* GPIOx, uint32_t GPIO_CLOCK, uint16_t GPIO_Pin, uint8_t ButtonState, void (*ButtonHandler)(TM_BUTTON_t*, TM_BUTTON_PressType_t)) {
 80028f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80028fc:	b082      	sub	sp, #8
	TM_BUTTON_t* ButtonStruct;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* Check if available */
	if (Buttons.ButtonsCount >= BUTTON_MAX_BUTTONS) {
 80028fe:	4c1e      	ldr	r4, [pc, #120]	; (8002978 <TM_BUTTON_Init+0x80>)
 8002900:	8d24      	ldrh	r4, [r4, #40]	; 0x28
 8002902:	2c09      	cmp	r4, #9
 8002904:	d832      	bhi.n	800296c <TM_BUTTON_Init+0x74>
 8002906:	461d      	mov	r5, r3
 8002908:	4617      	mov	r7, r2
 800290a:	4688      	mov	r8, r1
 800290c:	4606      	mov	r6, r0
		return NULL;
	}
	
	/* Allocate memory for button */
	ButtonStruct = (TM_BUTTON_t *) malloc(sizeof(TM_BUTTON_t));
 800290e:	2018      	movs	r0, #24
 8002910:	f002 fb08 	bl	8004f24 <malloc>
	
	/* Check if allocated */
	if (ButtonStruct == NULL) {
 8002914:	4604      	mov	r4, r0
 8002916:	b358      	cbz	r0, 8002970 <TM_BUTTON_Init+0x78>
		return NULL;
	}
	
	/* Save settings */
	ButtonStruct->GPIOx = GPIOx;
 8002918:	6006      	str	r6, [r0, #0]
	ButtonStruct->GPIO_Pin = GPIO_Pin;
 800291a:	8087      	strh	r7, [r0, #4]
	ButtonStruct->GPIO_State = ButtonState ? 1 : 0;
 800291c:	1c2b      	adds	r3, r5, #0
 800291e:	bf18      	it	ne
 8002920:	2301      	movne	r3, #1
 8002922:	7183      	strb	r3, [r0, #6]
	ButtonStruct->ButtonHandler = ButtonHandler;
 8002924:	9b08      	ldr	r3, [sp, #32]
 8002926:	6083      	str	r3, [r0, #8]
	ButtonStruct->State = BUTTON_STATE_START;
 8002928:	2300      	movs	r3, #0
 800292a:	7443      	strb	r3, [r0, #17]
	
	/* Set default values */
	ButtonStruct->PressNormalTime = BUTTON_NORMAL_PRESS_TIME;
 800292c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8002930:	8283      	strh	r3, [r0, #20]
	ButtonStruct->PressLongTime = BUTTON_LONG_PRESS_TIME;
 8002932:	f240 53dc 	movw	r3, #1500	; 0x5dc
 8002936:	82c3      	strh	r3, [r0, #22]
	ButtonStruct->PressDebounceTime = BUTTON_DEBOUNCE_TIME;
 8002938:	2305      	movs	r3, #5
 800293a:	8243      	strh	r3, [r0, #18]
	
	/* Init GPIO pin as input with proper pull resistor */
	RCC_APB2PeriphClockCmd(GPIO_CLOCK, ENABLE);
 800293c:	2101      	movs	r1, #1
 800293e:	4640      	mov	r0, r8
 8002940:	f001 fe92 	bl	8004668 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin;
 8002944:	f8ad 7004 	strh.w	r7, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002948:	2303      	movs	r3, #3
 800294a:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 800294e:	2328      	movs	r3, #40	; 0x28
 8002950:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(GPIOx, &GPIO_InitStructure);
 8002954:	a901      	add	r1, sp, #4
 8002956:	4630      	mov	r0, r6
 8002958:	f001 fbe4 	bl	8004124 <GPIO_Init>
	/* Save button */
	Buttons.Buttons[Buttons.ButtonsCount++] = ButtonStruct;
 800295c:	4b06      	ldr	r3, [pc, #24]	; (8002978 <TM_BUTTON_Init+0x80>)
 800295e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8002960:	1c51      	adds	r1, r2, #1
 8002962:	8519      	strh	r1, [r3, #40]	; 0x28
 8002964:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
	
	/* Return button pointer */
	return ButtonStruct;
 8002968:	4620      	mov	r0, r4
 800296a:	e002      	b.n	8002972 <TM_BUTTON_Init+0x7a>
	TM_BUTTON_t* ButtonStruct;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* Check if available */
	if (Buttons.ButtonsCount >= BUTTON_MAX_BUTTONS) {
		return NULL;
 800296c:	2000      	movs	r0, #0
 800296e:	e000      	b.n	8002972 <TM_BUTTON_Init+0x7a>
	/* Allocate memory for button */
	ButtonStruct = (TM_BUTTON_t *) malloc(sizeof(TM_BUTTON_t));
	
	/* Check if allocated */
	if (ButtonStruct == NULL) {
		return NULL;
 8002970:	2000      	movs	r0, #0
	/* Save button */
	Buttons.Buttons[Buttons.ButtonsCount++] = ButtonStruct;
	
	/* Return button pointer */
	return ButtonStruct;
}
 8002972:	b002      	add	sp, #8
 8002974:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002978:	20000398 	.word	0x20000398

0800297c <TM_BUTTON_SetPressTime>:

TM_BUTTON_t* TM_BUTTON_SetPressTime(TM_BUTTON_t* ButtonStruct, uint16_t Normal, uint16_t Long) {
	/* Set values */
	ButtonStruct->PressNormalTime = Normal;
 800297c:	8281      	strh	r1, [r0, #20]
	ButtonStruct->PressLongTime = Long;
 800297e:	82c2      	strh	r2, [r0, #22]
	
	/* Return pointer */
	return ButtonStruct;
}
 8002980:	4770      	bx	lr
 8002982:	bf00      	nop

08002984 <eMBFuncReadCoils>:
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
 8002984:	880b      	ldrh	r3, [r1, #0]
 8002986:	2b05      	cmp	r3, #5
 8002988:	d134      	bne.n	80029f4 <eMBFuncReadCoils+0x70>

#if MB_FUNC_READ_COILS_ENABLED == 1

eMBException
eMBFuncReadCoils( UCHAR * pucFrame, USHORT * usLen )
{
 800298a:	b570      	push	{r4, r5, r6, lr}
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
 800298c:	7842      	ldrb	r2, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
 800298e:	7883      	ldrb	r3, [r0, #2]
 8002990:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegAddress++;
 8002994:	3301      	adds	r3, #1
 8002996:	b29c      	uxth	r4, r3

        usCoilCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] << 8 );
 8002998:	78c2      	ldrb	r2, [r0, #3]
        usCoilCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF + 1] );
 800299a:	7903      	ldrb	r3, [r0, #4]
 800299c:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usCoilCount >= 1 ) &&
 80029a0:	1e53      	subs	r3, r2, #1
 80029a2:	b29b      	uxth	r3, r3
 80029a4:	f240 75ce 	movw	r5, #1998	; 0x7ce
 80029a8:	42ab      	cmp	r3, r5
 80029aa:	d825      	bhi.n	80029f8 <eMBFuncReadCoils+0x74>
            ( usCoilCount < MB_PDU_FUNC_READ_COILCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
 80029ac:	2300      	movs	r3, #0
 80029ae:	800b      	strh	r3, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_COILS;
 80029b0:	2301      	movs	r3, #1
 80029b2:	7003      	strb	r3, [r0, #0]
            *usLen += 1;
 80029b4:	880b      	ldrh	r3, [r1, #0]
 80029b6:	3301      	adds	r3, #1
 80029b8:	800b      	strh	r3, [r1, #0]

            /* Test if the quantity of coils is a multiple of 8. If not last
             * byte is only partially field with unused coils set to zero. */
            if( ( usCoilCount & 0x0007 ) != 0 )
 80029ba:	f012 0f07 	tst.w	r2, #7
 80029be:	d004      	beq.n	80029ca <eMBFuncReadCoils+0x46>
            {
                ucNBytes = ( UCHAR )( usCoilCount / 8 + 1 );
 80029c0:	f3c2 05c7 	ubfx	r5, r2, #3, #8
 80029c4:	3501      	adds	r5, #1
 80029c6:	b2ed      	uxtb	r5, r5
 80029c8:	e001      	b.n	80029ce <eMBFuncReadCoils+0x4a>
            }
            else
            {
                ucNBytes = ( UCHAR )( usCoilCount / 8 );
 80029ca:	f3c2 05c7 	ubfx	r5, r2, #3, #8
 80029ce:	460e      	mov	r6, r1
            }
            *pucFrameCur++ = ucNBytes;
 80029d0:	7045      	strb	r5, [r0, #1]
            *usLen += 1;
 80029d2:	880b      	ldrh	r3, [r1, #0]
 80029d4:	3301      	adds	r3, #1
 80029d6:	800b      	strh	r3, [r1, #0]

            eRegStatus =
 80029d8:	2300      	movs	r3, #0
 80029da:	4621      	mov	r1, r4
 80029dc:	3002      	adds	r0, #2
 80029de:	f7fd ffad 	bl	800093c <eMBRegCoilsCB>
                eMBRegCoilsCB( pucFrameCur, usRegAddress, usCoilCount,
                               MB_REG_READ );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 80029e2:	b110      	cbz	r0, 80029ea <eMBFuncReadCoils+0x66>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 80029e4:	f000 f9c6 	bl	8002d74 <prveMBError2Exception>
 80029e8:	bd70      	pop	{r4, r5, r6, pc}
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen += ucNBytes;;
 80029ea:	8833      	ldrh	r3, [r6, #0]
 80029ec:	441d      	add	r5, r3
 80029ee:	8035      	strh	r5, [r6, #0]
    USHORT          usRegAddress;
    USHORT          usCoilCount;
    UCHAR           ucNBytes;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 80029f0:	2000      	movs	r0, #0
 80029f2:	bd70      	pop	{r4, r5, r6, pc}
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 80029f4:	2003      	movs	r0, #3
    }
    return eStatus;
}
 80029f6:	4770      	bx	lr
                *usLen += ucNBytes;;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 80029f8:	2003      	movs	r0, #3
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 80029fa:	bd70      	pop	{r4, r5, r6, pc}

080029fc <eMBFuncWriteCoil>:
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
 80029fc:	880b      	ldrh	r3, [r1, #0]
 80029fe:	2b05      	cmp	r3, #5
 8002a00:	d123      	bne.n	8002a4a <eMBFuncWriteCoil+0x4e>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
 8002a02:	7841      	ldrb	r1, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 8002a04:	7883      	ldrb	r3, [r0, #2]
 8002a06:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
        usRegAddress++;
 8002a0a:	3101      	adds	r1, #1
 8002a0c:	b289      	uxth	r1, r1

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
 8002a0e:	7903      	ldrb	r3, [r0, #4]
 8002a10:	b9eb      	cbnz	r3, 8002a4e <eMBFuncWriteCoil+0x52>
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
 8002a12:	78c2      	ldrb	r2, [r0, #3]
 8002a14:	1e53      	subs	r3, r2, #1
 8002a16:	b2db      	uxtb	r3, r3
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
        usRegAddress++;

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
 8002a18:	2bfd      	cmp	r3, #253	; 0xfd
 8002a1a:	d91a      	bls.n	8002a52 <eMBFuncWriteCoil+0x56>
}

#if MB_FUNC_WRITE_COIL_ENABLED > 0
eMBException
eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
 8002a1c:	b500      	push	{lr}
 8002a1e:	b083      	sub	sp, #12

        if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
            ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
              ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
        {
            ucBuf[1] = 0;
 8002a20:	2300      	movs	r3, #0
 8002a22:	f88d 3005 	strb.w	r3, [sp, #5]
            if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
 8002a26:	2aff      	cmp	r2, #255	; 0xff
 8002a28:	d103      	bne.n	8002a32 <eMBFuncWriteCoil+0x36>
            {
                ucBuf[0] = 1;
 8002a2a:	2301      	movs	r3, #1
 8002a2c:	f88d 3004 	strb.w	r3, [sp, #4]
 8002a30:	e002      	b.n	8002a38 <eMBFuncWriteCoil+0x3c>
            }
            else
            {
                ucBuf[0] = 0;
 8002a32:	2300      	movs	r3, #0
 8002a34:	f88d 3004 	strb.w	r3, [sp, #4]
            }
            eRegStatus =
 8002a38:	2301      	movs	r3, #1
 8002a3a:	461a      	mov	r2, r3
 8002a3c:	a801      	add	r0, sp, #4
 8002a3e:	f7fd ff7d 	bl	800093c <eMBRegCoilsCB>
                eMBRegCoilsCB( &ucBuf[0], usRegAddress, 1, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8002a42:	b140      	cbz	r0, 8002a56 <eMBFuncWriteCoil+0x5a>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002a44:	f000 f996 	bl	8002d74 <prveMBError2Exception>
 8002a48:	e006      	b.n	8002a58 <eMBFuncWriteCoil+0x5c>
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002a4a:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8002a4c:	4770      	bx	lr
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002a4e:	2003      	movs	r0, #3
 8002a50:	4770      	bx	lr
 8002a52:	2003      	movs	r0, #3
 8002a54:	4770      	bx	lr
eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    UCHAR           ucBuf[2];

    eMBException    eStatus = MB_EX_NONE;
 8002a56:	2000      	movs	r0, #0
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002a58:	b003      	add	sp, #12
 8002a5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a5e:	bf00      	nop

08002a60 <eMBFuncWriteMultipleCoils>:
    UCHAR           ucByteCountVerify;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
 8002a60:	880b      	ldrh	r3, [r1, #0]
 8002a62:	2b05      	cmp	r3, #5
 8002a64:	d92a      	bls.n	8002abc <eMBFuncWriteMultipleCoils+0x5c>
#endif

#if MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED > 0
eMBException
eMBFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
{
 8002a66:	b570      	push	{r4, r5, r6, lr}
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
 8002a68:	7842      	ldrb	r2, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
 8002a6a:	7883      	ldrb	r3, [r0, #2]
 8002a6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegAddress++;
 8002a70:	3301      	adds	r3, #1
 8002a72:	b29d      	uxth	r5, r3

        usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
 8002a74:	78c2      	ldrb	r2, [r0, #3]
        usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
 8002a76:	7903      	ldrb	r3, [r0, #4]
 8002a78:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        ucByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
 8002a7c:	7946      	ldrb	r6, [r0, #5]

        /* Compute the number of expected bytes in the request. */
        if( ( usCoilCnt & 0x0007 ) != 0 )
 8002a7e:	f012 0f07 	tst.w	r2, #7
 8002a82:	d004      	beq.n	8002a8e <eMBFuncWriteMultipleCoils+0x2e>
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
 8002a84:	f3c2 04c7 	ubfx	r4, r2, #3, #8
 8002a88:	3401      	adds	r4, #1
 8002a8a:	b2e4      	uxtb	r4, r4
 8002a8c:	e001      	b.n	8002a92 <eMBFuncWriteMultipleCoils+0x32>
        }
        else
        {
            ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
 8002a8e:	f3c2 04c7 	ubfx	r4, r2, #3, #8
        }

        if( ( usCoilCnt >= 1 ) &&
 8002a92:	1e53      	subs	r3, r2, #1
 8002a94:	b29b      	uxth	r3, r3
 8002a96:	f5b3 6ff6 	cmp.w	r3, #1968	; 0x7b0
 8002a9a:	d211      	bcs.n	8002ac0 <eMBFuncWriteMultipleCoils+0x60>
            ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
 8002a9c:	42b4      	cmp	r4, r6
 8002a9e:	d111      	bne.n	8002ac4 <eMBFuncWriteMultipleCoils+0x64>
 8002aa0:	460c      	mov	r4, r1
            ( ucByteCountVerify == ucByteCount ) )
        {
            eRegStatus =
 8002aa2:	2301      	movs	r3, #1
 8002aa4:	4629      	mov	r1, r5
 8002aa6:	3006      	adds	r0, #6
 8002aa8:	f7fd ff48 	bl	800093c <eMBRegCoilsCB>
                eMBRegCoilsCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                               usRegAddress, usCoilCnt, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8002aac:	b110      	cbz	r0, 8002ab4 <eMBFuncWriteMultipleCoils+0x54>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002aae:	f000 f961 	bl	8002d74 <prveMBError2Exception>
 8002ab2:	bd70      	pop	{r4, r5, r6, pc}
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
 8002ab4:	2305      	movs	r3, #5
 8002ab6:	8023      	strh	r3, [r4, #0]
    USHORT          usRegAddress;
    USHORT          usCoilCnt;
    UCHAR           ucByteCount;
    UCHAR           ucByteCountVerify;

    eMBException    eStatus = MB_EX_NONE;
 8002ab8:	2000      	movs	r0, #0
 8002aba:	bd70      	pop	{r4, r5, r6, pc}
    }
    else
    {
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002abc:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8002abe:	4770      	bx	lr
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002ac0:	2003      	movs	r0, #3
 8002ac2:	bd70      	pop	{r4, r5, r6, pc}
 8002ac4:	2003      	movs	r0, #3
        /* Can't be a valid write coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002ac6:	bd70      	pop	{r4, r5, r6, pc}

08002ac8 <eMBFuncReadDiscreteInputs>:

#if MB_FUNC_READ_COILS_ENABLED > 0

eMBException
eMBFuncReadDiscreteInputs( UCHAR * pucFrame, USHORT * usLen )
{
 8002ac8:	b538      	push	{r3, r4, r5, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
 8002aca:	880b      	ldrh	r3, [r1, #0]
 8002acc:	2b05      	cmp	r3, #5
 8002ace:	d132      	bne.n	8002b36 <eMBFuncReadDiscreteInputs+0x6e>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
 8002ad0:	7842      	ldrb	r2, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
 8002ad2:	7883      	ldrb	r3, [r0, #2]
 8002ad4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegAddress++;
 8002ad8:	3301      	adds	r3, #1
 8002ada:	b29b      	uxth	r3, r3

        usDiscreteCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF] << 8 );
 8002adc:	78c4      	ldrb	r4, [r0, #3]
        usDiscreteCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF + 1] );
 8002ade:	7902      	ldrb	r2, [r0, #4]
 8002ae0:	ea42 2204 	orr.w	r2, r2, r4, lsl #8

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usDiscreteCnt >= 1 ) &&
 8002ae4:	1e54      	subs	r4, r2, #1
 8002ae6:	b2a4      	uxth	r4, r4
 8002ae8:	f240 75ce 	movw	r5, #1998	; 0x7ce
 8002aec:	42ac      	cmp	r4, r5
 8002aee:	d824      	bhi.n	8002b3a <eMBFuncReadDiscreteInputs+0x72>
            ( usDiscreteCnt < MB_PDU_FUNC_READ_DISCCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
 8002af0:	2400      	movs	r4, #0
 8002af2:	800c      	strh	r4, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_DISCRETE_INPUTS;
 8002af4:	2402      	movs	r4, #2
 8002af6:	7004      	strb	r4, [r0, #0]
            *usLen += 1;
 8002af8:	880c      	ldrh	r4, [r1, #0]
 8002afa:	3401      	adds	r4, #1
 8002afc:	800c      	strh	r4, [r1, #0]

            /* Test if the quantity of coils is a multiple of 8. If not last
             * byte is only partially field with unused coils set to zero. */
            if( ( usDiscreteCnt & 0x0007 ) != 0 )
 8002afe:	f012 0f07 	tst.w	r2, #7
 8002b02:	d004      	beq.n	8002b0e <eMBFuncReadDiscreteInputs+0x46>
            {
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 + 1 );
 8002b04:	f3c2 04c7 	ubfx	r4, r2, #3, #8
 8002b08:	3401      	adds	r4, #1
 8002b0a:	b2e4      	uxtb	r4, r4
 8002b0c:	e001      	b.n	8002b12 <eMBFuncReadDiscreteInputs+0x4a>
            }
            else
            {
                ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 );
 8002b0e:	f3c2 04c7 	ubfx	r4, r2, #3, #8
 8002b12:	460d      	mov	r5, r1
            }
            *pucFrameCur++ = ucNBytes;
 8002b14:	7044      	strb	r4, [r0, #1]
            *usLen += 1;
 8002b16:	8809      	ldrh	r1, [r1, #0]
 8002b18:	3101      	adds	r1, #1
 8002b1a:	8029      	strh	r1, [r5, #0]

            eRegStatus =
 8002b1c:	4619      	mov	r1, r3
 8002b1e:	3002      	adds	r0, #2
 8002b20:	f7fd ff0e 	bl	8000940 <eMBRegDiscreteCB>
                eMBRegDiscreteCB( pucFrameCur, usRegAddress, usDiscreteCnt );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8002b24:	b110      	cbz	r0, 8002b2c <eMBFuncReadDiscreteInputs+0x64>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002b26:	f000 f925 	bl	8002d74 <prveMBError2Exception>
 8002b2a:	bd38      	pop	{r3, r4, r5, pc}
            else
            {
                /* The response contains the function code, the starting address
                 * and the quantity of registers. We reuse the old values in the 
                 * buffer because they are still valid. */
                *usLen += ucNBytes;;
 8002b2c:	882b      	ldrh	r3, [r5, #0]
 8002b2e:	441c      	add	r4, r3
 8002b30:	802c      	strh	r4, [r5, #0]
    USHORT          usRegAddress;
    USHORT          usDiscreteCnt;
    UCHAR           ucNBytes;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 8002b32:	2000      	movs	r0, #0
 8002b34:	bd38      	pop	{r3, r4, r5, pc}
    }
    else
    {
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002b36:	2003      	movs	r0, #3
 8002b38:	bd38      	pop	{r3, r4, r5, pc}
                *usLen += ucNBytes;;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002b3a:	2003      	movs	r0, #3
        /* Can't be a valid read coil register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002b3c:	bd38      	pop	{r3, r4, r5, pc}
 8002b3e:	bf00      	nop

08002b40 <eMBFuncWriteHoldingRegister>:

#if MB_FUNC_WRITE_HOLDING_ENABLED > 0

eMBException
eMBFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8002b40:	b508      	push	{r3, lr}
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
 8002b42:	880b      	ldrh	r3, [r1, #0]
 8002b44:	2b05      	cmp	r3, #5
 8002b46:	d10e      	bne.n	8002b66 <eMBFuncWriteHoldingRegister+0x26>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
 8002b48:	7841      	ldrb	r1, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
 8002b4a:	7883      	ldrb	r3, [r0, #2]
 8002b4c:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
        usRegAddress++;
 8002b50:	3101      	adds	r1, #1

        /* Make callback to update the value. */
        eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF],
 8002b52:	2301      	movs	r3, #1
 8002b54:	461a      	mov	r2, r3
 8002b56:	b289      	uxth	r1, r1
 8002b58:	3003      	adds	r0, #3
 8002b5a:	f7fd feab 	bl	80008b4 <eMBRegHoldingCB>
                                      usRegAddress, 1, MB_REG_WRITE );

        /* If an error occured convert it into a Modbus exception. */
        if( eRegStatus != MB_ENOERR )
 8002b5e:	b120      	cbz	r0, 8002b6a <eMBFuncWriteHoldingRegister+0x2a>
        {
            eStatus = prveMBError2Exception( eRegStatus );
 8002b60:	f000 f908 	bl	8002d74 <prveMBError2Exception>
 8002b64:	bd08      	pop	{r3, pc}
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002b66:	2003      	movs	r0, #3
 8002b68:	bd08      	pop	{r3, pc}

eMBException
eMBFuncWriteHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
    USHORT          usRegAddress;
    eMBException    eStatus = MB_EX_NONE;
 8002b6a:	2000      	movs	r0, #0
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002b6c:	bd08      	pop	{r3, pc}
 8002b6e:	bf00      	nop

08002b70 <eMBFuncWriteMultipleHoldingRegister>:
#endif

#if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED > 0
eMBException
eMBFuncWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8002b70:	b538      	push	{r3, r4, r5, lr}
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_WRITE_MUL_SIZE_MIN + MB_PDU_SIZE_MIN ) )
 8002b72:	880b      	ldrh	r3, [r1, #0]
 8002b74:	2b05      	cmp	r3, #5
 8002b76:	d920      	bls.n	8002bba <eMBFuncWriteMultipleHoldingRegister+0x4a>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
 8002b78:	7842      	ldrb	r2, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
 8002b7a:	7883      	ldrb	r3, [r0, #2]
 8002b7c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegAddress++;
 8002b80:	3301      	adds	r3, #1
 8002b82:	b29d      	uxth	r5, r3

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF] << 8 );
 8002b84:	78c2      	ldrb	r2, [r0, #3]
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );
 8002b86:	7903      	ldrb	r3, [r0, #4]
 8002b88:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
 8002b8c:	7944      	ldrb	r4, [r0, #5]

        if( ( usRegCount >= 1 ) &&
 8002b8e:	1e53      	subs	r3, r2, #1
 8002b90:	b29b      	uxth	r3, r3
 8002b92:	2b77      	cmp	r3, #119	; 0x77
 8002b94:	d813      	bhi.n	8002bbe <eMBFuncWriteMultipleHoldingRegister+0x4e>
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
 8002b96:	0053      	lsls	r3, r2, #1
 8002b98:	b2db      	uxtb	r3, r3
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_REGCNT_OFF + 1] );

        ucRegByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];

        if( ( usRegCount >= 1 ) &&
            ( usRegCount <= MB_PDU_FUNC_WRITE_MUL_REGCNT_MAX ) &&
 8002b9a:	429c      	cmp	r4, r3
 8002b9c:	d111      	bne.n	8002bc2 <eMBFuncWriteMultipleHoldingRegister+0x52>
 8002b9e:	460c      	mov	r4, r1
            ( ucRegByteCount == ( UCHAR ) ( 2 * usRegCount ) ) )
        {
            /* Make callback to update the register values. */
            eRegStatus =
 8002ba0:	2301      	movs	r3, #1
 8002ba2:	4629      	mov	r1, r5
 8002ba4:	3006      	adds	r0, #6
 8002ba6:	f7fd fe85 	bl	80008b4 <eMBRegHoldingCB>
                eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
                                 usRegAddress, usRegCount, MB_REG_WRITE );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8002baa:	b110      	cbz	r0, 8002bb2 <eMBFuncWriteMultipleHoldingRegister+0x42>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002bac:	f000 f8e2 	bl	8002d74 <prveMBError2Exception>
 8002bb0:	bd38      	pop	{r3, r4, r5, pc}
            {
                /* The response contains the function code, the starting
                 * address and the quantity of registers. We reuse the
                 * old values in the buffer because they are still valid.
                 */
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
 8002bb2:	2305      	movs	r3, #5
 8002bb4:	8023      	strh	r3, [r4, #0]
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR           ucRegByteCount;

    eMBException    eStatus = MB_EX_NONE;
 8002bb6:	2000      	movs	r0, #0
 8002bb8:	bd38      	pop	{r3, r4, r5, pc}
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002bba:	2003      	movs	r0, #3
 8002bbc:	bd38      	pop	{r3, r4, r5, pc}
                *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002bbe:	2003      	movs	r0, #3
 8002bc0:	bd38      	pop	{r3, r4, r5, pc}
 8002bc2:	2003      	movs	r0, #3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002bc4:	bd38      	pop	{r3, r4, r5, pc}
 8002bc6:	bf00      	nop

08002bc8 <eMBFuncReadHoldingRegister>:

#if MB_FUNC_READ_HOLDING_ENABLED > 0

eMBException
eMBFuncReadHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8002bc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
 8002bca:	880b      	ldrh	r3, [r1, #0]
 8002bcc:	2b05      	cmp	r3, #5
 8002bce:	d128      	bne.n	8002c22 <eMBFuncReadHoldingRegister+0x5a>
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
 8002bd0:	7842      	ldrb	r2, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
 8002bd2:	7883      	ldrb	r3, [r0, #2]
 8002bd4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegAddress++;
 8002bd8:	3301      	adds	r3, #1
 8002bda:	b29d      	uxth	r5, r3

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
 8002bdc:	7907      	ldrb	r7, [r0, #4]
 8002bde:	b2be      	uxth	r6, r7

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 ) && ( usRegCount <= MB_PDU_FUNC_READ_REGCNT_MAX ) )
 8002be0:	1e73      	subs	r3, r6, #1
 8002be2:	b29b      	uxth	r3, r3
 8002be4:	2b7c      	cmp	r3, #124	; 0x7c
 8002be6:	d81e      	bhi.n	8002c26 <eMBFuncReadHoldingRegister+0x5e>
 8002be8:	460c      	mov	r4, r1
 8002bea:	4602      	mov	r2, r0
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
 8002bec:	2300      	movs	r3, #0
 8002bee:	800b      	strh	r3, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_HOLDING_REGISTER;
 8002bf0:	2103      	movs	r1, #3
 8002bf2:	f800 1b02 	strb.w	r1, [r0], #2
            *usLen += 1;
 8002bf6:	8821      	ldrh	r1, [r4, #0]
 8002bf8:	3101      	adds	r1, #1
 8002bfa:	8021      	strh	r1, [r4, #0]

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR ) ( usRegCount * 2 );
 8002bfc:	007f      	lsls	r7, r7, #1
 8002bfe:	7057      	strb	r7, [r2, #1]
            *usLen += 1;
 8002c00:	8822      	ldrh	r2, [r4, #0]
 8002c02:	3201      	adds	r2, #1
 8002c04:	8022      	strh	r2, [r4, #0]

            /* Make callback to fill the buffer. */
            eRegStatus = eMBRegHoldingCB( pucFrameCur, usRegAddress, usRegCount, MB_REG_READ );
 8002c06:	4632      	mov	r2, r6
 8002c08:	4629      	mov	r1, r5
 8002c0a:	f7fd fe53 	bl	80008b4 <eMBRegHoldingCB>
            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8002c0e:	b110      	cbz	r0, 8002c16 <eMBFuncReadHoldingRegister+0x4e>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002c10:	f000 f8b0 	bl	8002d74 <prveMBError2Exception>
 8002c14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            }
            else
            {
                *usLen += usRegCount * 2;
 8002c16:	8823      	ldrh	r3, [r4, #0]
 8002c18:	eb03 0646 	add.w	r6, r3, r6, lsl #1
 8002c1c:	8026      	strh	r6, [r4, #0]
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 8002c1e:	2000      	movs	r0, #0
 8002c20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
    }
    else
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002c22:	2003      	movs	r0, #3
 8002c24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002c26:	2003      	movs	r0, #3
    {
        /* Can't be a valid request because the length is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002c28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002c2a:	bf00      	nop

08002c2c <eMBFuncReadWriteMultipleHoldingRegister>:
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
 8002c2c:	880b      	ldrh	r3, [r1, #0]
 8002c2e:	2b09      	cmp	r3, #9
 8002c30:	d948      	bls.n	8002cc4 <eMBFuncReadWriteMultipleHoldingRegister+0x98>

#if MB_FUNC_READWRITE_HOLDING_ENABLED > 0

eMBException
eMBFuncReadWriteMultipleHoldingRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8002c32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen >= ( MB_PDU_FUNC_READWRITE_SIZE_MIN + MB_PDU_SIZE_MIN ) )
    {
        usRegReadAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF] << 8U );
 8002c36:	7842      	ldrb	r2, [r0, #1]
        usRegReadAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_ADDR_OFF + 1] );
 8002c38:	7883      	ldrb	r3, [r0, #2]
 8002c3a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegReadAddress++;
 8002c3e:	3301      	adds	r3, #1
 8002c40:	b29d      	uxth	r5, r3

        usRegReadCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF] << 8U );
 8002c42:	78c6      	ldrb	r6, [r0, #3]
        usRegReadCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_READ_REGCNT_OFF + 1] );
 8002c44:	7903      	ldrb	r3, [r0, #4]
 8002c46:	ea43 2606 	orr.w	r6, r3, r6, lsl #8

        usRegWriteAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF] << 8U );
 8002c4a:	7942      	ldrb	r2, [r0, #5]
        usRegWriteAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_ADDR_OFF + 1] );
 8002c4c:	7983      	ldrb	r3, [r0, #6]
 8002c4e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegWriteAddress++;
 8002c52:	3301      	adds	r3, #1
 8002c54:	b29c      	uxth	r4, r3

        usRegWriteCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF] << 8U );
 8002c56:	79c2      	ldrb	r2, [r0, #7]
        usRegWriteCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READWRITE_WRITE_REGCNT_OFF + 1] );
 8002c58:	7a03      	ldrb	r3, [r0, #8]
 8002c5a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

        ucRegWriteByteCount = pucFrame[MB_PDU_FUNC_READWRITE_BYTECNT_OFF];
 8002c5e:	7a47      	ldrb	r7, [r0, #9]

        if( ( usRegReadCount >= 1 ) && ( usRegReadCount <= 0x7D ) &&
 8002c60:	1e73      	subs	r3, r6, #1
 8002c62:	b29b      	uxth	r3, r3
 8002c64:	2b7c      	cmp	r3, #124	; 0x7c
 8002c66:	d82f      	bhi.n	8002cc8 <eMBFuncReadWriteMultipleHoldingRegister+0x9c>
 8002c68:	b38a      	cbz	r2, 8002cce <eMBFuncReadWriteMultipleHoldingRegister+0xa2>
            ( usRegWriteCount >= 1 ) && ( usRegWriteCount <= 0x79 ) &&
 8002c6a:	2a79      	cmp	r2, #121	; 0x79
 8002c6c:	d832      	bhi.n	8002cd4 <eMBFuncReadWriteMultipleHoldingRegister+0xa8>
 8002c6e:	ebb7 0f42 	cmp.w	r7, r2, lsl #1
 8002c72:	d132      	bne.n	8002cda <eMBFuncReadWriteMultipleHoldingRegister+0xae>
 8002c74:	460f      	mov	r7, r1
 8002c76:	4680      	mov	r8, r0
            ( ( 2 * usRegWriteCount ) == ucRegWriteByteCount ) )
        {
            /* Make callback to update the register values. */
            eRegStatus = eMBRegHoldingCB( &pucFrame[MB_PDU_FUNC_READWRITE_WRITE_VALUES_OFF],
 8002c78:	2301      	movs	r3, #1
 8002c7a:	4621      	mov	r1, r4
 8002c7c:	300a      	adds	r0, #10
 8002c7e:	f7fd fe19 	bl	80008b4 <eMBRegHoldingCB>
                                          usRegWriteAddress, usRegWriteCount, MB_REG_WRITE );

            if( eRegStatus == MB_ENOERR )
 8002c82:	4603      	mov	r3, r0
 8002c84:	b9c0      	cbnz	r0, 8002cb8 <eMBFuncReadWriteMultipleHoldingRegister+0x8c>
            {
                /* Set the current PDU data pointer to the beginning. */
                pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
                *usLen = MB_PDU_FUNC_OFF;
 8002c86:	2300      	movs	r3, #0
 8002c88:	803b      	strh	r3, [r7, #0]

                /* First byte contains the function code. */
                *pucFrameCur++ = MB_FUNC_READWRITE_MULTIPLE_REGISTERS;
 8002c8a:	4640      	mov	r0, r8
 8002c8c:	2217      	movs	r2, #23
 8002c8e:	f800 2b02 	strb.w	r2, [r0], #2
                *usLen += 1;
 8002c92:	883a      	ldrh	r2, [r7, #0]
 8002c94:	3201      	adds	r2, #1
 8002c96:	803a      	strh	r2, [r7, #0]

                /* Second byte in the response contain the number of bytes. */
                *pucFrameCur++ = ( UCHAR ) ( usRegReadCount * 2 );
 8002c98:	0072      	lsls	r2, r6, #1
 8002c9a:	f888 2001 	strb.w	r2, [r8, #1]
                *usLen += 1;
 8002c9e:	883a      	ldrh	r2, [r7, #0]
 8002ca0:	3201      	adds	r2, #1
 8002ca2:	803a      	strh	r2, [r7, #0]

                /* Make the read callback. */
                eRegStatus =
 8002ca4:	4632      	mov	r2, r6
 8002ca6:	4629      	mov	r1, r5
 8002ca8:	f7fd fe04 	bl	80008b4 <eMBRegHoldingCB>
                    eMBRegHoldingCB( pucFrameCur, usRegReadAddress, usRegReadCount, MB_REG_READ );
                if( eRegStatus == MB_ENOERR )
 8002cac:	4603      	mov	r3, r0
 8002cae:	b918      	cbnz	r0, 8002cb8 <eMBFuncReadWriteMultipleHoldingRegister+0x8c>
                {
                    *usLen += 2 * usRegReadCount;
 8002cb0:	883a      	ldrh	r2, [r7, #0]
 8002cb2:	eb02 0646 	add.w	r6, r2, r6, lsl #1
 8002cb6:	803e      	strh	r6, [r7, #0]
                }
            }
            if( eRegStatus != MB_ENOERR )
 8002cb8:	b193      	cbz	r3, 8002ce0 <eMBFuncReadWriteMultipleHoldingRegister+0xb4>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002cba:	4618      	mov	r0, r3
 8002cbc:	f000 f85a 	bl	8002d74 <prveMBError2Exception>
 8002cc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USHORT          usRegWriteAddress;
    USHORT          usRegWriteCount;
    UCHAR           ucRegWriteByteCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 8002cc4:	2000      	movs	r0, #0
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
        }
    }
    return eStatus;
}
 8002cc6:	4770      	bx	lr
                eStatus = prveMBError2Exception( eRegStatus );
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002cc8:	2003      	movs	r0, #3
 8002cca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002cce:	2003      	movs	r0, #3
 8002cd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002cd4:	2003      	movs	r0, #3
 8002cd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002cda:	2003      	movs	r0, #3
 8002cdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USHORT          usRegWriteAddress;
    USHORT          usRegWriteCount;
    UCHAR           ucRegWriteByteCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 8002ce0:	2000      	movs	r0, #0
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
        }
    }
    return eStatus;
}
 8002ce2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002ce6:	bf00      	nop

08002ce8 <eMBFuncReadInputRegister>:
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
 8002ce8:	880b      	ldrh	r3, [r1, #0]
 8002cea:	2b05      	cmp	r3, #5
 8002cec:	d12b      	bne.n	8002d46 <eMBFuncReadInputRegister+0x5e>
/* ----------------------- Start implementation -----------------------------*/
#if MB_FUNC_READ_INPUT_ENABLED > 0

eMBException
eMBFuncReadInputRegister( UCHAR * pucFrame, USHORT * usLen )
{
 8002cee:	b570      	push	{r4, r5, r6, lr}
    eMBException    eStatus = MB_EX_NONE;
    eMBErrorCode    eRegStatus;

    if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
    {
        usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
 8002cf0:	7842      	ldrb	r2, [r0, #1]
        usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
 8002cf2:	7883      	ldrb	r3, [r0, #2]
 8002cf4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        usRegAddress++;
 8002cf8:	3301      	adds	r3, #1
 8002cfa:	b29d      	uxth	r5, r3

        usRegCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF] << 8 );
 8002cfc:	78c6      	ldrb	r6, [r0, #3]
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );
 8002cfe:	7903      	ldrb	r3, [r0, #4]
 8002d00:	ea43 2606 	orr.w	r6, r3, r6, lsl #8

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 )
            && ( usRegCount < MB_PDU_FUNC_READ_REGCNT_MAX ) )
 8002d04:	1e73      	subs	r3, r6, #1
 8002d06:	b29b      	uxth	r3, r3
        usRegCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_REGCNT_OFF + 1] );

        /* Check if the number of registers to read is valid. If not
         * return Modbus illegal data value exception. 
         */
        if( ( usRegCount >= 1 )
 8002d08:	2b7b      	cmp	r3, #123	; 0x7b
 8002d0a:	d81e      	bhi.n	8002d4a <eMBFuncReadInputRegister+0x62>
 8002d0c:	460c      	mov	r4, r1
 8002d0e:	4603      	mov	r3, r0
            && ( usRegCount < MB_PDU_FUNC_READ_REGCNT_MAX ) )
        {
            /* Set the current PDU data pointer to the beginning. */
            pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
            *usLen = MB_PDU_FUNC_OFF;
 8002d10:	2200      	movs	r2, #0
 8002d12:	800a      	strh	r2, [r1, #0]

            /* First byte contains the function code. */
            *pucFrameCur++ = MB_FUNC_READ_INPUT_REGISTER;
 8002d14:	2204      	movs	r2, #4
 8002d16:	f800 2b02 	strb.w	r2, [r0], #2
            *usLen += 1;
 8002d1a:	880a      	ldrh	r2, [r1, #0]
 8002d1c:	3201      	adds	r2, #1
 8002d1e:	800a      	strh	r2, [r1, #0]

            /* Second byte in the response contain the number of bytes. */
            *pucFrameCur++ = ( UCHAR )( usRegCount * 2 );
 8002d20:	0072      	lsls	r2, r6, #1
 8002d22:	705a      	strb	r2, [r3, #1]
            *usLen += 1;
 8002d24:	880b      	ldrh	r3, [r1, #0]
 8002d26:	3301      	adds	r3, #1
 8002d28:	800b      	strh	r3, [r1, #0]

            eRegStatus =
 8002d2a:	4632      	mov	r2, r6
 8002d2c:	4629      	mov	r1, r5
 8002d2e:	f7fd fdbf 	bl	80008b0 <eMBRegInputCB>
                eMBRegInputCB( pucFrameCur, usRegAddress, usRegCount );

            /* If an error occured convert it into a Modbus exception. */
            if( eRegStatus != MB_ENOERR )
 8002d32:	b110      	cbz	r0, 8002d3a <eMBFuncReadInputRegister+0x52>
            {
                eStatus = prveMBError2Exception( eRegStatus );
 8002d34:	f000 f81e 	bl	8002d74 <prveMBError2Exception>
 8002d38:	bd70      	pop	{r4, r5, r6, pc}
            }
            else
            {
                *usLen += usRegCount * 2;
 8002d3a:	8823      	ldrh	r3, [r4, #0]
 8002d3c:	eb03 0646 	add.w	r6, r3, r6, lsl #1
 8002d40:	8026      	strh	r6, [r4, #0]
{
    USHORT          usRegAddress;
    USHORT          usRegCount;
    UCHAR          *pucFrameCur;

    eMBException    eStatus = MB_EX_NONE;
 8002d42:	2000      	movs	r0, #0
 8002d44:	bd70      	pop	{r4, r5, r6, pc}
    }
    else
    {
        /* Can't be a valid read input register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002d46:	2003      	movs	r0, #3
    }
    return eStatus;
}
 8002d48:	4770      	bx	lr
                *usLen += usRegCount * 2;
            }
        }
        else
        {
            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
 8002d4a:	2003      	movs	r0, #3
        /* Can't be a valid read input register request because the length
         * is incorrect. */
        eStatus = MB_EX_ILLEGAL_DATA_VALUE;
    }
    return eStatus;
}
 8002d4c:	bd70      	pop	{r4, r5, r6, pc}
 8002d4e:	bf00      	nop

08002d50 <eMBFuncReportSlaveID>:
    return eStatus;
}

eMBException
eMBFuncReportSlaveID( UCHAR * pucFrame, USHORT * usLen )
{
 8002d50:	b538      	push	{r3, r4, r5, lr}
 8002d52:	460d      	mov	r5, r1
    memcpy( &pucFrame[MB_PDU_DATA_OFF], &ucMBSlaveID[0], ( size_t )usMBSlaveIDLen );
 8002d54:	4b05      	ldr	r3, [pc, #20]	; (8002d6c <eMBFuncReportSlaveID+0x1c>)
 8002d56:	881c      	ldrh	r4, [r3, #0]
 8002d58:	4622      	mov	r2, r4
 8002d5a:	4905      	ldr	r1, [pc, #20]	; (8002d70 <eMBFuncReportSlaveID+0x20>)
 8002d5c:	3001      	adds	r0, #1
 8002d5e:	f002 f8e9 	bl	8004f34 <memcpy>
    *usLen = ( USHORT )( MB_PDU_DATA_OFF + usMBSlaveIDLen );
 8002d62:	3401      	adds	r4, #1
 8002d64:	802c      	strh	r4, [r5, #0]
    return MB_EX_NONE;
}
 8002d66:	2000      	movs	r0, #0
 8002d68:	bd38      	pop	{r3, r4, r5, pc}
 8002d6a:	bf00      	nop
 8002d6c:	200003c4 	.word	0x200003c4
 8002d70:	200003c8 	.word	0x200003c8

08002d74 <prveMBError2Exception>:
eMBException
prveMBError2Exception( eMBErrorCode eErrorCode )
{
    eMBException    eStatus;

    switch ( eErrorCode )
 8002d74:	2801      	cmp	r0, #1
 8002d76:	d009      	beq.n	8002d8c <prveMBError2Exception+0x18>
 8002d78:	b110      	cbz	r0, 8002d80 <prveMBError2Exception+0xc>
 8002d7a:	2807      	cmp	r0, #7
 8002d7c:	d002      	beq.n	8002d84 <prveMBError2Exception+0x10>
 8002d7e:	e003      	b.n	8002d88 <prveMBError2Exception+0x14>
    {
        case MB_ENOERR:
            eStatus = MB_EX_NONE;
 8002d80:	2000      	movs	r0, #0
 8002d82:	4770      	bx	lr
        case MB_ENOREG:
            eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
            break;

        case MB_ETIMEDOUT:
            eStatus = MB_EX_SLAVE_BUSY;
 8002d84:	2006      	movs	r0, #6
            break;
 8002d86:	4770      	bx	lr

        default:
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
 8002d88:	2004      	movs	r0, #4
            break;
 8002d8a:	4770      	bx	lr
        case MB_ENOERR:
            eStatus = MB_EX_NONE;
            break;

        case MB_ENOREG:
            eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
 8002d8c:	2002      	movs	r0, #2
            eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
            break;
    }

    return eStatus;
}
 8002d8e:	4770      	bx	lr

08002d90 <eMBInit>:
};

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBInit( eMBMode eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
 8002d90:	b570      	push	{r4, r5, r6, lr}
    eMBErrorCode    eStatus = MB_ENOERR;

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
        ( ucSlaveAddress < MB_ADDRESS_MIN ) || ( ucSlaveAddress > MB_ADDRESS_MAX ) )
 8002d92:	1e4c      	subs	r4, r1, #1
 8002d94:	b2e4      	uxtb	r4, r4
eMBInit( eMBMode eMode, UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
 8002d96:	2cf6      	cmp	r4, #246	; 0xf6
 8002d98:	d82f      	bhi.n	8002dfa <eMBInit+0x6a>
 8002d9a:	461e      	mov	r6, r3
 8002d9c:	4615      	mov	r5, r2
 8002d9e:	460c      	mov	r4, r1
    {
        eStatus = MB_EINVAL;
    }
    else
    {
        ucMBAddress = ucSlaveAddress;
 8002da0:	4b18      	ldr	r3, [pc, #96]	; (8002e04 <eMBInit+0x74>)
 8002da2:	7019      	strb	r1, [r3, #0]

        switch ( eMode )
 8002da4:	bb00      	cbnz	r0, 8002de8 <eMBInit+0x58>
        {
#if MB_RTU_ENABLED > 0
        case MB_RTU:
            pvMBFrameStartCur = eMBRTUStart;
 8002da6:	4a18      	ldr	r2, [pc, #96]	; (8002e08 <eMBInit+0x78>)
 8002da8:	4b18      	ldr	r3, [pc, #96]	; (8002e0c <eMBInit+0x7c>)
 8002daa:	601a      	str	r2, [r3, #0]
            pvMBFrameStopCur = eMBRTUStop;
 8002dac:	4a18      	ldr	r2, [pc, #96]	; (8002e10 <eMBInit+0x80>)
 8002dae:	4b19      	ldr	r3, [pc, #100]	; (8002e14 <eMBInit+0x84>)
 8002db0:	601a      	str	r2, [r3, #0]
            peMBFrameSendCur = eMBRTUSend;
 8002db2:	4a19      	ldr	r2, [pc, #100]	; (8002e18 <eMBInit+0x88>)
 8002db4:	4b19      	ldr	r3, [pc, #100]	; (8002e1c <eMBInit+0x8c>)
 8002db6:	601a      	str	r2, [r3, #0]
            peMBFrameReceiveCur = eMBRTUReceive;
 8002db8:	4a19      	ldr	r2, [pc, #100]	; (8002e20 <eMBInit+0x90>)
 8002dba:	4b1a      	ldr	r3, [pc, #104]	; (8002e24 <eMBInit+0x94>)
 8002dbc:	601a      	str	r2, [r3, #0]
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
 8002dbe:	2200      	movs	r2, #0
 8002dc0:	4b19      	ldr	r3, [pc, #100]	; (8002e28 <eMBInit+0x98>)
 8002dc2:	601a      	str	r2, [r3, #0]
            pxMBFrameCBByteReceived = xMBRTUReceiveFSM;
 8002dc4:	4a19      	ldr	r2, [pc, #100]	; (8002e2c <eMBInit+0x9c>)
 8002dc6:	4b1a      	ldr	r3, [pc, #104]	; (8002e30 <eMBInit+0xa0>)
 8002dc8:	601a      	str	r2, [r3, #0]
            pxMBFrameCBTransmitterEmpty = xMBRTUTransmitFSM;
 8002dca:	4a1a      	ldr	r2, [pc, #104]	; (8002e34 <eMBInit+0xa4>)
 8002dcc:	4b1a      	ldr	r3, [pc, #104]	; (8002e38 <eMBInit+0xa8>)
 8002dce:	601a      	str	r2, [r3, #0]
            pxMBPortCBTimerExpired = xMBRTUTimerT35Expired;
 8002dd0:	4a1a      	ldr	r2, [pc, #104]	; (8002e3c <eMBInit+0xac>)
 8002dd2:	4b1b      	ldr	r3, [pc, #108]	; (8002e40 <eMBInit+0xb0>)
 8002dd4:	601a      	str	r2, [r3, #0]

            eStatus = eMBRTUInit( ucMBAddress, ucPort, ulBaudRate, eParity );
 8002dd6:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8002dda:	4632      	mov	r2, r6
 8002ddc:	4629      	mov	r1, r5
 8002dde:	4620      	mov	r0, r4
 8002de0:	f000 f8e4 	bl	8002fac <eMBRTUInit>
 8002de4:	4604      	mov	r4, r0
            break;
 8002de6:	e000      	b.n	8002dea <eMBInit+0x5a>
            pxMBPortCBTimerExpired = xMBASCIITimerT1SExpired;
            eStatus = eMBASCIIInit( ucMBAddress, ucPort, ulBaudRate, eParity );
            break;
#endif
        default:
            eStatus = MB_EINVAL;
 8002de8:	2402      	movs	r4, #2
        }

        if( eStatus == MB_ENOERR )
 8002dea:	b94c      	cbnz	r4, 8002e00 <eMBInit+0x70>
        {
            if( !xMBPortEventInit(  ) )
 8002dec:	f000 fa22 	bl	8003234 <xMBPortEventInit>
 8002df0:	b128      	cbz	r0, 8002dfe <eMBInit+0x6e>
                eStatus = MB_EPORTERR;
            }
            else
            {
                eMBCurrentMode = eMode;
                eMBState = STATE_DISABLED;
 8002df2:	2201      	movs	r2, #1
 8002df4:	4b13      	ldr	r3, [pc, #76]	; (8002e44 <eMBInit+0xb4>)
 8002df6:	701a      	strb	r2, [r3, #0]
 8002df8:	e002      	b.n	8002e00 <eMBInit+0x70>

    /* check preconditions */
    if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
        ( ucSlaveAddress < MB_ADDRESS_MIN ) || ( ucSlaveAddress > MB_ADDRESS_MAX ) )
    {
        eStatus = MB_EINVAL;
 8002dfa:	2402      	movs	r4, #2
 8002dfc:	e000      	b.n	8002e00 <eMBInit+0x70>
        if( eStatus == MB_ENOERR )
        {
            if( !xMBPortEventInit(  ) )
            {
                /* port dependent event module initalization failed. */
                eStatus = MB_EPORTERR;
 8002dfe:	2403      	movs	r4, #3
                eMBState = STATE_DISABLED;
            }
        }
    }
    return eStatus;
}
 8002e00:	4620      	mov	r0, r4
 8002e02:	bd70      	pop	{r4, r5, r6, pc}
 8002e04:	200003fa 	.word	0x200003fa
 8002e08:	08002ff1 	.word	0x08002ff1
 8002e0c:	200003f0 	.word	0x200003f0
 8002e10:	0800300d 	.word	0x0800300d
 8002e14:	200003e8 	.word	0x200003e8
 8002e18:	0800306d 	.word	0x0800306d
 8002e1c:	200003f4 	.word	0x200003f4
 8002e20:	08003021 	.word	0x08003021
 8002e24:	200003ec 	.word	0x200003ec
 8002e28:	20000400 	.word	0x20000400
 8002e2c:	080030e9 	.word	0x080030e9
 8002e30:	20000590 	.word	0x20000590
 8002e34:	08003175 	.word	0x08003175
 8002e38:	20000588 	.word	0x20000588
 8002e3c:	080031f9 	.word	0x080031f9
 8002e40:	2000058c 	.word	0x2000058c
 8002e44:	20000174 	.word	0x20000174

08002e48 <eMBEnable>:
    return eStatus;
}

eMBErrorCode
eMBEnable( void )
{
 8002e48:	b508      	push	{r3, lr}
    eMBErrorCode    eStatus = MB_ENOERR;

    if( eMBState == STATE_DISABLED )
 8002e4a:	4b06      	ldr	r3, [pc, #24]	; (8002e64 <eMBEnable+0x1c>)
 8002e4c:	781b      	ldrb	r3, [r3, #0]
 8002e4e:	2b01      	cmp	r3, #1
 8002e50:	d106      	bne.n	8002e60 <eMBEnable+0x18>
    {
        /* Activate the protocol stack. */
        pvMBFrameStartCur(  );
 8002e52:	4b05      	ldr	r3, [pc, #20]	; (8002e68 <eMBEnable+0x20>)
 8002e54:	681b      	ldr	r3, [r3, #0]
 8002e56:	4798      	blx	r3
        eMBState = STATE_ENABLED;
 8002e58:	2000      	movs	r0, #0
 8002e5a:	4b02      	ldr	r3, [pc, #8]	; (8002e64 <eMBEnable+0x1c>)
 8002e5c:	7018      	strb	r0, [r3, #0]
 8002e5e:	bd08      	pop	{r3, pc}
    }
    else
    {
        eStatus = MB_EILLSTATE;
 8002e60:	2006      	movs	r0, #6
    }
    return eStatus;
}
 8002e62:	bd08      	pop	{r3, pc}
 8002e64:	20000174 	.word	0x20000174
 8002e68:	200003f0 	.word	0x200003f0

08002e6c <eMBPoll>:
    int             i;
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
 8002e6c:	4b38      	ldr	r3, [pc, #224]	; (8002f50 <eMBPoll+0xe4>)
 8002e6e:	781b      	ldrb	r3, [r3, #0]
 8002e70:	2b00      	cmp	r3, #0
 8002e72:	d15f      	bne.n	8002f34 <eMBPoll+0xc8>
    return eStatus;
}

eMBErrorCode
eMBPoll( void )
{
 8002e74:	b510      	push	{r4, lr}
 8002e76:	b082      	sub	sp, #8
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBPortEventGet( &eEvent ) == TRUE )
 8002e78:	f10d 0007 	add.w	r0, sp, #7
 8002e7c:	f000 f9ee 	bl	800325c <xMBPortEventGet>
 8002e80:	2801      	cmp	r0, #1
 8002e82:	d159      	bne.n	8002f38 <eMBPoll+0xcc>
    {
        switch ( eEvent )
 8002e84:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002e88:	2b01      	cmp	r3, #1
 8002e8a:	d002      	beq.n	8002e92 <eMBPoll+0x26>
 8002e8c:	2b02      	cmp	r3, #2
 8002e8e:	d015      	beq.n	8002ebc <eMBPoll+0x50>
 8002e90:	e054      	b.n	8002f3c <eMBPoll+0xd0>
        {
        case EV_READY:
            break;

        case EV_FRAME_RECEIVED:
            eStatus = peMBFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
 8002e92:	4b30      	ldr	r3, [pc, #192]	; (8002f54 <eMBPoll+0xe8>)
 8002e94:	681b      	ldr	r3, [r3, #0]
 8002e96:	4a30      	ldr	r2, [pc, #192]	; (8002f58 <eMBPoll+0xec>)
 8002e98:	4930      	ldr	r1, [pc, #192]	; (8002f5c <eMBPoll+0xf0>)
 8002e9a:	4831      	ldr	r0, [pc, #196]	; (8002f60 <eMBPoll+0xf4>)
 8002e9c:	4798      	blx	r3
            if( eStatus == MB_ENOERR )
 8002e9e:	2800      	cmp	r0, #0
 8002ea0:	d14e      	bne.n	8002f40 <eMBPoll+0xd4>
            {
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
 8002ea2:	4b2f      	ldr	r3, [pc, #188]	; (8002f60 <eMBPoll+0xf4>)
 8002ea4:	781b      	ldrb	r3, [r3, #0]
 8002ea6:	4a2f      	ldr	r2, [pc, #188]	; (8002f64 <eMBPoll+0xf8>)
 8002ea8:	7812      	ldrb	r2, [r2, #0]
 8002eaa:	4293      	cmp	r3, r2
 8002eac:	d001      	beq.n	8002eb2 <eMBPoll+0x46>
 8002eae:	2b00      	cmp	r3, #0
 8002eb0:	d148      	bne.n	8002f44 <eMBPoll+0xd8>
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
 8002eb2:	2002      	movs	r0, #2
 8002eb4:	f000 f9c6 	bl	8003244 <xMBPortEventPost>

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
 8002eb8:	2000      	movs	r0, #0
 8002eba:	e046      	b.n	8002f4a <eMBPoll+0xde>
                }
            }
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
 8002ebc:	4b27      	ldr	r3, [pc, #156]	; (8002f5c <eMBPoll+0xf0>)
 8002ebe:	6818      	ldr	r0, [r3, #0]
 8002ec0:	7801      	ldrb	r1, [r0, #0]
 8002ec2:	4b29      	ldr	r3, [pc, #164]	; (8002f68 <eMBPoll+0xfc>)
 8002ec4:	7019      	strb	r1, [r3, #0]
            eException = MB_EX_ILLEGAL_FUNCTION;
 8002ec6:	2201      	movs	r2, #1
 8002ec8:	4b28      	ldr	r3, [pc, #160]	; (8002f6c <eMBPoll+0x100>)
 8002eca:	701a      	strb	r2, [r3, #0]
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 8002ecc:	2300      	movs	r3, #0
 8002ece:	e00f      	b.n	8002ef0 <eMBPoll+0x84>
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
 8002ed0:	4a27      	ldr	r2, [pc, #156]	; (8002f70 <eMBPoll+0x104>)
 8002ed2:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
 8002ed6:	b16a      	cbz	r2, 8002ef4 <eMBPoll+0x88>
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
 8002ed8:	4291      	cmp	r1, r2
 8002eda:	d108      	bne.n	8002eee <eMBPoll+0x82>
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &usLength );
 8002edc:	4a24      	ldr	r2, [pc, #144]	; (8002f70 <eMBPoll+0x104>)
 8002ede:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002ee2:	685b      	ldr	r3, [r3, #4]
 8002ee4:	491c      	ldr	r1, [pc, #112]	; (8002f58 <eMBPoll+0xec>)
 8002ee6:	4798      	blx	r3
 8002ee8:	4b20      	ldr	r3, [pc, #128]	; (8002f6c <eMBPoll+0x100>)
 8002eea:	7018      	strb	r0, [r3, #0]
                    break;
 8002eec:	e002      	b.n	8002ef4 <eMBPoll+0x88>
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
 8002eee:	3301      	adds	r3, #1
 8002ef0:	2b0f      	cmp	r3, #15
 8002ef2:	dded      	ble.n	8002ed0 <eMBPoll+0x64>
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
 8002ef4:	4b1a      	ldr	r3, [pc, #104]	; (8002f60 <eMBPoll+0xf4>)
 8002ef6:	781b      	ldrb	r3, [r3, #0]
 8002ef8:	b333      	cbz	r3, 8002f48 <eMBPoll+0xdc>
            {
                if( eException != MB_EX_NONE )
 8002efa:	4b1c      	ldr	r3, [pc, #112]	; (8002f6c <eMBPoll+0x100>)
 8002efc:	781b      	ldrb	r3, [r3, #0]
 8002efe:	b173      	cbz	r3, 8002f1e <eMBPoll+0xb2>
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
 8002f00:	4a15      	ldr	r2, [pc, #84]	; (8002f58 <eMBPoll+0xec>)
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
 8002f02:	4816      	ldr	r0, [pc, #88]	; (8002f5c <eMBPoll+0xf0>)
 8002f04:	6804      	ldr	r4, [r0, #0]
 8002f06:	2101      	movs	r1, #1
 8002f08:	8011      	strh	r1, [r2, #0]
 8002f0a:	4917      	ldr	r1, [pc, #92]	; (8002f68 <eMBPoll+0xfc>)
 8002f0c:	7809      	ldrb	r1, [r1, #0]
 8002f0e:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8002f12:	7021      	strb	r1, [r4, #0]
                    ucMBFrame[usLength++] = eException;
 8002f14:	6800      	ldr	r0, [r0, #0]
 8002f16:	8811      	ldrh	r1, [r2, #0]
 8002f18:	1c4c      	adds	r4, r1, #1
 8002f1a:	8014      	strh	r4, [r2, #0]
 8002f1c:	5443      	strb	r3, [r0, r1]
                }
                if( ( eMBCurrentMode == MB_ASCII ) && MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
 8002f1e:	4b15      	ldr	r3, [pc, #84]	; (8002f74 <eMBPoll+0x108>)
 8002f20:	681b      	ldr	r3, [r3, #0]
 8002f22:	4a0d      	ldr	r2, [pc, #52]	; (8002f58 <eMBPoll+0xec>)
 8002f24:	8812      	ldrh	r2, [r2, #0]
 8002f26:	490d      	ldr	r1, [pc, #52]	; (8002f5c <eMBPoll+0xf0>)
 8002f28:	6809      	ldr	r1, [r1, #0]
 8002f2a:	480e      	ldr	r0, [pc, #56]	; (8002f64 <eMBPoll+0xf8>)
 8002f2c:	7800      	ldrb	r0, [r0, #0]
 8002f2e:	4798      	blx	r3

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
 8002f30:	2000      	movs	r0, #0
 8002f32:	e00a      	b.n	8002f4a <eMBPoll+0xde>
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    {
        return MB_EILLSTATE;
 8002f34:	2006      	movs	r0, #6
        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
}
 8002f36:	4770      	bx	lr

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
 8002f38:	2000      	movs	r0, #0
 8002f3a:	e006      	b.n	8002f4a <eMBPoll+0xde>
 8002f3c:	2000      	movs	r0, #0
 8002f3e:	e004      	b.n	8002f4a <eMBPoll+0xde>
 8002f40:	2000      	movs	r0, #0
 8002f42:	e002      	b.n	8002f4a <eMBPoll+0xde>
 8002f44:	2000      	movs	r0, #0
 8002f46:	e000      	b.n	8002f4a <eMBPoll+0xde>
 8002f48:	2000      	movs	r0, #0
}
 8002f4a:	b002      	add	sp, #8
 8002f4c:	bd10      	pop	{r4, pc}
 8002f4e:	bf00      	nop
 8002f50:	20000174 	.word	0x20000174
 8002f54:	200003ec 	.word	0x200003ec
 8002f58:	200003fc 	.word	0x200003fc
 8002f5c:	20000404 	.word	0x20000404
 8002f60:	200003f8 	.word	0x200003f8
 8002f64:	200003fa 	.word	0x200003fa
 8002f68:	200003f9 	.word	0x200003f9
 8002f6c:	200003fe 	.word	0x200003fe
 8002f70:	200000f4 	.word	0x200000f4
 8002f74:	200003f4 	.word	0x200003f4

08002f78 <usMBCRC16>:
    0x41, 0x81, 0x80,
    0x40
};

USHORT usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
 8002f78:	b430      	push	{r4, r5}
    UCHAR ucCRCHi = 0xFF;
    UCHAR ucCRCLo = 0xFF;
 8002f7a:	22ff      	movs	r2, #255	; 0xff
    0x40
};

USHORT usMBCRC16( UCHAR * pucFrame, USHORT usLen )
{
    UCHAR ucCRCHi = 0xFF;
 8002f7c:	4615      	mov	r5, r2
    UCHAR ucCRCLo = 0xFF;
    int iIndex;

    while ( usLen-- )
 8002f7e:	e008      	b.n	8002f92 <usMBCRC16+0x1a>
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
 8002f80:	7803      	ldrb	r3, [r0, #0]
 8002f82:	4053      	eors	r3, r2
        ucCRCLo = ucCRCHi ^ aucCRCHi[ iIndex ];
 8002f84:	4a07      	ldr	r2, [pc, #28]	; (8002fa4 <usMBCRC16+0x2c>)
 8002f86:	5cd2      	ldrb	r2, [r2, r3]
 8002f88:	406a      	eors	r2, r5
        ucCRCHi = aucCRCLo[ iIndex ];
 8002f8a:	4907      	ldr	r1, [pc, #28]	; (8002fa8 <usMBCRC16+0x30>)
 8002f8c:	5ccd      	ldrb	r5, [r1, r3]
{
    UCHAR ucCRCHi = 0xFF;
    UCHAR ucCRCLo = 0xFF;
    int iIndex;

    while ( usLen-- )
 8002f8e:	4621      	mov	r1, r4
    {
        iIndex = ucCRCLo ^ *( pucFrame++ );
 8002f90:	3001      	adds	r0, #1
{
    UCHAR ucCRCHi = 0xFF;
    UCHAR ucCRCLo = 0xFF;
    int iIndex;

    while ( usLen-- )
 8002f92:	1e4b      	subs	r3, r1, #1
 8002f94:	b29c      	uxth	r4, r3
 8002f96:	2900      	cmp	r1, #0
 8002f98:	d1f2      	bne.n	8002f80 <usMBCRC16+0x8>
        iIndex = ucCRCLo ^ *( pucFrame++ );
        ucCRCLo = ucCRCHi ^ aucCRCHi[ iIndex ];
        ucCRCHi = aucCRCLo[ iIndex ];
    }
    return ucCRCHi << 8 | ucCRCLo;
}
 8002f9a:	ea42 2005 	orr.w	r0, r2, r5, lsl #8
 8002f9e:	bc30      	pop	{r4, r5}
 8002fa0:	4770      	bx	lr
 8002fa2:	bf00      	nop
 8002fa4:	08005170 	.word	0x08005170
 8002fa8:	08005070 	.word	0x08005070

08002fac <eMBRTUInit>:
static volatile USHORT usRcvBufferPos;

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
 8002fac:	b510      	push	{r4, lr}
 8002fae:	4608      	mov	r0, r1
 8002fb0:	4614      	mov	r4, r2
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8002fb2:	b672      	cpsid	i

    ( void )ucSlaveAddress;
    ENTER_CRITICAL_SECTION(  );

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
 8002fb4:	2208      	movs	r2, #8
 8002fb6:	4621      	mov	r1, r4
 8002fb8:	f000 f990 	bl	80032dc <xMBPortSerialInit>
 8002fbc:	2801      	cmp	r0, #1
 8002fbe:	d10f      	bne.n	8002fe0 <eMBRTUInit+0x34>
    else
    {
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
 8002fc0:	f5b4 4f96 	cmp.w	r4, #19200	; 0x4b00
 8002fc4:	d804      	bhi.n	8002fd0 <eMBRTUInit+0x24>
             *             = 11 * Ticks_per_1s / Baudrate
             *             = 220000 / Baudrate
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
 8002fc6:	0064      	lsls	r4, r4, #1
 8002fc8:	4808      	ldr	r0, [pc, #32]	; (8002fec <eMBRTUInit+0x40>)
 8002fca:	fbb0 f0f4 	udiv	r0, r0, r4
 8002fce:	e000      	b.n	8002fd2 <eMBRTUInit+0x26>
        /* If baudrate > 19200 then we should use the fixed timer values
         * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
         */
        if( ulBaudRate > 19200 )
        {
            usTimerT35_50us = 35;       /* 1800us. */
 8002fd0:	2023      	movs	r0, #35	; 0x23
             * The reload for t3.5 is 1.5 times this value and similary
             * for t3.5.
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
 8002fd2:	b280      	uxth	r0, r0
 8002fd4:	f000 fa42 	bl	800345c <xMBPortTimersInit>
 8002fd8:	2801      	cmp	r0, #1
 8002fda:	d103      	bne.n	8002fe4 <eMBRTUInit+0x38>

/* ----------------------- Start implementation -----------------------------*/
eMBErrorCode
eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 8002fdc:	2000      	movs	r0, #0
 8002fde:	e002      	b.n	8002fe6 <eMBRTUInit+0x3a>
    ENTER_CRITICAL_SECTION(  );

    /* Modbus RTU uses 8 Databits. */
    if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
    {
        eStatus = MB_EPORTERR;
 8002fe0:	2003      	movs	r0, #3
 8002fe2:	e000      	b.n	8002fe6 <eMBRTUInit+0x3a>
             */
            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
        }
        if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
        {
            eStatus = MB_EPORTERR;
 8002fe4:	2003      	movs	r0, #3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 8002fe6:	b662      	cpsie	i
        }
    }
    EXIT_CRITICAL_SECTION(  );

    return eStatus;
}
 8002fe8:	bd10      	pop	{r4, pc}
 8002fea:	bf00      	nop
 8002fec:	00177fa0 	.word	0x00177fa0

08002ff0 <eMBRTUStart>:

void
eMBRTUStart( void )
{
 8002ff0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8002ff2:	b672      	cpsid	i
    /* Initially the receiver is in the state STATE_RX_INIT. we start
     * the timer and if no character is received within t3.5 we change
     * to STATE_RX_IDLE. This makes sure that we delay startup of the
     * modbus protocol stack until the bus is free.
     */
    eRcvState = STATE_RX_INIT;
 8002ff4:	2100      	movs	r1, #0
 8002ff6:	4b04      	ldr	r3, [pc, #16]	; (8003008 <eMBRTUStart+0x18>)
 8002ff8:	7019      	strb	r1, [r3, #0]
    vMBPortSerialEnable( TRUE, FALSE );
 8002ffa:	2001      	movs	r0, #1
 8002ffc:	f000 f940 	bl	8003280 <vMBPortSerialEnable>
    vMBPortTimersEnable(  );
 8003000:	f000 fa66 	bl	80034d0 <vMBPortTimersEnable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 8003004:	b662      	cpsie	i
 8003006:	bd08      	pop	{r3, pc}
 8003008:	20000411 	.word	0x20000411

0800300c <eMBRTUStop>:
    EXIT_CRITICAL_SECTION(  );
}

void
eMBRTUStop( void )
{
 800300c:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 800300e:	b672      	cpsid	i
    ENTER_CRITICAL_SECTION(  );
    vMBPortSerialEnable( FALSE, FALSE );
 8003010:	2100      	movs	r1, #0
 8003012:	4608      	mov	r0, r1
 8003014:	f000 f934 	bl	8003280 <vMBPortSerialEnable>
    vMBPortTimersDisable(  );
 8003018:	f000 fa68 	bl	80034ec <vMBPortTimersDisable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 800301c:	b662      	cpsie	i
 800301e:	bd08      	pop	{r3, pc}

08003020 <eMBRTUReceive>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 8003020:	b672      	cpsid	i
    eMBErrorCode    eStatus = MB_ENOERR;
    ENTER_CRITICAL_SECTION(  );
    assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
 8003022:	4b10      	ldr	r3, [pc, #64]	; (8003064 <eMBRTUReceive+0x44>)
 8003024:	881b      	ldrh	r3, [r3, #0]
 8003026:	b29b      	uxth	r3, r3
 8003028:	2b03      	cmp	r3, #3
 800302a:	d915      	bls.n	8003058 <eMBRTUReceive+0x38>
    EXIT_CRITICAL_SECTION(  );
}

eMBErrorCode
eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
{
 800302c:	b570      	push	{r4, r5, r6, lr}
 800302e:	4616      	mov	r6, r2
 8003030:	460d      	mov	r5, r1
 8003032:	4604      	mov	r4, r0
    ENTER_CRITICAL_SECTION(  );
    assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );

    /* Length and CRC check */
    if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
        && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
 8003034:	4b0b      	ldr	r3, [pc, #44]	; (8003064 <eMBRTUReceive+0x44>)
 8003036:	8819      	ldrh	r1, [r3, #0]
 8003038:	b289      	uxth	r1, r1
 800303a:	480b      	ldr	r0, [pc, #44]	; (8003068 <eMBRTUReceive+0x48>)
 800303c:	f7ff ff9c 	bl	8002f78 <usMBCRC16>
 8003040:	b968      	cbnz	r0, 800305e <eMBRTUReceive+0x3e>
    {
        /* Save the address field. All frames are passed to the upper layed
         * and the decision if a frame is used is done there.
         */
        *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
 8003042:	4a09      	ldr	r2, [pc, #36]	; (8003068 <eMBRTUReceive+0x48>)
 8003044:	f812 3b01 	ldrb.w	r3, [r2], #1
 8003048:	7023      	strb	r3, [r4, #0]

        /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
         * size of address field and CRC checksum.
         */
        *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
 800304a:	4b06      	ldr	r3, [pc, #24]	; (8003064 <eMBRTUReceive+0x44>)
 800304c:	881b      	ldrh	r3, [r3, #0]
 800304e:	b29b      	uxth	r3, r3
 8003050:	3b03      	subs	r3, #3
 8003052:	8033      	strh	r3, [r6, #0]

        /* Return the start of the Modbus PDU to the caller. */
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
 8003054:	602a      	str	r2, [r5, #0]
 8003056:	e003      	b.n	8003060 <eMBRTUReceive+0x40>
        //xFrameReceived = TRUE;
    }
    else
    {
        eStatus = MB_EIO;
 8003058:	2005      	movs	r0, #5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 800305a:	b662      	cpsie	i
    }

    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
 800305c:	4770      	bx	lr
        *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
        //xFrameReceived = TRUE;
    }
    else
    {
        eStatus = MB_EIO;
 800305e:	2005      	movs	r0, #5
 8003060:	b662      	cpsie	i
    }

    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
 8003062:	bd70      	pop	{r4, r5, r6, pc}
 8003064:	2000040e 	.word	0x2000040e
 8003068:	2000059c 	.word	0x2000059c

0800306c <eMBRTUSend>:

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
 800306c:	b538      	push	{r3, r4, r5, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 800306e:	b672      	cpsid	i

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
 8003070:	4b18      	ldr	r3, [pc, #96]	; (80030d4 <eMBRTUSend+0x68>)
 8003072:	781b      	ldrb	r3, [r3, #0]
 8003074:	b2db      	uxtb	r3, r3
 8003076:	2b01      	cmp	r3, #1
 8003078:	d129      	bne.n	80030ce <eMBRTUSend+0x62>
 800307a:	4603      	mov	r3, r0
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
 800307c:	1e48      	subs	r0, r1, #1
 800307e:	4c16      	ldr	r4, [pc, #88]	; (80030d8 <eMBRTUSend+0x6c>)
 8003080:	6020      	str	r0, [r4, #0]
        usSndBufferCount = 1;
 8003082:	4c16      	ldr	r4, [pc, #88]	; (80030dc <eMBRTUSend+0x70>)
 8003084:	2501      	movs	r5, #1
 8003086:	8025      	strh	r5, [r4, #0]

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
 8003088:	f801 3c01 	strb.w	r3, [r1, #-1]
        usSndBufferCount += usLength;
 800308c:	8823      	ldrh	r3, [r4, #0]
 800308e:	b29b      	uxth	r3, r3
 8003090:	441a      	add	r2, r3
 8003092:	b292      	uxth	r2, r2
 8003094:	8022      	strh	r2, [r4, #0]

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
 8003096:	8821      	ldrh	r1, [r4, #0]
 8003098:	b289      	uxth	r1, r1
 800309a:	f7ff ff6d 	bl	8002f78 <usMBCRC16>
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
 800309e:	8823      	ldrh	r3, [r4, #0]
 80030a0:	b29b      	uxth	r3, r3
 80030a2:	195a      	adds	r2, r3, r5
 80030a4:	b292      	uxth	r2, r2
 80030a6:	8022      	strh	r2, [r4, #0]
 80030a8:	b2c2      	uxtb	r2, r0
 80030aa:	490d      	ldr	r1, [pc, #52]	; (80030e0 <eMBRTUSend+0x74>)
 80030ac:	54ca      	strb	r2, [r1, r3]
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
 80030ae:	8823      	ldrh	r3, [r4, #0]
 80030b0:	b29b      	uxth	r3, r3
 80030b2:	195a      	adds	r2, r3, r5
 80030b4:	b292      	uxth	r2, r2
 80030b6:	8022      	strh	r2, [r4, #0]
 80030b8:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80030bc:	54c8      	strb	r0, [r1, r3]

        /* Activate the transmitter. */
        eSndState = STATE_TX_XMIT;
 80030be:	4b09      	ldr	r3, [pc, #36]	; (80030e4 <eMBRTUSend+0x78>)
 80030c0:	701d      	strb	r5, [r3, #0]
        vMBPortSerialEnable( FALSE, TRUE );
 80030c2:	4629      	mov	r1, r5
 80030c4:	2000      	movs	r0, #0
 80030c6:	f000 f8db 	bl	8003280 <vMBPortSerialEnable>
}

eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
 80030ca:	2000      	movs	r0, #0
 80030cc:	e000      	b.n	80030d0 <eMBRTUSend+0x64>
        eSndState = STATE_TX_XMIT;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
 80030ce:	2005      	movs	r0, #5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80030d0:	b662      	cpsie	i
    }
    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}
 80030d2:	bd38      	pop	{r3, r4, r5, pc}
 80030d4:	20000411 	.word	0x20000411
 80030d8:	20000408 	.word	0x20000408
 80030dc:	2000040c 	.word	0x2000040c
 80030e0:	2000059c 	.word	0x2000059c
 80030e4:	20000410 	.word	0x20000410

080030e8 <xMBRTUReceiveFSM>:

BOOL
xMBRTUReceiveFSM( void )
{
 80030e8:	b500      	push	{lr}
 80030ea:	b083      	sub	sp, #12
    BOOL            xTaskNeedSwitch = FALSE;
    UCHAR           ucByte;

    assert( eSndState == STATE_TX_IDLE );
    /* Always read the character. */
    ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
 80030ec:	f10d 0007 	add.w	r0, sp, #7
 80030f0:	f000 f986 	bl	8003400 <xMBPortSerialGetByte>

    switch ( eRcvState )
 80030f4:	4b1c      	ldr	r3, [pc, #112]	; (8003168 <xMBRTUReceiveFSM+0x80>)
 80030f6:	781b      	ldrb	r3, [r3, #0]
 80030f8:	b2db      	uxtb	r3, r3
 80030fa:	2b03      	cmp	r3, #3
 80030fc:	d830      	bhi.n	8003160 <xMBRTUReceiveFSM+0x78>
 80030fe:	e8df f003 	tbb	[pc, r3]
 8003102:	0802      	.short	0x0802
 8003104:	051a      	.short	0x051a
    {
        /* If we have received a character in the init state we have to
         * wait until the frame is finished.
         */
    case STATE_RX_INIT:
        vMBPortTimersEnable(  );
 8003106:	f000 f9e3 	bl	80034d0 <vMBPortTimersEnable>
        break;
 800310a:	e029      	b.n	8003160 <xMBRTUReceiveFSM+0x78>

        /* In the error state we wait until all characters in the
         * damaged frame are transmitted.
         */
    case STATE_RX_ERROR:
        vMBPortTimersEnable(  );
 800310c:	f000 f9e0 	bl	80034d0 <vMBPortTimersEnable>
        break;
 8003110:	e026      	b.n	8003160 <xMBRTUReceiveFSM+0x78>
        /* In the idle state we wait for a new character. If a character
         * is received the t1.5 and t3.5 timers are started and the
         * receiver is in the state STATE_RX_RECEIVCE.
         */
    case STATE_RX_IDLE:
        usRcvBufferPos = 0;
 8003112:	4a16      	ldr	r2, [pc, #88]	; (800316c <xMBRTUReceiveFSM+0x84>)
 8003114:	2300      	movs	r3, #0
 8003116:	8013      	strh	r3, [r2, #0]
        ucRTUBuf[usRcvBufferPos++] = ucByte;
 8003118:	8813      	ldrh	r3, [r2, #0]
 800311a:	b29b      	uxth	r3, r3
 800311c:	1c59      	adds	r1, r3, #1
 800311e:	b289      	uxth	r1, r1
 8003120:	8011      	strh	r1, [r2, #0]
 8003122:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8003126:	4a12      	ldr	r2, [pc, #72]	; (8003170 <xMBRTUReceiveFSM+0x88>)
 8003128:	54d1      	strb	r1, [r2, r3]
        eRcvState = STATE_RX_RCV;
 800312a:	2202      	movs	r2, #2
 800312c:	4b0e      	ldr	r3, [pc, #56]	; (8003168 <xMBRTUReceiveFSM+0x80>)
 800312e:	701a      	strb	r2, [r3, #0]

        /* Enable t3.5 timers. */
        vMBPortTimersEnable(  );
 8003130:	f000 f9ce 	bl	80034d0 <vMBPortTimersEnable>
        break;
 8003134:	e014      	b.n	8003160 <xMBRTUReceiveFSM+0x78>
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_RX_RCV:
        if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
 8003136:	4b0d      	ldr	r3, [pc, #52]	; (800316c <xMBRTUReceiveFSM+0x84>)
 8003138:	881b      	ldrh	r3, [r3, #0]
 800313a:	b29b      	uxth	r3, r3
 800313c:	2bff      	cmp	r3, #255	; 0xff
 800313e:	d80a      	bhi.n	8003156 <xMBRTUReceiveFSM+0x6e>
        {
            ucRTUBuf[usRcvBufferPos++] = ucByte;
 8003140:	490a      	ldr	r1, [pc, #40]	; (800316c <xMBRTUReceiveFSM+0x84>)
 8003142:	880b      	ldrh	r3, [r1, #0]
 8003144:	b29b      	uxth	r3, r3
 8003146:	1c5a      	adds	r2, r3, #1
 8003148:	b292      	uxth	r2, r2
 800314a:	800a      	strh	r2, [r1, #0]
 800314c:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8003150:	4a07      	ldr	r2, [pc, #28]	; (8003170 <xMBRTUReceiveFSM+0x88>)
 8003152:	54d1      	strb	r1, [r2, r3]
 8003154:	e002      	b.n	800315c <xMBRTUReceiveFSM+0x74>
        }
        else
        {
            eRcvState = STATE_RX_ERROR;
 8003156:	2203      	movs	r2, #3
 8003158:	4b03      	ldr	r3, [pc, #12]	; (8003168 <xMBRTUReceiveFSM+0x80>)
 800315a:	701a      	strb	r2, [r3, #0]
        }
        vMBPortTimersEnable(  );
 800315c:	f000 f9b8 	bl	80034d0 <vMBPortTimersEnable>
        break;
    }
    return xTaskNeedSwitch;
}
 8003160:	2000      	movs	r0, #0
 8003162:	b003      	add	sp, #12
 8003164:	f85d fb04 	ldr.w	pc, [sp], #4
 8003168:	20000411 	.word	0x20000411
 800316c:	2000040e 	.word	0x2000040e
 8003170:	2000059c 	.word	0x2000059c

08003174 <xMBRTUTransmitFSM>:

BOOL
xMBRTUTransmitFSM( void )
{
 8003174:	b510      	push	{r4, lr}
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_RX_IDLE );

    switch ( eSndState )
 8003176:	4b1c      	ldr	r3, [pc, #112]	; (80031e8 <xMBRTUTransmitFSM+0x74>)
 8003178:	781b      	ldrb	r3, [r3, #0]
 800317a:	b123      	cbz	r3, 8003186 <xMBRTUTransmitFSM+0x12>
 800317c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003180:	2a01      	cmp	r2, #1
 8003182:	d006      	beq.n	8003192 <xMBRTUTransmitFSM+0x1e>
 8003184:	e02b      	b.n	80031de <xMBRTUTransmitFSM+0x6a>
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
 8003186:	2100      	movs	r1, #0
 8003188:	2001      	movs	r0, #1
 800318a:	f000 f879 	bl	8003280 <vMBPortSerialEnable>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
 800318e:	2400      	movs	r4, #0
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
        break;
 8003190:	e028      	b.n	80031e4 <xMBRTUTransmitFSM+0x70>

    case STATE_TX_XMIT:
        /* check if we are finished. */
        if( usSndBufferCount != 0 )
 8003192:	4b16      	ldr	r3, [pc, #88]	; (80031ec <xMBRTUTransmitFSM+0x78>)
 8003194:	881b      	ldrh	r3, [r3, #0]
 8003196:	b29b      	uxth	r3, r3
 8003198:	b17b      	cbz	r3, 80031ba <xMBRTUTransmitFSM+0x46>
        {
            xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
 800319a:	4c15      	ldr	r4, [pc, #84]	; (80031f0 <xMBRTUTransmitFSM+0x7c>)
 800319c:	6823      	ldr	r3, [r4, #0]
 800319e:	7818      	ldrb	r0, [r3, #0]
 80031a0:	f000 f924 	bl	80033ec <xMBPortSerialPutByte>
            pucSndBufferCur++;  /* next byte in sendbuffer. */
 80031a4:	6823      	ldr	r3, [r4, #0]
 80031a6:	3301      	adds	r3, #1
 80031a8:	6023      	str	r3, [r4, #0]
            usSndBufferCount--;
 80031aa:	4a10      	ldr	r2, [pc, #64]	; (80031ec <xMBRTUTransmitFSM+0x78>)
 80031ac:	8813      	ldrh	r3, [r2, #0]
 80031ae:	b29b      	uxth	r3, r3
 80031b0:	3b01      	subs	r3, #1
 80031b2:	b29b      	uxth	r3, r3
 80031b4:	8013      	strh	r3, [r2, #0]
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
 80031b6:	2400      	movs	r4, #0
 80031b8:	e014      	b.n	80031e4 <xMBRTUTransmitFSM+0x70>
            usSndBufferCount--;
        }
        else
        {
        	//TODO: Added for testing waiting for transmit to finish
        	if(ADCT_BGS_RS485_USART_PORT->SR & USART_SR_TC)
 80031ba:	4b0e      	ldr	r3, [pc, #56]	; (80031f4 <xMBRTUTransmitFSM+0x80>)
 80031bc:	881b      	ldrh	r3, [r3, #0]
 80031be:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80031c2:	b29b      	uxth	r3, r3
 80031c4:	b16b      	cbz	r3, 80031e2 <xMBRTUTransmitFSM+0x6e>
        	{
        		xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
 80031c6:	2003      	movs	r0, #3
 80031c8:	f000 f83c 	bl	8003244 <xMBPortEventPost>
 80031cc:	4604      	mov	r4, r0
        		/* Disable transmitter. This prevents another transmit buffer
        		 * empty interrupt. */
        		vMBPortSerialEnable( TRUE, FALSE );
 80031ce:	2100      	movs	r1, #0
 80031d0:	2001      	movs	r0, #1
 80031d2:	f000 f855 	bl	8003280 <vMBPortSerialEnable>
        		eSndState = STATE_TX_IDLE;
 80031d6:	2200      	movs	r2, #0
 80031d8:	4b03      	ldr	r3, [pc, #12]	; (80031e8 <xMBRTUTransmitFSM+0x74>)
 80031da:	701a      	strb	r2, [r3, #0]
 80031dc:	e002      	b.n	80031e4 <xMBRTUTransmitFSM+0x70>
}

BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;
 80031de:	2400      	movs	r4, #0
 80031e0:	e000      	b.n	80031e4 <xMBRTUTransmitFSM+0x70>
 80031e2:	2400      	movs	r4, #0
        }
        break;
    }

    return xNeedPoll;
}
 80031e4:	4620      	mov	r0, r4
 80031e6:	bd10      	pop	{r4, pc}
 80031e8:	20000410 	.word	0x20000410
 80031ec:	2000040c 	.word	0x2000040c
 80031f0:	20000408 	.word	0x20000408
 80031f4:	40004800 	.word	0x40004800

080031f8 <xMBRTUTimerT35Expired>:

BOOL
xMBRTUTimerT35Expired( void )
{
 80031f8:	b510      	push	{r4, lr}
    BOOL            xNeedPoll = FALSE;

    switch ( eRcvState )
 80031fa:	4b0d      	ldr	r3, [pc, #52]	; (8003230 <xMBRTUTimerT35Expired+0x38>)
 80031fc:	781b      	ldrb	r3, [r3, #0]
 80031fe:	b123      	cbz	r3, 800320a <xMBRTUTimerT35Expired+0x12>
 8003200:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003204:	2a02      	cmp	r2, #2
 8003206:	d005      	beq.n	8003214 <xMBRTUTimerT35Expired+0x1c>
 8003208:	e009      	b.n	800321e <xMBRTUTimerT35Expired+0x26>
    {
        /* Timer t35 expired. Startup phase is finished. */
    case STATE_RX_INIT:
        xNeedPoll = xMBPortEventPost( EV_READY );
 800320a:	2000      	movs	r0, #0
 800320c:	f000 f81a 	bl	8003244 <xMBPortEventPost>
 8003210:	4604      	mov	r4, r0
        break;
 8003212:	e005      	b.n	8003220 <xMBRTUTimerT35Expired+0x28>

        /* A frame was received and t35 expired. Notify the listener that
         * a new frame was received. */
    case STATE_RX_RCV:
        xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
 8003214:	2001      	movs	r0, #1
 8003216:	f000 f815 	bl	8003244 <xMBPortEventPost>
 800321a:	4604      	mov	r4, r0
        break;
 800321c:	e000      	b.n	8003220 <xMBRTUTimerT35Expired+0x28>
}

BOOL
xMBRTUTimerT35Expired( void )
{
    BOOL            xNeedPoll = FALSE;
 800321e:	2400      	movs	r4, #0
    default:
        assert( ( eRcvState == STATE_RX_INIT ) ||
                ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    }

    vMBPortTimersDisable(  );
 8003220:	f000 f964 	bl	80034ec <vMBPortTimersDisable>
    eRcvState = STATE_RX_IDLE;
 8003224:	2201      	movs	r2, #1
 8003226:	4b02      	ldr	r3, [pc, #8]	; (8003230 <xMBRTUTimerT35Expired+0x38>)
 8003228:	701a      	strb	r2, [r3, #0]

    return xNeedPoll;
}
 800322a:	4620      	mov	r0, r4
 800322c:	bd10      	pop	{r4, pc}
 800322e:	bf00      	nop
 8003230:	20000411 	.word	0x20000411

08003234 <xMBPortEventInit>:
static BOOL     xEventInQueue;

/* ----------------------- Start implementation -----------------------------*/
BOOL xMBPortEventInit( void )
{
    xEventInQueue = FALSE;
 8003234:	2200      	movs	r2, #0
 8003236:	4b02      	ldr	r3, [pc, #8]	; (8003240 <xMBPortEventInit+0xc>)
 8003238:	701a      	strb	r2, [r3, #0]
    return TRUE;
}
 800323a:	2001      	movs	r0, #1
 800323c:	4770      	bx	lr
 800323e:	bf00      	nop
 8003240:	20000412 	.word	0x20000412

08003244 <xMBPortEventPost>:

BOOL xMBPortEventPost( eMBEventType eEvent )
{
    xEventInQueue = TRUE;
 8003244:	2301      	movs	r3, #1
 8003246:	4a03      	ldr	r2, [pc, #12]	; (8003254 <xMBPortEventPost+0x10>)
 8003248:	7013      	strb	r3, [r2, #0]
    eQueuedEvent = eEvent;
 800324a:	4a03      	ldr	r2, [pc, #12]	; (8003258 <xMBPortEventPost+0x14>)
 800324c:	7010      	strb	r0, [r2, #0]
    return TRUE;
}
 800324e:	4618      	mov	r0, r3
 8003250:	4770      	bx	lr
 8003252:	bf00      	nop
 8003254:	20000412 	.word	0x20000412
 8003258:	20000413 	.word	0x20000413

0800325c <xMBPortEventGet>:

BOOL xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL xEventHappened = FALSE;

    if ( xEventInQueue )
 800325c:	4b06      	ldr	r3, [pc, #24]	; (8003278 <xMBPortEventGet+0x1c>)
 800325e:	781b      	ldrb	r3, [r3, #0]
 8003260:	b13b      	cbz	r3, 8003272 <xMBPortEventGet+0x16>
    {
        *eEvent = eQueuedEvent;
 8003262:	4b06      	ldr	r3, [pc, #24]	; (800327c <xMBPortEventGet+0x20>)
 8003264:	781b      	ldrb	r3, [r3, #0]
 8003266:	7003      	strb	r3, [r0, #0]
        xEventInQueue = FALSE;
 8003268:	2200      	movs	r2, #0
 800326a:	4b03      	ldr	r3, [pc, #12]	; (8003278 <xMBPortEventGet+0x1c>)
 800326c:	701a      	strb	r2, [r3, #0]
        xEventHappened = TRUE;
 800326e:	2001      	movs	r0, #1
 8003270:	4770      	bx	lr
    return TRUE;
}

BOOL xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL xEventHappened = FALSE;
 8003272:	2000      	movs	r0, #0
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    return xEventHappened;
}
 8003274:	4770      	bx	lr
 8003276:	bf00      	nop
 8003278:	20000412 	.word	0x20000412
 800327c:	20000413 	.word	0x20000413

08003280 <vMBPortSerialEnable>:
/* ----------------------- Modbus includes ----------------------------------*/
#include "mb.h"
#include "mbport.h"

void vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )
{
 8003280:	b510      	push	{r4, lr}
 8003282:	460c      	mov	r4, r1
	if( xRxEnable )
 8003284:	b158      	cbz	r0, 800329e <vMBPortSerialEnable+0x1e>
	{
		/* enable RX interrupt */
		/* switch 485 to receive mode */
		GPIO_ResetBits(ADCT_BGS_RS485_PORT, ADCT_BGS_RS485_DE_RE_PIN);
 8003286:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800328a:	4812      	ldr	r0, [pc, #72]	; (80032d4 <vMBPortSerialEnable+0x54>)
 800328c:	f000 ffaa 	bl	80041e4 <GPIO_ResetBits>
		USART_ITConfig( ADCT_BGS_RS485_USART_PORT, USART_IT_RXNE, ENABLE );
 8003290:	2201      	movs	r2, #1
 8003292:	f240 5125 	movw	r1, #1317	; 0x525
 8003296:	4810      	ldr	r0, [pc, #64]	; (80032d8 <vMBPortSerialEnable+0x58>)
 8003298:	f001 fba8 	bl	80049ec <USART_ITConfig>
 800329c:	e005      	b.n	80032aa <vMBPortSerialEnable+0x2a>
	}
	else
	{
		/* disable RX interrupt */
		USART_ITConfig( ADCT_BGS_RS485_USART_PORT, USART_IT_RXNE, DISABLE );
 800329e:	2200      	movs	r2, #0
 80032a0:	f240 5125 	movw	r1, #1317	; 0x525
 80032a4:	480c      	ldr	r0, [pc, #48]	; (80032d8 <vMBPortSerialEnable+0x58>)
 80032a6:	f001 fba1 	bl	80049ec <USART_ITConfig>
	}

	if ( xTxEnable )
 80032aa:	b15c      	cbz	r4, 80032c4 <vMBPortSerialEnable+0x44>
	{
		/* switch 485 to transmit mode */
		GPIO_SetBits(ADCT_BGS_RS485_PORT, ADCT_BGS_RS485_DE_RE_PIN);
 80032ac:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80032b0:	4808      	ldr	r0, [pc, #32]	; (80032d4 <vMBPortSerialEnable+0x54>)
 80032b2:	f000 ff95 	bl	80041e0 <GPIO_SetBits>
		/* enable RX interrupt */
		USART_ITConfig( ADCT_BGS_RS485_USART_PORT, USART_IT_TXE, ENABLE );
 80032b6:	2201      	movs	r2, #1
 80032b8:	f240 7127 	movw	r1, #1831	; 0x727
 80032bc:	4806      	ldr	r0, [pc, #24]	; (80032d8 <vMBPortSerialEnable+0x58>)
 80032be:	f001 fb95 	bl	80049ec <USART_ITConfig>
 80032c2:	bd10      	pop	{r4, pc}
	}
	else
	{
		/* disable TX interrupt */
		USART_ITConfig( ADCT_BGS_RS485_USART_PORT, USART_IT_TXE, DISABLE );
 80032c4:	2200      	movs	r2, #0
 80032c6:	f240 7127 	movw	r1, #1831	; 0x727
 80032ca:	4803      	ldr	r0, [pc, #12]	; (80032d8 <vMBPortSerialEnable+0x58>)
 80032cc:	f001 fb8e 	bl	80049ec <USART_ITConfig>
 80032d0:	bd10      	pop	{r4, pc}
 80032d2:	bf00      	nop
 80032d4:	40010c00 	.word	0x40010c00
 80032d8:	40004800 	.word	0x40004800

080032dc <xMBPortSerialInit>:
	}
}

BOOL xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits,
		eMBParity eParity )
{
 80032dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80032e0:	b086      	sub	sp, #24
 80032e2:	4688      	mov	r8, r1
 80032e4:	4617      	mov	r7, r2
 80032e6:	461e      	mov	r6, r3
	USART_InitTypeDef       USART_InitStructure;

	/* prevent compiler warning. */
	(void) ucPORT;

	RCC_APB1PeriphClockCmd( ADCT_BGS_RS485_USART_CLK, ENABLE );
 80032e8:	2101      	movs	r1, #1
 80032ea:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80032ee:	f001 f9c9 	bl	8004684 <RCC_APB1PeriphClockCmd>
	RCC_APB2PeriphClockCmd( ADCT_BGS_RS485_CLK|RCC_APB2Periph_AFIO, ENABLE );
 80032f2:	2101      	movs	r1, #1
 80032f4:	2009      	movs	r0, #9
 80032f6:	f001 f9b7 	bl	8004668 <RCC_APB2PeriphClockCmd>


	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_RS485_TX_PIN;
 80032fa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80032fe:	f8ad 3010 	strh.w	r3, [sp, #16]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 8003302:	2318      	movs	r3, #24
 8003304:	f88d 3013 	strb.w	r3, [sp, #19]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003308:	2503      	movs	r5, #3
 800330a:	f88d 5012 	strb.w	r5, [sp, #18]

	GPIO_Init( ADCT_BGS_RS485_PORT, &GPIO_InitStructure );
 800330e:	4c35      	ldr	r4, [pc, #212]	; (80033e4 <xMBPortSerialInit+0x108>)
 8003310:	a904      	add	r1, sp, #16
 8003312:	4620      	mov	r0, r4
 8003314:	f000 ff06 	bl	8004124 <GPIO_Init>


	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_RS485_RX_PIN    ;
 8003318:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800331c:	f8ad 3010 	strh.w	r3, [sp, #16]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8003320:	2304      	movs	r3, #4
 8003322:	f88d 3013 	strb.w	r3, [sp, #19]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003326:	f88d 5012 	strb.w	r5, [sp, #18]

	GPIO_Init( ADCT_BGS_RS485_PORT, &GPIO_InitStructure );
 800332a:	a904      	add	r1, sp, #16
 800332c:	4620      	mov	r0, r4
 800332e:	f000 fef9 	bl	8004124 <GPIO_Init>
	NVIC_InitStructure.NVIC_IRQChannel = ADCT_BGS_RS485_USART_IRQ;
 8003332:	2327      	movs	r3, #39	; 0x27
 8003334:	f88d 3014 	strb.w	r3, [sp, #20]
//	NVIC_InitStructure.NVIC_IRQChannel = 20;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8003338:	2300      	movs	r3, #0
 800333a:	f88d 3015 	strb.w	r3, [sp, #21]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800333e:	f88d 3016 	strb.w	r3, [sp, #22]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003342:	2301      	movs	r3, #1
 8003344:	f88d 3017 	strb.w	r3, [sp, #23]
	NVIC_Init(&NVIC_InitStructure);
 8003348:	a805      	add	r0, sp, #20
 800334a:	f000 fd1d 	bl	8003d88 <NVIC_Init>

	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_RS485_DE_RE_PIN;
 800334e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003352:	f8ad 3010 	strh.w	r3, [sp, #16]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003356:	2310      	movs	r3, #16
 8003358:	f88d 3013 	strb.w	r3, [sp, #19]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800335c:	f88d 5012 	strb.w	r5, [sp, #18]
	GPIO_Init( ADCT_BGS_RS485_PORT, &GPIO_InitStructure );
 8003360:	eb0d 0103 	add.w	r1, sp, r3
 8003364:	4620      	mov	r0, r4
 8003366:	f000 fedd 	bl	8004124 <GPIO_Init>

	USART_InitStructure.USART_BaudRate = (uint32_t)ulBaudRate;
 800336a:	f8cd 8000 	str.w	r8, [sp]

	if( ucDataBits == 9 )
 800336e:	2f09      	cmp	r7, #9
 8003370:	d104      	bne.n	800337c <xMBPortSerialInit+0xa0>
		USART_InitStructure.USART_WordLength = USART_WordLength_9b;
 8003372:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003376:	f8ad 3004 	strh.w	r3, [sp, #4]
 800337a:	e002      	b.n	8003382 <xMBPortSerialInit+0xa6>
	else
		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800337c:	2300      	movs	r3, #0
 800337e:	f8ad 3004 	strh.w	r3, [sp, #4]

	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8003382:	2300      	movs	r3, #0
 8003384:	f8ad 3006 	strh.w	r3, [sp, #6]

	switch( eParity )
 8003388:	2e01      	cmp	r6, #1
 800338a:	d007      	beq.n	800339c <xMBPortSerialInit+0xc0>
 800338c:	b116      	cbz	r6, 8003394 <xMBPortSerialInit+0xb8>
 800338e:	2e02      	cmp	r6, #2
 8003390:	d009      	beq.n	80033a6 <xMBPortSerialInit+0xca>
 8003392:	e00d      	b.n	80033b0 <xMBPortSerialInit+0xd4>
	{
	case MB_PAR_NONE:
		USART_InitStructure.USART_Parity = USART_Parity_No;
 8003394:	2300      	movs	r3, #0
 8003396:	f8ad 3008 	strh.w	r3, [sp, #8]
		break;
 800339a:	e00c      	b.n	80033b6 <xMBPortSerialInit+0xda>
	case MB_PAR_ODD:
		USART_InitStructure.USART_Parity = USART_Parity_Odd;
 800339c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 80033a0:	f8ad 3008 	strh.w	r3, [sp, #8]
		break;
 80033a4:	e007      	b.n	80033b6 <xMBPortSerialInit+0xda>
	case MB_PAR_EVEN:
		USART_InitStructure.USART_Parity = USART_Parity_Even;
 80033a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80033aa:	f8ad 3008 	strh.w	r3, [sp, #8]
		break;
 80033ae:	e002      	b.n	80033b6 <xMBPortSerialInit+0xda>
	default:
		USART_InitStructure.USART_Parity = USART_Parity_No;
 80033b0:	2300      	movs	r3, #0
 80033b2:	f8ad 3008 	strh.w	r3, [sp, #8]
		break;
	};

	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80033b6:	230c      	movs	r3, #12
 80033b8:	f8ad 300a 	strh.w	r3, [sp, #10]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 80033bc:	2300      	movs	r3, #0
 80033be:	f8ad 300c 	strh.w	r3, [sp, #12]

	USART_Init( ADCT_BGS_RS485_USART_PORT, &USART_InitStructure );
 80033c2:	4c09      	ldr	r4, [pc, #36]	; (80033e8 <xMBPortSerialInit+0x10c>)
 80033c4:	4669      	mov	r1, sp
 80033c6:	4620      	mov	r0, r4
 80033c8:	f001 fa9e 	bl	8004908 <USART_Init>

	vMBPortSerialEnable( TRUE, TRUE );
 80033cc:	2101      	movs	r1, #1
 80033ce:	4608      	mov	r0, r1
 80033d0:	f7ff ff56 	bl	8003280 <vMBPortSerialEnable>

	USART_Cmd( ADCT_BGS_RS485_USART_PORT, ENABLE );
 80033d4:	2101      	movs	r1, #1
 80033d6:	4620      	mov	r0, r4
 80033d8:	f001 fafa 	bl	80049d0 <USART_Cmd>

	return TRUE;
}
 80033dc:	2001      	movs	r0, #1
 80033de:	b006      	add	sp, #24
 80033e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80033e4:	40010c00 	.word	0x40010c00
 80033e8:	40004800 	.word	0x40004800

080033ec <xMBPortSerialPutByte>:

BOOL xMBPortSerialPutByte( CHAR ucByte )
{
 80033ec:	b508      	push	{r3, lr}
	USART_SendData( ADCT_BGS_RS485_USART_PORT, (uint16_t) ucByte );
 80033ee:	4601      	mov	r1, r0
 80033f0:	4802      	ldr	r0, [pc, #8]	; (80033fc <xMBPortSerialPutByte+0x10>)
 80033f2:	f001 fb17 	bl	8004a24 <USART_SendData>
	return TRUE;
}
 80033f6:	2001      	movs	r0, #1
 80033f8:	bd08      	pop	{r3, pc}
 80033fa:	bf00      	nop
 80033fc:	40004800 	.word	0x40004800

08003400 <xMBPortSerialGetByte>:

BOOL xMBPortSerialGetByte( CHAR * pucByte )
{
 8003400:	b510      	push	{r4, lr}
 8003402:	4604      	mov	r4, r0
	*pucByte = (CHAR) USART_ReceiveData( ADCT_BGS_RS485_USART_PORT );
 8003404:	4802      	ldr	r0, [pc, #8]	; (8003410 <xMBPortSerialGetByte+0x10>)
 8003406:	f001 fb11 	bl	8004a2c <USART_ReceiveData>
 800340a:	7020      	strb	r0, [r4, #0]
	return TRUE;
}
 800340c:	2001      	movs	r0, #1
 800340e:	bd10      	pop	{r4, pc}
 8003410:	40004800 	.word	0x40004800

08003414 <USART3_IRQHandler>:

void USART3_IRQHandler( void )
{
 8003414:	b508      	push	{r3, lr}
	if ( USART_GetITStatus( ADCT_BGS_RS485_USART_PORT, USART_IT_RXNE ) != RESET )
 8003416:	f240 5125 	movw	r1, #1317	; 0x525
 800341a:	480d      	ldr	r0, [pc, #52]	; (8003450 <USART3_IRQHandler+0x3c>)
 800341c:	f001 fb0a 	bl	8004a34 <USART_GetITStatus>
 8003420:	b138      	cbz	r0, 8003432 <USART3_IRQHandler+0x1e>
	{
		USART_ClearITPendingBit( ADCT_BGS_RS485_USART_PORT, USART_IT_RXNE );
 8003422:	f240 5125 	movw	r1, #1317	; 0x525
 8003426:	480a      	ldr	r0, [pc, #40]	; (8003450 <USART3_IRQHandler+0x3c>)
 8003428:	f001 fb2a 	bl	8004a80 <USART_ClearITPendingBit>
		pxMBFrameCBByteReceived();
 800342c:	4b09      	ldr	r3, [pc, #36]	; (8003454 <USART3_IRQHandler+0x40>)
 800342e:	681b      	ldr	r3, [r3, #0]
 8003430:	4798      	blx	r3

	}
	if ( USART_GetITStatus( ADCT_BGS_RS485_USART_PORT, USART_IT_TXE ) != RESET )
 8003432:	f240 7127 	movw	r1, #1831	; 0x727
 8003436:	4806      	ldr	r0, [pc, #24]	; (8003450 <USART3_IRQHandler+0x3c>)
 8003438:	f001 fafc 	bl	8004a34 <USART_GetITStatus>
 800343c:	b138      	cbz	r0, 800344e <USART3_IRQHandler+0x3a>
	{
		pxMBFrameCBTransmitterEmpty();
 800343e:	4b06      	ldr	r3, [pc, #24]	; (8003458 <USART3_IRQHandler+0x44>)
 8003440:	681b      	ldr	r3, [r3, #0]
 8003442:	4798      	blx	r3
		//TODO: put this line after calling pxMBFrameCBTransmitterEmpty() fucntion
		USART_ClearITPendingBit( ADCT_BGS_RS485_USART_PORT, USART_IT_TXE );
 8003444:	f240 7127 	movw	r1, #1831	; 0x727
 8003448:	4801      	ldr	r0, [pc, #4]	; (8003450 <USART3_IRQHandler+0x3c>)
 800344a:	f001 fb19 	bl	8004a80 <USART_ClearITPendingBit>
 800344e:	bd08      	pop	{r3, pc}
 8003450:	40004800 	.word	0x40004800
 8003454:	20000590 	.word	0x20000590
 8003458:	20000588 	.word	0x20000588

0800345c <xMBPortTimersInit>:
#include "mb.h"
#include "mbport.h"

/* ----------------------- Start implementation -----------------------------*/
BOOL xMBPortTimersInit( USHORT usTim1Timerout50us )
{
 800345c:	b530      	push	{r4, r5, lr}
 800345e:	b085      	sub	sp, #20
 8003460:	4604      	mov	r4, r0
    NVIC_InitTypeDef NVIC_InitStructure;
    TIM_TimeBaseInitTypeDef base_timer;

    RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM4, ENABLE );
 8003462:	2101      	movs	r1, #1
 8003464:	2004      	movs	r0, #4
 8003466:	f001 f90d 	bl	8004684 <RCC_APB1PeriphClockCmd>

    TIM_TimeBaseStructInit( &base_timer );
 800346a:	4668      	mov	r0, sp
 800346c:	f001 fa16 	bl	800489c <TIM_TimeBaseStructInit>

    base_timer.TIM_Prescaler = 1800 - 1;
 8003470:	f240 7307 	movw	r3, #1799	; 0x707
 8003474:	f8ad 3000 	strh.w	r3, [sp]
    base_timer.TIM_Period = ( (uint32_t) usTim1Timerout50us ) - 1;
 8003478:	3c01      	subs	r4, #1
 800347a:	f8ad 4004 	strh.w	r4, [sp, #4]
    base_timer.TIM_ClockDivision = 0;
 800347e:	2300      	movs	r3, #0
 8003480:	f8ad 3006 	strh.w	r3, [sp, #6]
    base_timer.TIM_CounterMode = TIM_CounterMode_Up;
 8003484:	f8ad 3002 	strh.w	r3, [sp, #2]
    TIM_TimeBaseInit( TIM4, &base_timer );
 8003488:	4d10      	ldr	r5, [pc, #64]	; (80034cc <xMBPortTimersInit+0x70>)
 800348a:	4669      	mov	r1, sp
 800348c:	4628      	mov	r0, r5
 800348e:	f001 f9bb 	bl	8004808 <TIM_TimeBaseInit>

    TIM_ClearITPendingBit( TIM4, TIM_IT_Update );
 8003492:	2101      	movs	r1, #1
 8003494:	4628      	mov	r0, r5
 8003496:	f001 fa33 	bl	8004900 <TIM_ClearITPendingBit>

    TIM_ITConfig( TIM4, TIM_IT_Update, ENABLE );
 800349a:	2201      	movs	r2, #1
 800349c:	4611      	mov	r1, r2
 800349e:	4628      	mov	r0, r5
 80034a0:	f001 fa14 	bl	80048cc <TIM_ITConfig>

    NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
 80034a4:	231e      	movs	r3, #30
 80034a6:	f88d 300c 	strb.w	r3, [sp, #12]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 80034aa:	2401      	movs	r4, #1
 80034ac:	f88d 400d 	strb.w	r4, [sp, #13]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 80034b0:	f88d 400e 	strb.w	r4, [sp, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80034b4:	f88d 400f 	strb.w	r4, [sp, #15]
    NVIC_Init( &NVIC_InitStructure );
 80034b8:	a803      	add	r0, sp, #12
 80034ba:	f000 fc65 	bl	8003d88 <NVIC_Init>

    TIM_Cmd( TIM4, ENABLE );
 80034be:	4621      	mov	r1, r4
 80034c0:	4628      	mov	r0, r5
 80034c2:	f001 f9f5 	bl	80048b0 <TIM_Cmd>

    return TRUE;
}
 80034c6:	4620      	mov	r0, r4
 80034c8:	b005      	add	sp, #20
 80034ca:	bd30      	pop	{r4, r5, pc}
 80034cc:	40000800 	.word	0x40000800

080034d0 <vMBPortTimersEnable>:


void vMBPortTimersEnable()
{
 80034d0:	b510      	push	{r4, lr}
    TIM_SetCounter( TIM4, 0 );
 80034d2:	4c05      	ldr	r4, [pc, #20]	; (80034e8 <vMBPortTimersEnable+0x18>)
 80034d4:	2100      	movs	r1, #0
 80034d6:	4620      	mov	r0, r4
 80034d8:	f001 fa04 	bl	80048e4 <TIM_SetCounter>
    TIM_Cmd( TIM4, ENABLE );
 80034dc:	2101      	movs	r1, #1
 80034de:	4620      	mov	r0, r4
 80034e0:	f001 f9e6 	bl	80048b0 <TIM_Cmd>
 80034e4:	bd10      	pop	{r4, pc}
 80034e6:	bf00      	nop
 80034e8:	40000800 	.word	0x40000800

080034ec <vMBPortTimersDisable>:
}

void vMBPortTimersDisable()
{
 80034ec:	b508      	push	{r3, lr}
    TIM_Cmd( TIM4, DISABLE );
 80034ee:	2100      	movs	r1, #0
 80034f0:	4801      	ldr	r0, [pc, #4]	; (80034f8 <vMBPortTimersDisable+0xc>)
 80034f2:	f001 f9dd 	bl	80048b0 <TIM_Cmd>
 80034f6:	bd08      	pop	{r3, pc}
 80034f8:	40000800 	.word	0x40000800

080034fc <TIM4_IRQHandler>:
}

void TIM4_IRQHandler( void )
{
 80034fc:	b508      	push	{r3, lr}
    if ( TIM_GetITStatus( TIM4, TIM_IT_Update ) != RESET )
 80034fe:	2101      	movs	r1, #1
 8003500:	4805      	ldr	r0, [pc, #20]	; (8003518 <TIM4_IRQHandler+0x1c>)
 8003502:	f001 f9f1 	bl	80048e8 <TIM_GetITStatus>
 8003506:	b130      	cbz	r0, 8003516 <TIM4_IRQHandler+0x1a>
    {
        TIM_ClearITPendingBit( TIM4, TIM_IT_Update );
 8003508:	2101      	movs	r1, #1
 800350a:	4803      	ldr	r0, [pc, #12]	; (8003518 <TIM4_IRQHandler+0x1c>)
 800350c:	f001 f9f8 	bl	8004900 <TIM_ClearITPendingBit>

        (void) pxMBPortCBTimerExpired();
 8003510:	4b02      	ldr	r3, [pc, #8]	; (800351c <TIM4_IRQHandler+0x20>)
 8003512:	681b      	ldr	r3, [r3, #0]
 8003514:	4798      	blx	r3
 8003516:	bd08      	pop	{r3, pc}
 8003518:	40000800 	.word	0x40000800
 800351c:	2000058c 	.word	0x2000058c

08003520 <ADCT_Relay_Init>:
 *  Created on: Dec 25, 2016
 *      Author: Administrator
 */
#include "ADCT_Relay.h"
void ADCT_Relay_Init(void )
{
 8003520:	b570      	push	{r4, r5, r6, lr}
 8003522:	b082      	sub	sp, #8
	GPIO_InitTypeDef GPIO_InitStructure;
	/* GPIO Periph clock enable */
	RCC_APB2PeriphClockCmd(ADCT_BGS_CTRL_RELAY_S_CLK|ADCT_BGS_CTRL_RELAY_B09_CLK|ADCT_BGS_CTRL_RELAY_B10_CLK, ENABLE);
 8003524:	2101      	movs	r1, #1
 8003526:	2014      	movs	r0, #20
 8003528:	f001 f89e 	bl	8004668 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_CTRL_RELAY_S01|ADCT_BGS_CTRL_RELAY_S02|ADCT_BGS_CTRL_RELAY_S03|ADCT_BGS_CTRL_RELAY_S04|ADCT_BGS_CTRL_RELAY_S05|ADCT_BGS_CTRL_RELAY_S06|ADCT_BGS_CTRL_RELAY_S07|ADCT_BGS_CTRL_RELAY_S08;
 800352c:	23ff      	movs	r3, #255	; 0xff
 800352e:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003532:	2503      	movs	r5, #3
 8003534:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003538:	2410      	movs	r4, #16
 800353a:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(ADCT_BGS_CTRL_RELAY_S_PORT, &GPIO_InitStructure);
 800353e:	4e11      	ldr	r6, [pc, #68]	; (8003584 <ADCT_Relay_Init+0x64>)
 8003540:	a901      	add	r1, sp, #4
 8003542:	4630      	mov	r0, r6
 8003544:	f000 fdee 	bl	8004124 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_CTRL_RELAY_B09;
 8003548:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800354c:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003550:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003554:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(ADCT_BGS_CTRL_RELAY_B09_PORT, &GPIO_InitStructure);
 8003558:	a901      	add	r1, sp, #4
 800355a:	480b      	ldr	r0, [pc, #44]	; (8003588 <ADCT_Relay_Init+0x68>)
 800355c:	f000 fde2 	bl	8004124 <GPIO_Init>
	/* Disable the Serial Wire Jtag Debug Port SWJ-DP */
#ifdef PRODUCTION_CODE
	GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);
 8003560:	2101      	movs	r1, #1
 8003562:	480a      	ldr	r0, [pc, #40]	; (800358c <ADCT_Relay_Init+0x6c>)
 8003564:	f000 fe46 	bl	80041f4 <GPIO_PinRemapConfig>
#endif
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_CTRL_RELAY_B10;
 8003568:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800356c:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003570:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003574:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(ADCT_BGS_CTRL_RELAY_B10_PORT, &GPIO_InitStructure);
 8003578:	a901      	add	r1, sp, #4
 800357a:	4630      	mov	r0, r6
 800357c:	f000 fdd2 	bl	8004124 <GPIO_Init>
}
 8003580:	b002      	add	sp, #8
 8003582:	bd70      	pop	{r4, r5, r6, pc}
 8003584:	40010800 	.word	0x40010800
 8003588:	40011000 	.word	0x40011000
 800358c:	00300400 	.word	0x00300400

08003590 <RTC_RCC_Configuration>:
		}
	}
}

void RTC_RCC_Configuration(void)
{
 8003590:	b508      	push	{r3, lr}

	/* Enable HSE */
	//RCC_HSEConfig(RCC_HSE_ON);

	/* Wait till HSE is ready */
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
 8003592:	f001 f8a5 	bl	80046e0 <RCC_WaitForHSEStartUp>

	if(HSEStartUpStatus == SUCCESS)
 8003596:	2801      	cmp	r0, #1
 8003598:	d124      	bne.n	80035e4 <RTC_RCC_Configuration+0x54>
	{
		/* Enable Prefetch Buffer */
		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 800359a:	2010      	movs	r0, #16
 800359c:	f000 fdaa 	bl	80040f4 <FLASH_PrefetchBufferCmd>

		/* Flash 2 wait state */
		FLASH_SetLatency(FLASH_Latency_2);
 80035a0:	2002      	movs	r0, #2
 80035a2:	f000 fd9d 	bl	80040e0 <FLASH_SetLatency>

		/* HCLK = SYSCLK */
		RCC_HCLKConfig(RCC_SYSCLK_Div1);
 80035a6:	2000      	movs	r0, #0
 80035a8:	f000 ffb2 	bl	8004510 <RCC_HCLKConfig>

		/* PCLK2 = HCLK */
		RCC_PCLK2Config(RCC_HCLK_Div1);
 80035ac:	2000      	movs	r0, #0
 80035ae:	f000 ffc3 	bl	8004538 <RCC_PCLK2Config>

		/* PCLK1 = HCLK/2 */
		RCC_PCLK1Config(RCC_HCLK_Div2);
 80035b2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80035b6:	f000 ffb5 	bl	8004524 <RCC_PCLK1Config>
		//RCC_PCLK1Config(RCC_HCLK_Div1);
		/* PLLCLK = 8MHz * 9 = 72 MHz */
		/* PLLCLK = 12MHz * 6 = 72 MHz */
		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
 80035ba:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
 80035be:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80035c2:	f000 ff83 	bl	80044cc <RCC_PLLConfig>
		//RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
		/* Enable PLL */
		RCC_PLLCmd(ENABLE);
 80035c6:	2001      	movs	r0, #1
 80035c8:	f000 ff8a 	bl	80044e0 <RCC_PLLCmd>

		/* Wait till PLL is ready */
		while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
 80035cc:	2039      	movs	r0, #57	; 0x39
 80035ce:	f001 f86d 	bl	80046ac <RCC_GetFlagStatus>
 80035d2:	2800      	cmp	r0, #0
 80035d4:	d0fa      	beq.n	80035cc <RTC_RCC_Configuration+0x3c>
		{
		}

		/* Select PLL as system clock source */
		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 80035d6:	2002      	movs	r0, #2
 80035d8:	f000 ff88 	bl	80044ec <RCC_SYSCLKConfig>

		/* Wait till PLL is used as system clock source */
		while(RCC_GetSYSCLKSource() != 0x08)
 80035dc:	f000 ff90 	bl	8004500 <RCC_GetSYSCLKSource>
 80035e0:	2808      	cmp	r0, #8
 80035e2:	d1fb      	bne.n	80035dc <RTC_RCC_Configuration+0x4c>
 80035e4:	bd08      	pop	{r3, pc}
 80035e6:	bf00      	nop

080035e8 <SetTime>:
 * @brief  Sets the RTC Current Counter Value
 * @param Hour, Minute and Seconds data
 * @retval : None
 */
void SetTime(uint8_t Hour,uint8_t Minute,uint8_t Seconds)
{
 80035e8:	b510      	push	{r4, lr}
	uint32_t CounterValue;

	CounterValue=((Hour * 3600)+ (Minute * 60)+Seconds);
 80035ea:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 80035ee:	008c      	lsls	r4, r1, #2
 80035f0:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 80035f4:	fb03 4000 	mla	r0, r3, r0, r4
 80035f8:	1814      	adds	r4, r2, r0

	RTC_WaitForLastTask();
 80035fa:	f001 f8e1 	bl	80047c0 <RTC_WaitForLastTask>
	RTC_SetCounter(CounterValue);
 80035fe:	4620      	mov	r0, r4
 8003600:	f001 f8c0 	bl	8004784 <RTC_SetCounter>
	RTC_WaitForLastTask();
 8003604:	f001 f8dc 	bl	80047c0 <RTC_WaitForLastTask>
 8003608:	bd10      	pop	{r4, pc}
 800360a:	bf00      	nop

0800360c <ADCT_BGS_Run_RTC>:
{
	SetTime(ptr->RTC_Hour, ptr->RTC_Min, ptr->RTC_Sec);
	SetDate(ptr->RTC_Mday, ptr->RTC_Mon, ptr->RTC_Year);
}
void ADCT_BGS_Run_RTC(ADCT_BGS_RTC_Types  *ptr)
{
 800360c:	b538      	push	{r3, r4, r5, lr}
 800360e:	4604      	mov	r4, r0
	uint32_t TimeVar;
	TimeVar=RTC_GetCounter();
 8003610:	f001 f8a4 	bl	800475c <RTC_GetCounter>
	TimeVar=TimeVar % 86400;
 8003614:	4b14      	ldr	r3, [pc, #80]	; (8003668 <ADCT_BGS_Run_RTC+0x5c>)
 8003616:	fba3 2300 	umull	r2, r3, r3, r0
 800361a:	0c1b      	lsrs	r3, r3, #16
 800361c:	4a13      	ldr	r2, [pc, #76]	; (800366c <ADCT_BGS_Run_RTC+0x60>)
 800361e:	fb02 0313 	mls	r3, r2, r3, r0
	ptr->RTC_Sec = (uint8_t)((TimeVar %3600)%60);
 8003622:	4a13      	ldr	r2, [pc, #76]	; (8003670 <ADCT_BGS_Run_RTC+0x64>)
 8003624:	fba2 1203 	umull	r1, r2, r2, r3
 8003628:	0ad1      	lsrs	r1, r2, #11
 800362a:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 800362e:	fb00 3111 	mls	r1, r0, r1, r3
 8003632:	4b10      	ldr	r3, [pc, #64]	; (8003674 <ADCT_BGS_Run_RTC+0x68>)
 8003634:	fba3 0301 	umull	r0, r3, r3, r1
 8003638:	095b      	lsrs	r3, r3, #5
 800363a:	461d      	mov	r5, r3
 800363c:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8003640:	0098      	lsls	r0, r3, #2
 8003642:	1a0b      	subs	r3, r1, r0
 8003644:	7023      	strb	r3, [r4, #0]
	ptr->RTC_Min = (uint8_t)((TimeVar%3600)/60);
 8003646:	7065      	strb	r5, [r4, #1]
	ptr->RTC_Hour = (uint8_t)(TimeVar/3600);
 8003648:	f3c2 22c7 	ubfx	r2, r2, #11, #8
 800364c:	70a2      	strb	r2, [r4, #2]
	ptr->RTC_Year =(BKP_ReadBackupRegister(BKP_DR4));
 800364e:	2010      	movs	r0, #16
 8003650:	f000 fbec 	bl	8003e2c <BKP_ReadBackupRegister>
 8003654:	80e0      	strh	r0, [r4, #6]
	ptr->RTC_Mon = (BKP_ReadBackupRegister(BKP_DR2));
 8003656:	2008      	movs	r0, #8
 8003658:	f000 fbe8 	bl	8003e2c <BKP_ReadBackupRegister>
 800365c:	7120      	strb	r0, [r4, #4]
	ptr->RTC_Mday = (BKP_ReadBackupRegister(BKP_DR3));
 800365e:	200c      	movs	r0, #12
 8003660:	f000 fbe4 	bl	8003e2c <BKP_ReadBackupRegister>
 8003664:	70e0      	strb	r0, [r4, #3]
 8003666:	bd38      	pop	{r3, r4, r5, pc}
 8003668:	c22e4507 	.word	0xc22e4507
 800366c:	00015180 	.word	0x00015180
 8003670:	91a2b3c5 	.word	0x91a2b3c5
 8003674:	88888889 	.word	0x88888889

08003678 <CheckLeap>:
 * @retval : 1: leap year
 *   0: not leap year
 */
uint8_t CheckLeap(uint16_t Year)
{
	if((Year%400)==0)
 8003678:	4b0e      	ldr	r3, [pc, #56]	; (80036b4 <CheckLeap+0x3c>)
 800367a:	fba3 2300 	umull	r2, r3, r3, r0
 800367e:	09db      	lsrs	r3, r3, #7
 8003680:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8003684:	fb02 0313 	mls	r3, r2, r3, r0
 8003688:	b29b      	uxth	r3, r3
 800368a:	b16b      	cbz	r3, 80036a8 <CheckLeap+0x30>
	{
		return LEAP;
	}
	else if((Year%100)==0)
 800368c:	4b09      	ldr	r3, [pc, #36]	; (80036b4 <CheckLeap+0x3c>)
 800368e:	fba3 2300 	umull	r2, r3, r3, r0
 8003692:	095b      	lsrs	r3, r3, #5
 8003694:	2264      	movs	r2, #100	; 0x64
 8003696:	fb02 0313 	mls	r3, r2, r3, r0
 800369a:	b29b      	uxth	r3, r3
 800369c:	b133      	cbz	r3, 80036ac <CheckLeap+0x34>
	{
		return NOT_LEAP;
	}
	else if((Year%4)==0)
 800369e:	f010 0f03 	tst.w	r0, #3
 80036a2:	d105      	bne.n	80036b0 <CheckLeap+0x38>
	{
		return LEAP;
 80036a4:	2001      	movs	r0, #1
 80036a6:	4770      	bx	lr
 */
uint8_t CheckLeap(uint16_t Year)
{
	if((Year%400)==0)
	{
		return LEAP;
 80036a8:	2001      	movs	r0, #1
 80036aa:	4770      	bx	lr
	}
	else if((Year%100)==0)
	{
		return NOT_LEAP;
 80036ac:	2000      	movs	r0, #0
 80036ae:	4770      	bx	lr
	{
		return LEAP;
	}
	else
	{
		return NOT_LEAP;
 80036b0:	2000      	movs	r0, #0
	}
}
 80036b2:	4770      	bx	lr
 80036b4:	51eb851f 	.word	0x51eb851f

080036b8 <SetDate>:
 * @brief  Sets the RTC Date(DD/MM/YYYY)
 * @param DD,MM,YYYY
 * @retval : None
 */
void SetDate(uint8_t Day, uint8_t Month, uint16_t Year)
{
 80036b8:	b570      	push	{r4, r5, r6, lr}
 80036ba:	4605      	mov	r5, r0
 80036bc:	460c      	mov	r4, r1
 80036be:	4616      	mov	r6, r2
	uint32_t DateTimer;

	/*Check if the date entered by the user is correct or not, Displays an error
    message if date is incorrect  */
	if((( Month==4 || Month==6 || Month==9 || Month==11) && Day ==31) \
 80036c0:	2904      	cmp	r1, #4
 80036c2:	d007      	beq.n	80036d4 <SetDate+0x1c>
 80036c4:	2906      	cmp	r1, #6
 80036c6:	d005      	beq.n	80036d4 <SetDate+0x1c>
 80036c8:	2909      	cmp	r1, #9
 80036ca:	d003      	beq.n	80036d4 <SetDate+0x1c>
 80036cc:	290b      	cmp	r1, #11
 80036ce:	d001      	beq.n	80036d4 <SetDate+0x1c>
			|| (Month==2 && Day==31)|| (Month==2 && Day==30)|| \
 80036d0:	2902      	cmp	r1, #2
 80036d2:	d101      	bne.n	80036d8 <SetDate+0x20>
 80036d4:	2d1f      	cmp	r5, #31
 80036d6:	d00b      	beq.n	80036f0 <SetDate+0x38>
 80036d8:	2c02      	cmp	r4, #2
 80036da:	d101      	bne.n	80036e0 <SetDate+0x28>
 80036dc:	2d1e      	cmp	r5, #30
 80036de:	d007      	beq.n	80036f0 <SetDate+0x38>
 80036e0:	2c02      	cmp	r4, #2
 80036e2:	d10e      	bne.n	8003702 <SetDate+0x4a>
			(Month==2 && Day==29 && (CheckLeap(Year)==0)))
 80036e4:	2d1d      	cmp	r5, #29
 80036e6:	d10c      	bne.n	8003702 <SetDate+0x4a>
 80036e8:	4630      	mov	r0, r6
 80036ea:	f7ff ffc5 	bl	8003678 <CheckLeap>
 80036ee:	b940      	cbnz	r0, 8003702 <SetDate+0x4a>
	{
		DateTimer=RTC_GetCounter();
 80036f0:	f001 f834 	bl	800475c <RTC_GetCounter>
 80036f4:	4604      	mov	r4, r0

		while((RTC_GetCounter()-DateTimer)<2)
 80036f6:	f001 f831 	bl	800475c <RTC_GetCounter>
 80036fa:	1b00      	subs	r0, r0, r4
 80036fc:	2801      	cmp	r0, #1
 80036fe:	d9fa      	bls.n	80036f6 <SetDate+0x3e>
 8003700:	bd70      	pop	{r4, r5, r6, pc}
		}
	}
	/* if date entered is correct then set the date*/
	else
	{
			BKP_WriteBackupRegister(BKP_DR2,Month);
 8003702:	4621      	mov	r1, r4
 8003704:	2008      	movs	r0, #8
 8003706:	f000 fb83 	bl	8003e10 <BKP_WriteBackupRegister>
			BKP_WriteBackupRegister(BKP_DR3,Day);
 800370a:	4629      	mov	r1, r5
 800370c:	200c      	movs	r0, #12
 800370e:	f000 fb7f 	bl	8003e10 <BKP_WriteBackupRegister>
			BKP_WriteBackupRegister(BKP_DR4,Year);
 8003712:	4631      	mov	r1, r6
 8003714:	2010      	movs	r0, #16
 8003716:	f000 fb7b 	bl	8003e10 <BKP_WriteBackupRegister>
 800371a:	bd70      	pop	{r4, r5, r6, pc}

0800371c <ADCT_BGS_Setting_Date_Time>:
	}
}

void ADCT_BGS_Setting_Date_Time(ADCT_BGS_RTC_Types  *ptr)
{
 800371c:	b510      	push	{r4, lr}
 800371e:	4604      	mov	r4, r0
	SetTime(ptr->RTC_Hour, ptr->RTC_Min, ptr->RTC_Sec);
 8003720:	7802      	ldrb	r2, [r0, #0]
 8003722:	7841      	ldrb	r1, [r0, #1]
 8003724:	7880      	ldrb	r0, [r0, #2]
 8003726:	f7ff ff5f 	bl	80035e8 <SetTime>
	SetDate(ptr->RTC_Mday, ptr->RTC_Mon, ptr->RTC_Year);
 800372a:	88e2      	ldrh	r2, [r4, #6]
 800372c:	7921      	ldrb	r1, [r4, #4]
 800372e:	78e0      	ldrb	r0, [r4, #3]
 8003730:	f7ff ffc2 	bl	80036b8 <SetDate>
 8003734:	bd10      	pop	{r4, pc}
 8003736:	bf00      	nop

08003738 <DateUpdate>:
 * @brief Updates the Date (This function is called when 1 Day has elapsed
 * @param None
 * @retval :None
 */
void DateUpdate(void)
{
 8003738:	b538      	push	{r3, r4, r5, lr}
	s_DateStructVar.Month=BKP_ReadBackupRegister(BKP_DR2);
 800373a:	2008      	movs	r0, #8
 800373c:	f000 fb76 	bl	8003e2c <BKP_ReadBackupRegister>
 8003740:	4c38      	ldr	r4, [pc, #224]	; (8003824 <DateUpdate+0xec>)
 8003742:	7020      	strb	r0, [r4, #0]
	s_DateStructVar.Year=BKP_ReadBackupRegister(BKP_DR4);
 8003744:	2010      	movs	r0, #16
 8003746:	f000 fb71 	bl	8003e2c <BKP_ReadBackupRegister>
 800374a:	8060      	strh	r0, [r4, #2]
	s_DateStructVar.Day=BKP_ReadBackupRegister(BKP_DR3);
 800374c:	200c      	movs	r0, #12
 800374e:	f000 fb6d 	bl	8003e2c <BKP_ReadBackupRegister>
 8003752:	b2c5      	uxtb	r5, r0
 8003754:	7065      	strb	r5, [r4, #1]

	if(s_DateStructVar.Month == 1 || s_DateStructVar.Month == 3 || \
 8003756:	7824      	ldrb	r4, [r4, #0]
 8003758:	2c01      	cmp	r4, #1
 800375a:	d00b      	beq.n	8003774 <DateUpdate+0x3c>
 800375c:	2c03      	cmp	r4, #3
 800375e:	d009      	beq.n	8003774 <DateUpdate+0x3c>
 8003760:	2c05      	cmp	r4, #5
 8003762:	d007      	beq.n	8003774 <DateUpdate+0x3c>
			s_DateStructVar.Month == 5 || s_DateStructVar.Month == 7 ||\
 8003764:	2c07      	cmp	r4, #7
 8003766:	d005      	beq.n	8003774 <DateUpdate+0x3c>
 8003768:	2c08      	cmp	r4, #8
 800376a:	d003      	beq.n	8003774 <DateUpdate+0x3c>
			s_DateStructVar.Month == 8 || s_DateStructVar.Month == 10 \
 800376c:	2c0a      	cmp	r4, #10
 800376e:	d001      	beq.n	8003774 <DateUpdate+0x3c>
			|| s_DateStructVar.Month == 12)
 8003770:	2c0c      	cmp	r4, #12
 8003772:	d115      	bne.n	80037a0 <DateUpdate+0x68>
	{
		if(s_DateStructVar.Day < 31)
 8003774:	2d1e      	cmp	r5, #30
 8003776:	d803      	bhi.n	8003780 <DateUpdate+0x48>
		{
			s_DateStructVar.Day++;
 8003778:	3501      	adds	r5, #1
 800377a:	4b2a      	ldr	r3, [pc, #168]	; (8003824 <DateUpdate+0xec>)
 800377c:	705d      	strb	r5, [r3, #1]
 800377e:	e043      	b.n	8003808 <DateUpdate+0xd0>
		}
		/* Date structure member: s_DateStructVar.Day = 31 */
		else
		{
			if(s_DateStructVar.Month != 12)
 8003780:	2c0c      	cmp	r4, #12
 8003782:	d005      	beq.n	8003790 <DateUpdate+0x58>
			{
				s_DateStructVar.Month++;
 8003784:	4b27      	ldr	r3, [pc, #156]	; (8003824 <DateUpdate+0xec>)
 8003786:	3401      	adds	r4, #1
 8003788:	701c      	strb	r4, [r3, #0]
				s_DateStructVar.Day = 1;
 800378a:	2201      	movs	r2, #1
 800378c:	705a      	strb	r2, [r3, #1]
 800378e:	e03b      	b.n	8003808 <DateUpdate+0xd0>
			}
			/* Date structure member: s_DateStructVar.Day = 31 & s_DateStructVar.Month =12 */
			else
			{
				s_DateStructVar.Month = 1;
 8003790:	4b24      	ldr	r3, [pc, #144]	; (8003824 <DateUpdate+0xec>)
 8003792:	2201      	movs	r2, #1
 8003794:	701a      	strb	r2, [r3, #0]
				s_DateStructVar.Day = 1;
 8003796:	705a      	strb	r2, [r3, #1]
				s_DateStructVar.Year++;
 8003798:	885a      	ldrh	r2, [r3, #2]
 800379a:	3201      	adds	r2, #1
 800379c:	805a      	strh	r2, [r3, #2]
 800379e:	e033      	b.n	8003808 <DateUpdate+0xd0>
			}
		}
	}
	else if(s_DateStructVar.Month == 4 || s_DateStructVar.Month == 6 \
 80037a0:	2c04      	cmp	r4, #4
 80037a2:	d005      	beq.n	80037b0 <DateUpdate+0x78>
 80037a4:	2c06      	cmp	r4, #6
 80037a6:	d003      	beq.n	80037b0 <DateUpdate+0x78>
			|| s_DateStructVar.Month == 9 ||s_DateStructVar.Month == 11)
 80037a8:	2c09      	cmp	r4, #9
 80037aa:	d001      	beq.n	80037b0 <DateUpdate+0x78>
 80037ac:	2c0b      	cmp	r4, #11
 80037ae:	d10b      	bne.n	80037c8 <DateUpdate+0x90>
	{
		if(s_DateStructVar.Day < 30)
 80037b0:	2d1d      	cmp	r5, #29
 80037b2:	d803      	bhi.n	80037bc <DateUpdate+0x84>
		{
			s_DateStructVar.Day++;
 80037b4:	3501      	adds	r5, #1
 80037b6:	4b1b      	ldr	r3, [pc, #108]	; (8003824 <DateUpdate+0xec>)
 80037b8:	705d      	strb	r5, [r3, #1]
 80037ba:	e025      	b.n	8003808 <DateUpdate+0xd0>
		}
		/* Date structure member: s_DateStructVar.Day = 30 */
		else
		{
			s_DateStructVar.Month++;
 80037bc:	4b19      	ldr	r3, [pc, #100]	; (8003824 <DateUpdate+0xec>)
 80037be:	3401      	adds	r4, #1
 80037c0:	701c      	strb	r4, [r3, #0]
			s_DateStructVar.Day = 1;
 80037c2:	2201      	movs	r2, #1
 80037c4:	705a      	strb	r2, [r3, #1]
 80037c6:	e01f      	b.n	8003808 <DateUpdate+0xd0>
		}
	}
	else if(s_DateStructVar.Month == 2)
 80037c8:	2c02      	cmp	r4, #2
 80037ca:	d11d      	bne.n	8003808 <DateUpdate+0xd0>
	{
		if(s_DateStructVar.Day < 28)
 80037cc:	2d1b      	cmp	r5, #27
 80037ce:	d803      	bhi.n	80037d8 <DateUpdate+0xa0>
		{
			s_DateStructVar.Day++;
 80037d0:	3501      	adds	r5, #1
 80037d2:	4b14      	ldr	r3, [pc, #80]	; (8003824 <DateUpdate+0xec>)
 80037d4:	705d      	strb	r5, [r3, #1]
 80037d6:	e017      	b.n	8003808 <DateUpdate+0xd0>
		}
		else if(s_DateStructVar.Day == 28)
 80037d8:	2d1c      	cmp	r5, #28
 80037da:	d10e      	bne.n	80037fa <DateUpdate+0xc2>
		{
			/* Leap Year Correction */
			if(CheckLeap(s_DateStructVar.Year))
 80037dc:	4b11      	ldr	r3, [pc, #68]	; (8003824 <DateUpdate+0xec>)
 80037de:	8858      	ldrh	r0, [r3, #2]
 80037e0:	f7ff ff4a 	bl	8003678 <CheckLeap>
 80037e4:	b118      	cbz	r0, 80037ee <DateUpdate+0xb6>
			{
				s_DateStructVar.Day++;
 80037e6:	3501      	adds	r5, #1
 80037e8:	4b0e      	ldr	r3, [pc, #56]	; (8003824 <DateUpdate+0xec>)
 80037ea:	705d      	strb	r5, [r3, #1]
 80037ec:	e00c      	b.n	8003808 <DateUpdate+0xd0>
			}
			else
			{
				s_DateStructVar.Month++;
 80037ee:	4b0d      	ldr	r3, [pc, #52]	; (8003824 <DateUpdate+0xec>)
 80037f0:	3401      	adds	r4, #1
 80037f2:	701c      	strb	r4, [r3, #0]
				s_DateStructVar.Day = 1;
 80037f4:	2201      	movs	r2, #1
 80037f6:	705a      	strb	r2, [r3, #1]
 80037f8:	e006      	b.n	8003808 <DateUpdate+0xd0>
			}
		}
		else if(s_DateStructVar.Day == 29)
 80037fa:	2d1d      	cmp	r5, #29
 80037fc:	d104      	bne.n	8003808 <DateUpdate+0xd0>
		{
			s_DateStructVar.Month++;
 80037fe:	4b09      	ldr	r3, [pc, #36]	; (8003824 <DateUpdate+0xec>)
 8003800:	3401      	adds	r4, #1
 8003802:	701c      	strb	r4, [r3, #0]
			s_DateStructVar.Day = 1;
 8003804:	2201      	movs	r2, #1
 8003806:	705a      	strb	r2, [r3, #1]
		}
	}

	BKP_WriteBackupRegister(BKP_DR2,s_DateStructVar.Month);
 8003808:	4c06      	ldr	r4, [pc, #24]	; (8003824 <DateUpdate+0xec>)
 800380a:	7821      	ldrb	r1, [r4, #0]
 800380c:	2008      	movs	r0, #8
 800380e:	f000 faff 	bl	8003e10 <BKP_WriteBackupRegister>
	BKP_WriteBackupRegister(BKP_DR3,s_DateStructVar.Day);
 8003812:	7861      	ldrb	r1, [r4, #1]
 8003814:	200c      	movs	r0, #12
 8003816:	f000 fafb 	bl	8003e10 <BKP_WriteBackupRegister>
	BKP_WriteBackupRegister(BKP_DR4,s_DateStructVar.Year);
 800381a:	8861      	ldrh	r1, [r4, #2]
 800381c:	2010      	movs	r0, #16
 800381e:	f000 faf7 	bl	8003e10 <BKP_WriteBackupRegister>
 8003822:	bd38      	pop	{r3, r4, r5, pc}
 8003824:	200006a4 	.word	0x200006a4

08003828 <WeekDay>:
 * @brief Determines the weekday
 * @param Year,Month and Day
 * @retval :Returns the CurrentWeekDay Number 0- Sunday 6- Saturday
 */
uint16_t WeekDay(uint16_t CurrentYear,uint8_t CurrentMonth,uint8_t CurrentDay)
{
 8003828:	b430      	push	{r4, r5}
	uint16_t Temp1,Temp2,Temp3,Temp4,CurrentWeekDay;

	if(CurrentMonth < 3)
 800382a:	2902      	cmp	r1, #2
 800382c:	d803      	bhi.n	8003836 <WeekDay+0xe>
	{
		CurrentMonth=CurrentMonth + 12;
 800382e:	310c      	adds	r1, #12
 8003830:	b2c9      	uxtb	r1, r1
		CurrentYear=CurrentYear-1;
 8003832:	3801      	subs	r0, #1
 8003834:	b280      	uxth	r0, r0
	}

	Temp1=(6*(CurrentMonth + 1))/10;
 8003836:	1c4b      	adds	r3, r1, #1
 8003838:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800383c:	005c      	lsls	r4, r3, #1
 800383e:	4b12      	ldr	r3, [pc, #72]	; (8003888 <WeekDay+0x60>)
 8003840:	fb83 5304 	smull	r5, r3, r3, r4
 8003844:	17e4      	asrs	r4, r4, #31
 8003846:	ebc4 04a3 	rsb	r4, r4, r3, asr #2
 800384a:	b2a4      	uxth	r4, r4
	Temp2=CurrentYear/4;
	Temp3=CurrentYear/100;
 800384c:	4d0f      	ldr	r5, [pc, #60]	; (800388c <WeekDay+0x64>)
 800384e:	fba5 3500 	umull	r3, r5, r5, r0
 8003852:	f3c5 134f 	ubfx	r3, r5, #5, #16
	Temp4=CurrentYear/400;
 8003856:	f3c5 15cf 	ubfx	r5, r5, #7, #16
	CurrentWeekDay=CurrentDay + (2 * CurrentMonth) + Temp1 \
 800385a:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 800385e:	4422      	add	r2, r4
 8003860:	4402      	add	r2, r0
 8003862:	eb02 0090 	add.w	r0, r2, r0, lsr #2
 8003866:	1ac0      	subs	r0, r0, r3
 8003868:	182b      	adds	r3, r5, r0
 800386a:	3301      	adds	r3, #1
 800386c:	b29b      	uxth	r3, r3
			+ CurrentYear + Temp2 - Temp3 + Temp4 +1;
	CurrentWeekDay = CurrentWeekDay % 7;
 800386e:	4808      	ldr	r0, [pc, #32]	; (8003890 <WeekDay+0x68>)
 8003870:	fba3 0100 	umull	r0, r1, r3, r0
 8003874:	1a58      	subs	r0, r3, r1
 8003876:	eb01 0050 	add.w	r0, r1, r0, lsr #1
 800387a:	0880      	lsrs	r0, r0, #2
 800387c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8003880:	1a18      	subs	r0, r3, r0

	return(CurrentWeekDay);
}
 8003882:	b280      	uxth	r0, r0
 8003884:	bc30      	pop	{r4, r5}
 8003886:	4770      	bx	lr
 8003888:	66666667 	.word	0x66666667
 800388c:	51eb851f 	.word	0x51eb851f
 8003890:	24924925 	.word	0x24924925

08003894 <CheckForDaysElapsed>:
 *   elapsed and updates date that many times
 * @param None
 * @retval :None
 */
void CheckForDaysElapsed(void)
{
 8003894:	b510      	push	{r4, lr}
	uint8_t DaysElapsed;

	if((RTC_GetCounter() / SECONDS_IN_DAY) != 0)
 8003896:	f000 ff61 	bl	800475c <RTC_GetCounter>
 800389a:	4b12      	ldr	r3, [pc, #72]	; (80038e4 <CheckForDaysElapsed+0x50>)
 800389c:	4298      	cmp	r0, r3
 800389e:	d805      	bhi.n	80038ac <CheckForDaysElapsed+0x18>
 80038a0:	bd10      	pop	{r4, pc}
	{
		for(DaysElapsed = 0; DaysElapsed < (RTC_GetCounter() / SECONDS_IN_DAY) ;DaysElapsed++)
		{
			DateUpdate();
 80038a2:	f7ff ff49 	bl	8003738 <DateUpdate>
{
	uint8_t DaysElapsed;

	if((RTC_GetCounter() / SECONDS_IN_DAY) != 0)
	{
		for(DaysElapsed = 0; DaysElapsed < (RTC_GetCounter() / SECONDS_IN_DAY) ;DaysElapsed++)
 80038a6:	3401      	adds	r4, #1
 80038a8:	b2e4      	uxtb	r4, r4
 80038aa:	e000      	b.n	80038ae <CheckForDaysElapsed+0x1a>
 80038ac:	2400      	movs	r4, #0
 80038ae:	f000 ff55 	bl	800475c <RTC_GetCounter>
 80038b2:	4b0d      	ldr	r3, [pc, #52]	; (80038e8 <CheckForDaysElapsed+0x54>)
 80038b4:	fba3 2300 	umull	r2, r3, r3, r0
 80038b8:	1ac0      	subs	r0, r0, r3
 80038ba:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 80038be:	ebb4 4f13 	cmp.w	r4, r3, lsr #16
 80038c2:	d3ee      	bcc.n	80038a2 <CheckForDaysElapsed+0xe>
		{
			DateUpdate();
		}

		RTC_SetCounter(RTC_GetCounter() % SECONDS_IN_DAY);
 80038c4:	f000 ff4a 	bl	800475c <RTC_GetCounter>
 80038c8:	4b07      	ldr	r3, [pc, #28]	; (80038e8 <CheckForDaysElapsed+0x54>)
 80038ca:	fba3 2300 	umull	r2, r3, r3, r0
 80038ce:	1ac2      	subs	r2, r0, r3
 80038d0:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 80038d4:	0c1b      	lsrs	r3, r3, #16
 80038d6:	4a05      	ldr	r2, [pc, #20]	; (80038ec <CheckForDaysElapsed+0x58>)
 80038d8:	fb02 0013 	mls	r0, r2, r3, r0
 80038dc:	f000 ff52 	bl	8004784 <RTC_SetCounter>
 80038e0:	bd10      	pop	{r4, pc}
 80038e2:	bf00      	nop
 80038e4:	0001517e 	.word	0x0001517e
 80038e8:	845db0a3 	.word	0x845db0a3
 80038ec:	0001517f 	.word	0x0001517f

080038f0 <RTC_Configuration>:
 *   RTC clock
 * @param  None
 * @retval : None
 */
void RTC_Configuration()
{
 80038f0:	b510      	push	{r4, lr}
	uint16_t WaitForOscSource;

	/*Allow access to Backup Registers*/
	PWR_BackupAccessCmd(ENABLE);
 80038f2:	2001      	movs	r0, #1
 80038f4:	f000 fdd4 	bl	80044a0 <PWR_BackupAccessCmd>

	//if(BKP_ReadBackupRegister(BKP_DR1)==CONFIGURATION_DONE)
	bkupdata = BKP_ReadBackupRegister(BKP_DR1);
 80038f8:	2004      	movs	r0, #4
 80038fa:	f000 fa97 	bl	8003e2c <BKP_ReadBackupRegister>
 80038fe:	4b47      	ldr	r3, [pc, #284]	; (8003a1c <RTC_Configuration+0x12c>)
 8003900:	6018      	str	r0, [r3, #0]
	if(bkupdata==CONFIGURATION_RESET)
 8003902:	2800      	cmp	r0, #0
 8003904:	d15a      	bne.n	80039bc <RTC_Configuration+0xcc>
	{
		/*Enables the clock to Backup and power interface peripherals    */
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP | RCC_APB1Periph_PWR,ENABLE);
 8003906:	2101      	movs	r1, #1
 8003908:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 800390c:	f000 feba 	bl	8004684 <RCC_APB1PeriphClockCmd>
		/* Backup Domain Reset */
		BKP_DeInit();
 8003910:	f000 fa6c 	bl	8003dec <BKP_DeInit>

		s_DateStructVar.Month=DEFAULT_MONTH ;
 8003914:	4c42      	ldr	r4, [pc, #264]	; (8003a20 <RTC_Configuration+0x130>)
 8003916:	2305      	movs	r3, #5
 8003918:	7023      	strb	r3, [r4, #0]
		s_DateStructVar.Day=DEFAULT_DAY;
 800391a:	230e      	movs	r3, #14
 800391c:	7063      	strb	r3, [r4, #1]
		s_DateStructVar.Year=DEFAULT_YEAR;
 800391e:	f240 73e1 	movw	r3, #2017	; 0x7e1
 8003922:	8063      	strh	r3, [r4, #2]
		SummerTimeCorrect = OCTOBER_FLAG_SET;
 8003924:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8003928:	4b3e      	ldr	r3, [pc, #248]	; (8003a24 <RTC_Configuration+0x134>)
 800392a:	8019      	strh	r1, [r3, #0]
		BKP_WriteBackupRegister(BKP_DR7,SummerTimeCorrect);
 800392c:	201c      	movs	r0, #28
 800392e:	f000 fa6f 	bl	8003e10 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR2,s_DateStructVar.Month);
 8003932:	7821      	ldrb	r1, [r4, #0]
 8003934:	2008      	movs	r0, #8
 8003936:	f000 fa6b 	bl	8003e10 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR3,s_DateStructVar.Day);
 800393a:	7861      	ldrb	r1, [r4, #1]
 800393c:	200c      	movs	r0, #12
 800393e:	f000 fa67 	bl	8003e10 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR4,s_DateStructVar.Year);
 8003942:	8861      	ldrh	r1, [r4, #2]
 8003944:	2010      	movs	r0, #16
 8003946:	f000 fa63 	bl	8003e10 <BKP_WriteBackupRegister>
		BKP_WriteBackupRegister(BKP_DR1, CONFIGURATION_DONE);
 800394a:	f64a 21aa 	movw	r1, #43690	; 0xaaaa
 800394e:	2004      	movs	r0, #4
 8003950:	f000 fa5e 	bl	8003e10 <BKP_WriteBackupRegister>
		/*Enable 32.768 kHz external oscillator */
		RCC_LSEConfig(RCC_LSE_ON);
 8003954:	2001      	movs	r0, #1
 8003956:	f000 fdf9 	bl	800454c <RCC_LSEConfig>

		for(WaitForOscSource=0;WaitForOscSource<5000;WaitForOscSource++)
 800395a:	2300      	movs	r3, #0
 800395c:	e001      	b.n	8003962 <RTC_Configuration+0x72>
 800395e:	3301      	adds	r3, #1
 8003960:	b29b      	uxth	r3, r3
 8003962:	f241 3287 	movw	r2, #4999	; 0x1387
 8003966:	4293      	cmp	r3, r2
 8003968:	d9f9      	bls.n	800395e <RTC_Configuration+0x6e>
		{
		}
		while ((RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET))
 800396a:	2041      	movs	r0, #65	; 0x41
 800396c:	f000 fe9e 	bl	80046ac <RCC_GetFlagStatus>
 8003970:	2800      	cmp	r0, #0
 8003972:	d0fa      	beq.n	800396a <RTC_Configuration+0x7a>
		        // Wait till LSE is ready
		       ;
		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
 8003974:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003978:	f000 fdfc 	bl	8004574 <RCC_RTCCLKConfig>
		/* RTC Enabled */
		RCC_RTCCLKCmd(ENABLE);
 800397c:	2001      	movs	r0, #1
 800397e:	f000 fe01 	bl	8004584 <RCC_RTCCLKCmd>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 8003982:	f000 ff1d 	bl	80047c0 <RTC_WaitForLastTask>
		/* Setting RTC Interrupts-Seconds interrupt enabled */
		/* Enable the RTC Second */
		RTC_ITConfig(RTC_IT_SEC , ENABLE);
 8003986:	2101      	movs	r1, #1
 8003988:	4608      	mov	r0, r1
 800398a:	f000 fec3 	bl	8004714 <RTC_ITConfig>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 800398e:	f000 ff17 	bl	80047c0 <RTC_WaitForLastTask>

		BKP_WriteBackupRegister(BKP_DR6, 1);
 8003992:	2101      	movs	r1, #1
 8003994:	2018      	movs	r0, #24
 8003996:	f000 fa3b 	bl	8003e10 <BKP_WriteBackupRegister>

		/* Set RTC prescaler: set RTC period to 1 sec */
		RTC_SetPrescaler(32765); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
 800399a:	f647 70fd 	movw	r0, #32765	; 0x7ffd
 800399e:	f000 feff 	bl	80047a0 <RTC_SetPrescaler>
		/* Prescaler is set to 32766 instead of 32768 to compensate for
        lower as well as higher frequencies*/
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80039a2:	f000 ff0d 	bl	80047c0 <RTC_WaitForLastTask>

		/* Set default system time to 09 : 24 : 00 */
		SetTime(DEFAULT_HOURS,DEFAULT_MINUTES,DEFAULT_SECONDS);
 80039a6:	2200      	movs	r2, #0
 80039a8:	211c      	movs	r1, #28
 80039aa:	2013      	movs	r0, #19
 80039ac:	f7ff fe1c 	bl	80035e8 <SetTime>
		BKP_WriteBackupRegister(BKP_DR1, CONFIGURATION_DONE);
 80039b0:	f64a 21aa 	movw	r1, #43690	; 0xaaaa
 80039b4:	2004      	movs	r0, #4
 80039b6:	f000 fa2b 	bl	8003e10 <BKP_WriteBackupRegister>
 80039ba:	e014      	b.n	80039e6 <RTC_Configuration+0xf6>
	}
	else
	{
		/* PWR and BKP clocks selection */
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 80039bc:	2101      	movs	r1, #1
 80039be:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 80039c2:	f000 fe5f 	bl	8004684 <RCC_APB1PeriphClockCmd>
		for(WaitForOscSource=0;WaitForOscSource<5000;WaitForOscSource++);
 80039c6:	2300      	movs	r3, #0
 80039c8:	e001      	b.n	80039ce <RTC_Configuration+0xde>
 80039ca:	3301      	adds	r3, #1
 80039cc:	b29b      	uxth	r3, r3
 80039ce:	f241 3287 	movw	r2, #4999	; 0x1387
 80039d2:	4293      	cmp	r3, r2
 80039d4:	d9f9      	bls.n	80039ca <RTC_Configuration+0xda>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80039d6:	f000 fef3 	bl	80047c0 <RTC_WaitForLastTask>
		/* Enable the RTC Second */
		RTC_ITConfig(RTC_IT_SEC, ENABLE);
 80039da:	2101      	movs	r1, #1
 80039dc:	4608      	mov	r0, r1
 80039de:	f000 fe99 	bl	8004714 <RTC_ITConfig>
		RTC_WaitForLastTask();
 80039e2:	f000 feed 	bl	80047c0 <RTC_WaitForLastTask>
	}

	/* Check if how many days are elapsed in power down/Low Power Mode-
   Updates Date that many Times*/
	CheckForDaysElapsed();
 80039e6:	f7ff ff55 	bl	8003894 <CheckForDaysElapsed>
	ClockSource = BKP_ReadBackupRegister(BKP_DR6);
 80039ea:	2018      	movs	r0, #24
 80039ec:	f000 fa1e 	bl	8003e2c <BKP_ReadBackupRegister>
 80039f0:	4b0d      	ldr	r3, [pc, #52]	; (8003a28 <RTC_Configuration+0x138>)
 80039f2:	7018      	strb	r0, [r3, #0]
	s_DateStructVar.Month = BKP_ReadBackupRegister(BKP_DR2);
 80039f4:	2008      	movs	r0, #8
 80039f6:	f000 fa19 	bl	8003e2c <BKP_ReadBackupRegister>
 80039fa:	4c09      	ldr	r4, [pc, #36]	; (8003a20 <RTC_Configuration+0x130>)
 80039fc:	7020      	strb	r0, [r4, #0]
	s_DateStructVar.Day = BKP_ReadBackupRegister(BKP_DR3);
 80039fe:	200c      	movs	r0, #12
 8003a00:	f000 fa14 	bl	8003e2c <BKP_ReadBackupRegister>
 8003a04:	7060      	strb	r0, [r4, #1]
	s_DateStructVar.Year = BKP_ReadBackupRegister(BKP_DR4);
 8003a06:	2010      	movs	r0, #16
 8003a08:	f000 fa10 	bl	8003e2c <BKP_ReadBackupRegister>
 8003a0c:	8060      	strh	r0, [r4, #2]
	SummerTimeCorrect = BKP_ReadBackupRegister(BKP_DR7);
 8003a0e:	201c      	movs	r0, #28
 8003a10:	f000 fa0c 	bl	8003e2c <BKP_ReadBackupRegister>
 8003a14:	4b03      	ldr	r3, [pc, #12]	; (8003a24 <RTC_Configuration+0x134>)
 8003a16:	8018      	strh	r0, [r3, #0]
 8003a18:	bd10      	pop	{r4, pc}
 8003a1a:	bf00      	nop
 8003a1c:	20000178 	.word	0x20000178
 8003a20:	200006a4 	.word	0x200006a4
 8003a24:	200006a8 	.word	0x200006a8
 8003a28:	200006aa 	.word	0x200006aa

08003a2c <RTC_NVIC_Configuration>:
 * @brief  Configures RTC Interrupts
 * @param  None
 * @retval : None
 */
void RTC_NVIC_Configuration(void)
{
 8003a2c:	b500      	push	{lr}
 8003a2e:	b083      	sub	sp, #12
	NVIC_InitTypeDef NVIC_InitStructure;
	/* Configure one bit for preemption priority */
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	/* Enable the RTC Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
 8003a30:	2303      	movs	r3, #3
 8003a32:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
 8003a36:	2304      	movs	r3, #4
 8003a38:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
 8003a3c:	f88d 3006 	strb.w	r3, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003a40:	2301      	movs	r3, #1
 8003a42:	f88d 3007 	strb.w	r3, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8003a46:	a801      	add	r0, sp, #4
 8003a48:	f000 f99e 	bl	8003d88 <NVIC_Init>
}
 8003a4c:	b003      	add	sp, #12
 8003a4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a52:	bf00      	nop

08003a54 <ADCT_BGS_RTC_Init>:
 * @brief  RTC Initialisation Routine
 * @param  None
 * @retval : None
 */
void ADCT_BGS_RTC_Init(void)
{
 8003a54:	b508      	push	{r3, lr}
	RTC_RCC_Configuration();
 8003a56:	f7ff fd9b 	bl	8003590 <RTC_RCC_Configuration>
	/*Enables the clock to Backup and power interface peripherals    */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP | RCC_APB1Periph_PWR,ENABLE);// Enable PWR/BKP
 8003a5a:	2101      	movs	r1, #1
 8003a5c:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 8003a60:	f000 fe10 	bl	8004684 <RCC_APB1PeriphClockCmd>
	/* Unlock the Flash Program Erase controller */
	FLASH_Unlock();
 8003a64:	f000 fb52 	bl	800410c <FLASH_Unlock>
	RTC_NVIC_Configuration();
 8003a68:	f7ff ffe0 	bl	8003a2c <RTC_NVIC_Configuration>
	/* RTC Configuration*/
	RTC_Configuration();
 8003a6c:	f7ff ff40 	bl	80038f0 <RTC_Configuration>
	/*RTC_NVIC Configuration */

	BKP_RTCOutputConfig(BKP_RTCOutputSource_None);
 8003a70:	2000      	movs	r0, #0
 8003a72:	f000 f9c3 	bl	8003dfc <BKP_RTCOutputConfig>
	/* Configure PVD Supervisor to disable the Tamper Interrupt when voltage drops
  below 2.5 volts*/
	PWR_PVDCmd(ENABLE);
 8003a76:	2001      	movs	r0, #1
 8003a78:	f000 fd18 	bl	80044ac <PWR_PVDCmd>
	PWR_PVDLevelConfig(PWR_PVDLevel_2V5);
 8003a7c:	2060      	movs	r0, #96	; 0x60
 8003a7e:	f000 fd1b 	bl	80044b8 <PWR_PVDLevelConfig>
	PWR_BackupAccessCmd(ENABLE);
 8003a82:	2001      	movs	r0, #1
 8003a84:	f000 fd0c 	bl	80044a0 <PWR_BackupAccessCmd>
 8003a88:	bd08      	pop	{r3, pc}
 8003a8a:	bf00      	nop

08003a8c <RTC_IRQHandler>:
 * @brief  This function handles RTC_IRQHandler .
 * @param  None
 * @retval : None
 */
void RTC_IRQHandler(void)
{
 8003a8c:	b570      	push	{r4, r5, r6, lr}
	uint8_t Month,Day;
	uint16_t Year;

	Month = BKP_ReadBackupRegister(BKP_DR2);
 8003a8e:	2008      	movs	r0, #8
 8003a90:	f000 f9cc 	bl	8003e2c <BKP_ReadBackupRegister>
 8003a94:	b2c4      	uxtb	r4, r0
	Day = BKP_ReadBackupRegister(BKP_DR3);
 8003a96:	200c      	movs	r0, #12
 8003a98:	f000 f9c8 	bl	8003e2c <BKP_ReadBackupRegister>
 8003a9c:	b2c5      	uxtb	r5, r0
	Year = BKP_ReadBackupRegister(BKP_DR4);
 8003a9e:	2010      	movs	r0, #16
 8003aa0:	f000 f9c4 	bl	8003e2c <BKP_ReadBackupRegister>
 8003aa4:	4606      	mov	r6, r0
	if(RTC_GetITStatus(RTC_IT_SEC) !=RESET )
 8003aa6:	2001      	movs	r0, #1
 8003aa8:	f000 fe94 	bl	80047d4 <RTC_GetITStatus>
 8003aac:	b130      	cbz	r0, 8003abc <RTC_IRQHandler+0x30>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
 8003aae:	2208      	movs	r2, #8
 8003ab0:	4b41      	ldr	r3, [pc, #260]	; (8003bb8 <RTC_IRQHandler+0x12c>)
 8003ab2:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	{
		NVIC_ClearPendingIRQ(RTC_IRQn);
		RTC_ClearITPendingBit(RTC_IT_SEC);
 8003ab6:	2001      	movs	r0, #1
 8003ab8:	f000 fe9c 	bl	80047f4 <RTC_ClearITPendingBit>
	}

	/* If counter is equal to 86399: one day was elapsed */
	/* This takes care of date change and resetting of counter in case of
  power on - Run mode/ Main supply switched on condition*/
	if(RTC_GetCounter() == 86399)
 8003abc:	f000 fe4e 	bl	800475c <RTC_GetCounter>
 8003ac0:	4b3e      	ldr	r3, [pc, #248]	; (8003bbc <RTC_IRQHandler+0x130>)
 8003ac2:	4298      	cmp	r0, r3
 8003ac4:	d108      	bne.n	8003ad8 <RTC_IRQHandler+0x4c>
	{
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 8003ac6:	f000 fe7b 	bl	80047c0 <RTC_WaitForLastTask>
		/* Reset counter value */
		RTC_SetCounter(0x0);
 8003aca:	2000      	movs	r0, #0
 8003acc:	f000 fe5a 	bl	8004784 <RTC_SetCounter>
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 8003ad0:	f000 fe76 	bl	80047c0 <RTC_WaitForLastTask>

		/* Increment the date */
		DateUpdate();
 8003ad4:	f7ff fe30 	bl	8003738 <DateUpdate>
	}

	if((RTC_GetCounter()/3600 == 1)&&(((RTC_GetCounter()%3600)/60) == 59)&&
 8003ad8:	f000 fe40 	bl	800475c <RTC_GetCounter>
 8003adc:	f5a0 6061 	sub.w	r0, r0, #3600	; 0xe10
 8003ae0:	f5b0 6f61 	cmp.w	r0, #3600	; 0xe10
 8003ae4:	d267      	bcs.n	8003bb6 <RTC_IRQHandler+0x12a>
 8003ae6:	f000 fe39 	bl	800475c <RTC_GetCounter>
 8003aea:	4b35      	ldr	r3, [pc, #212]	; (8003bc0 <RTC_IRQHandler+0x134>)
 8003aec:	fba3 2300 	umull	r2, r3, r3, r0
 8003af0:	0adb      	lsrs	r3, r3, #11
 8003af2:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 8003af6:	fb02 0313 	mls	r3, r2, r3, r0
 8003afa:	f6a3 53d4 	subw	r3, r3, #3540	; 0xdd4
 8003afe:	2b3b      	cmp	r3, #59	; 0x3b
 8003b00:	d859      	bhi.n	8003bb6 <RTC_IRQHandler+0x12a>
			(((RTC_GetCounter()%3600)%60) == 59))
 8003b02:	f000 fe2b 	bl	800475c <RTC_GetCounter>
 8003b06:	4a2e      	ldr	r2, [pc, #184]	; (8003bc0 <RTC_IRQHandler+0x134>)
 8003b08:	fba2 3200 	umull	r3, r2, r2, r0
 8003b0c:	0ad2      	lsrs	r2, r2, #11
 8003b0e:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8003b12:	fb03 0212 	mls	r2, r3, r2, r0
 8003b16:	4b2b      	ldr	r3, [pc, #172]	; (8003bc4 <RTC_IRQHandler+0x138>)
 8003b18:	fba3 1302 	umull	r1, r3, r3, r2
 8003b1c:	095b      	lsrs	r3, r3, #5
 8003b1e:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8003b22:	eba2 0383 	sub.w	r3, r2, r3, lsl #2

		/* Increment the date */
		DateUpdate();
	}

	if((RTC_GetCounter()/3600 == 1)&&(((RTC_GetCounter()%3600)/60) == 59)&&
 8003b26:	2b3b      	cmp	r3, #59	; 0x3b
 8003b28:	d145      	bne.n	8003bb6 <RTC_IRQHandler+0x12a>
			(((RTC_GetCounter()%3600)%60) == 59))
	{
		/* March Correction */
		if((Month == 3) && (Day >24))
 8003b2a:	2c03      	cmp	r4, #3
 8003b2c:	d11e      	bne.n	8003b6c <RTC_IRQHandler+0xe0>
 8003b2e:	2d18      	cmp	r5, #24
 8003b30:	d91c      	bls.n	8003b6c <RTC_IRQHandler+0xe0>
		{
			if(WeekDay(Year,Month,Day)==0)
 8003b32:	462a      	mov	r2, r5
 8003b34:	4621      	mov	r1, r4
 8003b36:	4630      	mov	r0, r6
 8003b38:	f7ff fe76 	bl	8003828 <WeekDay>
 8003b3c:	b9b0      	cbnz	r0, 8003b6c <RTC_IRQHandler+0xe0>
			{
				if((SummerTimeCorrect & 0x8000) == 0x8000)
 8003b3e:	4b22      	ldr	r3, [pc, #136]	; (8003bc8 <RTC_IRQHandler+0x13c>)
 8003b40:	f9b3 3000 	ldrsh.w	r3, [r3]
 8003b44:	2b00      	cmp	r3, #0
 8003b46:	da11      	bge.n	8003b6c <RTC_IRQHandler+0xe0>
				{
					RTC_SetCounter(RTC_GetCounter() + 3601);
 8003b48:	f000 fe08 	bl	800475c <RTC_GetCounter>
 8003b4c:	f600 6011 	addw	r0, r0, #3601	; 0xe11
 8003b50:	f000 fe18 	bl	8004784 <RTC_SetCounter>

					/* Reset March correction flag */
					SummerTimeCorrect &= 0x7FFF;
 8003b54:	4b1c      	ldr	r3, [pc, #112]	; (8003bc8 <RTC_IRQHandler+0x13c>)
 8003b56:	8819      	ldrh	r1, [r3, #0]
 8003b58:	f3c1 010e 	ubfx	r1, r1, #0, #15

					/* Set October correction flag  */
					SummerTimeCorrect |= 0x4000;
 8003b5c:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
					SummerTimeCorrect |= Year;
 8003b60:	4331      	orrs	r1, r6
 8003b62:	b289      	uxth	r1, r1
 8003b64:	8019      	strh	r1, [r3, #0]
					BKP_WriteBackupRegister(BKP_DR7,SummerTimeCorrect);
 8003b66:	201c      	movs	r0, #28
 8003b68:	f000 f952 	bl	8003e10 <BKP_WriteBackupRegister>
				}
			}
		}
		/* October Correction */
		if((Month == 10) && (Day >24))
 8003b6c:	2c0a      	cmp	r4, #10
 8003b6e:	d122      	bne.n	8003bb6 <RTC_IRQHandler+0x12a>
 8003b70:	2d18      	cmp	r5, #24
 8003b72:	d920      	bls.n	8003bb6 <RTC_IRQHandler+0x12a>
		{
			if(WeekDay(Year,Month,Day)==0)
 8003b74:	462a      	mov	r2, r5
 8003b76:	4621      	mov	r1, r4
 8003b78:	4630      	mov	r0, r6
 8003b7a:	f7ff fe55 	bl	8003828 <WeekDay>
 8003b7e:	b9d0      	cbnz	r0, 8003bb6 <RTC_IRQHandler+0x12a>
			{
				if((SummerTimeCorrect & 0x4000) == 0x4000)
 8003b80:	4b11      	ldr	r3, [pc, #68]	; (8003bc8 <RTC_IRQHandler+0x13c>)
 8003b82:	881b      	ldrh	r3, [r3, #0]
 8003b84:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003b88:	b29b      	uxth	r3, r3
 8003b8a:	b1a3      	cbz	r3, 8003bb6 <RTC_IRQHandler+0x12a>
				{
					RTC_SetCounter(RTC_GetCounter() - 3599);
 8003b8c:	f000 fde6 	bl	800475c <RTC_GetCounter>
 8003b90:	f6a0 600f 	subw	r0, r0, #3599	; 0xe0f
 8003b94:	f000 fdf6 	bl	8004784 <RTC_SetCounter>

					/* Reset October correction flag */
					SummerTimeCorrect &= 0xBFFF;
 8003b98:	4b0b      	ldr	r3, [pc, #44]	; (8003bc8 <RTC_IRQHandler+0x13c>)
 8003b9a:	8819      	ldrh	r1, [r3, #0]
 8003b9c:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000

					/* Set March correction flag  */
					SummerTimeCorrect |= 0x8000;
 8003ba0:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 8003ba4:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 8003ba8:	b289      	uxth	r1, r1
					SummerTimeCorrect |= Year;
 8003baa:	4331      	orrs	r1, r6
 8003bac:	b289      	uxth	r1, r1
 8003bae:	8019      	strh	r1, [r3, #0]
					BKP_WriteBackupRegister(BKP_DR7,SummerTimeCorrect);
 8003bb0:	201c      	movs	r0, #28
 8003bb2:	f000 f92d 	bl	8003e10 <BKP_WriteBackupRegister>
 8003bb6:	bd70      	pop	{r4, r5, r6, pc}
 8003bb8:	e000e100 	.word	0xe000e100
 8003bbc:	0001517f 	.word	0x0001517f
 8003bc0:	91a2b3c5 	.word	0x91a2b3c5
 8003bc4:	88888889 	.word	0x88888889
 8003bc8:	200006a8 	.word	0x200006a8

08003bcc <ADCT_BGS_Sensor_Input_Init>:
 *      Author: Administrator
 */
#include "ADCT_Sensor.h"

void ADCT_BGS_Sensor_Input_Init(void)
{
 8003bcc:	b530      	push	{r4, r5, lr}
 8003bce:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	/* GPIO Periph clock enable */
	RCC_APB2PeriphClockCmd(ADCT_BGS_INPUT_CLK|ADCT_BGS_AC_GEN_INPUT_CLK, ENABLE);
 8003bd0:	2101      	movs	r1, #1
 8003bd2:	2018      	movs	r0, #24
 8003bd4:	f000 fd48 	bl	8004668 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_INT_SMOKE|ADCT_BGS_INT_DOOR|ADCT_BGS_INT_BURGLAR|ADCT_BGS_INT_FIRE|ADCT_BGS_INT_WATER;
 8003bd8:	231f      	movs	r3, #31
 8003bda:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003bde:	2503      	movs	r5, #3
 8003be0:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8003be4:	2448      	movs	r4, #72	; 0x48
 8003be6:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(ADCT_BGS_INPUT_PORT, &GPIO_InitStructure);
 8003bea:	a901      	add	r1, sp, #4
 8003bec:	4808      	ldr	r0, [pc, #32]	; (8003c10 <ADCT_BGS_Sensor_Input_Init+0x44>)
 8003bee:	f000 fa99 	bl	8004124 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = ADCT_BGS_INPUT_AC|ADCT_BGS_INPUT_GEN;
 8003bf2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8003bf6:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003bfa:	f88d 5006 	strb.w	r5, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8003bfe:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_Init(ADCT_BGS_AC_GEN_INPUT_PORT, &GPIO_InitStructure);
 8003c02:	a901      	add	r1, sp, #4
 8003c04:	4803      	ldr	r0, [pc, #12]	; (8003c14 <ADCT_BGS_Sensor_Input_Init+0x48>)
 8003c06:	f000 fa8d 	bl	8004124 <GPIO_Init>
}
 8003c0a:	b003      	add	sp, #12
 8003c0c:	bd30      	pop	{r4, r5, pc}
 8003c0e:	bf00      	nop
 8003c10:	40011000 	.word	0x40011000
 8003c14:	40010c00 	.word	0x40010c00

08003c18 <ADCT_BGS_Systick_Init>:
__IO uint32_t TM_Time2 = 0;
__IO uint32_t TM_Time = 0;
/* initialization system tick 1ms */
void ADCT_BGS_Systick_Init(void )
{
	if (SysTick_Config(SystemCoreClock / 1000))
 8003c18:	4b08      	ldr	r3, [pc, #32]	; (8003c3c <ADCT_BGS_Systick_Init+0x24>)
 8003c1a:	681b      	ldr	r3, [r3, #0]
 8003c1c:	4a08      	ldr	r2, [pc, #32]	; (8003c40 <ADCT_BGS_Systick_Init+0x28>)
 8003c1e:	fba2 2303 	umull	r2, r3, r2, r3
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 8003c22:	099b      	lsrs	r3, r3, #6
 8003c24:	3b01      	subs	r3, #1
 8003c26:	4a07      	ldr	r2, [pc, #28]	; (8003c44 <ADCT_BGS_Systick_Init+0x2c>)
 8003c28:	6053      	str	r3, [r2, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8003c2a:	21f0      	movs	r1, #240	; 0xf0
 8003c2c:	4b06      	ldr	r3, [pc, #24]	; (8003c48 <ADCT_BGS_Systick_Init+0x30>)
 8003c2e:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8003c32:	2300      	movs	r3, #0
 8003c34:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8003c36:	2307      	movs	r3, #7
 8003c38:	6013      	str	r3, [r2, #0]
 8003c3a:	4770      	bx	lr
 8003c3c:	20000190 	.word	0x20000190
 8003c40:	10624dd3 	.word	0x10624dd3
 8003c44:	e000e010 	.word	0xe000e010
 8003c48:	e000ed00 	.word	0xe000ed00

08003c4c <TM_DELAY_Init>:
uint32_t TM_DELAY_Init(void) {
#if !defined(STM32F0xx)
	uint32_t c;

    /* Enable TRC */
    CoreDebug->DEMCR &= ~0x01000000;
 8003c4c:	4b0c      	ldr	r3, [pc, #48]	; (8003c80 <TM_DELAY_Init+0x34>)
 8003c4e:	68da      	ldr	r2, [r3, #12]
 8003c50:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8003c54:	60da      	str	r2, [r3, #12]
    CoreDebug->DEMCR |=  0x01000000;
 8003c56:	68da      	ldr	r2, [r3, #12]
 8003c58:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8003c5c:	60da      	str	r2, [r3, #12]

    /* Enable counter */
    DWT->CTRL &= ~0x00000001;
 8003c5e:	4b09      	ldr	r3, [pc, #36]	; (8003c84 <TM_DELAY_Init+0x38>)
 8003c60:	681a      	ldr	r2, [r3, #0]
 8003c62:	f022 0201 	bic.w	r2, r2, #1
 8003c66:	601a      	str	r2, [r3, #0]
    DWT->CTRL |=  0x00000001;
 8003c68:	681a      	ldr	r2, [r3, #0]
 8003c6a:	f042 0201 	orr.w	r2, r2, #1
 8003c6e:	601a      	str	r2, [r3, #0]

    /* Reset counter */
    DWT->CYCCNT = 0;
 8003c70:	2200      	movs	r2, #0
 8003c72:	605a      	str	r2, [r3, #4]

	/* Check if DWT has started */
	c = DWT->CYCCNT;
 8003c74:	685a      	ldr	r2, [r3, #4]

	/* 2 dummys */
	__ASM volatile ("NOP");
 8003c76:	bf00      	nop
	__ASM volatile ("NOP");
 8003c78:	bf00      	nop

	/* Return difference, if result is zero, DWT has not started */
	return (DWT->CYCCNT - c);
 8003c7a:	6858      	ldr	r0, [r3, #4]
#else
	/* Return OK */
	return 1;
#endif
}
 8003c7c:	1a80      	subs	r0, r0, r2
 8003c7e:	4770      	bx	lr
 8003c80:	e000edf0 	.word	0xe000edf0
 8003c84:	e0001000 	.word	0xe0001000

08003c88 <TM_DELAY_TimerCreate>:

TM_DELAY_Timer_t* TM_DELAY_TimerCreate(uint32_t ReloadValue, uint8_t AutoReloadCmd, uint8_t StartTimer, void (*TM_DELAY_CustomTimerCallback)(struct _TM_DELAY_Timer_t*, void *), void* UserParameters) {
 8003c88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TM_DELAY_Timer_t* tmp;

	/* Check if available */
	if (CustomTimers.Count >= DELAY_MAX_CUSTOM_TIMERS) {
 8003c8c:	4c12      	ldr	r4, [pc, #72]	; (8003cd8 <TM_DELAY_TimerCreate+0x50>)
 8003c8e:	7824      	ldrb	r4, [r4, #0]
 8003c90:	2c04      	cmp	r4, #4
 8003c92:	d81b      	bhi.n	8003ccc <TM_DELAY_TimerCreate+0x44>
 8003c94:	461e      	mov	r6, r3
 8003c96:	4617      	mov	r7, r2
 8003c98:	4688      	mov	r8, r1
 8003c9a:	4605      	mov	r5, r0
		return NULL;
	}

	/* Try to allocate memory for timer structure */
	tmp = (TM_DELAY_Timer_t *) LIB_ALLOC_FUNC(sizeof(TM_DELAY_Timer_t));
 8003c9c:	2014      	movs	r0, #20
 8003c9e:	f001 f941 	bl	8004f24 <malloc>

	/* Check if allocated */
	if (tmp == NULL) {
 8003ca2:	b1b0      	cbz	r0, 8003cd2 <TM_DELAY_TimerCreate+0x4a>
		return NULL;
	}

	/* Fill settings */
	tmp->ARR = ReloadValue;
 8003ca4:	6045      	str	r5, [r0, #4]
	tmp->CNT = tmp->ARR;
 8003ca6:	6085      	str	r5, [r0, #8]
	tmp->Flags.F.AREN = AutoReloadCmd;
 8003ca8:	7801      	ldrb	r1, [r0, #0]
 8003caa:	f368 0100 	bfi	r1, r8, #0, #1
	tmp->Flags.F.CNTEN = StartTimer;
 8003cae:	f367 0141 	bfi	r1, r7, #1, #1
 8003cb2:	7001      	strb	r1, [r0, #0]
	tmp->Callback = TM_DELAY_CustomTimerCallback;
 8003cb4:	60c6      	str	r6, [r0, #12]
	tmp->UserParameters = UserParameters;
 8003cb6:	9b06      	ldr	r3, [sp, #24]
 8003cb8:	6103      	str	r3, [r0, #16]

	/* Increase number of timers in memory */
	CustomTimers.Timers[CustomTimers.Count++] = tmp;
 8003cba:	4b07      	ldr	r3, [pc, #28]	; (8003cd8 <TM_DELAY_TimerCreate+0x50>)
 8003cbc:	781a      	ldrb	r2, [r3, #0]
 8003cbe:	1c51      	adds	r1, r2, #1
 8003cc0:	7019      	strb	r1, [r3, #0]
 8003cc2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8003cc6:	6058      	str	r0, [r3, #4]

	/* Return pointer to user */
	return tmp;
 8003cc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
TM_DELAY_Timer_t* TM_DELAY_TimerCreate(uint32_t ReloadValue, uint8_t AutoReloadCmd, uint8_t StartTimer, void (*TM_DELAY_CustomTimerCallback)(struct _TM_DELAY_Timer_t*, void *), void* UserParameters) {
	TM_DELAY_Timer_t* tmp;

	/* Check if available */
	if (CustomTimers.Count >= DELAY_MAX_CUSTOM_TIMERS) {
		return NULL;
 8003ccc:	2000      	movs	r0, #0
 8003cce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	/* Try to allocate memory for timer structure */
	tmp = (TM_DELAY_Timer_t *) LIB_ALLOC_FUNC(sizeof(TM_DELAY_Timer_t));

	/* Check if allocated */
	if (tmp == NULL) {
		return NULL;
 8003cd2:	2000      	movs	r0, #0
	/* Increase number of timers in memory */
	CustomTimers.Timers[CustomTimers.Count++] = tmp;

	/* Return pointer to user */
	return tmp;
}
 8003cd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003cd8:	20000414 	.word	0x20000414

08003cdc <TimerGetUS>:
//           the TM_DELAY_1msHandler could be implemented in the user file
//	*/
//}
uint32_t TimerGetUS(void)
{
	return ( DWT->CYCCNT/72);
 8003cdc:	4b03      	ldr	r3, [pc, #12]	; (8003cec <TimerGetUS+0x10>)
 8003cde:	685b      	ldr	r3, [r3, #4]
 8003ce0:	4803      	ldr	r0, [pc, #12]	; (8003cf0 <TimerGetUS+0x14>)
 8003ce2:	fba0 3003 	umull	r3, r0, r0, r3
}
 8003ce6:	0900      	lsrs	r0, r0, #4
 8003ce8:	4770      	bx	lr
 8003cea:	bf00      	nop
 8003cec:	e0001000 	.word	0xe0001000
 8003cf0:	38e38e39 	.word	0x38e38e39

08003cf4 <HAL_IncTick>:
/***************************************************/
/*       Custom HAL function implementations       */
/***************************************************/

/* Called from Systick handler */
void HAL_IncTick(void) {
 8003cf4:	b538      	push	{r3, r4, r5, lr}
	uint8_t i;

	/* Increase system time */
	TM_Time++;
 8003cf6:	4a1c      	ldr	r2, [pc, #112]	; (8003d68 <HAL_IncTick+0x74>)
 8003cf8:	6813      	ldr	r3, [r2, #0]
 8003cfa:	3301      	adds	r3, #1
 8003cfc:	6013      	str	r3, [r2, #0]

	/* Decrease other system time */
	if (TM_Time2) {
 8003cfe:	4b1b      	ldr	r3, [pc, #108]	; (8003d6c <HAL_IncTick+0x78>)
 8003d00:	681b      	ldr	r3, [r3, #0]
 8003d02:	b11b      	cbz	r3, 8003d0c <HAL_IncTick+0x18>
		TM_Time2--;
 8003d04:	4a19      	ldr	r2, [pc, #100]	; (8003d6c <HAL_IncTick+0x78>)
 8003d06:	6813      	ldr	r3, [r2, #0]
 8003d08:	3b01      	subs	r3, #1
 8003d0a:	6013      	str	r3, [r2, #0]
/***************************************************/
/*       Custom HAL function implementations       */
/***************************************************/

/* Called from Systick handler */
void HAL_IncTick(void) {
 8003d0c:	2400      	movs	r4, #0
 8003d0e:	e026      	b.n	8003d5e <HAL_IncTick+0x6a>
	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
		/* Check if timer is enabled */
		if (
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
 8003d10:	4625      	mov	r5, r4
 8003d12:	4b17      	ldr	r3, [pc, #92]	; (8003d70 <HAL_IncTick+0x7c>)
 8003d14:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8003d18:	685b      	ldr	r3, [r3, #4]

	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
		/* Check if timer is enabled */
		if (
 8003d1a:	b1f3      	cbz	r3, 8003d5a <HAL_IncTick+0x66>
			CustomTimers.Timers[i] &&             /*!< Pointer exists */
 8003d1c:	781a      	ldrb	r2, [r3, #0]
 8003d1e:	f012 0f02 	tst.w	r2, #2
 8003d22:	d01a      	beq.n	8003d5a <HAL_IncTick+0x66>
			CustomTimers.Timers[i]->Flags.F.CNTEN /*!< Timer is enabled */
		) {
			/* Decrease counter if needed */
			if (CustomTimers.Timers[i]->CNT) {
 8003d24:	689a      	ldr	r2, [r3, #8]
 8003d26:	b10a      	cbz	r2, 8003d2c <HAL_IncTick+0x38>
				CustomTimers.Timers[i]->CNT--;
 8003d28:	3a01      	subs	r2, #1
 8003d2a:	609a      	str	r2, [r3, #8]
			}

			/* Check if count is zero */
			if (CustomTimers.Timers[i]->CNT == 0) {
 8003d2c:	4b10      	ldr	r3, [pc, #64]	; (8003d70 <HAL_IncTick+0x7c>)
 8003d2e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8003d32:	6858      	ldr	r0, [r3, #4]
 8003d34:	6883      	ldr	r3, [r0, #8]
 8003d36:	b983      	cbnz	r3, 8003d5a <HAL_IncTick+0x66>
				/* Call user callback function */
				CustomTimers.Timers[i]->Callback(CustomTimers.Timers[i], CustomTimers.Timers[i]->UserParameters);
 8003d38:	68c3      	ldr	r3, [r0, #12]
 8003d3a:	6901      	ldr	r1, [r0, #16]
 8003d3c:	4798      	blx	r3

				/* Set new counter value */
				CustomTimers.Timers[i]->CNT = CustomTimers.Timers[i]->ARR;
 8003d3e:	4b0c      	ldr	r3, [pc, #48]	; (8003d70 <HAL_IncTick+0x7c>)
 8003d40:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8003d44:	686b      	ldr	r3, [r5, #4]
 8003d46:	685a      	ldr	r2, [r3, #4]
 8003d48:	609a      	str	r2, [r3, #8]

				/* Disable timer if auto reload feature is not used */
				if (!CustomTimers.Timers[i]->Flags.F.AREN) {
 8003d4a:	781a      	ldrb	r2, [r3, #0]
 8003d4c:	f012 0f01 	tst.w	r2, #1
 8003d50:	d103      	bne.n	8003d5a <HAL_IncTick+0x66>
					/* Disable counter */
					CustomTimers.Timers[i]->Flags.F.CNTEN = 0;
 8003d52:	781a      	ldrb	r2, [r3, #0]
 8003d54:	f36f 0241 	bfc	r2, #1, #1
 8003d58:	701a      	strb	r2, [r3, #0]
		TM_Time2--;
	}

	/* Check for timers */
	/* Check custom timers */
	for (i = 0; i < CustomTimers.Count; i++) {
 8003d5a:	3401      	adds	r4, #1
 8003d5c:	b2e4      	uxtb	r4, r4
 8003d5e:	4b04      	ldr	r3, [pc, #16]	; (8003d70 <HAL_IncTick+0x7c>)
 8003d60:	781b      	ldrb	r3, [r3, #0]
 8003d62:	429c      	cmp	r4, r3
 8003d64:	d3d4      	bcc.n	8003d10 <HAL_IncTick+0x1c>
		}
	}

	/* Call 1ms interrupt handler function */
	//TM_DELAY_1msHandler();
}
 8003d66:	bd38      	pop	{r3, r4, r5, pc}
 8003d68:	2000042c 	.word	0x2000042c
 8003d6c:	20000430 	.word	0x20000430
 8003d70:	20000414 	.word	0x20000414

08003d74 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003d74:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8003d78:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8003d7c:	4b01      	ldr	r3, [pc, #4]	; (8003d84 <NVIC_PriorityGroupConfig+0x10>)
 8003d7e:	60d8      	str	r0, [r3, #12]
 8003d80:	4770      	bx	lr
 8003d82:	bf00      	nop
 8003d84:	e000ed00 	.word	0xe000ed00

08003d88 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003d88:	78c3      	ldrb	r3, [r0, #3]
 8003d8a:	b1fb      	cbz	r3, 8003dcc <NVIC_Init+0x44>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003d8c:	4b15      	ldr	r3, [pc, #84]	; (8003de4 <NVIC_Init+0x5c>)
 8003d8e:	68db      	ldr	r3, [r3, #12]
 8003d90:	43db      	mvns	r3, r3
 8003d92:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
 8003d96:	f1c3 0104 	rsb	r1, r3, #4
    tmpsub = tmpsub >> tmppriority;
 8003d9a:	220f      	movs	r2, #15
 8003d9c:	40da      	lsrs	r2, r3

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003d9e:	7843      	ldrb	r3, [r0, #1]
 8003da0:	fa03 f101 	lsl.w	r1, r3, r1
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003da4:	7883      	ldrb	r3, [r0, #2]
 8003da6:	4013      	ands	r3, r2
 8003da8:	430b      	orrs	r3, r1
    tmppriority = tmppriority << 0x04;
 8003daa:	011b      	lsls	r3, r3, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003dac:	7802      	ldrb	r2, [r0, #0]
 8003dae:	b2db      	uxtb	r3, r3
 8003db0:	490d      	ldr	r1, [pc, #52]	; (8003de8 <NVIC_Init+0x60>)
 8003db2:	440a      	add	r2, r1
 8003db4:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003db8:	7803      	ldrb	r3, [r0, #0]
 8003dba:	0958      	lsrs	r0, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003dbc:	f003 031f 	and.w	r3, r3, #31
 8003dc0:	2201      	movs	r2, #1
 8003dc2:	fa02 f303 	lsl.w	r3, r2, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003dc6:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
 8003dca:	4770      	bx	lr
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003dcc:	7803      	ldrb	r3, [r0, #0]
 8003dce:	095a      	lsrs	r2, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003dd0:	f003 031f 	and.w	r3, r3, #31
 8003dd4:	2101      	movs	r1, #1
 8003dd6:	fa01 f303 	lsl.w	r3, r1, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003dda:	3220      	adds	r2, #32
 8003ddc:	4902      	ldr	r1, [pc, #8]	; (8003de8 <NVIC_Init+0x60>)
 8003dde:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8003de2:	4770      	bx	lr
 8003de4:	e000ed00 	.word	0xe000ed00
 8003de8:	e000e100 	.word	0xe000e100

08003dec <BKP_DeInit>:
  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void BKP_DeInit(void)
{
 8003dec:	b508      	push	{r3, lr}
  RCC_BackupResetCmd(ENABLE);
 8003dee:	2001      	movs	r0, #1
 8003df0:	f000 fc56 	bl	80046a0 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 8003df4:	2000      	movs	r0, #0
 8003df6:	f000 fc53 	bl	80046a0 <RCC_BackupResetCmd>
 8003dfa:	bd08      	pop	{r3, pc}

08003dfc <BKP_RTCOutputConfig>:
void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource)
{
  uint16_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
  tmpreg = BKP->RTCCR;
 8003dfc:	4a03      	ldr	r2, [pc, #12]	; (8003e0c <BKP_RTCOutputConfig+0x10>)
 8003dfe:	8d93      	ldrh	r3, [r2, #44]	; 0x2c
 8003e00:	b29b      	uxth	r3, r3
  /* Clear CCO, ASOE and ASOS bits */
  tmpreg &= RTCCR_MASK;
 8003e02:	f423 7360 	bic.w	r3, r3, #896	; 0x380
  
  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
  tmpreg |= BKP_RTCOutputSource;
 8003e06:	4318      	orrs	r0, r3
  /* Store the new value */
  BKP->RTCCR = tmpreg;
 8003e08:	8590      	strh	r0, [r2, #44]	; 0x2c
 8003e0a:	4770      	bx	lr
 8003e0c:	40006c00 	.word	0x40006c00

08003e10 <BKP_WriteBackupRegister>:
  *   This parameter can be BKP_DRx where x:[1, 42]
  * @param  Data: data to write
  * @retval None
  */
void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)
{
 8003e10:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8003e12:	2300      	movs	r3, #0
 8003e14:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_BKP_DR(BKP_DR));

  tmp = (uint32_t)BKP_BASE; 
 8003e16:	4b04      	ldr	r3, [pc, #16]	; (8003e28 <BKP_WriteBackupRegister+0x18>)
 8003e18:	9301      	str	r3, [sp, #4]
  tmp += BKP_DR;
 8003e1a:	9b01      	ldr	r3, [sp, #4]
 8003e1c:	4418      	add	r0, r3
 8003e1e:	9001      	str	r0, [sp, #4]

  *(__IO uint32_t *) tmp = Data;
 8003e20:	9b01      	ldr	r3, [sp, #4]
 8003e22:	6019      	str	r1, [r3, #0]
}
 8003e24:	b002      	add	sp, #8
 8003e26:	4770      	bx	lr
 8003e28:	40006c00 	.word	0x40006c00

08003e2c <BKP_ReadBackupRegister>:
  * @param  BKP_DR: specifies the Data Backup Register.
  *   This parameter can be BKP_DRx where x:[1, 42]
  * @retval The content of the specified Data Backup Register
  */
uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)
{
 8003e2c:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8003e2e:	2300      	movs	r3, #0
 8003e30:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_BKP_DR(BKP_DR));

  tmp = (uint32_t)BKP_BASE; 
 8003e32:	4b05      	ldr	r3, [pc, #20]	; (8003e48 <BKP_ReadBackupRegister+0x1c>)
 8003e34:	9301      	str	r3, [sp, #4]
  tmp += BKP_DR;
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	4418      	add	r0, r3
 8003e3a:	9001      	str	r0, [sp, #4]

  return (*(__IO uint16_t *) tmp);
 8003e3c:	9b01      	ldr	r3, [sp, #4]
 8003e3e:	8818      	ldrh	r0, [r3, #0]
}
 8003e40:	b280      	uxth	r0, r0
 8003e42:	b002      	add	sp, #8
 8003e44:	4770      	bx	lr
 8003e46:	bf00      	nop
 8003e48:	40006c00 	.word	0x40006c00

08003e4c <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8003e4c:	6803      	ldr	r3, [r0, #0]
 8003e4e:	f023 0301 	bic.w	r3, r3, #1
 8003e52:	041b      	lsls	r3, r3, #16
 8003e54:	0c1b      	lsrs	r3, r3, #16
 8003e56:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8003e58:	2300      	movs	r3, #0
 8003e5a:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8003e5c:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8003e5e:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8003e60:	60c3      	str	r3, [r0, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8003e62:	4b36      	ldr	r3, [pc, #216]	; (8003f3c <DMA_DeInit+0xf0>)
 8003e64:	4298      	cmp	r0, r3
 8003e66:	d105      	bne.n	8003e74 <DMA_DeInit+0x28>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
 8003e68:	4a35      	ldr	r2, [pc, #212]	; (8003f40 <DMA_DeInit+0xf4>)
 8003e6a:	6853      	ldr	r3, [r2, #4]
 8003e6c:	f043 030f 	orr.w	r3, r3, #15
 8003e70:	6053      	str	r3, [r2, #4]
 8003e72:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8003e74:	4b33      	ldr	r3, [pc, #204]	; (8003f44 <DMA_DeInit+0xf8>)
 8003e76:	4298      	cmp	r0, r3
 8003e78:	d105      	bne.n	8003e86 <DMA_DeInit+0x3a>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
 8003e7a:	4a31      	ldr	r2, [pc, #196]	; (8003f40 <DMA_DeInit+0xf4>)
 8003e7c:	6853      	ldr	r3, [r2, #4]
 8003e7e:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8003e82:	6053      	str	r3, [r2, #4]
 8003e84:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8003e86:	4b30      	ldr	r3, [pc, #192]	; (8003f48 <DMA_DeInit+0xfc>)
 8003e88:	4298      	cmp	r0, r3
 8003e8a:	d105      	bne.n	8003e98 <DMA_DeInit+0x4c>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
 8003e8c:	4a2c      	ldr	r2, [pc, #176]	; (8003f40 <DMA_DeInit+0xf4>)
 8003e8e:	6853      	ldr	r3, [r2, #4]
 8003e90:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
 8003e94:	6053      	str	r3, [r2, #4]
 8003e96:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8003e98:	4b2c      	ldr	r3, [pc, #176]	; (8003f4c <DMA_DeInit+0x100>)
 8003e9a:	4298      	cmp	r0, r3
 8003e9c:	d105      	bne.n	8003eaa <DMA_DeInit+0x5e>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
 8003e9e:	4a28      	ldr	r2, [pc, #160]	; (8003f40 <DMA_DeInit+0xf4>)
 8003ea0:	6853      	ldr	r3, [r2, #4]
 8003ea2:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8003ea6:	6053      	str	r3, [r2, #4]
 8003ea8:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8003eaa:	4b29      	ldr	r3, [pc, #164]	; (8003f50 <DMA_DeInit+0x104>)
 8003eac:	4298      	cmp	r0, r3
 8003eae:	d105      	bne.n	8003ebc <DMA_DeInit+0x70>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
 8003eb0:	4a23      	ldr	r2, [pc, #140]	; (8003f40 <DMA_DeInit+0xf4>)
 8003eb2:	6853      	ldr	r3, [r2, #4]
 8003eb4:	f443 2370 	orr.w	r3, r3, #983040	; 0xf0000
 8003eb8:	6053      	str	r3, [r2, #4]
 8003eba:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8003ebc:	4b25      	ldr	r3, [pc, #148]	; (8003f54 <DMA_DeInit+0x108>)
 8003ebe:	4298      	cmp	r0, r3
 8003ec0:	d105      	bne.n	8003ece <DMA_DeInit+0x82>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 8003ec2:	4a1f      	ldr	r2, [pc, #124]	; (8003f40 <DMA_DeInit+0xf4>)
 8003ec4:	6853      	ldr	r3, [r2, #4]
 8003ec6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003eca:	6053      	str	r3, [r2, #4]
 8003ecc:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8003ece:	4b22      	ldr	r3, [pc, #136]	; (8003f58 <DMA_DeInit+0x10c>)
 8003ed0:	4298      	cmp	r0, r3
 8003ed2:	d105      	bne.n	8003ee0 <DMA_DeInit+0x94>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8003ed4:	4a1a      	ldr	r2, [pc, #104]	; (8003f40 <DMA_DeInit+0xf4>)
 8003ed6:	6853      	ldr	r3, [r2, #4]
 8003ed8:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 8003edc:	6053      	str	r3, [r2, #4]
 8003ede:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8003ee0:	4b1e      	ldr	r3, [pc, #120]	; (8003f5c <DMA_DeInit+0x110>)
 8003ee2:	4298      	cmp	r0, r3
 8003ee4:	d105      	bne.n	8003ef2 <DMA_DeInit+0xa6>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8003ee6:	4a1e      	ldr	r2, [pc, #120]	; (8003f60 <DMA_DeInit+0x114>)
 8003ee8:	6853      	ldr	r3, [r2, #4]
 8003eea:	f043 030f 	orr.w	r3, r3, #15
 8003eee:	6053      	str	r3, [r2, #4]
 8003ef0:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8003ef2:	4b1c      	ldr	r3, [pc, #112]	; (8003f64 <DMA_DeInit+0x118>)
 8003ef4:	4298      	cmp	r0, r3
 8003ef6:	d105      	bne.n	8003f04 <DMA_DeInit+0xb8>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 8003ef8:	4a19      	ldr	r2, [pc, #100]	; (8003f60 <DMA_DeInit+0x114>)
 8003efa:	6853      	ldr	r3, [r2, #4]
 8003efc:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8003f00:	6053      	str	r3, [r2, #4]
 8003f02:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 8003f04:	4b18      	ldr	r3, [pc, #96]	; (8003f68 <DMA_DeInit+0x11c>)
 8003f06:	4298      	cmp	r0, r3
 8003f08:	d105      	bne.n	8003f16 <DMA_DeInit+0xca>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8003f0a:	4a15      	ldr	r2, [pc, #84]	; (8003f60 <DMA_DeInit+0x114>)
 8003f0c:	6853      	ldr	r3, [r2, #4]
 8003f0e:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
 8003f12:	6053      	str	r3, [r2, #4]
 8003f14:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8003f16:	4b15      	ldr	r3, [pc, #84]	; (8003f6c <DMA_DeInit+0x120>)
 8003f18:	4298      	cmp	r0, r3
 8003f1a:	d105      	bne.n	8003f28 <DMA_DeInit+0xdc>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8003f1c:	4a10      	ldr	r2, [pc, #64]	; (8003f60 <DMA_DeInit+0x114>)
 8003f1e:	6853      	ldr	r3, [r2, #4]
 8003f20:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8003f24:	6053      	str	r3, [r2, #4]
 8003f26:	4770      	bx	lr
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8003f28:	4b11      	ldr	r3, [pc, #68]	; (8003f70 <DMA_DeInit+0x124>)
 8003f2a:	4298      	cmp	r0, r3
 8003f2c:	d104      	bne.n	8003f38 <DMA_DeInit+0xec>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 8003f2e:	4a0c      	ldr	r2, [pc, #48]	; (8003f60 <DMA_DeInit+0x114>)
 8003f30:	6853      	ldr	r3, [r2, #4]
 8003f32:	f443 2370 	orr.w	r3, r3, #983040	; 0xf0000
 8003f36:	6053      	str	r3, [r2, #4]
 8003f38:	4770      	bx	lr
 8003f3a:	bf00      	nop
 8003f3c:	40020008 	.word	0x40020008
 8003f40:	40020000 	.word	0x40020000
 8003f44:	4002001c 	.word	0x4002001c
 8003f48:	40020030 	.word	0x40020030
 8003f4c:	40020044 	.word	0x40020044
 8003f50:	40020058 	.word	0x40020058
 8003f54:	4002006c 	.word	0x4002006c
 8003f58:	40020080 	.word	0x40020080
 8003f5c:	40020408 	.word	0x40020408
 8003f60:	40020400 	.word	0x40020400
 8003f64:	4002041c 	.word	0x4002041c
 8003f68:	40020430 	.word	0x40020430
 8003f6c:	40020444 	.word	0x40020444
 8003f70:	40020458 	.word	0x40020458

08003f74 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *         contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 8003f74:	b410      	push	{r4}
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8003f76:	6803      	ldr	r3, [r0, #0]
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8003f78:	f423 42ff 	bic.w	r2, r3, #32640	; 0x7f80
 8003f7c:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003f80:	688c      	ldr	r4, [r1, #8]
 8003f82:	6a0b      	ldr	r3, [r1, #32]
 8003f84:	431c      	orrs	r4, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003f86:	690b      	ldr	r3, [r1, #16]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003f88:	431c      	orrs	r4, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003f8a:	694b      	ldr	r3, [r1, #20]
 8003f8c:	431c      	orrs	r4, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003f8e:	698b      	ldr	r3, [r1, #24]
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003f90:	431c      	orrs	r4, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003f92:	69cb      	ldr	r3, [r1, #28]
 8003f94:	431c      	orrs	r4, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003f96:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003f98:	431c      	orrs	r4, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003f9a:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003f9c:	4323      	orrs	r3, r4
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003f9e:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8003fa0:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8003fa2:	68cb      	ldr	r3, [r1, #12]
 8003fa4:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8003fa6:	680b      	ldr	r3, [r1, #0]
 8003fa8:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8003faa:	684b      	ldr	r3, [r1, #4]
 8003fac:	60c3      	str	r3, [r0, #12]
}
 8003fae:	bc10      	pop	{r4}
 8003fb0:	4770      	bx	lr
 8003fb2:	bf00      	nop

08003fb4 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003fb4:	b121      	cbz	r1, 8003fc0 <DMA_Cmd+0xc>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR1_EN;
 8003fb6:	6803      	ldr	r3, [r0, #0]
 8003fb8:	f043 0301 	orr.w	r3, r3, #1
 8003fbc:	6003      	str	r3, [r0, #0]
 8003fbe:	4770      	bx	lr
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8003fc0:	6803      	ldr	r3, [r0, #0]
 8003fc2:	f023 0301 	bic.w	r3, r3, #1
 8003fc6:	041b      	lsls	r3, r3, #16
 8003fc8:	0c1b      	lsrs	r3, r3, #16
 8003fca:	6003      	str	r3, [r0, #0]
 8003fcc:	4770      	bx	lr
 8003fce:	bf00      	nop

08003fd0 <DMA_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003fd0:	b11a      	cbz	r2, 8003fda <DMA_ITConfig+0xa>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003fd2:	6803      	ldr	r3, [r0, #0]
 8003fd4:	4319      	orrs	r1, r3
 8003fd6:	6001      	str	r1, [r0, #0]
 8003fd8:	4770      	bx	lr
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 8003fda:	6803      	ldr	r3, [r0, #0]
 8003fdc:	ea23 0101 	bic.w	r1, r3, r1
 8003fe0:	6001      	str	r1, [r0, #0]
 8003fe2:	4770      	bx	lr

08003fe4 <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8003fe4:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
 8003fe8:	d002      	beq.n	8003ff0 <DMA_GetFlagStatus+0xc>
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8003fea:	4b05      	ldr	r3, [pc, #20]	; (8004000 <DMA_GetFlagStatus+0x1c>)
 8003fec:	681b      	ldr	r3, [r3, #0]
 8003fee:	e001      	b.n	8003ff4 <DMA_GetFlagStatus+0x10>
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 8003ff0:	4b04      	ldr	r3, [pc, #16]	; (8004004 <DMA_GetFlagStatus+0x20>)
 8003ff2:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 8003ff4:	4203      	tst	r3, r0
 8003ff6:	d001      	beq.n	8003ffc <DMA_GetFlagStatus+0x18>
  {
    /* DMAy_FLAG is set */
    bitstatus = SET;
 8003ff8:	2001      	movs	r0, #1
 8003ffa:	4770      	bx	lr
  }
  else
  {
    /* DMAy_FLAG is reset */
    bitstatus = RESET;
 8003ffc:	2000      	movs	r0, #0
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
}
 8003ffe:	4770      	bx	lr
 8004000:	40020400 	.word	0x40020400
 8004004:	40020000 	.word	0x40020000

08004008 <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8004008:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
 800400c:	d002      	beq.n	8004014 <DMA_ClearFlag+0xc>
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 800400e:	4b03      	ldr	r3, [pc, #12]	; (800401c <DMA_ClearFlag+0x14>)
 8004010:	6058      	str	r0, [r3, #4]
 8004012:	4770      	bx	lr
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8004014:	4b02      	ldr	r3, [pc, #8]	; (8004020 <DMA_ClearFlag+0x18>)
 8004016:	6058      	str	r0, [r3, #4]
 8004018:	4770      	bx	lr
 800401a:	bf00      	nop
 800401c:	40020400 	.word	0x40020400
 8004020:	40020000 	.word	0x40020000

08004024 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8004024:	7983      	ldrb	r3, [r0, #6]
 8004026:	2b00      	cmp	r3, #0
 8004028:	d034      	beq.n	8004094 <EXTI_Init+0x70>
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800402a:	b410      	push	{r4}
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800402c:	4b20      	ldr	r3, [pc, #128]	; (80040b0 <EXTI_Init+0x8c>)
 800402e:	681a      	ldr	r2, [r3, #0]
 8004030:	6801      	ldr	r1, [r0, #0]
 8004032:	ea22 0201 	bic.w	r2, r2, r1
 8004036:	601a      	str	r2, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8004038:	685a      	ldr	r2, [r3, #4]
 800403a:	6801      	ldr	r1, [r0, #0]
 800403c:	ea22 0201 	bic.w	r2, r2, r1
 8004040:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8004042:	7902      	ldrb	r2, [r0, #4]
 8004044:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8004048:	f502 3282 	add.w	r2, r2, #66560	; 0x10400

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800404c:	6814      	ldr	r4, [r2, #0]
 800404e:	6801      	ldr	r1, [r0, #0]
 8004050:	4321      	orrs	r1, r4
 8004052:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8004054:	689a      	ldr	r2, [r3, #8]
 8004056:	6801      	ldr	r1, [r0, #0]
 8004058:	ea22 0201 	bic.w	r2, r2, r1
 800405c:	609a      	str	r2, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 800405e:	68da      	ldr	r2, [r3, #12]
 8004060:	6801      	ldr	r1, [r0, #0]
 8004062:	ea22 0201 	bic.w	r2, r2, r1
 8004066:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8004068:	7943      	ldrb	r3, [r0, #5]
 800406a:	2b10      	cmp	r3, #16
 800406c:	d109      	bne.n	8004082 <EXTI_Init+0x5e>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 800406e:	4b10      	ldr	r3, [pc, #64]	; (80040b0 <EXTI_Init+0x8c>)
 8004070:	6899      	ldr	r1, [r3, #8]
 8004072:	6802      	ldr	r2, [r0, #0]
 8004074:	430a      	orrs	r2, r1
 8004076:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8004078:	68d9      	ldr	r1, [r3, #12]
 800407a:	6802      	ldr	r2, [r0, #0]
 800407c:	430a      	orrs	r2, r1
 800407e:	60da      	str	r2, [r3, #12]
 8004080:	e013      	b.n	80040aa <EXTI_Init+0x86>
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8004082:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8004086:	f503 3382 	add.w	r3, r3, #66560	; 0x10400

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800408a:	6819      	ldr	r1, [r3, #0]
 800408c:	6802      	ldr	r2, [r0, #0]
 800408e:	430a      	orrs	r2, r1
 8004090:	601a      	str	r2, [r3, #0]
 8004092:	e00a      	b.n	80040aa <EXTI_Init+0x86>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8004094:	7903      	ldrb	r3, [r0, #4]
 8004096:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800409a:	f503 3382 	add.w	r3, r3, #66560	; 0x10400

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 800409e:	681a      	ldr	r2, [r3, #0]
 80040a0:	6801      	ldr	r1, [r0, #0]
 80040a2:	ea22 0201 	bic.w	r2, r2, r1
 80040a6:	601a      	str	r2, [r3, #0]
  }
}
 80040a8:	4770      	bx	lr
 80040aa:	bc10      	pop	{r4}
 80040ac:	4770      	bx	lr
 80040ae:	bf00      	nop
 80040b0:	40010400 	.word	0x40010400

080040b4 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 80040b4:	4a06      	ldr	r2, [pc, #24]	; (80040d0 <EXTI_GetITStatus+0x1c>)
 80040b6:	6813      	ldr	r3, [r2, #0]
 80040b8:	4003      	ands	r3, r0
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 80040ba:	6952      	ldr	r2, [r2, #20]
 80040bc:	4210      	tst	r0, r2
 80040be:	d002      	beq.n	80040c6 <EXTI_GetITStatus+0x12>
 80040c0:	b91b      	cbnz	r3, 80040ca <EXTI_GetITStatus+0x16>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80040c2:	2000      	movs	r0, #0
 80040c4:	4770      	bx	lr
 80040c6:	2000      	movs	r0, #0
 80040c8:	4770      	bx	lr
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
  {
    bitstatus = SET;
 80040ca:	2001      	movs	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80040cc:	4770      	bx	lr
 80040ce:	bf00      	nop
 80040d0:	40010400 	.word	0x40010400

080040d4 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80040d4:	4b01      	ldr	r3, [pc, #4]	; (80040dc <EXTI_ClearITPendingBit+0x8>)
 80040d6:	6158      	str	r0, [r3, #20]
 80040d8:	4770      	bx	lr
 80040da:	bf00      	nop
 80040dc:	40010400 	.word	0x40010400

080040e0 <FLASH_SetLatency>:
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 80040e0:	4a03      	ldr	r2, [pc, #12]	; (80040f0 <FLASH_SetLatency+0x10>)
 80040e2:	6813      	ldr	r3, [r2, #0]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 80040e4:	f003 0338 	and.w	r3, r3, #56	; 0x38
  tmpreg |= FLASH_Latency;
 80040e8:	4318      	orrs	r0, r3
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 80040ea:	6010      	str	r0, [r2, #0]
 80040ec:	4770      	bx	lr
 80040ee:	bf00      	nop
 80040f0:	40022000 	.word	0x40022000

080040f4 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 80040f4:	4b04      	ldr	r3, [pc, #16]	; (8004108 <FLASH_PrefetchBufferCmd+0x14>)
 80040f6:	681a      	ldr	r2, [r3, #0]
 80040f8:	f022 0210 	bic.w	r2, r2, #16
 80040fc:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 80040fe:	681a      	ldr	r2, [r3, #0]
 8004100:	4310      	orrs	r0, r2
 8004102:	6018      	str	r0, [r3, #0]
 8004104:	4770      	bx	lr
 8004106:	bf00      	nop
 8004108:	40022000 	.word	0x40022000

0800410c <FLASH_Unlock>:
  * @retval None
  */
void FLASH_Unlock(void)
{
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
 800410c:	4b03      	ldr	r3, [pc, #12]	; (800411c <FLASH_Unlock+0x10>)
 800410e:	4a04      	ldr	r2, [pc, #16]	; (8004120 <FLASH_Unlock+0x14>)
 8004110:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 8004112:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8004116:	605a      	str	r2, [r3, #4]
 8004118:	4770      	bx	lr
 800411a:	bf00      	nop
 800411c:	40022000 	.word	0x40022000
 8004120:	45670123 	.word	0x45670123

08004124 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8004124:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8004126:	78cb      	ldrb	r3, [r1, #3]
 8004128:	f003 020f 	and.w	r2, r3, #15
 800412c:	4615      	mov	r5, r2
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 800412e:	f013 0f10 	tst.w	r3, #16
 8004132:	d001      	beq.n	8004138 <GPIO_Init+0x14>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8004134:	788d      	ldrb	r5, [r1, #2]
 8004136:	4315      	orrs	r5, r2
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8004138:	780b      	ldrb	r3, [r1, #0]
 800413a:	b1e3      	cbz	r3, 8004176 <GPIO_Init+0x52>
  {
    tmpreg = GPIOx->CRL;
 800413c:	6806      	ldr	r6, [r0, #0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800413e:	2300      	movs	r3, #0
 8004140:	e016      	b.n	8004170 <GPIO_Init+0x4c>
    {
      pos = ((uint32_t)0x01) << pinpos;
 8004142:	2201      	movs	r2, #1
 8004144:	409a      	lsls	r2, r3
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8004146:	880c      	ldrh	r4, [r1, #0]
      if (currentpin == pos)
 8004148:	ea32 0404 	bics.w	r4, r2, r4
 800414c:	d10f      	bne.n	800416e <GPIO_Init+0x4a>
      {
        pos = pinpos << 2;
 800414e:	009c      	lsls	r4, r3, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8004150:	270f      	movs	r7, #15
 8004152:	40a7      	lsls	r7, r4
        tmpreg &= ~pinmask;
 8004154:	ea26 0607 	bic.w	r6, r6, r7
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8004158:	fa05 f404 	lsl.w	r4, r5, r4
 800415c:	4326      	orrs	r6, r4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800415e:	78cc      	ldrb	r4, [r1, #3]
 8004160:	2c28      	cmp	r4, #40	; 0x28
 8004162:	d101      	bne.n	8004168 <GPIO_Init+0x44>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8004164:	6142      	str	r2, [r0, #20]
 8004166:	e002      	b.n	800416e <GPIO_Init+0x4a>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8004168:	2c48      	cmp	r4, #72	; 0x48
 800416a:	d100      	bne.n	800416e <GPIO_Init+0x4a>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800416c:	6102      	str	r2, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800416e:	3301      	adds	r3, #1
 8004170:	2b07      	cmp	r3, #7
 8004172:	d9e6      	bls.n	8004142 <GPIO_Init+0x1e>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8004174:	6006      	str	r6, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8004176:	880b      	ldrh	r3, [r1, #0]
 8004178:	2bff      	cmp	r3, #255	; 0xff
 800417a:	d91e      	bls.n	80041ba <GPIO_Init+0x96>
  {
    tmpreg = GPIOx->CRH;
 800417c:	6846      	ldr	r6, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800417e:	2300      	movs	r3, #0
 8004180:	e018      	b.n	80041b4 <GPIO_Init+0x90>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8004182:	f103 0408 	add.w	r4, r3, #8
 8004186:	2201      	movs	r2, #1
 8004188:	40a2      	lsls	r2, r4
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 800418a:	880c      	ldrh	r4, [r1, #0]
      if (currentpin == pos)
 800418c:	ea32 0404 	bics.w	r4, r2, r4
 8004190:	d10f      	bne.n	80041b2 <GPIO_Init+0x8e>
      {
        pos = pinpos << 2;
 8004192:	009c      	lsls	r4, r3, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8004194:	270f      	movs	r7, #15
 8004196:	40a7      	lsls	r7, r4
        tmpreg &= ~pinmask;
 8004198:	ea26 0607 	bic.w	r6, r6, r7
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800419c:	fa05 f404 	lsl.w	r4, r5, r4
 80041a0:	4326      	orrs	r6, r4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 80041a2:	78cc      	ldrb	r4, [r1, #3]
 80041a4:	2c28      	cmp	r4, #40	; 0x28
 80041a6:	d100      	bne.n	80041aa <GPIO_Init+0x86>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80041a8:	6142      	str	r2, [r0, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 80041aa:	78cc      	ldrb	r4, [r1, #3]
 80041ac:	2c48      	cmp	r4, #72	; 0x48
 80041ae:	d100      	bne.n	80041b2 <GPIO_Init+0x8e>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80041b0:	6102      	str	r2, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80041b2:	3301      	adds	r3, #1
 80041b4:	2b07      	cmp	r3, #7
 80041b6:	d9e4      	bls.n	8004182 <GPIO_Init+0x5e>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 80041b8:	6046      	str	r6, [r0, #4]
  }
}
 80041ba:	bcf0      	pop	{r4, r5, r6, r7}
 80041bc:	4770      	bx	lr
 80041be:	bf00      	nop

080041c0 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80041c0:	6883      	ldr	r3, [r0, #8]
 80041c2:	4219      	tst	r1, r3
 80041c4:	d001      	beq.n	80041ca <GPIO_ReadInputDataBit+0xa>
  {
    bitstatus = (uint8_t)Bit_SET;
 80041c6:	2001      	movs	r0, #1
 80041c8:	4770      	bx	lr
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 80041ca:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 80041cc:	4770      	bx	lr
 80041ce:	bf00      	nop

080041d0 <GPIO_ReadOutputDataBit>:
  uint8_t bitstatus = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80041d0:	68c3      	ldr	r3, [r0, #12]
 80041d2:	4219      	tst	r1, r3
 80041d4:	d001      	beq.n	80041da <GPIO_ReadOutputDataBit+0xa>
  {
    bitstatus = (uint8_t)Bit_SET;
 80041d6:	2001      	movs	r0, #1
 80041d8:	4770      	bx	lr
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 80041da:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 80041dc:	4770      	bx	lr
 80041de:	bf00      	nop

080041e0 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 80041e0:	6101      	str	r1, [r0, #16]
 80041e2:	4770      	bx	lr

080041e4 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 80041e4:	6141      	str	r1, [r0, #20]
 80041e6:	4770      	bx	lr

080041e8 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 80041e8:	b10a      	cbz	r2, 80041ee <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 80041ea:	6101      	str	r1, [r0, #16]
 80041ec:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 80041ee:	6141      	str	r1, [r0, #20]
 80041f0:	4770      	bx	lr
 80041f2:	bf00      	nop

080041f4 <GPIO_PinRemapConfig>:
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 80041f4:	b430      	push	{r4, r5}

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80041f6:	2800      	cmp	r0, #0
 80041f8:	da02      	bge.n	8004200 <GPIO_PinRemapConfig+0xc>
  {
    tmpreg = AFIO->MAPR2;
 80041fa:	4b1a      	ldr	r3, [pc, #104]	; (8004264 <GPIO_PinRemapConfig+0x70>)
 80041fc:	69db      	ldr	r3, [r3, #28]
 80041fe:	e001      	b.n	8004204 <GPIO_PinRemapConfig+0x10>
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8004200:	4b18      	ldr	r3, [pc, #96]	; (8004264 <GPIO_PinRemapConfig+0x70>)
 8004202:	685b      	ldr	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8004204:	f3c0 4503 	ubfx	r5, r0, #16, #4
  tmp = GPIO_Remap & LSB_MASK;
 8004208:	b282      	uxth	r2, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 800420a:	f400 1440 	and.w	r4, r0, #3145728	; 0x300000
 800420e:	f5b4 1f40 	cmp.w	r4, #3145728	; 0x300000
 8004212:	d107      	bne.n	8004224 <GPIO_PinRemapConfig+0x30>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8004214:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8004218:	4d12      	ldr	r5, [pc, #72]	; (8004264 <GPIO_PinRemapConfig+0x70>)
 800421a:	686c      	ldr	r4, [r5, #4]
 800421c:	f024 6470 	bic.w	r4, r4, #251658240	; 0xf000000
 8004220:	606c      	str	r4, [r5, #4]
 8004222:	e011      	b.n	8004248 <GPIO_PinRemapConfig+0x54>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8004224:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8004228:	d006      	beq.n	8004238 <GPIO_PinRemapConfig+0x44>
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 800422a:	2403      	movs	r4, #3
 800422c:	40ac      	lsls	r4, r5
    tmpreg &= ~tmp1;
 800422e:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8004232:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 8004236:	e007      	b.n	8004248 <GPIO_PinRemapConfig+0x54>
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8004238:	0d44      	lsrs	r4, r0, #21
 800423a:	0124      	lsls	r4, r4, #4
 800423c:	fa02 f404 	lsl.w	r4, r2, r4
 8004240:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8004244:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 8004248:	b119      	cbz	r1, 8004252 <GPIO_PinRemapConfig+0x5e>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 800424a:	0d41      	lsrs	r1, r0, #21
 800424c:	0109      	lsls	r1, r1, #4
 800424e:	408a      	lsls	r2, r1
 8004250:	4313      	orrs	r3, r2
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8004252:	2800      	cmp	r0, #0
 8004254:	da02      	bge.n	800425c <GPIO_PinRemapConfig+0x68>
  {
    AFIO->MAPR2 = tmpreg;
 8004256:	4a03      	ldr	r2, [pc, #12]	; (8004264 <GPIO_PinRemapConfig+0x70>)
 8004258:	61d3      	str	r3, [r2, #28]
 800425a:	e001      	b.n	8004260 <GPIO_PinRemapConfig+0x6c>
  }
  else
  {
    AFIO->MAPR = tmpreg;
 800425c:	4a01      	ldr	r2, [pc, #4]	; (8004264 <GPIO_PinRemapConfig+0x70>)
 800425e:	6053      	str	r3, [r2, #4]
  }  
}
 8004260:	bc30      	pop	{r4, r5}
 8004262:	4770      	bx	lr
 8004264:	40010000 	.word	0x40010000

08004268 <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8004268:	b430      	push	{r4, r5}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800426a:	f001 0303 	and.w	r3, r1, #3
 800426e:	009b      	lsls	r3, r3, #2
 8004270:	240f      	movs	r4, #15
 8004272:	fa04 f503 	lsl.w	r5, r4, r3
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8004276:	0889      	lsrs	r1, r1, #2
 8004278:	4a07      	ldr	r2, [pc, #28]	; (8004298 <GPIO_EXTILineConfig+0x30>)
 800427a:	3102      	adds	r1, #2
 800427c:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
 8004280:	ea24 0405 	bic.w	r4, r4, r5
 8004284:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8004288:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
 800428c:	4098      	lsls	r0, r3
 800428e:	4320      	orrs	r0, r4
 8004290:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
}
 8004294:	bc30      	pop	{r4, r5}
 8004296:	4770      	bx	lr
 8004298:	40010000 	.word	0x40010000

0800429c <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
  *   contains the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 800429c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800429e:	b087      	sub	sp, #28
 80042a0:	4604      	mov	r4, r0
 80042a2:	460d      	mov	r5, r1
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 80042a4:	8886      	ldrh	r6, [r0, #4]
 80042a6:	b2b6      	uxth	r6, r6
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
 80042a8:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
 80042ac:	b2b6      	uxth	r6, r6
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 80042ae:	a801      	add	r0, sp, #4
 80042b0:	f000 f96e 	bl	8004590 <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 80042b4:	9803      	ldr	r0, [sp, #12]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 80042b6:	492d      	ldr	r1, [pc, #180]	; (800436c <I2C_Init+0xd0>)
 80042b8:	fba1 3100 	umull	r3, r1, r1, r0
 80042bc:	0c89      	lsrs	r1, r1, #18
 80042be:	b28f      	uxth	r7, r1
  tmpreg |= freqrange;
 80042c0:	433e      	orrs	r6, r7
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 80042c2:	80a6      	strh	r6, [r4, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= CR1_PE_Reset;
 80042c4:	8822      	ldrh	r2, [r4, #0]
 80042c6:	b292      	uxth	r2, r2
 80042c8:	f022 0201 	bic.w	r2, r2, #1
 80042cc:	b292      	uxth	r2, r2
 80042ce:	8022      	strh	r2, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 80042d0:	682b      	ldr	r3, [r5, #0]
 80042d2:	4a27      	ldr	r2, [pc, #156]	; (8004370 <I2C_Init+0xd4>)
 80042d4:	4293      	cmp	r3, r2
 80042d6:	d809      	bhi.n	80042ec <I2C_Init+0x50>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 80042d8:	005b      	lsls	r3, r3, #1
 80042da:	fbb0 f3f3 	udiv	r3, r0, r3
 80042de:	b29b      	uxth	r3, r3
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 80042e0:	2b03      	cmp	r3, #3
 80042e2:	d800      	bhi.n	80042e6 <I2C_Init+0x4a>
    {
      /* Set minimum allowed value */
      result = 0x04;  
 80042e4:	2304      	movs	r3, #4
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 80042e6:	3701      	adds	r7, #1
 80042e8:	8427      	strh	r7, [r4, #32]
 80042ea:	e027      	b.n	800433c <I2C_Init+0xa0>
  }
  /* Configure speed in fast mode */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 80042ec:	88ee      	ldrh	r6, [r5, #6]
 80042ee:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 80042f2:	4296      	cmp	r6, r2
 80042f4:	d105      	bne.n	8004302 <I2C_Init+0x66>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 80042f6:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 80042fa:	fbb0 f3f2 	udiv	r3, r0, r2
 80042fe:	b29b      	uxth	r3, r3
 8004300:	e008      	b.n	8004314 <I2C_Init+0x78>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 8004302:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004306:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800430a:	fbb0 f3f3 	udiv	r3, r0, r3
 800430e:	b29b      	uxth	r3, r3
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 8004310:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    }

    /* Test if CCR value is under 0x1*/
    if ((result & CCR_CCR_Set) == 0)
 8004314:	f3c3 020b 	ubfx	r2, r3, #0, #12
 8004318:	b90a      	cbnz	r2, 800431e <I2C_Init+0x82>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 800431a:	f043 0301 	orr.w	r3, r3, #1
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | CCR_FS_Set);
 800431e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8004322:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8004326:	fb01 f102 	mul.w	r1, r1, r2
 800432a:	4a12      	ldr	r2, [pc, #72]	; (8004374 <I2C_Init+0xd8>)
 800432c:	fb82 0201 	smull	r0, r2, r2, r1
 8004330:	17c9      	asrs	r1, r1, #31
 8004332:	ebc1 11a2 	rsb	r1, r1, r2, asr #6
 8004336:	3101      	adds	r1, #1
 8004338:	b289      	uxth	r1, r1
 800433a:	8421      	strh	r1, [r4, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 800433c:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= CR1_PE_Set;
 800433e:	8823      	ldrh	r3, [r4, #0]
 8004340:	b29b      	uxth	r3, r3
 8004342:	f043 0301 	orr.w	r3, r3, #1
 8004346:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8004348:	8823      	ldrh	r3, [r4, #0]
 800434a:	b29b      	uxth	r3, r3
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
 800434c:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8004350:	f023 0302 	bic.w	r3, r3, #2
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8004354:	88a9      	ldrh	r1, [r5, #4]
 8004356:	896a      	ldrh	r2, [r5, #10]
 8004358:	430a      	orrs	r2, r1
 800435a:	4313      	orrs	r3, r2
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 800435c:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 800435e:	89aa      	ldrh	r2, [r5, #12]
 8004360:	892b      	ldrh	r3, [r5, #8]
 8004362:	4313      	orrs	r3, r2
 8004364:	8123      	strh	r3, [r4, #8]
}
 8004366:	b007      	add	sp, #28
 8004368:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800436a:	bf00      	nop
 800436c:	431bde83 	.word	0x431bde83
 8004370:	000186a0 	.word	0x000186a0
 8004374:	10624dd3 	.word	0x10624dd3

08004378 <I2C_Cmd>:
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004378:	b129      	cbz	r1, 8004386 <I2C_Cmd+0xe>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= CR1_PE_Set;
 800437a:	8803      	ldrh	r3, [r0, #0]
 800437c:	b29b      	uxth	r3, r3
 800437e:	f043 0301 	orr.w	r3, r3, #1
 8004382:	8003      	strh	r3, [r0, #0]
 8004384:	4770      	bx	lr
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= CR1_PE_Reset;
 8004386:	8803      	ldrh	r3, [r0, #0]
 8004388:	b29b      	uxth	r3, r3
 800438a:	f023 0301 	bic.w	r3, r3, #1
 800438e:	b29b      	uxth	r3, r3
 8004390:	8003      	strh	r3, [r0, #0]
 8004392:	4770      	bx	lr

08004394 <I2C_DMACmd>:
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004394:	b129      	cbz	r1, 80043a2 <I2C_DMACmd+0xe>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= CR2_DMAEN_Set;
 8004396:	8883      	ldrh	r3, [r0, #4]
 8004398:	b29b      	uxth	r3, r3
 800439a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800439e:	8083      	strh	r3, [r0, #4]
 80043a0:	4770      	bx	lr
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= CR2_DMAEN_Reset;
 80043a2:	8883      	ldrh	r3, [r0, #4]
 80043a4:	b29b      	uxth	r3, r3
 80043a6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80043aa:	b29b      	uxth	r3, r3
 80043ac:	8083      	strh	r3, [r0, #4]
 80043ae:	4770      	bx	lr

080043b0 <I2C_DMALastTransferCmd>:
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80043b0:	b129      	cbz	r1, 80043be <I2C_DMALastTransferCmd+0xe>
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= CR2_LAST_Set;
 80043b2:	8883      	ldrh	r3, [r0, #4]
 80043b4:	b29b      	uxth	r3, r3
 80043b6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80043ba:	8083      	strh	r3, [r0, #4]
 80043bc:	4770      	bx	lr
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= CR2_LAST_Reset;
 80043be:	8883      	ldrh	r3, [r0, #4]
 80043c0:	b29b      	uxth	r3, r3
 80043c2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80043c6:	b29b      	uxth	r3, r3
 80043c8:	8083      	strh	r3, [r0, #4]
 80043ca:	4770      	bx	lr

080043cc <I2C_GenerateSTART>:
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80043cc:	b129      	cbz	r1, 80043da <I2C_GenerateSTART+0xe>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 80043ce:	8803      	ldrh	r3, [r0, #0]
 80043d0:	b29b      	uxth	r3, r3
 80043d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80043d6:	8003      	strh	r3, [r0, #0]
 80043d8:	4770      	bx	lr
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 80043da:	8803      	ldrh	r3, [r0, #0]
 80043dc:	b29b      	uxth	r3, r3
 80043de:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80043e2:	b29b      	uxth	r3, r3
 80043e4:	8003      	strh	r3, [r0, #0]
 80043e6:	4770      	bx	lr

080043e8 <I2C_GenerateSTOP>:
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80043e8:	b129      	cbz	r1, 80043f6 <I2C_GenerateSTOP+0xe>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 80043ea:	8803      	ldrh	r3, [r0, #0]
 80043ec:	b29b      	uxth	r3, r3
 80043ee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80043f2:	8003      	strh	r3, [r0, #0]
 80043f4:	4770      	bx	lr
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 80043f6:	8803      	ldrh	r3, [r0, #0]
 80043f8:	b29b      	uxth	r3, r3
 80043fa:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80043fe:	b29b      	uxth	r3, r3
 8004400:	8003      	strh	r3, [r0, #0]
 8004402:	4770      	bx	lr

08004404 <I2C_AcknowledgeConfig>:
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004404:	b129      	cbz	r1, 8004412 <I2C_AcknowledgeConfig+0xe>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8004406:	8803      	ldrh	r3, [r0, #0]
 8004408:	b29b      	uxth	r3, r3
 800440a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800440e:	8003      	strh	r3, [r0, #0]
 8004410:	4770      	bx	lr
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 8004412:	8803      	ldrh	r3, [r0, #0]
 8004414:	b29b      	uxth	r3, r3
 8004416:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800441a:	b29b      	uxth	r3, r3
 800441c:	8003      	strh	r3, [r0, #0]
 800441e:	4770      	bx	lr

08004420 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8004420:	8201      	strh	r1, [r0, #16]
 8004422:	4770      	bx	lr

08004424 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8004424:	8a00      	ldrh	r0, [r0, #16]
}
 8004426:	b2c0      	uxtb	r0, r0
 8004428:	4770      	bx	lr
 800442a:	bf00      	nop

0800442c <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 800442c:	b112      	cbz	r2, 8004434 <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 800442e:	f041 0101 	orr.w	r1, r1, #1
 8004432:	e001      	b.n	8004438 <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 8004434:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8004438:	b289      	uxth	r1, r1
 800443a:	8201      	strh	r1, [r0, #16]
 800443c:	4770      	bx	lr
 800443e:	bf00      	nop

08004440 <I2C_CheckEvent>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8004440:	8a83      	ldrh	r3, [r0, #20]
 8004442:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
 8004444:	8b02      	ldrh	r2, [r0, #24]
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8004446:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800444a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 800444e:	ea31 0303 	bics.w	r3, r1, r3
 8004452:	d101      	bne.n	8004458 <I2C_CheckEvent+0x18>
  {
    /* SUCCESS: last event is equal to I2C_EVENT */
    status = SUCCESS;
 8004454:	2001      	movs	r0, #1
 8004456:	4770      	bx	lr
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
 8004458:	2000      	movs	r0, #0
  }
  /* Return status */
  return status;
}
 800445a:	4770      	bx	lr

0800445c <I2C_GetFlagStatus>:
  *   Address matched flag (Slave mode)"ENDA"
  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 800445c:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 800445e:	2300      	movs	r3, #0
 8004460:	9301      	str	r3, [sp, #4]
 8004462:	9300      	str	r3, [sp, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 8004464:	9000      	str	r0, [sp, #0]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 8004466:	0f0b      	lsrs	r3, r1, #28
 8004468:	9301      	str	r3, [sp, #4]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_Mask;
 800446a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  
  if(i2creg != 0)
 800446e:	9b01      	ldr	r3, [sp, #4]
 8004470:	b11b      	cbz	r3, 800447a <I2C_GetFlagStatus+0x1e>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 8004472:	9b00      	ldr	r3, [sp, #0]
 8004474:	3314      	adds	r3, #20
 8004476:	9300      	str	r3, [sp, #0]
 8004478:	e003      	b.n	8004482 <I2C_GetFlagStatus+0x26>
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 800447a:	0c09      	lsrs	r1, r1, #16
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 800447c:	9b00      	ldr	r3, [sp, #0]
 800447e:	3318      	adds	r3, #24
 8004480:	9300      	str	r3, [sp, #0]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 8004482:	9b00      	ldr	r3, [sp, #0]
 8004484:	681b      	ldr	r3, [r3, #0]
 8004486:	4219      	tst	r1, r3
 8004488:	d001      	beq.n	800448e <I2C_GetFlagStatus+0x32>
  {
    /* I2C_FLAG is set */
    bitstatus = SET;
 800448a:	2001      	movs	r0, #1
 800448c:	e000      	b.n	8004490 <I2C_GetFlagStatus+0x34>
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
 800448e:	2000      	movs	r0, #0
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
}
 8004490:	b002      	add	sp, #8
 8004492:	4770      	bx	lr

08004494 <I2C_ClearFlag>:
  uint32_t flagpos = 0;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_Mask;
 8004494:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8004498:	43c9      	mvns	r1, r1
 800449a:	b289      	uxth	r1, r1
 800449c:	8281      	strh	r1, [r0, #20]
 800449e:	4770      	bx	lr

080044a0 <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 80044a0:	4b01      	ldr	r3, [pc, #4]	; (80044a8 <PWR_BackupAccessCmd+0x8>)
 80044a2:	6018      	str	r0, [r3, #0]
 80044a4:	4770      	bx	lr
 80044a6:	bf00      	nop
 80044a8:	420e0020 	.word	0x420e0020

080044ac <PWR_PVDCmd>:
  */
void PWR_PVDCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 80044ac:	4b01      	ldr	r3, [pc, #4]	; (80044b4 <PWR_PVDCmd+0x8>)
 80044ae:	6018      	str	r0, [r3, #0]
 80044b0:	4770      	bx	lr
 80044b2:	bf00      	nop
 80044b4:	420e0010 	.word	0x420e0010

080044b8 <PWR_PVDLevelConfig>:
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  tmpreg = PWR->CR;
 80044b8:	4a03      	ldr	r2, [pc, #12]	; (80044c8 <PWR_PVDLevelConfig+0x10>)
 80044ba:	6813      	ldr	r3, [r2, #0]
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 80044bc:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 80044c0:	4318      	orrs	r0, r3
  /* Store the new value */
  PWR->CR = tmpreg;
 80044c2:	6010      	str	r0, [r2, #0]
 80044c4:	4770      	bx	lr
 80044c6:	bf00      	nop
 80044c8:	40007000 	.word	0x40007000

080044cc <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 80044cc:	4a03      	ldr	r2, [pc, #12]	; (80044dc <RCC_PLLConfig+0x10>)
 80044ce:	6853      	ldr	r3, [r2, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 80044d0:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 80044d4:	4301      	orrs	r1, r0
 80044d6:	4319      	orrs	r1, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80044d8:	6051      	str	r1, [r2, #4]
 80044da:	4770      	bx	lr
 80044dc:	40021000 	.word	0x40021000

080044e0 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 80044e0:	4b01      	ldr	r3, [pc, #4]	; (80044e8 <RCC_PLLCmd+0x8>)
 80044e2:	6018      	str	r0, [r3, #0]
 80044e4:	4770      	bx	lr
 80044e6:	bf00      	nop
 80044e8:	42420060 	.word	0x42420060

080044ec <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 80044ec:	4a03      	ldr	r2, [pc, #12]	; (80044fc <RCC_SYSCLKConfig+0x10>)
 80044ee:	6853      	ldr	r3, [r2, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 80044f0:	f023 0303 	bic.w	r3, r3, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80044f4:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80044f6:	6050      	str	r0, [r2, #4]
 80044f8:	4770      	bx	lr
 80044fa:	bf00      	nop
 80044fc:	40021000 	.word	0x40021000

08004500 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8004500:	4b02      	ldr	r3, [pc, #8]	; (800450c <RCC_GetSYSCLKSource+0xc>)
 8004502:	6858      	ldr	r0, [r3, #4]
}
 8004504:	f000 000c 	and.w	r0, r0, #12
 8004508:	4770      	bx	lr
 800450a:	bf00      	nop
 800450c:	40021000 	.word	0x40021000

08004510 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8004510:	4a03      	ldr	r2, [pc, #12]	; (8004520 <RCC_HCLKConfig+0x10>)
 8004512:	6853      	ldr	r3, [r2, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8004514:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8004518:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800451a:	6050      	str	r0, [r2, #4]
 800451c:	4770      	bx	lr
 800451e:	bf00      	nop
 8004520:	40021000 	.word	0x40021000

08004524 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8004524:	4a03      	ldr	r2, [pc, #12]	; (8004534 <RCC_PCLK1Config+0x10>)
 8004526:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8004528:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800452c:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800452e:	6050      	str	r0, [r2, #4]
 8004530:	4770      	bx	lr
 8004532:	bf00      	nop
 8004534:	40021000 	.word	0x40021000

08004538 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8004538:	4a03      	ldr	r2, [pc, #12]	; (8004548 <RCC_PCLK2Config+0x10>)
 800453a:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 800453c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8004540:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8004544:	6050      	str	r0, [r2, #4]
 8004546:	4770      	bx	lr
 8004548:	40021000 	.word	0x40021000

0800454c <RCC_LSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800454c:	4b08      	ldr	r3, [pc, #32]	; (8004570 <RCC_LSEConfig+0x24>)
 800454e:	2200      	movs	r2, #0
 8004550:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8004552:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8004554:	2801      	cmp	r0, #1
 8004556:	d002      	beq.n	800455e <RCC_LSEConfig+0x12>
 8004558:	2804      	cmp	r0, #4
 800455a:	d004      	beq.n	8004566 <RCC_LSEConfig+0x1a>
 800455c:	4770      	bx	lr
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 800455e:	2201      	movs	r2, #1
 8004560:	4b03      	ldr	r3, [pc, #12]	; (8004570 <RCC_LSEConfig+0x24>)
 8004562:	701a      	strb	r2, [r3, #0]
      break;
 8004564:	4770      	bx	lr
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8004566:	2205      	movs	r2, #5
 8004568:	4b01      	ldr	r3, [pc, #4]	; (8004570 <RCC_LSEConfig+0x24>)
 800456a:	701a      	strb	r2, [r3, #0]
 800456c:	4770      	bx	lr
 800456e:	bf00      	nop
 8004570:	40021020 	.word	0x40021020

08004574 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8004574:	4a02      	ldr	r2, [pc, #8]	; (8004580 <RCC_RTCCLKConfig+0xc>)
 8004576:	6a13      	ldr	r3, [r2, #32]
 8004578:	4318      	orrs	r0, r3
 800457a:	6210      	str	r0, [r2, #32]
 800457c:	4770      	bx	lr
 800457e:	bf00      	nop
 8004580:	40021000 	.word	0x40021000

08004584 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8004584:	4b01      	ldr	r3, [pc, #4]	; (800458c <RCC_RTCCLKCmd+0x8>)
 8004586:	6018      	str	r0, [r3, #0]
 8004588:	4770      	bx	lr
 800458a:	bf00      	nop
 800458c:	4242043c 	.word	0x4242043c

08004590 <RCC_GetClocksFreq>:
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8004590:	b410      	push	{r4}
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8004592:	4b29      	ldr	r3, [pc, #164]	; (8004638 <RCC_GetClocksFreq+0xa8>)
 8004594:	685b      	ldr	r3, [r3, #4]
 8004596:	f003 030c 	and.w	r3, r3, #12
  
  switch (tmp)
 800459a:	2b04      	cmp	r3, #4
 800459c:	d005      	beq.n	80045aa <RCC_GetClocksFreq+0x1a>
 800459e:	2b08      	cmp	r3, #8
 80045a0:	d006      	beq.n	80045b0 <RCC_GetClocksFreq+0x20>
 80045a2:	bb13      	cbnz	r3, 80045ea <RCC_GetClocksFreq+0x5a>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80045a4:	4b25      	ldr	r3, [pc, #148]	; (800463c <RCC_GetClocksFreq+0xac>)
 80045a6:	6003      	str	r3, [r0, #0]
      break;
 80045a8:	e021      	b.n	80045ee <RCC_GetClocksFreq+0x5e>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80045aa:	4b24      	ldr	r3, [pc, #144]	; (800463c <RCC_GetClocksFreq+0xac>)
 80045ac:	6003      	str	r3, [r0, #0]
      break;
 80045ae:	e01e      	b.n	80045ee <RCC_GetClocksFreq+0x5e>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 80045b0:	4a21      	ldr	r2, [pc, #132]	; (8004638 <RCC_GetClocksFreq+0xa8>)
 80045b2:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 80045b4:	6852      	ldr	r2, [r2, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 80045b6:	f3c3 4383 	ubfx	r3, r3, #18, #4
 80045ba:	3302      	adds	r3, #2
      
      if (pllsource == 0x00)
 80045bc:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 80045c0:	d104      	bne.n	80045cc <RCC_GetClocksFreq+0x3c>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
 80045c2:	4a1f      	ldr	r2, [pc, #124]	; (8004640 <RCC_GetClocksFreq+0xb0>)
 80045c4:	fb02 f303 	mul.w	r3, r2, r3
 80045c8:	6003      	str	r3, [r0, #0]
 80045ca:	e010      	b.n	80045ee <RCC_GetClocksFreq+0x5e>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 80045cc:	4a1a      	ldr	r2, [pc, #104]	; (8004638 <RCC_GetClocksFreq+0xa8>)
 80045ce:	6852      	ldr	r2, [r2, #4]
 80045d0:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80045d4:	d004      	beq.n	80045e0 <RCC_GetClocksFreq+0x50>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 80045d6:	4a1a      	ldr	r2, [pc, #104]	; (8004640 <RCC_GetClocksFreq+0xb0>)
 80045d8:	fb02 f303 	mul.w	r3, r2, r3
 80045dc:	6003      	str	r3, [r0, #0]
 80045de:	e006      	b.n	80045ee <RCC_GetClocksFreq+0x5e>
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 80045e0:	4a16      	ldr	r2, [pc, #88]	; (800463c <RCC_GetClocksFreq+0xac>)
 80045e2:	fb02 f303 	mul.w	r3, r2, r3
 80045e6:	6003      	str	r3, [r0, #0]
 80045e8:	e001      	b.n	80045ee <RCC_GetClocksFreq+0x5e>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80045ea:	4b14      	ldr	r3, [pc, #80]	; (800463c <RCC_GetClocksFreq+0xac>)
 80045ec:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80045ee:	4912      	ldr	r1, [pc, #72]	; (8004638 <RCC_GetClocksFreq+0xa8>)
 80045f0:	684b      	ldr	r3, [r1, #4]
  tmp = tmp >> 4;
 80045f2:	f3c3 1303 	ubfx	r3, r3, #4, #4
  presc = APBAHBPrescTable[tmp];
 80045f6:	4c13      	ldr	r4, [pc, #76]	; (8004644 <RCC_GetClocksFreq+0xb4>)
 80045f8:	5ce3      	ldrb	r3, [r4, r3]
 80045fa:	b2da      	uxtb	r2, r3
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80045fc:	6803      	ldr	r3, [r0, #0]
 80045fe:	40d3      	lsrs	r3, r2
 8004600:	6043      	str	r3, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8004602:	684a      	ldr	r2, [r1, #4]
  tmp = tmp >> 8;
 8004604:	f3c2 2202 	ubfx	r2, r2, #8, #3
  presc = APBAHBPrescTable[tmp];
 8004608:	5ca2      	ldrb	r2, [r4, r2]
 800460a:	b2d2      	uxtb	r2, r2
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800460c:	fa23 f202 	lsr.w	r2, r3, r2
 8004610:	6082      	str	r2, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8004612:	684a      	ldr	r2, [r1, #4]
  tmp = tmp >> 11;
 8004614:	f3c2 22c2 	ubfx	r2, r2, #11, #3
  presc = APBAHBPrescTable[tmp];
 8004618:	5ca2      	ldrb	r2, [r4, r2]
 800461a:	b2d2      	uxtb	r2, r2
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800461c:	40d3      	lsrs	r3, r2
 800461e:	60c3      	str	r3, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8004620:	684a      	ldr	r2, [r1, #4]
  tmp = tmp >> 14;
 8004622:	f3c2 3281 	ubfx	r2, r2, #14, #2
  presc = ADCPrescTable[tmp];
 8004626:	4908      	ldr	r1, [pc, #32]	; (8004648 <RCC_GetClocksFreq+0xb8>)
 8004628:	5c8a      	ldrb	r2, [r1, r2]
 800462a:	b2d2      	uxtb	r2, r2
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 800462c:	fbb3 f3f2 	udiv	r3, r3, r2
 8004630:	6103      	str	r3, [r0, #16]
}
 8004632:	bc10      	pop	{r4}
 8004634:	4770      	bx	lr
 8004636:	bf00      	nop
 8004638:	40021000 	.word	0x40021000
 800463c:	007a1200 	.word	0x007a1200
 8004640:	003d0900 	.word	0x003d0900
 8004644:	20000180 	.word	0x20000180
 8004648:	2000017c 	.word	0x2000017c

0800464c <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800464c:	b121      	cbz	r1, 8004658 <RCC_AHBPeriphClockCmd+0xc>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800464e:	4b05      	ldr	r3, [pc, #20]	; (8004664 <RCC_AHBPeriphClockCmd+0x18>)
 8004650:	695a      	ldr	r2, [r3, #20]
 8004652:	4310      	orrs	r0, r2
 8004654:	6158      	str	r0, [r3, #20]
 8004656:	4770      	bx	lr
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8004658:	4a02      	ldr	r2, [pc, #8]	; (8004664 <RCC_AHBPeriphClockCmd+0x18>)
 800465a:	6953      	ldr	r3, [r2, #20]
 800465c:	ea23 0000 	bic.w	r0, r3, r0
 8004660:	6150      	str	r0, [r2, #20]
 8004662:	4770      	bx	lr
 8004664:	40021000 	.word	0x40021000

08004668 <RCC_APB2PeriphClockCmd>:
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004668:	b121      	cbz	r1, 8004674 <RCC_APB2PeriphClockCmd+0xc>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800466a:	4b05      	ldr	r3, [pc, #20]	; (8004680 <RCC_APB2PeriphClockCmd+0x18>)
 800466c:	699a      	ldr	r2, [r3, #24]
 800466e:	4310      	orrs	r0, r2
 8004670:	6198      	str	r0, [r3, #24]
 8004672:	4770      	bx	lr
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8004674:	4a02      	ldr	r2, [pc, #8]	; (8004680 <RCC_APB2PeriphClockCmd+0x18>)
 8004676:	6993      	ldr	r3, [r2, #24]
 8004678:	ea23 0000 	bic.w	r0, r3, r0
 800467c:	6190      	str	r0, [r2, #24]
 800467e:	4770      	bx	lr
 8004680:	40021000 	.word	0x40021000

08004684 <RCC_APB1PeriphClockCmd>:
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004684:	b121      	cbz	r1, 8004690 <RCC_APB1PeriphClockCmd+0xc>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8004686:	4b05      	ldr	r3, [pc, #20]	; (800469c <RCC_APB1PeriphClockCmd+0x18>)
 8004688:	69da      	ldr	r2, [r3, #28]
 800468a:	4310      	orrs	r0, r2
 800468c:	61d8      	str	r0, [r3, #28]
 800468e:	4770      	bx	lr
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8004690:	4a02      	ldr	r2, [pc, #8]	; (800469c <RCC_APB1PeriphClockCmd+0x18>)
 8004692:	69d3      	ldr	r3, [r2, #28]
 8004694:	ea23 0000 	bic.w	r0, r3, r0
 8004698:	61d0      	str	r0, [r2, #28]
 800469a:	4770      	bx	lr
 800469c:	40021000 	.word	0x40021000

080046a0 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80046a0:	4b01      	ldr	r3, [pc, #4]	; (80046a8 <RCC_BackupResetCmd+0x8>)
 80046a2:	6018      	str	r0, [r3, #0]
 80046a4:	4770      	bx	lr
 80046a6:	bf00      	nop
 80046a8:	42420440 	.word	0x42420440

080046ac <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 80046ac:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 80046ae:	2b01      	cmp	r3, #1
 80046b0:	d102      	bne.n	80046b8 <RCC_GetFlagStatus+0xc>
  {
    statusreg = RCC->CR;
 80046b2:	4b0a      	ldr	r3, [pc, #40]	; (80046dc <RCC_GetFlagStatus+0x30>)
 80046b4:	681b      	ldr	r3, [r3, #0]
 80046b6:	e006      	b.n	80046c6 <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 80046b8:	2b02      	cmp	r3, #2
 80046ba:	d102      	bne.n	80046c2 <RCC_GetFlagStatus+0x16>
  {
    statusreg = RCC->BDCR;
 80046bc:	4b07      	ldr	r3, [pc, #28]	; (80046dc <RCC_GetFlagStatus+0x30>)
 80046be:	6a1b      	ldr	r3, [r3, #32]
 80046c0:	e001      	b.n	80046c6 <RCC_GetFlagStatus+0x1a>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 80046c2:	4b06      	ldr	r3, [pc, #24]	; (80046dc <RCC_GetFlagStatus+0x30>)
 80046c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 80046c6:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80046ca:	fa23 f000 	lsr.w	r0, r3, r0
 80046ce:	f010 0f01 	tst.w	r0, #1
 80046d2:	d001      	beq.n	80046d8 <RCC_GetFlagStatus+0x2c>
  {
    bitstatus = SET;
 80046d4:	2001      	movs	r0, #1
 80046d6:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 80046d8:	2000      	movs	r0, #0
  }

  /* Return the flag status */
  return bitstatus;
}
 80046da:	4770      	bx	lr
 80046dc:	40021000 	.word	0x40021000

080046e0 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80046e0:	b500      	push	{lr}
 80046e2:	b083      	sub	sp, #12
  __IO uint32_t StartUpCounter = 0;
 80046e4:	2300      	movs	r3, #0
 80046e6:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80046e8:	2031      	movs	r0, #49	; 0x31
 80046ea:	f7ff ffdf 	bl	80046ac <RCC_GetFlagStatus>
    StartUpCounter++;  
 80046ee:	9b01      	ldr	r3, [sp, #4]
 80046f0:	3301      	adds	r3, #1
 80046f2:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80046f4:	9b01      	ldr	r3, [sp, #4]
 80046f6:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80046fa:	d001      	beq.n	8004700 <RCC_WaitForHSEStartUp+0x20>
 80046fc:	2800      	cmp	r0, #0
 80046fe:	d0f3      	beq.n	80046e8 <RCC_WaitForHSEStartUp+0x8>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8004700:	2031      	movs	r0, #49	; 0x31
 8004702:	f7ff ffd3 	bl	80046ac <RCC_GetFlagStatus>
 8004706:	b108      	cbz	r0, 800470c <RCC_WaitForHSEStartUp+0x2c>
  {
    status = SUCCESS;
 8004708:	2001      	movs	r0, #1
 800470a:	e000      	b.n	800470e <RCC_WaitForHSEStartUp+0x2e>
  }
  else
  {
    status = ERROR;
 800470c:	2000      	movs	r0, #0
  }  
  return (status);
}
 800470e:	b003      	add	sp, #12
 8004710:	f85d fb04 	ldr.w	pc, [sp], #4

08004714 <RTC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004714:	b129      	cbz	r1, 8004722 <RTC_ITConfig+0xe>
  {
    RTC->CRH |= RTC_IT;
 8004716:	4a06      	ldr	r2, [pc, #24]	; (8004730 <RTC_ITConfig+0x1c>)
 8004718:	8813      	ldrh	r3, [r2, #0]
 800471a:	b29b      	uxth	r3, r3
 800471c:	4318      	orrs	r0, r3
 800471e:	8010      	strh	r0, [r2, #0]
 8004720:	4770      	bx	lr
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 8004722:	4a03      	ldr	r2, [pc, #12]	; (8004730 <RTC_ITConfig+0x1c>)
 8004724:	8813      	ldrh	r3, [r2, #0]
 8004726:	43c0      	mvns	r0, r0
 8004728:	b280      	uxth	r0, r0
 800472a:	4018      	ands	r0, r3
 800472c:	8010      	strh	r0, [r2, #0]
 800472e:	4770      	bx	lr
 8004730:	40002800 	.word	0x40002800

08004734 <RTC_EnterConfigMode>:
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= RTC_CRL_CNF;
 8004734:	4a03      	ldr	r2, [pc, #12]	; (8004744 <RTC_EnterConfigMode+0x10>)
 8004736:	8893      	ldrh	r3, [r2, #4]
 8004738:	b29b      	uxth	r3, r3
 800473a:	f043 0310 	orr.w	r3, r3, #16
 800473e:	8093      	strh	r3, [r2, #4]
 8004740:	4770      	bx	lr
 8004742:	bf00      	nop
 8004744:	40002800 	.word	0x40002800

08004748 <RTC_ExitConfigMode>:
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
 8004748:	4a03      	ldr	r2, [pc, #12]	; (8004758 <RTC_ExitConfigMode+0x10>)
 800474a:	8893      	ldrh	r3, [r2, #4]
 800474c:	b29b      	uxth	r3, r3
 800474e:	f023 0310 	bic.w	r3, r3, #16
 8004752:	b29b      	uxth	r3, r3
 8004754:	8093      	strh	r3, [r2, #4]
 8004756:	4770      	bx	lr
 8004758:	40002800 	.word	0x40002800

0800475c <RTC_GetCounter>:
  */
uint32_t RTC_GetCounter(void)
{
  uint16_t high1 = 0, high2 = 0, low = 0;

  high1 = RTC->CNTH;
 800475c:	4908      	ldr	r1, [pc, #32]	; (8004780 <RTC_GetCounter+0x24>)
 800475e:	8b08      	ldrh	r0, [r1, #24]
 8004760:	b282      	uxth	r2, r0
  low   = RTC->CNTL;
 8004762:	8b8b      	ldrh	r3, [r1, #28]
 8004764:	b29b      	uxth	r3, r3
  high2 = RTC->CNTH;
 8004766:	8b08      	ldrh	r0, [r1, #24]
 8004768:	b280      	uxth	r0, r0

  if (high1 != high2)
 800476a:	4282      	cmp	r2, r0
 800476c:	d004      	beq.n	8004778 <RTC_GetCounter+0x1c>
  { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
       read again CNTL register then return the counter value */
    return (((uint32_t) high2 << 16 ) | RTC->CNTL);
 800476e:	8b8b      	ldrh	r3, [r1, #28]
 8004770:	b29b      	uxth	r3, r3
 8004772:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8004776:	4770      	bx	lr
  }
  else
  { /* No counter roll over during reading of CNTL and CNTH registers, counter 
       value is equal to first value of CNTL and CNTH */
    return (((uint32_t) high1 << 16 ) | low);
 8004778:	ea43 4002 	orr.w	r0, r3, r2, lsl #16
  }
}
 800477c:	4770      	bx	lr
 800477e:	bf00      	nop
 8004780:	40002800 	.word	0x40002800

08004784 <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 8004784:	b510      	push	{r4, lr}
 8004786:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 8004788:	f7ff ffd4 	bl	8004734 <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 800478c:	0c22      	lsrs	r2, r4, #16
 800478e:	4b03      	ldr	r3, [pc, #12]	; (800479c <RTC_SetCounter+0x18>)
 8004790:	831a      	strh	r2, [r3, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
 8004792:	b2a4      	uxth	r4, r4
 8004794:	839c      	strh	r4, [r3, #28]
  RTC_ExitConfigMode();
 8004796:	f7ff ffd7 	bl	8004748 <RTC_ExitConfigMode>
 800479a:	bd10      	pop	{r4, pc}
 800479c:	40002800 	.word	0x40002800

080047a0 <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 80047a0:	b510      	push	{r4, lr}
 80047a2:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 80047a4:	f7ff ffc6 	bl	8004734 <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
 80047a8:	f3c4 4203 	ubfx	r2, r4, #16, #4
 80047ac:	4b03      	ldr	r3, [pc, #12]	; (80047bc <RTC_SetPrescaler+0x1c>)
 80047ae:	811a      	strh	r2, [r3, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
 80047b0:	b2a4      	uxth	r4, r4
 80047b2:	819c      	strh	r4, [r3, #12]
  RTC_ExitConfigMode();
 80047b4:	f7ff ffc8 	bl	8004748 <RTC_ExitConfigMode>
 80047b8:	bd10      	pop	{r4, pc}
 80047ba:	bf00      	nop
 80047bc:	40002800 	.word	0x40002800

080047c0 <RTC_WaitForLastTask>:
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 80047c0:	4b03      	ldr	r3, [pc, #12]	; (80047d0 <RTC_WaitForLastTask+0x10>)
 80047c2:	889b      	ldrh	r3, [r3, #4]
 80047c4:	f003 0320 	and.w	r3, r3, #32
 80047c8:	b29b      	uxth	r3, r3
 80047ca:	2b00      	cmp	r3, #0
 80047cc:	d0f8      	beq.n	80047c0 <RTC_WaitForLastTask>
  {
  }
}
 80047ce:	4770      	bx	lr
 80047d0:	40002800 	.word	0x40002800

080047d4 <RTC_GetITStatus>:
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT)); 
  
  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
 80047d4:	4a06      	ldr	r2, [pc, #24]	; (80047f0 <RTC_GetITStatus+0x1c>)
 80047d6:	8893      	ldrh	r3, [r2, #4]
 80047d8:	b2c1      	uxtb	r1, r0
 80047da:	400b      	ands	r3, r1
  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
 80047dc:	8812      	ldrh	r2, [r2, #0]
 80047de:	4210      	tst	r0, r2
 80047e0:	d002      	beq.n	80047e8 <RTC_GetITStatus+0x14>
 80047e2:	b91b      	cbnz	r3, 80047ec <RTC_GetITStatus+0x18>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80047e4:	2000      	movs	r0, #0
 80047e6:	4770      	bx	lr
 80047e8:	2000      	movs	r0, #0
 80047ea:	4770      	bx	lr
  assert_param(IS_RTC_GET_IT(RTC_IT)); 
  
  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
  {
    bitstatus = SET;
 80047ec:	2001      	movs	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80047ee:	4770      	bx	lr
 80047f0:	40002800 	.word	0x40002800

080047f4 <RTC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  
  /* Clear the corresponding RTC pending bit */
  RTC->CRL &= (uint16_t)~RTC_IT;
 80047f4:	4a03      	ldr	r2, [pc, #12]	; (8004804 <RTC_ClearITPendingBit+0x10>)
 80047f6:	8893      	ldrh	r3, [r2, #4]
 80047f8:	43c0      	mvns	r0, r0
 80047fa:	b280      	uxth	r0, r0
 80047fc:	4003      	ands	r3, r0
 80047fe:	8093      	strh	r3, [r2, #4]
 8004800:	4770      	bx	lr
 8004802:	bf00      	nop
 8004804:	40002800 	.word	0x40002800

08004808 <TIM_TimeBaseInit>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004808:	8803      	ldrh	r3, [r0, #0]
 800480a:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 800480c:	4a21      	ldr	r2, [pc, #132]	; (8004894 <TIM_TimeBaseInit+0x8c>)
 800480e:	4290      	cmp	r0, r2
 8004810:	d012      	beq.n	8004838 <TIM_TimeBaseInit+0x30>
 8004812:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8004816:	4290      	cmp	r0, r2
 8004818:	d00e      	beq.n	8004838 <TIM_TimeBaseInit+0x30>
 800481a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800481e:	d00b      	beq.n	8004838 <TIM_TimeBaseInit+0x30>
 8004820:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8004824:	4290      	cmp	r0, r2
 8004826:	d007      	beq.n	8004838 <TIM_TimeBaseInit+0x30>
 8004828:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800482c:	4290      	cmp	r0, r2
 800482e:	d003      	beq.n	8004838 <TIM_TimeBaseInit+0x30>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8004830:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004834:	4290      	cmp	r0, r2
 8004836:	d103      	bne.n	8004840 <TIM_TimeBaseInit+0x38>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 8004838:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800483c:	884a      	ldrh	r2, [r1, #2]
 800483e:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8004840:	4a15      	ldr	r2, [pc, #84]	; (8004898 <TIM_TimeBaseInit+0x90>)
 8004842:	4290      	cmp	r0, r2
 8004844:	d008      	beq.n	8004858 <TIM_TimeBaseInit+0x50>
 8004846:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800484a:	4290      	cmp	r0, r2
 800484c:	d004      	beq.n	8004858 <TIM_TimeBaseInit+0x50>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800484e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004852:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004854:	88ca      	ldrh	r2, [r1, #6]
 8004856:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8004858:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800485a:	888b      	ldrh	r3, [r1, #4]
 800485c:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800485e:	880b      	ldrh	r3, [r1, #0]
 8004860:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8004862:	4b0c      	ldr	r3, [pc, #48]	; (8004894 <TIM_TimeBaseInit+0x8c>)
 8004864:	4298      	cmp	r0, r3
 8004866:	d00f      	beq.n	8004888 <TIM_TimeBaseInit+0x80>
 8004868:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800486c:	4298      	cmp	r0, r3
 800486e:	d00b      	beq.n	8004888 <TIM_TimeBaseInit+0x80>
 8004870:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004874:	4298      	cmp	r0, r3
 8004876:	d007      	beq.n	8004888 <TIM_TimeBaseInit+0x80>
 8004878:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800487c:	4298      	cmp	r0, r3
 800487e:	d003      	beq.n	8004888 <TIM_TimeBaseInit+0x80>
 8004880:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004884:	4298      	cmp	r0, r3
 8004886:	d101      	bne.n	800488c <TIM_TimeBaseInit+0x84>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8004888:	7a0b      	ldrb	r3, [r1, #8]
 800488a:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 800488c:	2301      	movs	r3, #1
 800488e:	8283      	strh	r3, [r0, #20]
 8004890:	4770      	bx	lr
 8004892:	bf00      	nop
 8004894:	40012c00 	.word	0x40012c00
 8004898:	40001000 	.word	0x40001000

0800489c <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
 800489c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80048a0:	8083      	strh	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 80048a2:	2300      	movs	r3, #0
 80048a4:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 80048a6:	80c3      	strh	r3, [r0, #6]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 80048a8:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 80048aa:	7203      	strb	r3, [r0, #8]
 80048ac:	4770      	bx	lr
 80048ae:	bf00      	nop

080048b0 <TIM_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80048b0:	b129      	cbz	r1, 80048be <TIM_Cmd+0xe>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80048b2:	8803      	ldrh	r3, [r0, #0]
 80048b4:	b29b      	uxth	r3, r3
 80048b6:	f043 0301 	orr.w	r3, r3, #1
 80048ba:	8003      	strh	r3, [r0, #0]
 80048bc:	4770      	bx	lr
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 80048be:	8803      	ldrh	r3, [r0, #0]
 80048c0:	b29b      	uxth	r3, r3
 80048c2:	f023 0301 	bic.w	r3, r3, #1
 80048c6:	b29b      	uxth	r3, r3
 80048c8:	8003      	strh	r3, [r0, #0]
 80048ca:	4770      	bx	lr

080048cc <TIM_ITConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80048cc:	b122      	cbz	r2, 80048d8 <TIM_ITConfig+0xc>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80048ce:	8983      	ldrh	r3, [r0, #12]
 80048d0:	b29b      	uxth	r3, r3
 80048d2:	4319      	orrs	r1, r3
 80048d4:	8181      	strh	r1, [r0, #12]
 80048d6:	4770      	bx	lr
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 80048d8:	8983      	ldrh	r3, [r0, #12]
 80048da:	43c9      	mvns	r1, r1
 80048dc:	b289      	uxth	r1, r1
 80048de:	4019      	ands	r1, r3
 80048e0:	8181      	strh	r1, [r0, #12]
 80048e2:	4770      	bx	lr

080048e4 <TIM_SetCounter>:
void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 80048e4:	8481      	strh	r1, [r0, #36]	; 0x24
 80048e6:	4770      	bx	lr

080048e8 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 80048e8:	8a02      	ldrh	r2, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 80048ea:	8983      	ldrh	r3, [r0, #12]
 80048ec:	400b      	ands	r3, r1
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80048ee:	4211      	tst	r1, r2
 80048f0:	d002      	beq.n	80048f8 <TIM_GetITStatus+0x10>
 80048f2:	b91b      	cbnz	r3, 80048fc <TIM_GetITStatus+0x14>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80048f4:	2000      	movs	r0, #0
 80048f6:	4770      	bx	lr
 80048f8:	2000      	movs	r0, #0
 80048fa:	4770      	bx	lr
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
  {
    bitstatus = SET;
 80048fc:	2001      	movs	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80048fe:	4770      	bx	lr

08004900 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8004900:	43c9      	mvns	r1, r1
 8004902:	b289      	uxth	r1, r1
 8004904:	8201      	strh	r1, [r0, #16]
 8004906:	4770      	bx	lr

08004908 <USART_Init>:
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8004908:	b530      	push	{r4, r5, lr}
 800490a:	b087      	sub	sp, #28
 800490c:	4604      	mov	r4, r0
 800490e:	460d      	mov	r5, r1
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8004910:	8a03      	ldrh	r3, [r0, #16]
 8004912:	b29b      	uxth	r3, r3
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8004914:	88ca      	ldrh	r2, [r1, #6]
 8004916:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800491a:	4313      	orrs	r3, r2
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 800491c:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 800491e:	8983      	ldrh	r3, [r0, #12]
 8004920:	b29b      	uxth	r3, r3
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8004922:	888a      	ldrh	r2, [r1, #4]
 8004924:	8909      	ldrh	r1, [r1, #8]
            USART_InitStruct->USART_Mode;
 8004926:	8968      	ldrh	r0, [r5, #10]
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8004928:	430a      	orrs	r2, r1
 800492a:	4302      	orrs	r2, r0
 800492c:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8004930:	f023 030c 	bic.w	r3, r3, #12
 8004934:	4313      	orrs	r3, r2
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8004936:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8004938:	8aa3      	ldrh	r3, [r4, #20]
 800493a:	b29b      	uxth	r3, r3
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 800493c:	89aa      	ldrh	r2, [r5, #12]
 800493e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004942:	4313      	orrs	r3, r2
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8004944:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8004946:	a801      	add	r0, sp, #4
 8004948:	f7ff fe22 	bl	8004590 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 800494c:	4b1e      	ldr	r3, [pc, #120]	; (80049c8 <USART_Init+0xc0>)
 800494e:	429c      	cmp	r4, r3
 8004950:	d101      	bne.n	8004956 <USART_Init+0x4e>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8004952:	9a04      	ldr	r2, [sp, #16]
 8004954:	e000      	b.n	8004958 <USART_Init+0x50>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8004956:	9a03      	ldr	r2, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8004958:	89a3      	ldrh	r3, [r4, #12]
 800495a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800495e:	d008      	beq.n	8004972 <USART_Init+0x6a>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8004960:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004964:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004968:	6829      	ldr	r1, [r5, #0]
 800496a:	0049      	lsls	r1, r1, #1
 800496c:	fbb2 f1f1 	udiv	r1, r2, r1
 8004970:	e007      	b.n	8004982 <USART_Init+0x7a>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8004972:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004976:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800497a:	6829      	ldr	r1, [r5, #0]
 800497c:	0089      	lsls	r1, r1, #2
 800497e:	fbb2 f1f1 	udiv	r1, r2, r1
  }
  tmpreg = (integerdivider / 100) << 4;
 8004982:	4b12      	ldr	r3, [pc, #72]	; (80049cc <USART_Init+0xc4>)
 8004984:	fba3 2301 	umull	r2, r3, r3, r1
 8004988:	095b      	lsrs	r3, r3, #5
 800498a:	011b      	lsls	r3, r3, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 800498c:	091a      	lsrs	r2, r3, #4
 800498e:	2064      	movs	r0, #100	; 0x64
 8004990:	fb00 1212 	mls	r2, r0, r2, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8004994:	89a1      	ldrh	r1, [r4, #12]
 8004996:	f411 4f00 	tst.w	r1, #32768	; 0x8000
 800499a:	d008      	beq.n	80049ae <USART_Init+0xa6>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 800499c:	00d2      	lsls	r2, r2, #3
 800499e:	3232      	adds	r2, #50	; 0x32
 80049a0:	490a      	ldr	r1, [pc, #40]	; (80049cc <USART_Init+0xc4>)
 80049a2:	fba1 1202 	umull	r1, r2, r1, r2
 80049a6:	f3c2 1242 	ubfx	r2, r2, #5, #3
 80049aa:	431a      	orrs	r2, r3
 80049ac:	e007      	b.n	80049be <USART_Init+0xb6>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 80049ae:	0112      	lsls	r2, r2, #4
 80049b0:	3232      	adds	r2, #50	; 0x32
 80049b2:	4906      	ldr	r1, [pc, #24]	; (80049cc <USART_Init+0xc4>)
 80049b4:	fba1 1202 	umull	r1, r2, r1, r2
 80049b8:	f3c2 1243 	ubfx	r2, r2, #5, #4
 80049bc:	431a      	orrs	r2, r3
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 80049be:	b292      	uxth	r2, r2
 80049c0:	8122      	strh	r2, [r4, #8]
}
 80049c2:	b007      	add	sp, #28
 80049c4:	bd30      	pop	{r4, r5, pc}
 80049c6:	bf00      	nop
 80049c8:	40013800 	.word	0x40013800
 80049cc:	51eb851f 	.word	0x51eb851f

080049d0 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80049d0:	b129      	cbz	r1, 80049de <USART_Cmd+0xe>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 80049d2:	8983      	ldrh	r3, [r0, #12]
 80049d4:	b29b      	uxth	r3, r3
 80049d6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80049da:	8183      	strh	r3, [r0, #12]
 80049dc:	4770      	bx	lr
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 80049de:	8983      	ldrh	r3, [r0, #12]
 80049e0:	b29b      	uxth	r3, r3
 80049e2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80049e6:	b29b      	uxth	r3, r3
 80049e8:	8183      	strh	r3, [r0, #12]
 80049ea:	4770      	bx	lr

080049ec <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 80049ec:	b410      	push	{r4}
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 80049ee:	f3c1 1442 	ubfx	r4, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 80049f2:	f001 011f 	and.w	r1, r1, #31
  itmask = (((uint32_t)0x01) << itpos);
 80049f6:	2301      	movs	r3, #1
 80049f8:	fa03 f101 	lsl.w	r1, r3, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80049fc:	429c      	cmp	r4, r3
 80049fe:	d101      	bne.n	8004a04 <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 8004a00:	300c      	adds	r0, #12
 8004a02:	e004      	b.n	8004a0e <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8004a04:	2c02      	cmp	r4, #2
 8004a06:	d101      	bne.n	8004a0c <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 8004a08:	3010      	adds	r0, #16
 8004a0a:	e000      	b.n	8004a0e <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8004a0c:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 8004a0e:	b11a      	cbz	r2, 8004a18 <USART_ITConfig+0x2c>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8004a10:	6803      	ldr	r3, [r0, #0]
 8004a12:	4319      	orrs	r1, r3
 8004a14:	6001      	str	r1, [r0, #0]
 8004a16:	e003      	b.n	8004a20 <USART_ITConfig+0x34>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8004a18:	6803      	ldr	r3, [r0, #0]
 8004a1a:	ea23 0101 	bic.w	r1, r3, r1
 8004a1e:	6001      	str	r1, [r0, #0]
  }
}
 8004a20:	bc10      	pop	{r4}
 8004a22:	4770      	bx	lr

08004a24 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8004a24:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8004a28:	8081      	strh	r1, [r0, #4]
 8004a2a:	4770      	bx	lr

08004a2c <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8004a2c:	8880      	ldrh	r0, [r0, #4]
}
 8004a2e:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8004a32:	4770      	bx	lr

08004a34 <USART_GetITStatus>:
  *     @arg USART_IT_FE:   Framing Error interrupt
  *     @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8004a34:	b410      	push	{r4}
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8004a36:	f3c1 1242 	ubfx	r2, r1, #5, #3
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
 8004a3a:	f001 041f 	and.w	r4, r1, #31
  itmask = (uint32_t)0x01 << itmask;
 8004a3e:	2301      	movs	r3, #1
 8004a40:	40a3      	lsls	r3, r4
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8004a42:	2a01      	cmp	r2, #1
 8004a44:	d103      	bne.n	8004a4e <USART_GetITStatus+0x1a>
  {
    itmask &= USARTx->CR1;
 8004a46:	8982      	ldrh	r2, [r0, #12]
 8004a48:	b292      	uxth	r2, r2
 8004a4a:	4013      	ands	r3, r2
 8004a4c:	e008      	b.n	8004a60 <USART_GetITStatus+0x2c>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8004a4e:	2a02      	cmp	r2, #2
 8004a50:	d103      	bne.n	8004a5a <USART_GetITStatus+0x26>
  {
    itmask &= USARTx->CR2;
 8004a52:	8a02      	ldrh	r2, [r0, #16]
 8004a54:	b292      	uxth	r2, r2
 8004a56:	4013      	ands	r3, r2
 8004a58:	e002      	b.n	8004a60 <USART_GetITStatus+0x2c>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8004a5a:	8a82      	ldrh	r2, [r0, #20]
 8004a5c:	b292      	uxth	r2, r2
 8004a5e:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
 8004a60:	0a09      	lsrs	r1, r1, #8
  bitpos = (uint32_t)0x01 << bitpos;
 8004a62:	2201      	movs	r2, #1
 8004a64:	fa02 f101 	lsl.w	r1, r2, r1
  bitpos &= USARTx->SR;
 8004a68:	8802      	ldrh	r2, [r0, #0]
 8004a6a:	b292      	uxth	r2, r2
 8004a6c:	4011      	ands	r1, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8004a6e:	b113      	cbz	r3, 8004a76 <USART_GetITStatus+0x42>
 8004a70:	b919      	cbnz	r1, 8004a7a <USART_GetITStatus+0x46>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8004a72:	2000      	movs	r0, #0
 8004a74:	e002      	b.n	8004a7c <USART_GetITStatus+0x48>
 8004a76:	2000      	movs	r0, #0
 8004a78:	e000      	b.n	8004a7c <USART_GetITStatus+0x48>
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->SR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
  {
    bitstatus = SET;
 8004a7a:	2001      	movs	r0, #1
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
 8004a7c:	bc10      	pop	{r4}
 8004a7e:	4770      	bx	lr

08004a80 <USART_ClearITPendingBit>:
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  bitpos = USART_IT >> 0x08;
 8004a80:	0a09      	lsrs	r1, r1, #8
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8004a82:	2301      	movs	r3, #1
 8004a84:	408b      	lsls	r3, r1
 8004a86:	b29b      	uxth	r3, r3
  USARTx->SR = (uint16_t)~itmask;
 8004a88:	43db      	mvns	r3, r3
 8004a8a:	b29b      	uxth	r3, r3
 8004a8c:	8003      	strh	r3, [r0, #0]
 8004a8e:	4770      	bx	lr

08004a90 <ADCT_BGS_Initialize_system>:
  GstSystemStatus.mbData.usCurrentGenFreq = 20;
  GstSystemStatus.mbData.usCurrentGenMode = 50;
}

void ADCT_BGS_Initialize_system(void)
{
 8004a90:	b570      	push	{r4, r5, r6, lr}
	static uint16_t HighByte =0, LowByte =0;
	ADCT_BGS_AIR_1_2_OFF();
 8004a92:	4c7c      	ldr	r4, [pc, #496]	; (8004c84 <ADCT_BGS_Initialize_system+0x1f4>)
 8004a94:	2140      	movs	r1, #64	; 0x40
 8004a96:	4620      	mov	r0, r4
 8004a98:	f7ff fba2 	bl	80041e0 <GPIO_SetBits>
 8004a9c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8004aa0:	4879      	ldr	r0, [pc, #484]	; (8004c88 <ADCT_BGS_Initialize_system+0x1f8>)
 8004aa2:	f7ff fb9d 	bl	80041e0 <GPIO_SetBits>
	ADCT_BGS_AIR_3_4_OFF();
 8004aa6:	2180      	movs	r1, #128	; 0x80
 8004aa8:	4620      	mov	r0, r4
 8004aaa:	f7ff fb99 	bl	80041e0 <GPIO_SetBits>
 8004aae:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8004ab2:	4620      	mov	r0, r4
 8004ab4:	f7ff fb94 	bl	80041e0 <GPIO_SetBits>
	ADCT_BGS_FAN_OFF();
 8004ab8:	2104      	movs	r1, #4
 8004aba:	4620      	mov	r0, r4
 8004abc:	f7ff fb92 	bl	80041e4 <GPIO_ResetBits>
 8004ac0:	2108      	movs	r1, #8
 8004ac2:	4620      	mov	r0, r4
 8004ac4:	f7ff fb8e 	bl	80041e4 <GPIO_ResetBits>
 8004ac8:	2110      	movs	r1, #16
 8004aca:	4620      	mov	r0, r4
 8004acc:	f7ff fb8a 	bl	80041e4 <GPIO_ResetBits>
 8004ad0:	2120      	movs	r1, #32
 8004ad2:	4620      	mov	r0, r4
 8004ad4:	f7ff fb86 	bl	80041e4 <GPIO_ResetBits>
	ADCT_BGS_RELAY_LAMP_OFF();
 8004ad8:	2200      	movs	r2, #0
 8004ada:	2101      	movs	r1, #1
 8004adc:	4620      	mov	r0, r4
 8004ade:	f7ff fb83 	bl	80041e8 <GPIO_WriteBit>
	ADCT_BGS_RELAY_BUZZER_OFF();
 8004ae2:	2200      	movs	r2, #0
 8004ae4:	2102      	movs	r1, #2
 8004ae6:	4620      	mov	r0, r4
 8004ae8:	f7ff fb7e 	bl	80041e8 <GPIO_WriteBit>
	// Read parameters saved in EEPROM
	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_TEMPERATURE_T1_LOW );
 8004aec:	2001      	movs	r0, #1
 8004aee:	f7fd fe73 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004af2:	4c66      	ldr	r4, [pc, #408]	; (8004c8c <ADCT_BGS_Initialize_system+0x1fc>)
 8004af4:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_TEMPERATURE_T1_HIGH );
 8004af6:	2002      	movs	r0, #2
 8004af8:	f7fd fe6e 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004afc:	b280      	uxth	r0, r0

	GstSystemSetting.usLowTemperatureT1 = HighByte*256 + LowByte;
 8004afe:	4d64      	ldr	r5, [pc, #400]	; (8004c90 <ADCT_BGS_Initialize_system+0x200>)
 8004b00:	8823      	ldrh	r3, [r4, #0]
 8004b02:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004b06:	8028      	strh	r0, [r5, #0]
	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_TEMPERATURE_T2_LOW );
 8004b08:	2003      	movs	r0, #3
 8004b0a:	f7fd fe65 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b0e:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_TEMPERATURE_T2_HIGH );
 8004b10:	2004      	movs	r0, #4
 8004b12:	f7fd fe61 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b16:	b280      	uxth	r0, r0
	GstSystemSetting.usHighTemperatureT2 = (uint16_t)(HighByte*256 + LowByte);
 8004b18:	8823      	ldrh	r3, [r4, #0]
 8004b1a:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004b1e:	8068      	strh	r0, [r5, #2]

	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_HUMIDITY_H1_LOW );
 8004b20:	2007      	movs	r0, #7
 8004b22:	f7fd fe59 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b26:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_LOW_HUMIDITY_H1_HIGH);
 8004b28:	2008      	movs	r0, #8
 8004b2a:	f7fd fe55 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b2e:	b280      	uxth	r0, r0
	GstSystemSetting.usLowHumidityH1 = HighByte*256 + LowByte;
 8004b30:	8823      	ldrh	r3, [r4, #0]
 8004b32:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004b36:	80e8      	strh	r0, [r5, #6]

	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_HUMIDITY_H2_LOW);
 8004b38:	2009      	movs	r0, #9
 8004b3a:	f7fd fe4d 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b3e:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_HIGH_HUMIDITY_H2_HIGH);
 8004b40:	200a      	movs	r0, #10
 8004b42:	f7fd fe49 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b46:	b280      	uxth	r0, r0
	GstSystemSetting.usHighHumidityH2 = HighByte*256 + LowByte;
 8004b48:	8823      	ldrh	r3, [r4, #0]
 8004b4a:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004b4e:	8128      	strh	r0, [r5, #8]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_MINSWITCHINGTIME_HOUR);
 8004b50:	201f      	movs	r0, #31
 8004b52:	f7fd fe41 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b56:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_MINSWITCHINGTIME_MINUTE);
 8004b58:	2020      	movs	r0, #32
 8004b5a:	f7fd fe3d 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b5e:	b280      	uxth	r0, r0
	GstSystemSetting.ulMinSwitchingTime = LowByte*3600 + HighByte*60;
 8004b60:	8823      	ldrh	r3, [r4, #0]
 8004b62:	f44f 6661 	mov.w	r6, #3600	; 0xe10
 8004b66:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8004b6a:	0082      	lsls	r2, r0, #2
 8004b6c:	fb06 2303 	mla	r3, r6, r3, r2
 8004b70:	622b      	str	r3, [r5, #32]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_HOUR);
 8004b72:	200b      	movs	r0, #11
 8004b74:	f7fd fe30 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b78:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_SWITCHING_MINUTE);
 8004b7a:	200c      	movs	r0, #12
 8004b7c:	f7fd fe2c 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b80:	b280      	uxth	r0, r0
	GstSystemSetting.ulSwitchingTime = LowByte*3600 + HighByte*60;
 8004b82:	8823      	ldrh	r3, [r4, #0]
 8004b84:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8004b88:	0082      	lsls	r2, r0, #2
 8004b8a:	fb06 2303 	mla	r3, r6, r3, r2
 8004b8e:	61eb      	str	r3, [r5, #28]
	LowByte = ADCT_AT24C64_ReadOneByte(EEPROM_FAN_TEMPERATURE_T3_LOW);
 8004b90:	2005      	movs	r0, #5
 8004b92:	f7fd fe21 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b96:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EEPROM_FAN_TEMPERATURE_T3_HIGH);
 8004b98:	2006      	movs	r0, #6
 8004b9a:	f7fd fe1d 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004b9e:	b280      	uxth	r0, r0
	GstSystemSetting.usFanTemperatureT3 = HighByte*256 + LowByte;
 8004ba0:	8823      	ldrh	r3, [r4, #0]
 8004ba2:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004ba6:	80a8      	strh	r0, [r5, #4]
	GstSystemSetting.ucDoorBurglarEnableAlarm = ADCT_AT24C64_ReadOneByte(EPPROM_DOORBURGLAR_ENABLEALARM);
 8004ba8:	200d      	movs	r0, #13
 8004baa:	f7fd fe15 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004bae:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
	GstSystemSetting.ucEnableAlarm = ADCT_AT24C64_ReadOneByte(EPPROM_ENABLE_ALARM);;
 8004bb2:	200e      	movs	r0, #14
 8004bb4:	f7fd fe10 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004bb8:	f885 0028 	strb.w	r0, [r5, #40]	; 0x28
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_LOW);
 8004bbc:	200f      	movs	r0, #15
 8004bbe:	f7fd fe0b 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004bc2:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_ALARMDURATION_HIGH);
 8004bc4:	2010      	movs	r0, #16
 8004bc6:	f7fd fe07 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004bca:	b280      	uxth	r0, r0
	GstSystemSetting.ulAlarmDuration = HighByte*3600+ LowByte*60;
 8004bcc:	8823      	ldrh	r3, [r4, #0]
 8004bce:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8004bd2:	009a      	lsls	r2, r3, #2
 8004bd4:	fb06 2600 	mla	r6, r6, r0, r2
 8004bd8:	62ee      	str	r6, [r5, #44]	; 0x2c
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENBATTERYVOLTAGEALARMVALUE_LOW);
 8004bda:	2011      	movs	r0, #17
 8004bdc:	f7fd fdfc 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004be0:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENBATTERYVOLTAGEALARMVALUE_HIGH);
 8004be2:	2012      	movs	r0, #18
 8004be4:	f7fd fdf8 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004be8:	b280      	uxth	r0, r0
	GstSystemSetting.usGenBatteryVoltageAlarmValue = HighByte*256 + LowByte;
 8004bea:	8823      	ldrh	r3, [r4, #0]
 8004bec:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004bf0:	8268      	strh	r0, [r5, #18]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENCOOLANTTEMPALARMVALUE_LOW);
 8004bf2:	2013      	movs	r0, #19
 8004bf4:	f7fd fdf0 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004bf8:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENCOOLANTTEMPALARMVALUE_HIGH);
 8004bfa:	2014      	movs	r0, #20
 8004bfc:	f7fd fdec 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c00:	b280      	uxth	r0, r0
	GstSystemSetting.usGenCoolantTempAlarmValue = HighByte*256 + LowByte;
 8004c02:	8823      	ldrh	r3, [r4, #0]
 8004c04:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004c08:	82a8      	strh	r0, [r5, #20]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENENGINESPEEDALARMVALUE_LOW);
 8004c0a:	2015      	movs	r0, #21
 8004c0c:	f7fd fde4 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c10:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENENGINESPEEDALARMVALUE_HIGH);
 8004c12:	2016      	movs	r0, #22
 8004c14:	f7fd fde0 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c18:	b280      	uxth	r0, r0
	GstSystemSetting.usGenEngineSpeedAlarmValue =  HighByte*256 + LowByte;
 8004c1a:	8823      	ldrh	r3, [r4, #0]
 8004c1c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004c20:	82e8      	strh	r0, [r5, #22]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENFUELLOWVALUE_LOW);
 8004c22:	2017      	movs	r0, #23
 8004c24:	f7fd fdd8 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c28:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENFUELLOWVALUE_HIGH);
 8004c2a:	2018      	movs	r0, #24
 8004c2c:	f7fd fdd4 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c30:	b280      	uxth	r0, r0
	GstSystemSetting.usGenFuelLowValue = HighByte*256 + LowByte;
 8004c32:	8823      	ldrh	r3, [r4, #0]
 8004c34:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004c38:	81e8      	strh	r0, [r5, #14]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENOILPRESSUREALARMVALUE_LOW);
 8004c3a:	2019      	movs	r0, #25
 8004c3c:	f7fd fdcc 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c40:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENOILPRESSUREALARMVALUE_HIGH);
 8004c42:	201a      	movs	r0, #26
 8004c44:	f7fd fdc8 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c48:	b280      	uxth	r0, r0
	GstSystemSetting.usGenOilPressureAlarmValue = HighByte*256 + LowByte;
 8004c4a:	8823      	ldrh	r3, [r4, #0]
 8004c4c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004c50:	8328      	strh	r0, [r5, #24]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENVOLTAGEALARMVALUE_LOW);
 8004c52:	201b      	movs	r0, #27
 8004c54:	f7fd fdc0 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c58:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_GENVOLTAGEALARMVALUE_HIGH);
 8004c5a:	201c      	movs	r0, #28
 8004c5c:	f7fd fdbc 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c60:	b280      	uxth	r0, r0
	GstSystemSetting.usGenVoltageAlarmValue = HighByte*256 + LowByte;
 8004c62:	8823      	ldrh	r3, [r4, #0]
 8004c64:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004c68:	8228      	strh	r0, [r5, #16]
	LowByte = ADCT_AT24C64_ReadOneByte(EPPROM_LOWMAINVOLTAGE_LOW);
 8004c6a:	201d      	movs	r0, #29
 8004c6c:	f7fd fdb4 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c70:	8020      	strh	r0, [r4, #0]
	HighByte = ADCT_AT24C64_ReadOneByte(EPPROM_LOWMAINVOLTAGE_HIGH);
 8004c72:	201e      	movs	r0, #30
 8004c74:	f7fd fdb0 	bl	80027d8 <ADCT_AT24C64_ReadOneByte>
 8004c78:	b280      	uxth	r0, r0
	GstSystemSetting.usLowMainVoltage = HighByte*256 + LowByte;
 8004c7a:	8823      	ldrh	r3, [r4, #0]
 8004c7c:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8004c80:	8168      	strh	r0, [r5, #10]
 8004c82:	bd70      	pop	{r4, r5, r6, pc}
 8004c84:	40010800 	.word	0x40010800
 8004c88:	40011000 	.word	0x40011000
 8004c8c:	20000436 	.word	0x20000436
 8004c90:	200004c0 	.word	0x200004c0

08004c94 <main>:
 **===========================================================================
 */
void ADCT_BGS_Initialize_system(void);
void ADCT_BGS_Factory_Reset(void);
int main(void)
{
 8004c94:	b508      	push	{r3, lr}
	ADCT_BGS_MODBUS_RS485_Init();
 8004c96:	f7fb fb3b 	bl	8000310 <ADCT_BGS_MODBUS_RS485_Init>
	DHT22_Module_Init_Hardware();
 8004c9a:	f7fc fea1 	bl	80019e0 <DHT22_Module_Init_Hardware>
	ADCT_BGS_Systick_Init();
 8004c9e:	f7fe ffbb 	bl	8003c18 <ADCT_BGS_Systick_Init>
	TM_DELAY_Init();
 8004ca2:	f7fe ffd3 	bl	8003c4c <TM_DELAY_Init>
	sprintf(LCD_Buffer.lcd_line1, "    ADCTeam     ");
	sprintf(LCD_Buffer.lcd_line2, "DA KHOI TAO XONG");
	(void)lcd_update(LCD_Buffer.lcd_line1, LCD_Buffer.lcd_line2);
#endif
	/* TODO - Add your application code here */
	ADCT_BGS_ASW_100ms_Init();
 8004ca6:	f7fb fa6f 	bl	8000188 <ADCT_BGS_ASW_100ms_Init>
	ADCT_BGS_ASW_10ms_Init();
 8004caa:	f7fb fa7d 	bl	80001a8 <ADCT_BGS_ASW_10ms_Init>
	ADCT_BGS_ASW_1s_Init();
 8004cae:	f7fb faa3 	bl	80001f8 <ADCT_BGS_ASW_1s_Init>
	ADCT_BGS_ASW_1ms_Init();
 8004cb2:	f7fb fa8d 	bl	80001d0 <ADCT_BGS_ASW_1ms_Init>
	ADCT_BGS_Button_Init();
 8004cb6:	f7fd fdc3 	bl	8002840 <ADCT_BGS_Button_Init>
	ADCT_BGS_RTC_Init();
 8004cba:	f7fe fecb 	bl	8003a54 <ADCT_BGS_RTC_Init>
	EEPROM_Init();
 8004cbe:	f7fd f9ad 	bl	800201c <EEPROM_Init>
	ADCT_Relay_Init();
 8004cc2:	f7fe fc2d 	bl	8003520 <ADCT_Relay_Init>
	ADCT_BGS_Sensor_Input_Init();
 8004cc6:	f7fe ff81 	bl	8003bcc <ADCT_BGS_Sensor_Input_Init>
#ifdef SUPPORT_FACTORY_RESET
	ADCT_BGS_Factory_Reset();
#endif
	ADCT_BGS_Initialize_system();
 8004cca:	f7ff fee1 	bl	8004a90 <ADCT_BGS_Initialize_system>
	{

#ifdef ADCT_BGS_USE_STANDALONE
		TM_BUTTON_Update();
#endif
		if(g_ASW_Task_flag.ASW_100ms_flag == TRUE)
 8004cce:	4b16      	ldr	r3, [pc, #88]	; (8004d28 <main+0x94>)
 8004cd0:	785b      	ldrb	r3, [r3, #1]
 8004cd2:	2b01      	cmp	r3, #1
 8004cd4:	d104      	bne.n	8004ce0 <main+0x4c>
		{
#ifdef DONT_USE_SIMULATION_MODE
			ADCT_BGS_MODBUS_GetSetting();
 8004cd6:	f7fb fc89 	bl	80005ec <ADCT_BGS_MODBUS_GetSetting>
#endif

			g_ASW_Task_flag.ASW_100ms_flag = FALSE;
 8004cda:	2200      	movs	r2, #0
 8004cdc:	4b12      	ldr	r3, [pc, #72]	; (8004d28 <main+0x94>)
 8004cde:	705a      	strb	r2, [r3, #1]
		}
		eMBPoll();
 8004ce0:	f7fe f8c4 	bl	8002e6c <eMBPoll>
		ADCT_BGS_MODBUS_RS485_UpdateData();
 8004ce4:	f7fb fb24 	bl	8000330 <ADCT_BGS_MODBUS_RS485_UpdateData>
#ifdef DONT_USE_SIMULATION_MODE
		ADCT_BGS_MODBUS_Get_BE_DKG_Data();
 8004ce8:	f7fb fc4e 	bl	8000588 <ADCT_BGS_MODBUS_Get_BE_DKG_Data>
#endif
		ADCT_BGS_StateManger();
 8004cec:	f7fb ff82 	bl	8000bf4 <ADCT_BGS_StateManger>
		ADCT_SystemFPT_RunOutput();
 8004cf0:	f7fc fa48 	bl	8001184 <ADCT_SystemFPT_RunOutput>
		/* Adding this line for setting RTC time in runtime with support from STLINK debugger and code compile without PRODUCTION CODE mode */
		if(ui8flag_set_time)
 8004cf4:	4b0d      	ldr	r3, [pc, #52]	; (8004d2c <main+0x98>)
 8004cf6:	781b      	ldrb	r3, [r3, #0]
 8004cf8:	b12b      	cbz	r3, 8004d06 <main+0x72>
		{

			ADCT_BGS_Setting_Date_Time(&ADCT_BGS_Date_Time_Setting);
 8004cfa:	480d      	ldr	r0, [pc, #52]	; (8004d30 <main+0x9c>)
 8004cfc:	f7fe fd0e 	bl	800371c <ADCT_BGS_Setting_Date_Time>
			ui8flag_set_time = 0;
 8004d00:	2200      	movs	r2, #0
 8004d02:	4b0a      	ldr	r3, [pc, #40]	; (8004d2c <main+0x98>)
 8004d04:	701a      	strb	r2, [r3, #0]
		}

		if(ADCT_BGS_REBOOT_BOARD)
 8004d06:	4b0b      	ldr	r3, [pc, #44]	; (8004d34 <main+0xa0>)
 8004d08:	781b      	ldrb	r3, [r3, #0]
 8004d0a:	f013 0fff 	tst.w	r3, #255	; 0xff
 8004d0e:	d0de      	beq.n	8004cce <main+0x3a>
    This function acts as a special kind of Data Memory Barrier. 
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
 8004d10:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004d14:	4908      	ldr	r1, [pc, #32]	; (8004d38 <main+0xa4>)
 8004d16:	68ca      	ldr	r2, [r1, #12]
 8004d18:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8004d1c:	4b07      	ldr	r3, [pc, #28]	; (8004d3c <main+0xa8>)
 8004d1e:	4313      	orrs	r3, r2
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
 8004d20:	60cb      	str	r3, [r1, #12]
 8004d22:	f3bf 8f4f 	dsb	sy
 8004d26:	e7fe      	b.n	8004d26 <main+0x92>
 8004d28:	20000444 	.word	0x20000444
 8004d2c:	20000434 	.word	0x20000434
 8004d30:	200006ac 	.word	0x200006ac
 8004d34:	2000044a 	.word	0x2000044a
 8004d38:	e000ed00 	.word	0xe000ed00
 8004d3c:	05fa0004 	.word	0x05fa0004

08004d40 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8004d40:	f8df d034 	ldr.w	sp, [pc, #52]	; 8004d78 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8004d44:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8004d46:	e003      	b.n	8004d50 <LoopCopyDataInit>

08004d48 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8004d48:	4b0c      	ldr	r3, [pc, #48]	; (8004d7c <LoopFillZerobss+0x18>)
	ldr	r3, [r3, r1]
 8004d4a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8004d4c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8004d4e:	3104      	adds	r1, #4

08004d50 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8004d50:	480b      	ldr	r0, [pc, #44]	; (8004d80 <LoopFillZerobss+0x1c>)
	ldr	r3, =_edata
 8004d52:	4b0c      	ldr	r3, [pc, #48]	; (8004d84 <LoopFillZerobss+0x20>)
	adds	r2, r0, r1
 8004d54:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8004d56:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8004d58:	d3f6      	bcc.n	8004d48 <CopyDataInit>
	ldr	r2, =_sbss
 8004d5a:	4a0b      	ldr	r2, [pc, #44]	; (8004d88 <LoopFillZerobss+0x24>)
	b	LoopFillZerobss
 8004d5c:	e002      	b.n	8004d64 <LoopFillZerobss>

08004d5e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8004d5e:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8004d60:	f842 3b04 	str.w	r3, [r2], #4

08004d64 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8004d64:	4b09      	ldr	r3, [pc, #36]	; (8004d8c <LoopFillZerobss+0x28>)
	cmp	r2, r3
 8004d66:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8004d68:	d3f9      	bcc.n	8004d5e <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8004d6a:	f000 f88d 	bl	8004e88 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8004d6e:	f000 f8b3 	bl	8004ed8 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8004d72:	f7ff ff8f 	bl	8004c94 <main>
	bx	lr
 8004d76:	4770      	bx	lr

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8004d78:	20005000 	.word	0x20005000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8004d7c:	0800527c 	.word	0x0800527c
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8004d80:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8004d84:	200001f8 	.word	0x200001f8
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8004d88:	200001f8 	.word	0x200001f8
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8004d8c:	200006bc 	.word	0x200006bc

08004d90 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8004d90:	e7fe      	b.n	8004d90 <ADC1_2_IRQHandler>
	...

08004d94 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8004d94:	4770      	bx	lr
 8004d96:	bf00      	nop

08004d98 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8004d98:	e7fe      	b.n	8004d98 <HardFault_Handler>
 8004d9a:	bf00      	nop

08004d9c <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8004d9c:	e7fe      	b.n	8004d9c <MemManage_Handler>
 8004d9e:	bf00      	nop

08004da0 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8004da0:	e7fe      	b.n	8004da0 <BusFault_Handler>
 8004da2:	bf00      	nop

08004da4 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8004da4:	e7fe      	b.n	8004da4 <UsageFault_Handler>
 8004da6:	bf00      	nop

08004da8 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8004da8:	4770      	bx	lr
 8004daa:	bf00      	nop

08004dac <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8004dac:	4770      	bx	lr
 8004dae:	bf00      	nop

08004db0 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8004db0:	4770      	bx	lr
 8004db2:	bf00      	nop

08004db4 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8004db4:	b508      	push	{r3, lr}
	HAL_IncTick();
 8004db6:	f7fe ff9d 	bl	8003cf4 <HAL_IncTick>
 8004dba:	bd08      	pop	{r3, pc}

08004dbc <SetSysClockTo72>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
 8004dbc:	b082      	sub	sp, #8
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8004dbe:	2300      	movs	r3, #0
 8004dc0:	9301      	str	r3, [sp, #4]
 8004dc2:	9300      	str	r3, [sp, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8004dc4:	4a2c      	ldr	r2, [pc, #176]	; (8004e78 <SetSysClockTo72+0xbc>)
 8004dc6:	6813      	ldr	r3, [r2, #0]
 8004dc8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004dcc:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8004dce:	4b2a      	ldr	r3, [pc, #168]	; (8004e78 <SetSysClockTo72+0xbc>)
 8004dd0:	681b      	ldr	r3, [r3, #0]
 8004dd2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004dd6:	9300      	str	r3, [sp, #0]
    StartUpCounter++;  
 8004dd8:	9b01      	ldr	r3, [sp, #4]
 8004dda:	3301      	adds	r3, #1
 8004ddc:	9301      	str	r3, [sp, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8004dde:	9b00      	ldr	r3, [sp, #0]
 8004de0:	b91b      	cbnz	r3, 8004dea <SetSysClockTo72+0x2e>
 8004de2:	9b01      	ldr	r3, [sp, #4]
 8004de4:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8004de8:	d1f1      	bne.n	8004dce <SetSysClockTo72+0x12>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8004dea:	4b23      	ldr	r3, [pc, #140]	; (8004e78 <SetSysClockTo72+0xbc>)
 8004dec:	681b      	ldr	r3, [r3, #0]
 8004dee:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8004df2:	d002      	beq.n	8004dfa <SetSysClockTo72+0x3e>
  {
    HSEStatus = (uint32_t)0x01;
 8004df4:	2301      	movs	r3, #1
 8004df6:	9300      	str	r3, [sp, #0]
 8004df8:	e001      	b.n	8004dfe <SetSysClockTo72+0x42>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8004dfa:	2300      	movs	r3, #0
 8004dfc:	9300      	str	r3, [sp, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
 8004dfe:	9b00      	ldr	r3, [sp, #0]
 8004e00:	2b01      	cmp	r3, #1
 8004e02:	d136      	bne.n	8004e72 <SetSysClockTo72+0xb6>
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8004e04:	4b1d      	ldr	r3, [pc, #116]	; (8004e7c <SetSysClockTo72+0xc0>)
 8004e06:	681a      	ldr	r2, [r3, #0]
 8004e08:	f042 0210 	orr.w	r2, r2, #16
 8004e0c:	601a      	str	r2, [r3, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 8004e0e:	681a      	ldr	r2, [r3, #0]
 8004e10:	f022 0203 	bic.w	r2, r2, #3
 8004e14:	601a      	str	r2, [r3, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 8004e16:	681a      	ldr	r2, [r3, #0]
 8004e18:	f042 0202 	orr.w	r2, r2, #2
 8004e1c:	601a      	str	r2, [r3, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8004e1e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 8004e22:	685a      	ldr	r2, [r3, #4]
 8004e24:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8004e26:	685a      	ldr	r2, [r3, #4]
 8004e28:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8004e2a:	685a      	ldr	r2, [r3, #4]
 8004e2c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8004e30:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 8004e32:	685a      	ldr	r2, [r3, #4]
 8004e34:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 8004e38:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 8004e3a:	685a      	ldr	r2, [r3, #4]
 8004e3c:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 8004e40:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8004e42:	681a      	ldr	r2, [r3, #0]
 8004e44:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8004e48:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8004e4a:	4b0b      	ldr	r3, [pc, #44]	; (8004e78 <SetSysClockTo72+0xbc>)
 8004e4c:	681b      	ldr	r3, [r3, #0]
 8004e4e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8004e52:	d0fa      	beq.n	8004e4a <SetSysClockTo72+0x8e>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8004e54:	4b08      	ldr	r3, [pc, #32]	; (8004e78 <SetSysClockTo72+0xbc>)
 8004e56:	685a      	ldr	r2, [r3, #4]
 8004e58:	f022 0203 	bic.w	r2, r2, #3
 8004e5c:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 8004e5e:	685a      	ldr	r2, [r3, #4]
 8004e60:	f042 0202 	orr.w	r2, r2, #2
 8004e64:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8004e66:	4b04      	ldr	r3, [pc, #16]	; (8004e78 <SetSysClockTo72+0xbc>)
 8004e68:	685b      	ldr	r3, [r3, #4]
 8004e6a:	f003 030c 	and.w	r3, r3, #12
 8004e6e:	2b08      	cmp	r3, #8
 8004e70:	d1f9      	bne.n	8004e66 <SetSysClockTo72+0xaa>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
}
 8004e72:	b002      	add	sp, #8
 8004e74:	4770      	bx	lr
 8004e76:	bf00      	nop
 8004e78:	40021000 	.word	0x40021000
 8004e7c:	40022000 	.word	0x40022000

08004e80 <SetSysClock>:
  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8004e80:	b508      	push	{r3, lr}
#elif defined SYSCLK_FREQ_48MHz
  SetSysClockTo48();
#elif defined SYSCLK_FREQ_56MHz
  SetSysClockTo56();  
#elif defined SYSCLK_FREQ_72MHz
  SetSysClockTo72();
 8004e82:	f7ff ff9b 	bl	8004dbc <SetSysClockTo72>
 8004e86:	bd08      	pop	{r3, pc}

08004e88 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8004e88:	b508      	push	{r3, lr}
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8004e8a:	4b10      	ldr	r3, [pc, #64]	; (8004ecc <SystemInit+0x44>)
 8004e8c:	681a      	ldr	r2, [r3, #0]
 8004e8e:	f042 0201 	orr.w	r2, r2, #1
 8004e92:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8004e94:	6859      	ldr	r1, [r3, #4]
 8004e96:	4a0e      	ldr	r2, [pc, #56]	; (8004ed0 <SystemInit+0x48>)
 8004e98:	400a      	ands	r2, r1
 8004e9a:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8004e9c:	681a      	ldr	r2, [r3, #0]
 8004e9e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8004ea2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004ea6:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8004ea8:	681a      	ldr	r2, [r3, #0]
 8004eaa:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004eae:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8004eb0:	685a      	ldr	r2, [r3, #4]
 8004eb2:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8004eb6:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8004eb8:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8004ebc:	609a      	str	r2, [r3, #8]
  #endif /* DATA_IN_ExtSRAM */
#endif 

  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
  /* Configure the Flash Latency cycles and enable prefetch buffer */
  SetSysClock();
 8004ebe:	f7ff ffdf 	bl	8004e80 <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8004ec2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8004ec6:	4b03      	ldr	r3, [pc, #12]	; (8004ed4 <SystemInit+0x4c>)
 8004ec8:	609a      	str	r2, [r3, #8]
 8004eca:	bd08      	pop	{r3, pc}
 8004ecc:	40021000 	.word	0x40021000
 8004ed0:	f8ff0000 	.word	0xf8ff0000
 8004ed4:	e000ed00 	.word	0xe000ed00

08004ed8 <__libc_init_array>:
 8004ed8:	4b0e      	ldr	r3, [pc, #56]	; (8004f14 <__libc_init_array+0x3c>)
 8004eda:	b570      	push	{r4, r5, r6, lr}
 8004edc:	461e      	mov	r6, r3
 8004ede:	4c0e      	ldr	r4, [pc, #56]	; (8004f18 <__libc_init_array+0x40>)
 8004ee0:	2500      	movs	r5, #0
 8004ee2:	1ae4      	subs	r4, r4, r3
 8004ee4:	10a4      	asrs	r4, r4, #2
 8004ee6:	42a5      	cmp	r5, r4
 8004ee8:	d004      	beq.n	8004ef4 <__libc_init_array+0x1c>
 8004eea:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8004eee:	4798      	blx	r3
 8004ef0:	3501      	adds	r5, #1
 8004ef2:	e7f8      	b.n	8004ee6 <__libc_init_array+0xe>
 8004ef4:	f000 f8b0 	bl	8005058 <_init>
 8004ef8:	4b08      	ldr	r3, [pc, #32]	; (8004f1c <__libc_init_array+0x44>)
 8004efa:	4c09      	ldr	r4, [pc, #36]	; (8004f20 <__libc_init_array+0x48>)
 8004efc:	461e      	mov	r6, r3
 8004efe:	1ae4      	subs	r4, r4, r3
 8004f00:	10a4      	asrs	r4, r4, #2
 8004f02:	2500      	movs	r5, #0
 8004f04:	42a5      	cmp	r5, r4
 8004f06:	d004      	beq.n	8004f12 <__libc_init_array+0x3a>
 8004f08:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8004f0c:	4798      	blx	r3
 8004f0e:	3501      	adds	r5, #1
 8004f10:	e7f8      	b.n	8004f04 <__libc_init_array+0x2c>
 8004f12:	bd70      	pop	{r4, r5, r6, pc}
 8004f14:	08005274 	.word	0x08005274
 8004f18:	08005274 	.word	0x08005274
 8004f1c:	08005274 	.word	0x08005274
 8004f20:	08005278 	.word	0x08005278

08004f24 <malloc>:
 8004f24:	4b02      	ldr	r3, [pc, #8]	; (8004f30 <malloc+0xc>)
 8004f26:	4601      	mov	r1, r0
 8004f28:	6818      	ldr	r0, [r3, #0]
 8004f2a:	f000 b817 	b.w	8004f5c <_malloc_r>
 8004f2e:	bf00      	nop
 8004f30:	200001f4 	.word	0x200001f4

08004f34 <memcpy>:
 8004f34:	b510      	push	{r4, lr}
 8004f36:	1e43      	subs	r3, r0, #1
 8004f38:	440a      	add	r2, r1
 8004f3a:	4291      	cmp	r1, r2
 8004f3c:	d004      	beq.n	8004f48 <memcpy+0x14>
 8004f3e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8004f42:	f803 4f01 	strb.w	r4, [r3, #1]!
 8004f46:	e7f8      	b.n	8004f3a <memcpy+0x6>
 8004f48:	bd10      	pop	{r4, pc}

08004f4a <memset>:
 8004f4a:	4603      	mov	r3, r0
 8004f4c:	4402      	add	r2, r0
 8004f4e:	4293      	cmp	r3, r2
 8004f50:	d002      	beq.n	8004f58 <memset+0xe>
 8004f52:	f803 1b01 	strb.w	r1, [r3], #1
 8004f56:	e7fa      	b.n	8004f4e <memset+0x4>
 8004f58:	4770      	bx	lr
	...

08004f5c <_malloc_r>:
 8004f5c:	b570      	push	{r4, r5, r6, lr}
 8004f5e:	1ccd      	adds	r5, r1, #3
 8004f60:	f025 0503 	bic.w	r5, r5, #3
 8004f64:	3508      	adds	r5, #8
 8004f66:	2d0c      	cmp	r5, #12
 8004f68:	bf38      	it	cc
 8004f6a:	250c      	movcc	r5, #12
 8004f6c:	2d00      	cmp	r5, #0
 8004f6e:	4606      	mov	r6, r0
 8004f70:	db01      	blt.n	8004f76 <_malloc_r+0x1a>
 8004f72:	42a9      	cmp	r1, r5
 8004f74:	d902      	bls.n	8004f7c <_malloc_r+0x20>
 8004f76:	230c      	movs	r3, #12
 8004f78:	6033      	str	r3, [r6, #0]
 8004f7a:	e046      	b.n	800500a <_malloc_r+0xae>
 8004f7c:	f000 f85c 	bl	8005038 <__malloc_lock>
 8004f80:	4b23      	ldr	r3, [pc, #140]	; (8005010 <_malloc_r+0xb4>)
 8004f82:	681c      	ldr	r4, [r3, #0]
 8004f84:	461a      	mov	r2, r3
 8004f86:	4621      	mov	r1, r4
 8004f88:	b1a1      	cbz	r1, 8004fb4 <_malloc_r+0x58>
 8004f8a:	680b      	ldr	r3, [r1, #0]
 8004f8c:	1b5b      	subs	r3, r3, r5
 8004f8e:	d40e      	bmi.n	8004fae <_malloc_r+0x52>
 8004f90:	2b0b      	cmp	r3, #11
 8004f92:	d903      	bls.n	8004f9c <_malloc_r+0x40>
 8004f94:	600b      	str	r3, [r1, #0]
 8004f96:	18cc      	adds	r4, r1, r3
 8004f98:	50cd      	str	r5, [r1, r3]
 8004f9a:	e01e      	b.n	8004fda <_malloc_r+0x7e>
 8004f9c:	428c      	cmp	r4, r1
 8004f9e:	bf0b      	itete	eq
 8004fa0:	6863      	ldreq	r3, [r4, #4]
 8004fa2:	684b      	ldrne	r3, [r1, #4]
 8004fa4:	6013      	streq	r3, [r2, #0]
 8004fa6:	6063      	strne	r3, [r4, #4]
 8004fa8:	bf18      	it	ne
 8004faa:	460c      	movne	r4, r1
 8004fac:	e015      	b.n	8004fda <_malloc_r+0x7e>
 8004fae:	460c      	mov	r4, r1
 8004fb0:	6849      	ldr	r1, [r1, #4]
 8004fb2:	e7e9      	b.n	8004f88 <_malloc_r+0x2c>
 8004fb4:	4c17      	ldr	r4, [pc, #92]	; (8005014 <_malloc_r+0xb8>)
 8004fb6:	6823      	ldr	r3, [r4, #0]
 8004fb8:	b91b      	cbnz	r3, 8004fc2 <_malloc_r+0x66>
 8004fba:	4630      	mov	r0, r6
 8004fbc:	f000 f82c 	bl	8005018 <_sbrk_r>
 8004fc0:	6020      	str	r0, [r4, #0]
 8004fc2:	4629      	mov	r1, r5
 8004fc4:	4630      	mov	r0, r6
 8004fc6:	f000 f827 	bl	8005018 <_sbrk_r>
 8004fca:	1c43      	adds	r3, r0, #1
 8004fcc:	d018      	beq.n	8005000 <_malloc_r+0xa4>
 8004fce:	1cc4      	adds	r4, r0, #3
 8004fd0:	f024 0403 	bic.w	r4, r4, #3
 8004fd4:	42a0      	cmp	r0, r4
 8004fd6:	d10d      	bne.n	8004ff4 <_malloc_r+0x98>
 8004fd8:	6025      	str	r5, [r4, #0]
 8004fda:	4630      	mov	r0, r6
 8004fdc:	f000 f82d 	bl	800503a <__malloc_unlock>
 8004fe0:	f104 000b 	add.w	r0, r4, #11
 8004fe4:	1d23      	adds	r3, r4, #4
 8004fe6:	f020 0007 	bic.w	r0, r0, #7
 8004fea:	1ac3      	subs	r3, r0, r3
 8004fec:	d00e      	beq.n	800500c <_malloc_r+0xb0>
 8004fee:	425a      	negs	r2, r3
 8004ff0:	50e2      	str	r2, [r4, r3]
 8004ff2:	bd70      	pop	{r4, r5, r6, pc}
 8004ff4:	1a21      	subs	r1, r4, r0
 8004ff6:	4630      	mov	r0, r6
 8004ff8:	f000 f80e 	bl	8005018 <_sbrk_r>
 8004ffc:	3001      	adds	r0, #1
 8004ffe:	d1eb      	bne.n	8004fd8 <_malloc_r+0x7c>
 8005000:	230c      	movs	r3, #12
 8005002:	6033      	str	r3, [r6, #0]
 8005004:	4630      	mov	r0, r6
 8005006:	f000 f818 	bl	800503a <__malloc_unlock>
 800500a:	2000      	movs	r0, #0
 800500c:	bd70      	pop	{r4, r5, r6, pc}
 800500e:	bf00      	nop
 8005010:	2000043c 	.word	0x2000043c
 8005014:	20000438 	.word	0x20000438

08005018 <_sbrk_r>:
 8005018:	b538      	push	{r3, r4, r5, lr}
 800501a:	4c06      	ldr	r4, [pc, #24]	; (8005034 <_sbrk_r+0x1c>)
 800501c:	2300      	movs	r3, #0
 800501e:	4605      	mov	r5, r0
 8005020:	4608      	mov	r0, r1
 8005022:	6023      	str	r3, [r4, #0]
 8005024:	f000 f80a 	bl	800503c <_sbrk>
 8005028:	1c43      	adds	r3, r0, #1
 800502a:	d102      	bne.n	8005032 <_sbrk_r+0x1a>
 800502c:	6823      	ldr	r3, [r4, #0]
 800502e:	b103      	cbz	r3, 8005032 <_sbrk_r+0x1a>
 8005030:	602b      	str	r3, [r5, #0]
 8005032:	bd38      	pop	{r3, r4, r5, pc}
 8005034:	200006b8 	.word	0x200006b8

08005038 <__malloc_lock>:
 8005038:	4770      	bx	lr

0800503a <__malloc_unlock>:
 800503a:	4770      	bx	lr

0800503c <_sbrk>:
 800503c:	4b04      	ldr	r3, [pc, #16]	; (8005050 <_sbrk+0x14>)
 800503e:	4602      	mov	r2, r0
 8005040:	6819      	ldr	r1, [r3, #0]
 8005042:	b909      	cbnz	r1, 8005048 <_sbrk+0xc>
 8005044:	4903      	ldr	r1, [pc, #12]	; (8005054 <_sbrk+0x18>)
 8005046:	6019      	str	r1, [r3, #0]
 8005048:	6818      	ldr	r0, [r3, #0]
 800504a:	4402      	add	r2, r0
 800504c:	601a      	str	r2, [r3, #0]
 800504e:	4770      	bx	lr
 8005050:	20000440 	.word	0x20000440
 8005054:	200006bc 	.word	0x200006bc

08005058 <_init>:
 8005058:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800505a:	bf00      	nop
 800505c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800505e:	bc08      	pop	{r3}
 8005060:	469e      	mov	lr, r3
 8005062:	4770      	bx	lr

08005064 <_fini>:
 8005064:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005066:	bf00      	nop
 8005068:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800506a:	bc08      	pop	{r3}
 800506c:	469e      	mov	lr, r3
 800506e:	4770      	bx	lr
